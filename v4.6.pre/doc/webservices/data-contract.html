<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Data Contract </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Data Contract ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/FrameworkSystemsGmbH/fs/blob/4.6/release/17/docs/doc/webservices/data-contract.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="data-contract">Data Contract</h1>

<p>Es kann sein, dass Webservices komplexere Datenstrukturen empfangen oder versenden müssen als die normalen Datentypen wie Integer, String, Boolean usw.</p>
<p><strong>Beispiel:</strong></p>
<p>Ein Webservice erhält eine ID eines Herstellers in Form eines Integer. Er sucht dann in einer Datenbank nach allen PC’s, die von diesem Hersteller am Lager sind. Der Webservice wird also als Rückgabewert eine Liste von PC’s generieren. Intern im Webservice kann mit Klassen des PC’s oder auch des Herstellers operiert werden. Der Client, der den Webservice aufruft, kennt diese Klassendefinitionen jedoch nicht.</p>
<p>Es wird also eine Datenbasis benötigt, die sowohl der Client als auch der Server kennt. Diese muss sich somit in die WSDL-Definition des Webservices integrieren und vom Client abrufbar sein.</p>
<p><img src="media/data-contract.png" alt="Data Contract"></p>
<h3 id="name">Name</h3>
<p>Definiert den Namen des Data Contracts.</p>
<h3 id="type">Type</h3>
<p>Wie Service Contracts können auch Data Contracts generiert werden. Dies geschieht bei Data Contracts mit Hilfe des ServiceProxies (siehe <a href="service-proxy.html#generieren-eines-data-contracts-aus-einem-service-proxy">Generieren eines Data Contracts aus einem Service Proxy</a>). Dieser liest die WSDL-Definition des Webservice aus. In dieser sind alle Data Contracts als XSD-Definition hinterlegt. Sind in einem Webservice mehrere Data Contracts definiert, wird der Service Proxy auch mehrere Data Contract-Elemente erstellen.</p>
<p>Somit existieren Data Contracts des Typs <strong>Userdefined Contract</strong> und <strong>External Contract</strong>, wenn dieser über einen Service Proxy generiert wurde.</p>
<h2 id="registerkarte-general">Registerkarte General</h2>
<h3 id="contract-type">Contract Type</h3>
<p>Hier kann definiert werden, von welchem Typ der Data Contract sein soll. Wird als Typ ein Collection-Type ausgewählt, muss der Datentyp der Collection-Elemente in der Combobox Element datatype definiert werden. Dies kann z.B. ein weiterer Data Contract sein.</p>
<h3 id="interfaces">Interfaces</h3>
<p>Hier können per Komma getrennt Interfaces angegeben werden, die die Data Contract-Klasse implementieren soll.</p>
<h2 id="binden-eines-externen-data-contracts">Binden eines externen Data Contracts</h2>
<p>Es besteht die Möglichkeit, in externen Assemblies untergebrachte WCF Data Contracts direkt in Framework Studio einzubinden. Hierzu kann über den Button Bind Contract eine .NET-Dll importiert werden.</p>
<p>Importieren eines Data Contracts aus einer Assembly:</p>
<p><img src="media/data-contract-extern-data-contracts.png" alt="ext"></p>
<p>Mit dem Button <strong>Add Assembly</strong> kann nach einer gewünschten Assembly auf dem System gesucht werden. Nach dem Import wird die Assembly automatisch nach Klassen mit dem Attribut <strong>[Data Contract]</strong> durchsucht und diese in der Combobox <strong>Choose Contract</strong> angezeigt.</p>
<p>Die importierte Assembly wird als Ressource in Framework Studio eingebunden und bei einem Anwendungsstart oder Publish in das /bin-Verzeichnis des Brokers herausgeschrieben.</p>
<h2 id="registerkarte-properties">Registerkarte Properties</h2>
<p><img src="media/data-contract-tab-properties.png" alt="Registerkarte Properties"></p>
<p>Hier werden die Properties des Data Contracts definiert. Mit Rechtsklick auf die <strong>Liste &gt; New &gt; Property</strong> wird ein neues Property angelegt.</p>
<h4 id="name-1">Name</h4>
<p>Definiert den Namen des Properties. Der erste Buchstabe des Namens wird immer in einen Großbuchstaben umgewandelt.</p>
<h4 id="datatype">Datatype</h4>
<p>Definiert den Datentyp des Properties. (Siehe <a href="../comp/tab_properties.html#datentyp-bearbeiten">Datentyp bearbeiten</a>).</p>
<h4 id="property-type">Property Type</h4>
<p>Definiert die Art des Properties (siehe <a href="../comp/tab_properties.html#membervariablen">Membervariablen</a>).</p>
<h4 id="attributes">Attributes</h4>
<p>Das Häkchen <strong>[DataMember]</strong> definiert, dass das Property des Data Contracts Bestandteil der XSD-Definition sein wird, welche in die WSDL-Definition eingebunden wird. Es müssen also nicht zwingend alle Properties des Data Contracts über den Webservice abrufbar gemacht werden.</p>
<p>In der Textbox können zusätzliche Attribute zum Property definiert werden. Muss z.B. auf jeden Fall ein Wert in einem Property an den Webservice übergeben werden, kann dieses Property mit <code>[DataMember(IsRequired=true)]</code> erweitert werden.</p>
<h3 id="ableiten-und-customizen-von-data-contracts">Ableiten und Customizen von Data Contracts</h3>
<p>Data Contracts können gecustomized werden. Dabei können neue Properties hinzugefügt werden oder Get-/Set-Methoden von Individual Properties überschrieben werden. Ableitungen von Data Contracts sind nicht möglich.</p>
<h2 id="service-contract-automatisch-generieren">Service Contract automatisch generieren</h2>
<p>In WCF ist für jeden Webservice zwingend ein Service Contract nötig. Der Service Contract wird dem Konsumenten über die WSDL zur Verfügung gestellt. Zur Vereinfachung der Implementierung eines Services in Framework Studio bietet dieses an, den Service Contract aus den Informationen des Servives automatisch zu generieren. Es wird also kein Service Contract-Element benötigt, um den Service zu betreiben.</p>
<p>Um die automatische Generierung des Service Contracts am Service zu aktivieren, muss die Combobox <strong>Implement</strong> auf <strong>Yes</strong> gestellt werden (siehe  <a href="service.html#registerkarte-contracts">Registerkarte Contracts</a>). Dies ist gleichzeitig der Standardwert für neu erstellte Service-Elemente. Auch wenn an einem Service der letzte zugeordnete Service Contract gelöscht wird, wird die automatische Generierung des Contracts aktiviert.</p>
<p>Um aus einem Service den Contract automatisch zu generieren, wird der Service von Framework Studio nach allen Methoden mit Access Level <strong>public</strong> durchsucht.</p>
<p>Öffentliche Methoden am Service:</p>
<p><img src="media/data-contract-autogen-methoden.png" alt="Öffentliche Methoden am Service"></p>
<p>Der Name des automatisch generierten Contracts wird wie folgt abgeleitet:</p>
<p><strong>I</strong> + <strong>[Servicename]</strong> + <em>Contract</em></p>
<p>Für den Service <strong>AtricleInfoService</strong> aus dem Beispiel heißt der zugehörige, automatisch generierte Contract somit <strong>IArticleInfoService Contract</strong>.</p>
<p>In der folgenden Abbildung wird verdeutlicht, wie der Code für den autogenerierten Contract erzeugt wird.</p>
<p>Automatisch generierter Service Contract in der Use-Schicht:</p>
<p><img src="media/data-contract-autogen-usecode.png" alt="use-code"></p>
<p>Es ist zu erkennen, dass die beiden öffentlichen Methoden aus dem Service in das Contract-Interface aufgenommen wurden und dass der Service den automatisch generierten Contract implementiert. Zusätzlich hat die Methode <code>GetArticleByID(string id)</code> ein FaultContract-Attribut erhalten, da an der Service-Methode der Data Contract „dcArticleError“ entsprechend als Fault Contract hinterlegt wurde (siehe <a href="service.html#registerkarte-methods">Registerkarte Methods</a>).</p>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span><a href="https://www.enventa-group.com/" target="_blank" rel="noopener noreferrer nofollow"><img class="dark" src="../../media/enventa-group-logo-dark.svg" alt="enventa-group" style="height: 1.5rem"><img class="light" src="../../media/enventa-group-logo.svg" alt="enventa-group" style="height: 1.5rem"></a></span> <span style="float:right">Made with <a href="https://dotnet.github.io/docfx" target="_blank" rel="noopener noreferrer nofollow" class="external">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
