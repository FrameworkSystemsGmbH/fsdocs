{
  "api/FS.DataClient.FrameworkDataCommand.CommandTimeout.html": {
    "href": "api/FS.DataClient.FrameworkDataCommand.CommandTimeout.html",
    "title": "Property CommandTimeout",
    "keywords": "Property CommandTimeout Namespace FS.DataClient Assembly FS.DataClient.dll CommandTimeout Timeout für das Command in Sekunden. Der Standard-Wert ist 300 Sekunden. Wird der Wert 0 angegeben, gibt es keinen Timeout. public int CommandTimeout { get; set; } Property Value int"
  },
  "api/FS.DataClient.FrameworkDataCommand.html": {
    "href": "api/FS.DataClient.FrameworkDataCommand.html",
    "title": "Class FrameworkDataCommand",
    "keywords": "Class FrameworkDataCommand Namespace FS.DataClient Assembly FS.DataClient.dll Klasse steht für SQL-Statements bzw. Stored Procedures die an einer FS.DataClient.FrameworkDataConnection ausgeführt werden. public class FrameworkDataCommand : IDbCommand, IDisposable Inheritance object FrameworkDataCommand Implements IDbCommand IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CommandTimeout Timeout für das Command in Sekunden. Der Standard-Wert ist 300 Sekunden. Wird der Wert 0 angegeben, gibt es keinen Timeout."
  },
  "api/FS.DataClient.FrameworkDataConnectionStringBuilder.ConnectionStringDecoded.html": {
    "href": "api/FS.DataClient.FrameworkDataConnectionStringBuilder.ConnectionStringDecoded.html",
    "title": "Property ConnectionStringDecoded",
    "keywords": "Property ConnectionStringDecoded Namespace FS.DataClient Assembly FS.DataClient.dll ConnectionStringDecoded Gibt den Connection-String mit decodiertem Passwort zurück. public string ConnectionStringDecoded { get; } Property Value string"
  },
  "api/FS.DataClient.FrameworkDataConnectionStringBuilder.html": {
    "href": "api/FS.DataClient.FrameworkDataConnectionStringBuilder.html",
    "title": "Class FrameworkDataConnectionStringBuilder",
    "keywords": "Class FrameworkDataConnectionStringBuilder Namespace FS.DataClient Assembly FS.DataClient.dll Diese Klasse erzeugt einen String zur Instanziierung von FrameworkDataConnections. Über die Eigenschaft ProviderConnectionString kann ein Connection String abgefragt werden, mit dem die direkte Instanziierung der zu Grunde liegenden Provider Connection (z.B. SQLConnection) instanziiert werden kann. Mit der Eigenschaft FSProviderType wird der DBProvider (SQL Server, Oracle, ...) festgelegt. Der Connection String Builder schleift grundsätzlich unbekannte Schlüsselwerte durch. Im ProviderConnectionString werden aber nur Schlüsselworte erlaubt, die vom Provider gekannt werden (siehe InitProviderKeywords). Schlüsselwerte werden Case-Insensitiv ausgewertet. public class FrameworkDataConnectionStringBuilder : DbConnectionStringBuilder, IDictionary, ICollection, IEnumerable, ICustomTypeDescriptor Inheritance object DbConnectionStringBuilder FrameworkDataConnectionStringBuilder Implements IDictionary ICollection IEnumerable ICustomTypeDescriptor Inherited Members DbConnectionStringBuilder.Add(string, object) DbConnectionStringBuilder.AppendKeyValuePair(StringBuilder, string, string) DbConnectionStringBuilder.AppendKeyValuePair(StringBuilder, string, string, bool) DbConnectionStringBuilder.Clear() DbConnectionStringBuilder.ClearPropertyDescriptors() DbConnectionStringBuilder.ContainsKey(string) DbConnectionStringBuilder.EquivalentTo(DbConnectionStringBuilder) DbConnectionStringBuilder.GetProperties(Hashtable) DbConnectionStringBuilder.Remove(string) DbConnectionStringBuilder.ShouldSerialize(string) DbConnectionStringBuilder.ToString() DbConnectionStringBuilder.TryGetValue(string, out object) DbConnectionStringBuilder.BrowsableConnectionString DbConnectionStringBuilder.ConnectionString DbConnectionStringBuilder.Count DbConnectionStringBuilder.IsFixedSize DbConnectionStringBuilder.IsReadOnly DbConnectionStringBuilder.this[string] DbConnectionStringBuilder.Keys DbConnectionStringBuilder.Values object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties ConnectionStringDecoded Gibt den Connection-String mit decodiertem Passwort zurück."
  },
  "api/FS.DataClient.Metadatatype.IFSType.DBValue.html": {
    "href": "api/FS.DataClient.Metadatatype.IFSType.DBValue.html",
    "title": "Property DBValue",
    "keywords": "Property DBValue Namespace FS.DataClient.Metadatatype Assembly FS.DataClient.dll DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. object DBValue { get; } Property Value object"
  },
  "api/FS.DataClient.Metadatatype.IFSType.EqualsValue.html": {
    "href": "api/FS.DataClient.Metadatatype.IFSType.EqualsValue.html",
    "title": "Method EqualsValue",
    "keywords": "Method EqualsValue Namespace FS.DataClient.Metadatatype Assembly FS.DataClient.dll EqualsValue(string) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. bool EqualsValue(string value2) Parameters value2 string Returns bool"
  },
  "api/FS.DataClient.Metadatatype.IFSType.GetFromObject.html": {
    "href": "api/FS.DataClient.Metadatatype.IFSType.GetFromObject.html",
    "title": "Method GetFromObject",
    "keywords": "Method GetFromObject Namespace FS.DataClient.Metadatatype Assembly FS.DataClient.dll GetFromObject(object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter. IFSType GetFromObject(object val) Parameters val object Returns IFSType"
  },
  "api/FS.DataClient.Metadatatype.IFSType.HasValue.html": {
    "href": "api/FS.DataClient.Metadatatype.IFSType.HasValue.html",
    "title": "Property HasValue",
    "keywords": "Property HasValue Namespace FS.DataClient.Metadatatype Assembly FS.DataClient.dll HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. bool HasValue { get; } Property Value bool"
  },
  "api/FS.DataClient.Metadatatype.IFSType.IsNull.html": {
    "href": "api/FS.DataClient.Metadatatype.IFSType.IsNull.html",
    "title": "Property IsNull",
    "keywords": "Property IsNull Namespace FS.DataClient.Metadatatype Assembly FS.DataClient.dll IsNull Gibt an, ob der Wert der Variable Null ist. bool IsNull { get; set; } Property Value bool"
  },
  "api/FS.DataClient.Metadatatype.IFSType.ValueAsObject.html": {
    "href": "api/FS.DataClient.Metadatatype.IFSType.ValueAsObject.html",
    "title": "Property ValueAsObject",
    "keywords": "Property ValueAsObject Namespace FS.DataClient.Metadatatype Assembly FS.DataClient.dll ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. object ValueAsObject { get; set; } Property Value object"
  },
  "api/FS.DataClient.Metadatatype.IFSType.html": {
    "href": "api/FS.DataClient.Metadatatype.IFSType.html",
    "title": "Interface IFSType",
    "keywords": "Interface IFSType Namespace FS.DataClient.Metadatatype Assembly FS.DataClient.dll Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung. public interface IFSType : IComparable Inherited Members IComparable.CompareTo(object) Remarks Siehe auch: FS-Datentypen Properties DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. IsNull Gibt an, ob der Wert der Variable Null ist. ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. Methods EqualsValue(string) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. GetFromObject(object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter."
  },
  "api/FS.DataClient.Metadatatype.html": {
    "href": "api/FS.DataClient.Metadatatype.html",
    "title": "Namespace FS.DataClient.Metadatatype",
    "keywords": "Namespace FS.DataClient.Metadatatype Interfaces IFSType Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung."
  },
  "api/FS.DataClient.html": {
    "href": "api/FS.DataClient.html",
    "title": "Namespace FS.DataClient",
    "keywords": "Namespace FS.DataClient Classes FrameworkDataCommand Klasse steht für SQL-Statements bzw. Stored Procedures die an einer FS.DataClient.FrameworkDataConnection ausgeführt werden. FrameworkDataConnectionStringBuilder Diese Klasse erzeugt einen String zur Instanziierung von FrameworkDataConnections. Über die Eigenschaft ProviderConnectionString kann ein Connection String abgefragt werden, mit dem die direkte Instanziierung der zu Grunde liegenden Provider Connection (z.B. SQLConnection) instanziiert werden kann. Mit der Eigenschaft FSProviderType wird der DBProvider (SQL Server, Oracle, ...) festgelegt. Der Connection String Builder schleift grundsätzlich unbekannte Schlüsselwerte durch. Im ProviderConnectionString werden aber nur Schlüsselworte erlaubt, die vom Provider gekannt werden (siehe InitProviderKeywords). Schlüsselwerte werden Case-Insensitiv ausgewertet."
  },
  "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.CancelLoading.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.CancelLoading.html",
    "title": "Method CancelLoading",
    "keywords": "Method CancelLoading Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll CancelLoading() Sends an action to the client, which cancels the loading of the current page. public virtual void CancelLoading()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.ExecuteJavaScript.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.ExecuteJavaScript.html",
    "title": "Method ExecuteJavaScript",
    "keywords": "Method ExecuteJavaScript Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll ExecuteJavaScript(string) Übergibt ein Skript, welches im Browser synchron ausgeführt wird. public virtual void ExecuteJavaScript(string script) Parameters script string Remarks Das Script wird synchron ausgeführt und der Client wartet bis zur Beendigung des Scripts. So können z.B. bei einem Close-Form noch Aktionen an den Browser gesendet werden. protected void FE_btnClose_OnClick(FrameworkButtonClickEventArgs e) { brwBrowser.ExecuteJavaScript(\"// my java script ...\"); this.CloseForm(); } Caution Es dürfen keine alert()-Meldungen ausgelöst werden. Diese führen dazu, dass sich der Java Client aufhängt."
  },
  "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.GenerateSnapshot.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.GenerateSnapshot.html",
    "title": "Method GenerateSnapshot",
    "keywords": "Method GenerateSnapshot Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll GenerateSnapshot() Erstellt einen Snapshot von der aktuellen Ansicht des Browser-Fensters. public virtual void GenerateSnapshot()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.ReloadPage.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.ReloadPage.html",
    "title": "Method ReloadPage",
    "keywords": "Method ReloadPage Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll ReloadPage() Aktuelle Seite erneut laden. public virtual void ReloadPage()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.SetZoomFactor.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.SetZoomFactor.html",
    "title": "Method SetZoomFactor",
    "keywords": "Method SetZoomFactor Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetZoomFactor(double) Setzt den Zoom-Faktor für den Content des Browser-Controls. Ein Wert von 1.0 entspricht 100%. Dieser bezieht sich auf die im Client eingestellte Skalierung. Bei 100% wird die Skalierung verwendet. public virtual void SetZoomFactor(double zoomfactor) Parameters zoomfactor double"
  },
  "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.BrowserControlAction.html",
    "title": "Class BrowserControlAction",
    "keywords": "Class BrowserControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll [Serializable] public class BrowserControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction BrowserControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CancelLoading() Sends an action to the client, which cancels the loading of the current page. ExecuteJavaScript(string) Übergibt ein Skript, welches im Browser synchron ausgeführt wird. GenerateSnapshot() Erstellt einen Snapshot von der aktuellen Ansicht des Browser-Fensters. ReloadPage() Aktuelle Seite erneut laden. SetZoomFactor(double) Setzt den Zoom-Faktor für den Content des Browser-Controls. Ein Wert von 1.0 entspricht 100%. Dieser bezieht sich auf die im Client eingestellte Skalierung. Bei 100% wird die Skalierung verwendet."
  },
  "api/FS.Hosting.Broker.Shared.Actions.ButtonControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.ButtonControlAction.html",
    "title": "Class ButtonControlAction",
    "keywords": "Class ButtonControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Button angeboten. [Serializable] public class ButtonControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction ButtonControlAction Implements IFrameworkControlActionBase ISerializable Derived ImageButtonControlAction Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also ButtonDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.CheckboxControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.CheckboxControlAction.html",
    "title": "Class CheckboxControlAction",
    "keywords": "Class CheckboxControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Checkbox angeboten. [Serializable] public class CheckboxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction CheckboxControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also CheckBoxDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.ComboBoxControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.ComboBoxControlAction.html",
    "title": "Class ComboBoxControlAction",
    "keywords": "Class ComboBoxControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Combobox angeboten. [Serializable] public class ComboBoxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction ComboBoxControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also ComboboxDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.DashboardContainerControlAction.SetEditable.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.DashboardContainerControlAction.SetEditable.html",
    "title": "Method SetEditable",
    "keywords": "Method SetEditable Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetEditable(bool) Schaltet den Bearbeitungsmodus des Steuerelements an(true) oder aus(false). Genau dann,wenn der Bearbeitungsmodus angeschalten ist, kann der Benutzer Layout Änderungen vornehmen.Die Features Maximieren/Wiederherstellen sowie Zu-/Aufklappen bleiben davon jedoch unberührt. public void SetEditable(bool isEditable) Parameters isEditable bool"
  },
  "api/FS.Hosting.Broker.Shared.Actions.DashboardContainerControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.DashboardContainerControlAction.html",
    "title": "Class DashboardContainerControlAction",
    "keywords": "Class DashboardContainerControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control DashboardContainer angeboten. [Serializable] public class DashboardContainerControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction DashboardContainerControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods SetEditable(bool) Schaltet den Bearbeitungsmodus des Steuerelements an(true) oder aus(false). Genau dann,wenn der Bearbeitungsmodus angeschalten ist, kann der Benutzer Layout Änderungen vornehmen.Die Features Maximieren/Wiederherstellen sowie Zu-/Aufklappen bleiben davon jedoch unberührt. See Also DashBoardContainerViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.DockPanelControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.DockPanelControlAction.html",
    "title": "Class DockPanelControlAction",
    "keywords": "Class DockPanelControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll public class DockPanelControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction DockPanelControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditableControlAction.SetEnabled.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditableControlAction.SetEnabled.html",
    "title": "Method SetEnabled",
    "keywords": "Method SetEnabled Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetEnabled(bool?) Bestimmt, ob der Button reagiert, also gedrückt werden kann, oder nicht. public virtual void SetEnabled(bool? value) Parameters value bool?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditableControlAction.SetFocus.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditableControlAction.SetFocus.html",
    "title": "Method SetFocus",
    "keywords": "Method SetFocus Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetFocus() Setzt den Fokus auf das entsprechende Control, an dem diese Action ausgeführt wird. Werden in einem Request an den Broker mehrere SetFocus-Actions ausgeführt, gewinnt die letzte. public virtual void SetFocus()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditableControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditableControlAction.html",
    "title": "Class EditableControlAction",
    "keywords": "Class EditableControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Summary description for EditableControlAction. [Serializable] public class EditableControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction Implements IFrameworkControlActionBase ISerializable Derived ButtonControlAction CheckboxControlAction ComboBoxControlAction DockPanelControlAction EditboxControlAction FieldPanelControlAction GridColumnControlAction GridControlAction ListBoxControlAction ListViewControlAction MainMenuControlAction PictureControlAction RadioButtonControlAction TabPageControlAction TabbedWindowControlAction TemplateControlAction TreeViewControlAction WrapPanelControlAction Inherited Members FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods SetEnabled(bool?) Bestimmt, ob der Button reagiert, also gedrückt werden kann, oder nicht. SetFocus() Setzt den Fokus auf das entsprechende Control, an dem diese Action ausgeführt wird. Werden in einem Request an den Broker mehrere SetFocus-Actions ausgeführt, gewinnt die letzte."
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.PastePlainText.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.PastePlainText.html",
    "title": "Method PastePlainText",
    "keywords": "Method PastePlainText Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll PastePlainText(string) Diese Action fügt den angegebenen (unformatierten) Text in einem Editfield an die aktuelle Cursorposition ein. Wenn im Control Text markiert ist, wird dieser durch den angegebenen Text ersetzt. Dadurch kann insbesondere in mehrzeiligen Textfeldern Text durch die Businesslogik an der aktuellen Position eingefügt werden, ohne dass der neue Text unter Verwendung der Datasources SelectionStart und SelectionEnd manuell zusammengesetzt werden muss. public virtual void PastePlainText(string plainText) Parameters plainText string"
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SelectAllText.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SelectAllText.html",
    "title": "Method SelectAllText",
    "keywords": "Method SelectAllText Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SelectAllText() Diese Action selektiert den kompletten Text des Editfields. Sie ist gedacht für Multiline Editfields, weil diese im Gegensatz zu normalen Editfields nicht den Text selektieren, wenn im Java-Client der Fokus in das Feld gesetzt wird. Idealerweise erfolgt der Aufruf dieser Action im OnEnter- Event des Editfields. public virtual void SelectAllText()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SetDisplayMaxLength.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SetDisplayMaxLength.html",
    "title": "Method SetDisplayMaxLength",
    "keywords": "Method SetDisplayMaxLength Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetDisplayMaxLength(FSint) public void SetDisplayMaxLength(FSint value) Parameters value FSint SetDisplayMaxLength(int?) public void SetDisplayMaxLength(int? value) Parameters value int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SetDisplayMaxLines.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SetDisplayMaxLines.html",
    "title": "Method SetDisplayMaxLines",
    "keywords": "Method SetDisplayMaxLines Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetDisplayMaxLines(FSint) public void SetDisplayMaxLines(FSint value) Parameters value FSint"
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SetDisplayMinLength.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SetDisplayMinLength.html",
    "title": "Method SetDisplayMinLength",
    "keywords": "Method SetDisplayMinLength Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetDisplayMinLength(FSint) public void SetDisplayMinLength(FSint value) Parameters value FSint SetDisplayMinLength(int?) public void SetDisplayMinLength(int? value) Parameters value int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SetDisplayMinLines.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.SetDisplayMinLines.html",
    "title": "Method SetDisplayMinLines",
    "keywords": "Method SetDisplayMinLines Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetDisplayMinLines(FSint) public void SetDisplayMinLines(FSint value) Parameters value FSint SetDisplayMinLines(int?) public void SetDisplayMinLines(int? value) Parameters value int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.EditboxControlAction.html",
    "title": "Class EditboxControlAction",
    "keywords": "Class EditboxControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control EditField angeboten. [Serializable] public class EditboxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction EditboxControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods PastePlainText(string) Diese Action fügt den angegebenen (unformatierten) Text in einem Editfield an die aktuelle Cursorposition ein. Wenn im Control Text markiert ist, wird dieser durch den angegebenen Text ersetzt. Dadurch kann insbesondere in mehrzeiligen Textfeldern Text durch die Businesslogik an der aktuellen Position eingefügt werden, ohne dass der neue Text unter Verwendung der Datasources SelectionStart und SelectionEnd manuell zusammengesetzt werden muss. SelectAllText() Diese Action selektiert den kompletten Text des Editfields. Sie ist gedacht für Multiline Editfields, weil diese im Gegensatz zu normalen Editfields nicht den Text selektieren, wenn im Java-Client der Fokus in das Feld gesetzt wird. Idealerweise erfolgt der Aufruf dieser Action im OnEnter- Event des Editfields. SetDisplayMaxLength(FSint) SetDisplayMaxLength(int?) SetDisplayMaxLines(FSint) SetDisplayMinLength(FSint) SetDisplayMinLength(int?) SetDisplayMinLines(FSint) SetDisplayMinLines(int?) See Also EditboxDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FieldPanelControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FieldPanelControlAction.html",
    "title": "Class FieldPanelControlAction",
    "keywords": "Class FieldPanelControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll public class FieldPanelControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction FieldPanelControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FieldRowControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FieldRowControlAction.html",
    "title": "Class FieldRowControlAction",
    "keywords": "Class FieldRowControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll public class FieldRowControlAction : FrameworkControlActionBase, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FieldRowControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FormContainerControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FormContainerControlAction.html",
    "title": "Class FormContainerControlAction",
    "keywords": "Class FormContainerControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control FormCointainer angeboten. [Serializable] public class FormContainerControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction FormContainerControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also FormContainerDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.GetDefaultLabel.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.GetDefaultLabel.html",
    "title": "Method GetDefaultLabel",
    "keywords": "Method GetDefaultLabel Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll GetDefaultLabel() public virtual string GetDefaultLabel() Returns string"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetBackColor.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetBackColor.html",
    "title": "Method SetBackColor",
    "keywords": "Method SetBackColor Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetBackColor(Color?) public virtual void SetBackColor(Color? color) Parameters color Color?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetBorderColor.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetBorderColor.html",
    "title": "Method SetBorderColor",
    "keywords": "Method SetBorderColor Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetBorderColor(Color?) public virtual void SetBorderColor(Color? color) Parameters color Color?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetCaption.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetCaption.html",
    "title": "Method SetCaption",
    "keywords": "Method SetCaption Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetCaption(string) public virtual void SetCaption(string caption) Parameters caption string"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontBold.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontBold.html",
    "title": "Method SetFontBold",
    "keywords": "Method SetFontBold Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetFontBold(FSbool) public virtual void SetFontBold(FSbool bold) Parameters bold FSbool SetFontBold(bool?) public virtual void SetFontBold(bool? bold) Parameters bold bool?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontFamily.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontFamily.html",
    "title": "Method SetFontFamily",
    "keywords": "Method SetFontFamily Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetFontFamily(string) public virtual void SetFontFamily(string family) Parameters family string"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontItalic.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontItalic.html",
    "title": "Method SetFontItalic",
    "keywords": "Method SetFontItalic Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetFontItalic(FSbool) public virtual void SetFontItalic(FSbool italic) Parameters italic FSbool SetFontItalic(bool?) public virtual void SetFontItalic(bool? italic) Parameters italic bool?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontSize.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontSize.html",
    "title": "Method SetFontSize",
    "keywords": "Method SetFontSize Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetFontSize(FSint) public virtual void SetFontSize(FSint size) Parameters size FSint SetFontSize(int?) public virtual void SetFontSize(int? size) Parameters size int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontUnderline.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetFontUnderline.html",
    "title": "Method SetFontUnderline",
    "keywords": "Method SetFontUnderline Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetFontUnderline(FSbool) public virtual void SetFontUnderline(FSbool underline) Parameters underline FSbool SetFontUnderline(bool?) public virtual void SetFontUnderline(bool? underline) Parameters underline bool?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetForeColor.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetForeColor.html",
    "title": "Method SetForeColor",
    "keywords": "Method SetForeColor Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetForeColor(Color?) Ermöglicht das Setzen der Control-Farbe zur Laufzeit. public virtual void SetForeColor(Color? color) Parameters color Color?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetMaxHeight.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetMaxHeight.html",
    "title": "Method SetMaxHeight",
    "keywords": "Method SetMaxHeight Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetMaxHeight(FSint) public virtual void SetMaxHeight(FSint value) Parameters value FSint SetMaxHeight(int?) public virtual void SetMaxHeight(int? value) Parameters value int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetMaxWidth.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetMaxWidth.html",
    "title": "Method SetMaxWidth",
    "keywords": "Method SetMaxWidth Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetMaxWidth(FSint) public virtual void SetMaxWidth(FSint value) Parameters value FSint SetMaxWidth(int?) public virtual void SetMaxWidth(int? value) Parameters value int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetMinHeight.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetMinHeight.html",
    "title": "Method SetMinHeight",
    "keywords": "Method SetMinHeight Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetMinHeight(FSint) public virtual void SetMinHeight(FSint value) Parameters value FSint SetMinHeight(int?) public virtual void SetMinHeight(int? value) Parameters value int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetMinWidth.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetMinWidth.html",
    "title": "Method SetMinWidth",
    "keywords": "Method SetMinWidth Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetMinWidth(FSint) public virtual void SetMinWidth(FSint value) Parameters value FSint SetMinWidth(int?) public virtual void SetMinWidth(int? value) Parameters value int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetToolTip.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.SetToolTip.html",
    "title": "Method SetToolTip",
    "keywords": "Method SetToolTip Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetToolTip(string) public virtual void SetToolTip(string toolTipExtension) Parameters toolTipExtension string"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlAction.html",
    "title": "Class FrameworkControlAction",
    "keywords": "Class FrameworkControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Summary description for FrameworkControlAction. [Serializable] public class FrameworkControlAction : FrameworkControlActionBase, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction Implements IFrameworkControlActionBase ISerializable Derived BrowserControlAction DashboardContainerControlAction EditableControlAction FormContainerControlAction LabelControlAction Inherited Members FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetDefaultLabel() SetBackColor(Color?) SetBorderColor(Color?) SetCaption(string) SetFontBold(FSbool) SetFontBold(bool?) SetFontFamily(string) SetFontItalic(FSbool) SetFontItalic(bool?) SetFontSize(FSint) SetFontSize(int?) SetFontUnderline(FSbool) SetFontUnderline(bool?) SetForeColor(Color?) Ermöglicht das Setzen der Control-Farbe zur Laufzeit. SetMaxHeight(FSint) SetMaxHeight(int?) SetMaxWidth(FSint) SetMaxWidth(int?) SetMinHeight(FSint) SetMinHeight(int?) SetMinWidth(FSint) SetMinWidth(int?) SetToolTip(string)"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlActionBase.HidePermanent.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlActionBase.HidePermanent.html",
    "title": "Method HidePermanent",
    "keywords": "Method HidePermanent Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll HidePermanent() Versteckt ein control vollständig, indem sichergestellt wird, dass es niemals an den Client gesendet wird. Auf der Oberfläche ist der Effekt dessen gleich Collapsed. public virtual void HidePermanent()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlActionBase.SetVisible.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlActionBase.SetVisible.html",
    "title": "Method SetVisible",
    "keywords": "Method SetVisible Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetVisible(bool) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true, wird das Control eingeblendet und bei false ausgeblendet. public virtual void SetVisible(bool value) Parameters value bool SetVisible(FSVisibility?) Mit dieser Action kann die Sichtbarkeit eines Controls zur Laufzeit geändert werden. public virtual void SetVisible(FSVisibility? value) Parameters value FSVisibility?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlActionBase.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.FrameworkControlActionBase.html",
    "title": "Class FrameworkControlActionBase",
    "keywords": "Class FrameworkControlActionBase Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Actions, die so ziemlich jedes Control besitzt. [Serializable] public class FrameworkControlActionBase : IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase Implements IFrameworkControlActionBase ISerializable Derived FieldRowControlAction FrameworkControlAction Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods HidePermanent() Versteckt ein control vollständig, indem sichergestellt wird, dass es niemals an den Client gesendet wird. Auf der Oberfläche ist der Effekt dessen gleich Collapsed. SetVisible(bool) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true, wird das Control eingeblendet und bei false ausgeblendet. SetVisible(FSVisibility?) Mit dieser Action kann die Sichtbarkeit eines Controls zur Laufzeit geändert werden."
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.MoveAfter.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.MoveAfter.html",
    "title": "Method MoveAfter",
    "keywords": "Method MoveAfter Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll MoveAfter(IGridColumnControlAction) Verschiebt das aktuelle Grid-Column hinter das übergebene afterControl. public virtual void MoveAfter(IGridColumnControlAction afterControl) Parameters afterControl IGridColumnControlAction Examples Verschiebt das Column grd_sID hinter das Column grd_decPrice. this.grd_sID.MoveAfter(this.grd_decPrice);"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.MoveBefore.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.MoveBefore.html",
    "title": "Method MoveBefore",
    "keywords": "Method MoveBefore Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll MoveBefore(IGridColumnControlAction) Verschiebt das aktuelle Grid-Column vor das übergebene beforeControl. public virtual void MoveBefore(IGridColumnControlAction beforeControl) Parameters beforeControl IGridColumnControlAction Examples Verschiebt das Column grd_sID vor das Column grd_decPrice. this.grd_sID.MoveBefore(this.grd_decPrice);"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetCell.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetCell.html",
    "title": "Method SetCell",
    "keywords": "Method SetCell Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetCell(guid) Setzt den Fokus auf ein Feld. public virtual void SetCell(guid rowID) Parameters rowID guid Gibt die GUID des Objekts an"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetCellBackColor.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetCellBackColor.html",
    "title": "Method SetCellBackColor",
    "keywords": "Method SetCellBackColor Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetCellBackColor(guid, Color?) public virtual void SetCellBackColor(guid rowID, Color? color) Parameters rowID guid color Color?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetCellEditable.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetCellEditable.html",
    "title": "Method SetCellEditable",
    "keywords": "Method SetCellEditable Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetCellEditable(guid, bool) Setzt die Editierbarkeit einer Grid-Zelle. public virtual void SetCellEditable(guid rowID, bool isEditable) Parameters rowID guid Gibt die ObjectRowID des Objekts an. isEditable bool Gibt an, ob das Feld editierbar ist Remarks Wird als rowID der null übergeben, dann gilt die Einstellung für alle Zeilen des Grids. So ein Aufruf überschreibt aber nicht die Aufrufe, die für einzelne Zeilen getätigt wurden. Aufrufe mit einer bestimmten rowID haben höhere Priorität."
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetCellForeColor.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetCellForeColor.html",
    "title": "Method SetCellForeColor",
    "keywords": "Method SetCellForeColor Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetCellForeColor(guid, Color?) public virtual void SetCellForeColor(guid rowID, Color? color) Parameters rowID guid color Color?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetMaxWidth.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetMaxWidth.html",
    "title": "Method SetMaxWidth",
    "keywords": "Method SetMaxWidth Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetMaxWidth(int?) public override void SetMaxWidth(int? value) Parameters value int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetMinWidth.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.SetMinWidth.html",
    "title": "Method SetMinWidth",
    "keywords": "Method SetMinWidth Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetMinWidth(int?) public override void SetMinWidth(int? value) Parameters value int?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridColumnControlAction.html",
    "title": "Class GridColumnControlAction",
    "keywords": "Class GridColumnControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Grid-Column angeboten. [Serializable] public class GridColumnControlAction : EditableControlAction, ISerializable, IFrameworkControlActionBase Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction GridColumnControlAction Implements ISerializable IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods MoveAfter(IGridColumnControlAction) Verschiebt das aktuelle Grid-Column hinter das übergebene afterControl. MoveBefore(IGridColumnControlAction) Verschiebt das aktuelle Grid-Column vor das übergebene beforeControl. SetCell(guid) Setzt den Fokus auf ein Feld. SetCellBackColor(guid, Color?) SetCellEditable(guid, bool) Setzt die Editierbarkeit einer Grid-Zelle. SetCellForeColor(guid, Color?) SetMaxWidth(int?) SetMinWidth(int?) See Also GridColDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.AddColumn.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.AddColumn.html",
    "title": "Method AddColumn",
    "keywords": "Method AddColumn Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll AddColumn(GridColumnDefinition) Fügt dem Grid eine neue Spalte hinzu. Sollte zu dem in der GridColumnDefinition angegebenen Property bereits eine Spalte existieren, so wird eine Exception ausgelöst. public GridColumnControlAction AddColumn(GridColumnDefinition columnDefinition) Parameters columnDefinition GridColumnDefinition Returns GridColumnControlAction"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.GetDynamicColumnAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.GetDynamicColumnAction.html",
    "title": "Method GetDynamicColumnAction",
    "keywords": "Method GetDynamicColumnAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll GetDynamicColumnAction(string) Gibt die GridColumnControlAction der zur Laufzeit hinzugefügten Spalte (=dynamische Spalte) für das angegebene Property zurück. Wenn für das Property keine dynamische Spalte existiert, wird null zurück gegeben. public GridColumnControlAction GetDynamicColumnAction(string property) Parameters property string Returns GridColumnControlAction"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.GetView.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.GetView.html",
    "title": "Method GetView",
    "keywords": "Method GetView Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll GetView() public IGridView GetView() Returns IGridView"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.InsertAfter.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.InsertAfter.html",
    "title": "Method InsertAfter",
    "keywords": "Method InsertAfter Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll InsertAfter(GridColumnControlAction, params GridColumnControlAction[]) Verschiebt die Grid-Columns controlsToInsert hinter afterControl. public void InsertAfter(GridColumnControlAction afterControl, params GridColumnControlAction[] controlsToInsert) Parameters afterControl GridColumnControlAction controlsToInsert GridColumnControlAction[] Examples Verschiebt das Column grd_sName hinter das Column grd_decPrice. this.grd.InsertAfter(this.grd_decPrice, this.grd_sName); Remarks Wenn afterControl null ist, werden die Grid-Columns controlsToInsert an das Ende des Grids verschoben. InsertAfter(GridColumnControlAction, IEnumerable<GridColumnControlAction>) Verschiebt die Grid-Columns controlsToInsert hinter afterControl. public void InsertAfter(GridColumnControlAction afterControl, IEnumerable<GridColumnControlAction> controlsToInsert) Parameters afterControl GridColumnControlAction controlsToInsert IEnumerable<GridColumnControlAction> Examples Verschiebt das Column grd_sName hinter das Column grd_decPrice. this.grd.InsertAfter(this.grd_decPrice, this.grd_sName); Remarks Wenn afterControl null ist, werden die Grid-Columns controlsToInsert an das Ende des Grids verschoben."
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.InsertBefore.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.InsertBefore.html",
    "title": "Method InsertBefore",
    "keywords": "Method InsertBefore Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll InsertBefore(GridColumnControlAction, params GridColumnControlAction[]) Verschiebt die Grid-Columns controlsToInsert vor das beforeControl. public void InsertBefore(GridColumnControlAction beforeControl, params GridColumnControlAction[] controlsToInsert) Parameters beforeControl GridColumnControlAction controlsToInsert GridColumnControlAction[] Examples Verschiebt die Columns grd_sName, grd_decPrice und grd_sID in der angegebenen Reihenfolge an den Anfang des Grids. this.grd.InsertBefore(null, this.grd_sName, this.grd_decPrice, this.grd_sID); Verschiebt die Columns `grd_decPrice` und `grd_sID` in der angegebenen Reihenfolge vor das Column grd_sName. this.grd.InsertBefore(this.grd_sName, this.grd_decPrice, this.grd_sID); Remarks Wenn beforeControl null ist, werden die Grid-Columns controlsToInsert an den Anfang des Grids verschoben. InsertBefore(GridColumnControlAction, IEnumerable<GridColumnControlAction>) Verschiebt die Grid-Columns controlsToInsert vor das beforeControl. public void InsertBefore(GridColumnControlAction beforeControl, IEnumerable<GridColumnControlAction> controlsToInsert) Parameters beforeControl GridColumnControlAction controlsToInsert IEnumerable<GridColumnControlAction> Examples Verschiebt die Columns grd_sName, grd_decPrice und grd_sID in der angegebenen Reihenfolge an den Anfang des Grids. this.grd.InsertBefore(null, this.grd_sName, this.grd_decPrice, this.grd_sID); Verschiebt die Columns `grd_decPrice` und `grd_sID` in der angegebenen Reihenfolge vor das Column grd_sName. this.grd.InsertBefore(this.grd_sName, this.grd_decPrice, this.grd_sID); Remarks Wenn beforeControl null ist, werden die Grid-Columns controlsToInsert an den Anfang des Grids verschoben."
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.LoadGridLayout.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.LoadGridLayout.html",
    "title": "Method LoadGridLayout",
    "keywords": "Method LoadGridLayout Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll LoadGridLayout(string, bool) Sendet eine Action an den Client, die ein auf dem Client-Rechner gespeichertes Grid-Layout einliest. public virtual void LoadGridLayout(string fileName, bool displayErrorMsg) Parameters fileName string Relativer Dateipfad. displayErrorMsg bool Gibt an, ob im Fehlerfall eine Meldung angezeigt werden soll. See Also SaveGridLayout(string, bool)"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.RedoSortAndFilter.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.RedoSortAndFilter.html",
    "title": "Method RedoSortAndFilter",
    "keywords": "Method RedoSortAndFilter Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll RedoSortAndFilter() public void RedoSortAndFilter()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.RemoveAllDynamicColumns.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.RemoveAllDynamicColumns.html",
    "title": "Method RemoveAllDynamicColumns",
    "keywords": "Method RemoveAllDynamicColumns Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll RemoveAllDynamicColumns() Entfernt alle dynamischen Spalten. public void RemoveAllDynamicColumns()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.RemoveColumn.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.RemoveColumn.html",
    "title": "Method RemoveColumn",
    "keywords": "Method RemoveColumn Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll RemoveColumn(GridColumnDefinition) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. public void RemoveColumn(GridColumnDefinition columnDefinition) Parameters columnDefinition GridColumnDefinition RemoveColumn(GridColumnControlAction) Entfernt die dynamische Spalte, falls sie existiert. public void RemoveColumn(GridColumnControlAction gridColumnControlAction) Parameters gridColumnControlAction GridColumnControlAction RemoveColumn(string) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. public void RemoveColumn(string property) Parameters property string"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.ResetSortAndFilter.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.ResetSortAndFilter.html",
    "title": "Method ResetSortAndFilter",
    "keywords": "Method ResetSortAndFilter Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll ResetSortAndFilter() public void ResetSortAndFilter()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SaveGridLayout.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SaveGridLayout.html",
    "title": "Method SaveGridLayout",
    "keywords": "Method SaveGridLayout Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SaveGridLayout(string, bool) Sendet eine Action an den Client, die das Layout des Grids auf dem Client-Rechner speichert. public virtual void SaveGridLayout(string fileName, bool displayErrorMsg) Parameters fileName string Relativer Dateipfad. displayErrorMsg bool Gibt an, ob im Fehlerfall eine Meldung angezeigt werden soll. Remarks Es muss ein relativer Dateipfad angegeben werden. Dieser wird unterhalb des Ordners %userprofile%\\FSJavaClient\\[Broker-Url]\\ gespeichert. In diesem Ordner werden auch die Layout-Einstellungen gespeichert. Werden Layout-Einstellungen mit ResetClientLayout() zurückgesetzt, dann wird der komplette Ordner gelöscht. Absolute Dateipfade werden vom Java-Client unterbunden. See Also LoadGridLayout(string, bool)"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.ScrollTo.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.ScrollTo.html",
    "title": "Method ScrollTo",
    "keywords": "Method ScrollTo Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll ScrollTo(int) public virtual void ScrollTo(int row) Parameters row int ScrollTo(guid) public virtual void ScrollTo(guid objectRowID) Parameters objectRowID guid"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetCell.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetCell.html",
    "title": "Method SetCell",
    "keywords": "Method SetCell Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetCell(guid, int) Diese Aktion setzt den Fokus in eine Zelle des Grids. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. public virtual void SetCell(guid rowID, int columnPos) Parameters rowID guid columnPos int SetCell(guid, string) Wie SetCell(guid, int). Zusätzlich gibt es hier den Parameter SelectAll, mit dem angegeben werden kann, ob der gesamte Inhalt der Zelle markiert werden soll. Mit true wird der Inhalt markiert und kann direkt überschrieben werden. public virtual void SetCell(guid rowID, string columnName) Parameters rowID guid columnName string"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetCellBackColor.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetCellBackColor.html",
    "title": "Method SetCellBackColor",
    "keywords": "Method SetCellBackColor Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetCellBackColor(guid, int, Color) public virtual void SetCellBackColor(guid rowID, int columnPos, Color color) Parameters rowID guid columnPos int color Color SetCellBackColor(guid, string, Color) public virtual void SetCellBackColor(guid rowID, string columnName, Color color) Parameters rowID guid columnName string color Color"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetCellEditable.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetCellEditable.html",
    "title": "Method SetCellEditable",
    "keywords": "Method SetCellEditable Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetCellEditable(guid, int, bool) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. public virtual void SetCellEditable(guid rowID, int columnPos, bool isEditable) Parameters rowID guid columnPos int isEditable bool SetCellEditable(guid, string, bool) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. columnName ist der Name der Spalte. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. public virtual void SetCellEditable(guid rowID, string columnName, bool isEditable) Parameters rowID guid columnName string isEditable bool"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetCellForeColor.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetCellForeColor.html",
    "title": "Method SetCellForeColor",
    "keywords": "Method SetCellForeColor Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetCellForeColor(guid, int, Color) public virtual void SetCellForeColor(guid rowID, int columnPos, Color color) Parameters rowID guid columnPos int color Color SetCellForeColor(guid, string, Color) public virtual void SetCellForeColor(guid rowID, string columnName, Color color) Parameters rowID guid columnName string color Color"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetColumnCaption.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetColumnCaption.html",
    "title": "Method SetColumnCaption",
    "keywords": "Method SetColumnCaption Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetColumnCaption(int, string) Setzt die Spaltenüberschrift der Spalte Nummer ColumnPos auf den Wert value. public virtual void SetColumnCaption(int columnPos, string value) Parameters columnPos int value string SetColumnCaption(string, string) Setzt die Spaltenüberschrift der Spalte ColumnName auf den neuen Wert value. public virtual void SetColumnCaption(string columnName, string value) Parameters columnName string value string"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetColumnToolTip.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetColumnToolTip.html",
    "title": "Method SetColumnToolTip",
    "keywords": "Method SetColumnToolTip Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetColumnToolTip(int, string) public virtual void SetColumnToolTip(int columnPos, string toolTipExtension) Parameters columnPos int toolTipExtension string SetColumnToolTip(string, string) public virtual void SetColumnToolTip(string columnName, string toolTipExtension) Parameters columnName string toolTipExtension string"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetColumnVisible.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetColumnVisible.html",
    "title": "Method SetColumnVisible",
    "keywords": "Method SetColumnVisible Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetColumnVisible(int, bool) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. public virtual void SetColumnVisible(int columnPos, bool value) Parameters columnPos int value bool SetColumnVisible(int, bool?) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. public virtual void SetColumnVisible(int columnPos, bool? value) Parameters columnPos int value bool? SetColumnVisible(string, bool) Legt fest, ob die Spalte ColumnName dargestellt werden soll. public virtual void SetColumnVisible(string columnName, bool value) Parameters columnName string value bool SetColumnVisible(string, bool?) Legt fest, ob die Spalte ColumnName dargestellt werden soll. public virtual void SetColumnVisible(string columnName, bool? value) Parameters columnName string value bool?"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetEditable.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetEditable.html",
    "title": "Method SetEditable",
    "keywords": "Method SetEditable Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetEditable(bool) public void SetEditable(bool isEditable) Parameters isEditable bool"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetGridColor.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetGridColor.html",
    "title": "Method SetGridColor",
    "keywords": "Method SetGridColor Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetGridColor(Color) public virtual void SetGridColor(Color color) Parameters color Color"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetGridRowHeight.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetGridRowHeight.html",
    "title": "Method SetGridRowHeight",
    "keywords": "Method SetGridRowHeight Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetGridRowHeight(int) Legt die Zeilenhöhe der einzelnen Zeilen im Grid fest. public void SetGridRowHeight(int height) Parameters height int"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetMultiselect.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.SetMultiselect.html",
    "title": "Method SetMultiselect",
    "keywords": "Method SetMultiselect Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetMultiselect(bool) Diese Methode ermöglicht es während der Laufzeit Mehrfachselektionen am GridControl zuzulassen oder zu verweigern. public void SetMultiselect(bool isMultiselectAllowed) Parameters isMultiselectAllowed bool"
  },
  "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.GridControlAction.html",
    "title": "Class GridControlAction",
    "keywords": "Class GridControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Grid angeboten. [Serializable] public class GridControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction GridControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddColumn(GridColumnDefinition) Fügt dem Grid eine neue Spalte hinzu. Sollte zu dem in der GridColumnDefinition angegebenen Property bereits eine Spalte existieren, so wird eine Exception ausgelöst. GetDynamicColumnAction(string) Gibt die GridColumnControlAction der zur Laufzeit hinzugefügten Spalte (=dynamische Spalte) für das angegebene Property zurück. Wenn für das Property keine dynamische Spalte existiert, wird null zurück gegeben. GetView() InsertAfter(GridColumnControlAction, params GridColumnControlAction[]) Verschiebt die Grid-Columns controlsToInsert hinter afterControl. InsertAfter(GridColumnControlAction, IEnumerable<GridColumnControlAction>) Verschiebt die Grid-Columns controlsToInsert hinter afterControl. InsertBefore(GridColumnControlAction, params GridColumnControlAction[]) Verschiebt die Grid-Columns controlsToInsert vor das beforeControl. InsertBefore(GridColumnControlAction, IEnumerable<GridColumnControlAction>) Verschiebt die Grid-Columns controlsToInsert vor das beforeControl. LoadGridLayout(string, bool) Sendet eine Action an den Client, die ein auf dem Client-Rechner gespeichertes Grid-Layout einliest. RedoSortAndFilter() RemoveAllDynamicColumns() Entfernt alle dynamischen Spalten. RemoveColumn(GridColumnControlAction) Entfernt die dynamische Spalte, falls sie existiert. RemoveColumn(GridColumnDefinition) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. RemoveColumn(string) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. ResetSortAndFilter() SaveGridLayout(string, bool) Sendet eine Action an den Client, die das Layout des Grids auf dem Client-Rechner speichert. ScrollTo(guid) ScrollTo(int) SetCell(guid, int) Diese Aktion setzt den Fokus in eine Zelle des Grids. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. SetCell(guid, string) Wie SetCell(guid, int). Zusätzlich gibt es hier den Parameter SelectAll, mit dem angegeben werden kann, ob der gesamte Inhalt der Zelle markiert werden soll. Mit true wird der Inhalt markiert und kann direkt überschrieben werden. SetCellBackColor(guid, int, Color) SetCellBackColor(guid, string, Color) SetCellEditable(guid, int, bool) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. SetCellEditable(guid, string, bool) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. columnName ist der Name der Spalte. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. SetCellForeColor(guid, int, Color) SetCellForeColor(guid, string, Color) SetColumnCaption(int, string) Setzt die Spaltenüberschrift der Spalte Nummer ColumnPos auf den Wert value. SetColumnCaption(string, string) Setzt die Spaltenüberschrift der Spalte ColumnName auf den neuen Wert value. SetColumnToolTip(int, string) SetColumnToolTip(string, string) SetColumnVisible(int, bool) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. SetColumnVisible(int, bool?) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. SetColumnVisible(string, bool) Legt fest, ob die Spalte ColumnName dargestellt werden soll. SetColumnVisible(string, bool?) Legt fest, ob die Spalte ColumnName dargestellt werden soll. SetEditable(bool) SetGridColor(Color) SetGridRowHeight(int) Legt die Zeilenhöhe der einzelnen Zeilen im Grid fest. SetMultiselect(bool) Diese Methode ermöglicht es während der Laufzeit Mehrfachselektionen am GridControl zuzulassen oder zu verweigern. See Also GridDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.ImageButtonControlAction.SetHighlighted.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.ImageButtonControlAction.SetHighlighted.html",
    "title": "Method SetHighlighted",
    "keywords": "Method SetHighlighted Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SetHighlighted(bool) Sends an action to the client, which sets the caption of the control. public virtual void SetHighlighted(bool highlighted) Parameters highlighted bool"
  },
  "api/FS.Hosting.Broker.Shared.Actions.ImageButtonControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.ImageButtonControlAction.html",
    "title": "Class ImageButtonControlAction",
    "keywords": "Class ImageButtonControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control ImageButton angeboten. [Serializable] public class ImageButtonControlAction : ButtonControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction ButtonControlAction ImageButtonControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods SetHighlighted(bool) Sends an action to the client, which sets the caption of the control. See Also ImageButtonDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.LabelControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.LabelControlAction.html",
    "title": "Class LabelControlAction",
    "keywords": "Class LabelControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Label angeboten. [Serializable] public class LabelControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction LabelControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also LabelDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.ListBoxControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.ListBoxControlAction.html",
    "title": "Class ListBoxControlAction",
    "keywords": "Class ListBoxControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Listbox angeboten. [Serializable] public class ListBoxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction ListBoxControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also ListboxDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.ListViewControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.ListViewControlAction.html",
    "title": "Class ListViewControlAction",
    "keywords": "Class ListViewControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control ListView angeboten. [Serializable] public class ListViewControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction ListViewControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also ListViewDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.MainMenuControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.MainMenuControlAction.html",
    "title": "Class MainMenuControlAction",
    "keywords": "Class MainMenuControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Menu-Item angeboten. [Serializable] public class MainMenuControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction MainMenuControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also MainMenuDesignViewModel ContextMenuDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.PictureControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.PictureControlAction.html",
    "title": "Class PictureControlAction",
    "keywords": "Class PictureControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Picture angeboten. [Serializable] public class PictureControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction PictureControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also PictureDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.RadioButtonControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.RadioButtonControlAction.html",
    "title": "Class RadioButtonControlAction",
    "keywords": "Class RadioButtonControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll [Serializable] public class RadioButtonControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction RadioButtonControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.TabPageControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.TabPageControlAction.html",
    "title": "Class TabPageControlAction",
    "keywords": "Class TabPageControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll [Serializable] public class TabPageControlAction : EditableControlAction, ISerializable, IFrameworkControlActionBase Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction TabPageControlAction Implements ISerializable IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.TabbedWindowControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.TabbedWindowControlAction.html",
    "title": "Class TabbedWindowControlAction",
    "keywords": "Class TabbedWindowControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll [Serializable] public class TabbedWindowControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction TabbedWindowControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.TemplateControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.TemplateControlAction.html",
    "title": "Class TemplateControlAction",
    "keywords": "Class TemplateControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll Über diese Klasse werden zur Laufzeit die Actions für das Control Template Control angeboten. [Serializable] public class TemplateControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction TemplateControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() See Also TemplateControlDesignViewModel"
  },
  "api/FS.Hosting.Broker.Shared.Actions.TreeViewControlAction.ExpandTreeView.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.TreeViewControlAction.ExpandTreeView.html",
    "title": "Method ExpandTreeView",
    "keywords": "Method ExpandTreeView Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll ExpandTreeView() Expandiert den TreeView vollständig. public virtual void ExpandTreeView() ExpandTreeView(int) Expandiert den TreeView bis zu der Ebene, die mit dem Parameter level festgelegt wird. public virtual void ExpandTreeView(int level) Parameters level int ExpandTreeView(string) Expandiert den Pfad im TreeView, der durch den Parameter path festgelegt wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll (Unterknoten des zuletzt genannten Knotens werden nicht angezeigt). Jeder Knoten wird durch einen Punkt (.) vom nächsten Knoten getrennt. Jeder Knoten wird durch ObjectRowID Semikolon und Name des TreeNodes angegeben. public virtual void ExpandTreeView(string path) Parameters path string Examples „3197;tndStructureElement.52f3;tndStructureElementChild.4f04a4;tndPhaseElement“ Die Namen der Nodes können auch durch “NN” ersetzt werden.Z.B: „3197; NN.52f3;NN.4f04a4;NN“ ExpandTreeView(IDevFrameworkObject[]) Expandiert den Pfad im TreeView, der durch die Objekte objectPath definiert wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll. Die Unterknoten des im Pfad zuletzt genannten Knotens werden also nicht angezeigt. public virtual void ExpandTreeView(IDevFrameworkObject[] objectPath) Parameters objectPath IDevFrameworkObject[] Examples ExpandTreeView( new IDevFrameworkObject[ ]{ oObject.oParent.oParent, oObject.oParent, oObject} ); Remarks Intern wird ein Pfad aufgebaut. Der Pfad enthält - anstatt des korrekten Knotennamens - den Zusatz NN."
  },
  "api/FS.Hosting.Broker.Shared.Actions.TreeViewControlAction.SelectTreeNode.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.TreeViewControlAction.SelectTreeNode.html",
    "title": "Method SelectTreeNode",
    "keywords": "Method SelectTreeNode Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll SelectTreeNode(IDevFrameworkObject[]) Diese Action dient zum Selektieren eines Knotens im TreeView. Sie ist an die ExpandTreeView() Action angelehnt und hat somit auch mehrere Aufrufmöglichkeiten. Entweder mit einem String, welcher einen Pfad zu einem Knoten über die RowID und Knotennamen beschreibt, oder durch eine Liste mit IDevFrameworkObjects. public virtual void SelectTreeNode(IDevFrameworkObject[] objectPath) Parameters objectPath IDevFrameworkObject[] Remarks Hintergrund zum Objekt-Pfad: Der TreeView arbeitet mit LazyLoading – d.h.der Client liest Einträge bei Bedarf vom Broker nach.Dadurch ist der komplette Baum – der mitunter extrem komplex sein kann – im Client nicht bekannt.Ein einzelner Eintrag müsste sehr aufwendig im Baum gesucht werden, was im extremsten Fall bedeutet, dass der komplette Baum an den Client übertragen werden müsste. Bei einem Baum mit 5 Ebenen und jeweils 10 Knoten wären das 11.111 Requests und 111.110 Datensätze. Durch die Angabe des Pfades kann der Client ganz gezielt die benötigten Baum-Teile nachlesen. In diesem Beispiel wären das 5 Requests und nur 50 Datensätze."
  },
  "api/FS.Hosting.Broker.Shared.Actions.TreeViewControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.TreeViewControlAction.html",
    "title": "Class TreeViewControlAction",
    "keywords": "Class TreeViewControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll [Serializable] public class TreeViewControlAction : EditableControlAction, ISerializable, IFrameworkControlActionBase Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction TreeViewControlAction Implements ISerializable IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExpandTreeView() Expandiert den TreeView vollständig. ExpandTreeView(IDevFrameworkObject[]) Expandiert den Pfad im TreeView, der durch die Objekte objectPath definiert wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll. Die Unterknoten des im Pfad zuletzt genannten Knotens werden also nicht angezeigt. ExpandTreeView(int) Expandiert den TreeView bis zu der Ebene, die mit dem Parameter level festgelegt wird. ExpandTreeView(string) Expandiert den Pfad im TreeView, der durch den Parameter path festgelegt wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll (Unterknoten des zuletzt genannten Knotens werden nicht angezeigt). Jeder Knoten wird durch einen Punkt (.) vom nächsten Knoten getrennt. Jeder Knoten wird durch ObjectRowID Semikolon und Name des TreeNodes angegeben. SelectTreeNode(IDevFrameworkObject[]) Diese Action dient zum Selektieren eines Knotens im TreeView. Sie ist an die ExpandTreeView() Action angelehnt und hat somit auch mehrere Aufrufmöglichkeiten. Entweder mit einem String, welcher einen Pfad zu einem Knoten über die RowID und Knotennamen beschreibt, oder durch eine Liste mit IDevFrameworkObjects."
  },
  "api/FS.Hosting.Broker.Shared.Actions.WrapPanelControlAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.WrapPanelControlAction.html",
    "title": "Class WrapPanelControlAction",
    "keywords": "Class WrapPanelControlAction Namespace FS.Hosting.Broker.Shared.Actions Assembly FS.Hosting.Broker.Shared.dll public class WrapPanelControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Inheritance object FrameworkControlActionBase FrameworkControlAction EditableControlAction WrapPanelControlAction Implements IFrameworkControlActionBase ISerializable Inherited Members EditableControlAction.SetEnabled(bool?) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Color?) FrameworkControlAction.SetBackColor(Color?) FrameworkControlAction.SetBorderColor(Color?) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(int?) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(int?) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(int?) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(int?) FrameworkControlAction.SetToolTip(string) FrameworkControlAction.SetFontFamily(string) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(int?) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(bool?) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(bool?) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(bool?) FrameworkControlAction.SetCaption(string) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(bool) FrameworkControlActionBase.SetVisible(FSVisibility?) FrameworkControlActionBase.HidePermanent() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.Actions.html": {
    "href": "api/FS.Hosting.Broker.Shared.Actions.html",
    "title": "Namespace FS.Hosting.Broker.Shared.Actions",
    "keywords": "Namespace FS.Hosting.Broker.Shared.Actions Classes BrowserControlAction ButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Button angeboten. CheckboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Checkbox angeboten. ComboBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Combobox angeboten. DashboardContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control DashboardContainer angeboten. DockPanelControlAction EditableControlAction Summary description for EditableControlAction. EditboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control EditField angeboten. FieldPanelControlAction FieldRowControlAction FormContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control FormCointainer angeboten. FrameworkControlAction Summary description for FrameworkControlAction. FrameworkControlActionBase Actions, die so ziemlich jedes Control besitzt. GridColumnControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid-Column angeboten. GridControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid angeboten. ImageButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ImageButton angeboten. LabelControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Label angeboten. ListBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Listbox angeboten. ListViewControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ListView angeboten. MainMenuControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Menu-Item angeboten. PictureControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Picture angeboten. RadioButtonControlAction TabPageControlAction TabbedWindowControlAction TemplateControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Template Control angeboten. TreeViewControlAction WrapPanelControlAction"
  },
  "api/FS.Hosting.Broker.Shared.ColumnListDataSource.-ctor.html": {
    "href": "api/FS.Hosting.Broker.Shared.ColumnListDataSource.-ctor.html",
    "title": "Constructor ColumnListDataSource",
    "keywords": "Constructor ColumnListDataSource Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll ColumnListDataSource() public ColumnListDataSource()"
  },
  "api/FS.Hosting.Broker.Shared.ColumnListDataSource.ContainsNullEntry.html": {
    "href": "api/FS.Hosting.Broker.Shared.ColumnListDataSource.ContainsNullEntry.html",
    "title": "Property ContainsNullEntry",
    "keywords": "Property ContainsNullEntry Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null-Entrag enthalten soll. public bool? ContainsNullEntry { get; set; } Property Value bool?"
  },
  "api/FS.Hosting.Broker.Shared.ColumnListDataSource.DataSource.html": {
    "href": "api/FS.Hosting.Broker.Shared.ColumnListDataSource.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. public string DataSource { get; set; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.ColumnListDataSource.DisplayMdt.html": {
    "href": "api/FS.Hosting.Broker.Shared.ColumnListDataSource.DisplayMdt.html",
    "title": "Property DisplayMdt",
    "keywords": "Property DisplayMdt Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. public MLContainer DisplayMdt { get; set; } Property Value MLContainer"
  },
  "api/FS.Hosting.Broker.Shared.ColumnListDataSource.DisplayMember.html": {
    "href": "api/FS.Hosting.Broker.Shared.ColumnListDataSource.DisplayMember.html",
    "title": "Property DisplayMember",
    "keywords": "Property DisplayMember Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. public string DisplayMember { get; set; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.ColumnListDataSource.ValueMember.html": {
    "href": "api/FS.Hosting.Broker.Shared.ColumnListDataSource.ValueMember.html",
    "title": "Property ValueMember",
    "keywords": "Property ValueMember Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest. public string ValueMember { get; set; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.ColumnListDataSource.html": {
    "href": "api/FS.Hosting.Broker.Shared.ColumnListDataSource.html",
    "title": "Class ColumnListDataSource",
    "keywords": "Class ColumnListDataSource Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid (List). public class ColumnListDataSource Inheritance object ColumnListDataSource Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ColumnListDataSource() Properties ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null-Entrag enthalten soll. DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkButtonClickEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkButtonClickEventArgs.html",
    "title": "Class FrameworkButtonClickEventArgs",
    "keywords": "Class FrameworkButtonClickEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll public class FrameworkButtonClickEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkButtonClickEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCancelEventEventArgs.Cancel.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCancelEventEventArgs.Cancel.html",
    "title": "Property Cancel",
    "keywords": "Property Cancel Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Cancel Legt fest, ob das Event abgebrochen / verhindert werden soll. public bool Cancel { get; set; } Property Value bool"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCancelEventEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCancelEventEventArgs.html",
    "title": "Class FrameworkCancelEventEventArgs",
    "keywords": "Class FrameworkCancelEventEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll public class FrameworkCancelEventEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkCancelEventEventArgs Derived FrameworkCellCancelEventArgs FrameworkOnDragEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Cancel Legt fest, ob das Event abgebrochen / verhindert werden soll."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellCancelEventArgs.Activator.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellCancelEventArgs.Activator.html",
    "title": "Property Activator",
    "keywords": "Property Activator Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Activator public OnLeaveActivator Activator { get; } Property Value OnLeaveActivator"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellCancelEventArgs.RowID.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellCancelEventArgs.RowID.html",
    "title": "Property RowID",
    "keywords": "Property RowID Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll RowID Die ID des betroffenen Datensatzes. public guid RowID { get; } Property Value guid Remarks Über z.B. this.oCollection[e.RowID] lässt sich der Satz ermitteln."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellCancelEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellCancelEventArgs.html",
    "title": "Class FrameworkCellCancelEventArgs",
    "keywords": "Class FrameworkCellCancelEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll public class FrameworkCellCancelEventArgs : FrameworkCancelEventEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkCancelEventEventArgs FrameworkCellCancelEventArgs Inherited Members FrameworkCancelEventEventArgs.Cancel EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Activator RowID Die ID des betroffenen Datensatzes."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellDoubleClickEventArgs.ColNum.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellDoubleClickEventArgs.ColNum.html",
    "title": "Property ColNum",
    "keywords": "Property ColNum Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll ColNum public int ColNum { get; } Property Value int"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellDoubleClickEventArgs.ColumnName.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellDoubleClickEventArgs.ColumnName.html",
    "title": "Property ColumnName",
    "keywords": "Property ColumnName Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll ColumnName public string ColumnName { get; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellDoubleClickEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCellDoubleClickEventArgs.html",
    "title": "Class FrameworkCellDoubleClickEventArgs",
    "keywords": "Class FrameworkCellDoubleClickEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Spezialisierung von FrameworkEventArgs. public class FrameworkCellDoubleClickEventArgs : FrameworkDoubleClickEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkDoubleClickEventArgs FrameworkCellDoubleClickEventArgs Derived FrameworkColumnChangedEventArgs Inherited Members FrameworkDoubleClickEventArgs.RowID FrameworkDoubleClickEventArgs.RowIndex EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples private void MyDataGrid_DoubleClickEventHandler (FrameworkDoubleClickEventArgs e) { ArtikelObj = ArtikelColl[e.RowID]; } Properties ColNum ColumnName"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCheckBoxClickEventArgs.IsChecked.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCheckBoxClickEventArgs.IsChecked.html",
    "title": "Property IsChecked",
    "keywords": "Property IsChecked Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll IsChecked public bool IsChecked { get; } Property Value bool"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCheckBoxClickEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkCheckBoxClickEventArgs.html",
    "title": "Class FrameworkCheckBoxClickEventArgs",
    "keywords": "Class FrameworkCheckBoxClickEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll public class FrameworkCheckBoxClickEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkCheckBoxClickEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties IsChecked"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkColumnChangedEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkColumnChangedEventArgs.html",
    "title": "Class FrameworkColumnChangedEventArgs",
    "keywords": "Class FrameworkColumnChangedEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll !TODO public class FrameworkColumnChangedEventArgs : FrameworkCellDoubleClickEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkDoubleClickEventArgs FrameworkCellDoubleClickEventArgs FrameworkColumnChangedEventArgs Inherited Members FrameworkCellDoubleClickEventArgs.ColNum FrameworkCellDoubleClickEventArgs.ColumnName FrameworkDoubleClickEventArgs.RowID FrameworkDoubleClickEventArgs.RowIndex EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkDoubleClickEventArgs.RowID.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkDoubleClickEventArgs.RowID.html",
    "title": "Property RowID",
    "keywords": "Property RowID Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll RowID GUID der Zeile, auf der ein Doppelklick erfolgt ist. public guid RowID { get; } Property Value guid"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkDoubleClickEventArgs.RowIndex.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkDoubleClickEventArgs.RowIndex.html",
    "title": "Property RowIndex",
    "keywords": "Property RowIndex Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll RowIndex Zero-Based index of the row -1 if not valid. public int RowIndex { get; } Property Value int"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkDoubleClickEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkDoubleClickEventArgs.html",
    "title": "Class FrameworkDoubleClickEventArgs",
    "keywords": "Class FrameworkDoubleClickEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Spezialisierung von FrameworkEventArgs. public class FrameworkDoubleClickEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkDoubleClickEventArgs Derived FrameworkCellDoubleClickEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples private void MyDataGrid_DoubleClickEventHandler (FrameworkDoubleClickEventArgs e) { ArtikelObj = ArtikelColl[e.RowID]; } Properties RowID GUID der Zeile, auf der ein Doppelklick erfolgt ist. RowIndex Zero-Based index of the row -1 if not valid."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkEventArgs.html",
    "title": "Class FrameworkEventArgs",
    "keywords": "Class FrameworkEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Alle FormMethod-EventHandler haben als (einziger) Parameter ein Objekt vom Typ FrameworkEventArgs (oder einer Ableitung). FrameworkEventArgs stellt selbst noch keine besondere Funktionalität bereit, dies kann aber von Ableitungen gemacht werden. So ist es möglich, dem EventHandler weitere Informationen zu übergeben. public class FrameworkEventArgs : EventArgs Inheritance object EventArgs FrameworkEventArgs Derived FrameworkButtonClickEventArgs FrameworkCancelEventEventArgs FrameworkCheckBoxClickEventArgs FrameworkDoubleClickEventArgs FrameworkOnCanDropEventArgs FrameworkOnDropEventArgs FrameworkOnItemActivatedEventArgs FrameworkOnLeaveEventArgs FrameworkOnLinkClickEventArgs FrameworkOnReloadEventArgs FrameworkSelectionChangedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.RegisterDropAction.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.RegisterDropAction.html",
    "title": "Method RegisterDropAction",
    "keywords": "Method RegisterDropAction Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll RegisterDropAction(FrameworkOnDropActionHandler, IDevFrameworkObjectMLString, IDevFrameworkObjectMLString, DropMode) Registriert die angegebene DropAction. public void RegisterDropAction(FrameworkOnDropActionHandler onDropDelegate, IDevFrameworkObjectMLString title, IDevFrameworkObjectMLString description, DropMode dropMode = DropMode.FullControl) Parameters onDropDelegate FrameworkOnDropActionHandler title IDevFrameworkObjectMLString description IDevFrameworkObjectMLString dropMode DropMode RegisterDropAction(FrameworkOnDropActionHandler, string, IDevFrameworkObjectMLString, DropMode) Registriert die angegebene DropAction. public void RegisterDropAction(FrameworkOnDropActionHandler onDropDelegate, string title, IDevFrameworkObjectMLString description, DropMode dropMode = DropMode.FullControl) Parameters onDropDelegate FrameworkOnDropActionHandler title string description IDevFrameworkObjectMLString dropMode DropMode RegisterDropAction(FrameworkOnDropActionHandler, IDevFrameworkObjectMLString, string, DropMode) Registriert die angegebene DropAction. public void RegisterDropAction(FrameworkOnDropActionHandler onDropDelegate, IDevFrameworkObjectMLString title, string description, DropMode dropMode = DropMode.FullControl) Parameters onDropDelegate FrameworkOnDropActionHandler title IDevFrameworkObjectMLString description string dropMode DropMode RegisterDropAction(FrameworkOnDropActionHandler, string, string, DropMode) Registriert die angegebene DropAction. public void RegisterDropAction(FrameworkOnDropActionHandler onDropDelegate, string title, string description, DropMode dropMode = DropMode.FullControl) Parameters onDropDelegate FrameworkOnDropActionHandler title string description string dropMode DropMode"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceControl.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceControl.html",
    "title": "Property SourceControl",
    "keywords": "Property SourceControl Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceControl Das Quell-Control, an dem der DragDrop-Vorgang gestartet wurde. public IFrameworkControlActionBase SourceControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceControlName.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceControlName.html",
    "title": "Property SourceControlName",
    "keywords": "Property SourceControlName Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceControlName Der Name des Quell-Controls, an dem der DragDrop-Vorgang gestartet wurde. public string SourceControlName { get; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceLink.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceLink.html",
    "title": "Property SourceLink",
    "keywords": "Property SourceLink Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceLink Url des Links, falls es sich bei dem SourceControl um ein Browser-Control handelt. public UrlLink SourceLink { get; } Property Value UrlLink"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceNode.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceNode.html",
    "title": "Property SourceNode",
    "keywords": "Property SourceNode Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceNode Gibt das Quell-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeView handelt. public DevFrameworkObject SourceNode { get; } Property Value DevFrameworkObject"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceNodePath.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceNodePath.html",
    "title": "Property SourceNodePath",
    "keywords": "Property SourceNodePath Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceNodePath Gibt den Quell-Knotenpfad als Array von DevFrameworkObjects zurück, falls es sich bei dem SourceControl um einen TreeView handelt. public DevFrameworkObject[] SourceNodePath { get; } Property Value DevFrameworkObject[]"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceRowID.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceRowID.html",
    "title": "Property SourceRowID",
    "keywords": "Property SourceRowID Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceRowID ObjectRowID des Datensatzes, falls es sich bei dem SourceControl um ein Grid handelt. public guid SourceRowID { get; } Property Value guid"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceRowIndex.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.SourceRowIndex.html",
    "title": "Property SourceRowIndex",
    "keywords": "Property SourceRowIndex Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceRowIndex Index der Grid-Zeile, falls es sich bei dem SourceControl um ein Grid handelt. public int SourceRowIndex { get; } Property Value int"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.TargetControl.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.TargetControl.html",
    "title": "Property TargetControl",
    "keywords": "Property TargetControl Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TargetControl Das Control, für das das OnCanDrop Event ausgelöst wurde. public IFrameworkControlActionBase TargetControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.TargetControlName.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.TargetControlName.html",
    "title": "Property TargetControlName",
    "keywords": "Property TargetControlName Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TargetControlName Der Name des Controls, für das das OnCanDrop Event ausgelöst wurde. public string TargetControlName { get; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.TransferObject.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.TransferObject.html",
    "title": "Property TransferObject",
    "keywords": "Property TransferObject Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TransferObject Das Object, das im DragDrop-Vorgang transportiert wird. public object TransferObject { get; } Property Value object"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnCanDropEventArgs.html",
    "title": "Class FrameworkOnCanDropEventArgs",
    "keywords": "Class FrameworkOnCanDropEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Spezialisierung von FrameworkEventArgs. public class FrameworkOnCanDropEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkOnCanDropEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties SourceControl Das Quell-Control, an dem der DragDrop-Vorgang gestartet wurde. SourceControlName Der Name des Quell-Controls, an dem der DragDrop-Vorgang gestartet wurde. SourceLink Url des Links, falls es sich bei dem SourceControl um ein Browser-Control handelt. SourceNode Gibt das Quell-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeView handelt. SourceNodePath Gibt den Quell-Knotenpfad als Array von DevFrameworkObjects zurück, falls es sich bei dem SourceControl um einen TreeView handelt. SourceRowID ObjectRowID des Datensatzes, falls es sich bei dem SourceControl um ein Grid handelt. SourceRowIndex Index der Grid-Zeile, falls es sich bei dem SourceControl um ein Grid handelt. TargetControl Das Control, für das das OnCanDrop Event ausgelöst wurde. TargetControlName Der Name des Controls, für das das OnCanDrop Event ausgelöst wurde. TransferObject Das Object, das im DragDrop-Vorgang transportiert wird. Methods RegisterDropAction(FrameworkOnDropActionHandler, IDevFrameworkObjectMLString, IDevFrameworkObjectMLString, DropMode) Registriert die angegebene DropAction. RegisterDropAction(FrameworkOnDropActionHandler, IDevFrameworkObjectMLString, string, DropMode) Registriert die angegebene DropAction. RegisterDropAction(FrameworkOnDropActionHandler, string, IDevFrameworkObjectMLString, DropMode) Registriert die angegebene DropAction. RegisterDropAction(FrameworkOnDropActionHandler, string, string, DropMode) Registriert die angegebene DropAction."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.FadingEnabled.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.FadingEnabled.html",
    "title": "Property FadingEnabled",
    "keywords": "Property FadingEnabled Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll FadingEnabled Genau dann true, wenn Steuerelemente, auf denen kein Drop möglich ist übermalt werden sollen. public bool FadingEnabled { get; set; } Property Value bool"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.Icon.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.Icon.html",
    "title": "Property Icon",
    "keywords": "Property Icon Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Icon Der Pfad zu dem Icon, welches neben dem Mauszeiger erscheinen soll. public string Icon { get; set; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceControl.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceControl.html",
    "title": "Property SourceControl",
    "keywords": "Property SourceControl Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceControl Gibt den ActionWrapper des Quell-Steuerelements zurück. public IFrameworkControlActionBase SourceControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceControlName.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceControlName.html",
    "title": "Property SourceControlName",
    "keywords": "Property SourceControlName Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceControlName Gibt den Namen des Quell-Steuerelements zurück. public string SourceControlName { get; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceLink.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceLink.html",
    "title": "Property SourceLink",
    "keywords": "Property SourceLink Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceLink Link, falls es sich bei dem Quell-Steuerelement um ein HTML-Formular handelt. public UrlLink SourceLink { get; } Property Value UrlLink"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceNode.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceNode.html",
    "title": "Property SourceNode",
    "keywords": "Property SourceNode Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceNode Gibt das Quell-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeNode in einem TreeView handelt. public DevFrameworkObject SourceNode { get; } Property Value DevFrameworkObject"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceNodeInfo.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceNodeInfo.html",
    "title": "Property SourceNodeInfo",
    "keywords": "Property SourceNodeInfo Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceNodeInfo Quell-Knotenpfad. public string SourceNodeInfo { get; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceNodePath.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceNodePath.html",
    "title": "Property SourceNodePath",
    "keywords": "Property SourceNodePath Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceNodePath Gibt den Quell-Knotenpfad als Array von DevFrameworkObjects zurück. public DevFrameworkObject[] SourceNodePath { get; } Property Value DevFrameworkObject[]"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceRowID.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceRowID.html",
    "title": "Property SourceRowID",
    "keywords": "Property SourceRowID Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceRowID RowID, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. public guid SourceRowID { get; } Property Value guid"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceRowIndex.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.SourceRowIndex.html",
    "title": "Property SourceRowIndex",
    "keywords": "Property SourceRowIndex Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceRowIndex Zeilenindex, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. public int SourceRowIndex { get; } Property Value int"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.TransferObject.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.TransferObject.html",
    "title": "Property TransferObject",
    "keywords": "Property TransferObject Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TransferObject Das hier zugewiesene objekt wird in die Drop-Aktion weitergereicht und kann dort mit TransferObject abgeholt werden. public object TransferObject { get; set; } Property Value object"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDragEventArgs.html",
    "title": "Class FrameworkOnDragEventArgs",
    "keywords": "Class FrameworkOnDragEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Spezialisierung von FrameworkCancelEventEventArgs. public class FrameworkOnDragEventArgs : FrameworkCancelEventEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkCancelEventEventArgs FrameworkOnDragEventArgs Inherited Members FrameworkCancelEventEventArgs.Cancel EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties FadingEnabled Genau dann true, wenn Steuerelemente, auf denen kein Drop möglich ist übermalt werden sollen. Icon Der Pfad zu dem Icon, welches neben dem Mauszeiger erscheinen soll. SourceControl Gibt den ActionWrapper des Quell-Steuerelements zurück. SourceControlName Gibt den Namen des Quell-Steuerelements zurück. SourceLink Link, falls es sich bei dem Quell-Steuerelement um ein HTML-Formular handelt. SourceNode Gibt das Quell-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeNode in einem TreeView handelt. SourceNodeInfo Quell-Knotenpfad. SourceNodePath Gibt den Quell-Knotenpfad als Array von DevFrameworkObjects zurück. SourceRowID RowID, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. SourceRowIndex Zeilenindex, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. TransferObject Das hier zugewiesene objekt wird in die Drop-Aktion weitergereicht und kann dort mit TransferObject abgeholt werden."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropActionHandler.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropActionHandler.html",
    "title": "Delegate FrameworkOnDropActionHandler",
    "keywords": "Delegate FrameworkOnDropActionHandler Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Bei diesem Delegat handelt es sich um ein Pseudo-Ereignis. public delegate void FrameworkOnDropActionHandler(FrameworkOnDropEventArgs e) Parameters e FrameworkOnDropEventArgs Bei diesem Delegat handelt es sich um ein Pseudo-Ereignis. Remarks Methoden mit dieser Signatur führen Drop-Aktionen aus, sofern sie im OnCanDrop-Ereignis als solche mit der Methode RegisterDropAction(FrameworkOnDropActionHandler, string, string, DropMode) registriert wurden und der Benutzer auf dem entsprechenden Steuerelement die Maustaste losgelassen hat. Das TransferObject, welches beim OnDrag hinterlegt wurde, kann hier ausgewertet werden. Dabei stehen eine Reihe weiterer Eigenschaften vom EventArgs-Objekt zur Verfügung. Unter anderem der ActionIndex.Dieser identifiziert die Action eindeutig pro Ziel-Steuerelement. Des Weiteren kann abgefragt werden, ob vor (BeforeRow) oder hinter(AfterRow) einer Grid-Zeile oder eines TreeView-Knoten losgelassen wurde. Ist der Zustand beider Eigenschaften false, so wurde auf einer Grid-Zeile oder einem TreeView-Knoten oder auf dem gesamten Control losgelassen."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.ActionIndex.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.ActionIndex.html",
    "title": "Property ActionIndex",
    "keywords": "Property ActionIndex Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll ActionIndex Der Index der ausgewählten Aktion. public int ActionIndex { get; } Property Value int"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.AfterRow.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.AfterRow.html",
    "title": "Property AfterRow",
    "keywords": "Property AfterRow Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll AfterRow Genau dann True, wenn das Objekt hinter der aktuellen Zeile fallen gelassen wurde. public bool AfterRow { get; } Property Value bool"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.BeforeRow.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.BeforeRow.html",
    "title": "Property BeforeRow",
    "keywords": "Property BeforeRow Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll BeforeRow Genau dann True, wenn das Objekt vor der aktuellen Zeile fallen gelassen wurde. public bool BeforeRow { get; } Property Value bool"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceControl.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceControl.html",
    "title": "Property SourceControl",
    "keywords": "Property SourceControl Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceControl Wrapper des Quell-Steuerelements. public IFrameworkControlActionBase SourceControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceControlName.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceControlName.html",
    "title": "Property SourceControlName",
    "keywords": "Property SourceControlName Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceControlName Name des Quell-Steuerelements. public string SourceControlName { get; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceLink.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceLink.html",
    "title": "Property SourceLink",
    "keywords": "Property SourceLink Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceLink Link, falls es sich bei dem Quell-Steuerelement um ein HTML-Formular handelt. public UrlLink SourceLink { get; } Property Value UrlLink"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceNode.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceNode.html",
    "title": "Property SourceNode",
    "keywords": "Property SourceNode Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceNode Gibt das Quell-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeView handelt. public DevFrameworkObject SourceNode { get; } Property Value DevFrameworkObject"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceNodePath.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceNodePath.html",
    "title": "Property SourceNodePath",
    "keywords": "Property SourceNodePath Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceNodePath Gibt den Quell-Knotenpfad als Array von DevFrameworkObjects zurück. public DevFrameworkObject[] SourceNodePath { get; } Property Value DevFrameworkObject[]"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceRowID.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceRowID.html",
    "title": "Property SourceRowID",
    "keywords": "Property SourceRowID Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceRowID RowID, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. public guid SourceRowID { get; } Property Value guid"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceRowIndex.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.SourceRowIndex.html",
    "title": "Property SourceRowIndex",
    "keywords": "Property SourceRowIndex Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceRowIndex Zeilenindex, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. public int SourceRowIndex { get; } Property Value int"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetControl.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetControl.html",
    "title": "Property TargetControl",
    "keywords": "Property TargetControl Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TargetControl Das Control, für das das OnDrop Event ausgelöst wurde. public IFrameworkControlActionBase TargetControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetControlName.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetControlName.html",
    "title": "Property TargetControlName",
    "keywords": "Property TargetControlName Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TargetControlName Der Name des Controls, für das das OnDrop Event ausgelöst wurde. public string TargetControlName { get; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetNode.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetNode.html",
    "title": "Property TargetNode",
    "keywords": "Property TargetNode Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TargetNode Gibt das Ziel-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeView handelt. public DevFrameworkObject TargetNode { get; } Property Value DevFrameworkObject"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetNodeInfo.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetNodeInfo.html",
    "title": "Property TargetNodeInfo",
    "keywords": "Property TargetNodeInfo Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TargetNodeInfo Ziel-Knotenpfad. public string TargetNodeInfo { get; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetNodePath.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetNodePath.html",
    "title": "Property TargetNodePath",
    "keywords": "Property TargetNodePath Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TargetNodePath Gibt den Ziel-Knotenpfad als Array von DevFrameworkObjects zurück. public DevFrameworkObject[] TargetNodePath { get; } Property Value DevFrameworkObject[]"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetRowID.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetRowID.html",
    "title": "Property TargetRowID",
    "keywords": "Property TargetRowID Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TargetRowID RowID, falls es sich bei dem Ziel-Steuerelement um ein Grid handelt. public guid TargetRowID { get; } Property Value guid"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetRowIndex.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TargetRowIndex.html",
    "title": "Property TargetRowIndex",
    "keywords": "Property TargetRowIndex Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TargetRowIndex Zeilenindex, falls es sich bei dem Ziel-Steuerelement um ein Grid handelt. public int TargetRowIndex { get; } Property Value int"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TransferObject.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.TransferObject.html",
    "title": "Property TransferObject",
    "keywords": "Property TransferObject Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll TransferObject Das Drag'n'Drop Transfer-Objekt. public object TransferObject { get; } Property Value object"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnDropEventArgs.html",
    "title": "Class FrameworkOnDropEventArgs",
    "keywords": "Class FrameworkOnDropEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Spezialisierung von FrameworkEventArgs. Bietet die Möglichkeit die DragAndDrop Daten aus OnDropActions heraus abzurufen. public class FrameworkOnDropEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkOnDropEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ActionIndex Der Index der ausgewählten Aktion. AfterRow Genau dann True, wenn das Objekt hinter der aktuellen Zeile fallen gelassen wurde. BeforeRow Genau dann True, wenn das Objekt vor der aktuellen Zeile fallen gelassen wurde. SourceControl Wrapper des Quell-Steuerelements. SourceControlName Name des Quell-Steuerelements. SourceLink Link, falls es sich bei dem Quell-Steuerelement um ein HTML-Formular handelt. SourceNode Gibt das Quell-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeView handelt. SourceNodePath Gibt den Quell-Knotenpfad als Array von DevFrameworkObjects zurück. SourceRowID RowID, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. SourceRowIndex Zeilenindex, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. TargetControl Das Control, für das das OnDrop Event ausgelöst wurde. TargetControlName Der Name des Controls, für das das OnDrop Event ausgelöst wurde. TargetNode Gibt das Ziel-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeView handelt. TargetNodeInfo Ziel-Knotenpfad. TargetNodePath Gibt den Ziel-Knotenpfad als Array von DevFrameworkObjects zurück. TargetRowID RowID, falls es sich bei dem Ziel-Steuerelement um ein Grid handelt. TargetRowIndex Zeilenindex, falls es sich bei dem Ziel-Steuerelement um ein Grid handelt. TransferObject Das Drag'n'Drop Transfer-Objekt."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnItemActivatedEventArgs.ItemId.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnItemActivatedEventArgs.ItemId.html",
    "title": "Property ItemId",
    "keywords": "Property ItemId Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll ItemId Die ID des aktivierten Objekts in der zu Grunde liegenden Collection. public guid ItemId { get; } Property Value guid"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnItemActivatedEventArgs.ItemIndex.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnItemActivatedEventArgs.ItemIndex.html",
    "title": "Property ItemIndex",
    "keywords": "Property ItemIndex Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll ItemIndex Der 0-basierte Index des aktivierten Objekts in der Collection. public int ItemIndex { get; } Property Value int"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnItemActivatedEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnItemActivatedEventArgs.html",
    "title": "Class FrameworkOnItemActivatedEventArgs",
    "keywords": "Class FrameworkOnItemActivatedEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll public class FrameworkOnItemActivatedEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkOnItemActivatedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ItemId Die ID des aktivierten Objekts in der zu Grunde liegenden Collection. ItemIndex Der 0-basierte Index des aktivierten Objekts in der Collection."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.Activator.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.Activator.html",
    "title": "Property Activator",
    "keywords": "Property Activator Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Activator Gibt die Ursache des Events (Typ OnLeaveActivator) an. public OnLeaveActivator Activator { get; } Property Value OnLeaveActivator"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.DefaultNextControl.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.DefaultNextControl.html",
    "title": "Property DefaultNextControl",
    "keywords": "Property DefaultNextControl Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll DefaultNextControl Gibt das Control an, in welches der Focus als nächstes vom Client gesetzt wird bzw.gesetzt werden würde. Wenn der Focus in ein anderes Form wechselt, dann ist der Wert <null>. public IFrameworkControlActionBase DefaultNextControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.HasValueChanged.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.HasValueChanged.html",
    "title": "Property HasValueChanged",
    "keywords": "Property HasValueChanged Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll HasValueChanged Diese Eigenschaft gibt an, ob der Inhalt des Controls geändert wurde. So können Validierungsprüfungen in diesem Event behandelt werden. public bool HasValueChanged { get; } Property Value bool"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.NextControlAfterKeyboardEvent.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.NextControlAfterKeyboardEvent.html",
    "title": "Property NextControlAfterKeyboardEvent",
    "keywords": "Property NextControlAfterKeyboardEvent Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll NextControlAfterKeyboardEvent Diese Eigenschaft kann vom Programmierer geändert werden.Hier kann das Control angegeben werden, in das der Focus als nächstes gesetzt werden soll.Dadurch wird die Angabe in DefaultNextControl übersteuert. Diese Angabe funktioniert aber nur, wenn das OnLeave durch eine Tastatur-Eingabe ausgelöst wurde.Wenn der Benutzer mit der Maus gezielt in ein anderes Control klickt, dann hat das für den Client Priorität. public IFrameworkControlActionBase NextControlAfterKeyboardEvent { get; set; } Property Value IFrameworkControlActionBase Examples protected virtual void FE_edt3_OnLeave(FrameworkOnLeaveEventArgs e) { // Ausgabe der Informationen this.sInfo = \"edt3_OnLeave\" + \"\\r\\n Activator: \" + e.Activator + \"\\r\\n DefaultNextControl: \" + (e.DefaultNextControl == null ? \"<null>\" : e.DefaultNextControl.ControlName); // vorwärts >> Focus in das nächste Control setzen if (e.Activator == OnLeaveActivator.KeyboardEnter || e.Activator == OnLeaveActivator.KeyboardTabForward) { e.NextControlAfterKeyboardEvent = this.edt2; } // rückwärts >> Focus in das vorherige Control setzen else if (e.Activator == OnLeaveActivator.KeyboardTabBackward) { e.NextControlAfterKeyboardEvent = this.edtsInfo; } }"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.SourceControl.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.SourceControl.html",
    "title": "Property SourceControl",
    "keywords": "Property SourceControl Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll SourceControl Gibt an, aus welchem Control das Event gefeuert wurde. Das ist hilfreich, wenn die EventArgs als Parameter in andere Logiken übergeben werden. public IFrameworkControlActionBase SourceControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLeaveEventArgs.html",
    "title": "Class FrameworkOnLeaveEventArgs",
    "keywords": "Class FrameworkOnLeaveEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Spezialisierung von FrameworkEventArgs. public class FrameworkOnLeaveEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkOnLeaveEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples private void MyDataGrid_DoubleClickEventHandler (FrameworkDoubleClickEventArgs e) { ArtikelObj = ArtikelColl[e.RowID]; } Properties Activator Gibt die Ursache des Events (Typ OnLeaveActivator) an. DefaultNextControl Gibt das Control an, in welches der Focus als nächstes vom Client gesetzt wird bzw.gesetzt werden würde. Wenn der Focus in ein anderes Form wechselt, dann ist der Wert <null>. HasValueChanged Diese Eigenschaft gibt an, ob der Inhalt des Controls geändert wurde. So können Validierungsprüfungen in diesem Event behandelt werden. NextControlAfterKeyboardEvent Diese Eigenschaft kann vom Programmierer geändert werden.Hier kann das Control angegeben werden, in das der Focus als nächstes gesetzt werden soll.Dadurch wird die Angabe in DefaultNextControl übersteuert. Diese Angabe funktioniert aber nur, wenn das OnLeave durch eine Tastatur-Eingabe ausgelöst wurde.Wenn der Benutzer mit der Maus gezielt in ein anderes Control klickt, dann hat das für den Client Priorität. SourceControl Gibt an, aus welchem Control das Event gefeuert wurde. Das ist hilfreich, wenn die EventArgs als Parameter in andere Logiken übergeben werden."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html",
    "title": "Method GetArgumentFSlong",
    "keywords": "Method GetArgumentFSlong Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll GetArgumentFSlong(string) public FSlong GetArgumentFSlong(string key) Parameters key string Returns FSlong"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLinkClickEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnLinkClickEventArgs.html",
    "title": "Class FrameworkOnLinkClickEventArgs",
    "keywords": "Class FrameworkOnLinkClickEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll public class FrameworkOnLinkClickEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkOnLinkClickEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetArgumentFSlong(string)"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnReloadEventArgs.RowIDList.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnReloadEventArgs.RowIDList.html",
    "title": "Property RowIDList",
    "keywords": "Property RowIDList Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll RowIDList Diese Liste enthält die ObjectRowIDs der betroffenen Datensätze. Mit diesen kann der Datensatz direkt aus der Collection ermittelt werden (oMyColl[rowID]). public List<guid> RowIDList { get; } Property Value List<guid>"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnReloadEventArgs.RowList.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnReloadEventArgs.RowList.html",
    "title": "Property RowList",
    "keywords": "Property RowList Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll RowList Diese Liste enthält die Zeilennummern der betroffenen Datensätze. public List<int> RowList { get; } Property Value List<int>"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnReloadEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkOnReloadEventArgs.html",
    "title": "Class FrameworkOnReloadEventArgs",
    "keywords": "Class FrameworkOnReloadEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll Spezialisierung von FrameworkEventArgs. public class FrameworkOnReloadEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkOnReloadEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties RowIDList Diese Liste enthält die ObjectRowIDs der betroffenen Datensätze. Mit diesen kann der Datensatz direkt aus der Collection ermittelt werden (oMyColl[rowID]). RowList Diese Liste enthält die Zeilennummern der betroffenen Datensätze."
  },
  "api/FS.Hosting.Broker.Shared.EventTab.FrameworkSelectionChangedEventArgs.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.FrameworkSelectionChangedEventArgs.html",
    "title": "Class FrameworkSelectionChangedEventArgs",
    "keywords": "Class FrameworkSelectionChangedEventArgs Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll public class FrameworkSelectionChangedEventArgs : FrameworkEventArgs Inheritance object EventArgs FrameworkEventArgs FrameworkSelectionChangedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.OnLeaveActivator.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.OnLeaveActivator.html",
    "title": "Enum OnLeaveActivator",
    "keywords": "Enum OnLeaveActivator Namespace FS.Hosting.Broker.Shared.EventTab Assembly FS.Hosting.Broker.Shared.dll public enum OnLeaveActivator Fields Action = 7 OnLeaveActivator.Action Durch eine Action wie z.B. setFocus() KeyboardDown = 5 KeyboardEnter = 3 Drücken der Enter-Taste KeyboardF2 = 6 Drücken von F2 KeyboardTabBackward = 2 Drücken von Shift+Tab KeyboardTabForward = 1 Drücken der Tab-Taste KeyboardUp = 4 Mouse = 0 Mit der Maus wurde in ein anderes Control geklickt. Undefined = 8"
  },
  "api/FS.Hosting.Broker.Shared.EventTab.html": {
    "href": "api/FS.Hosting.Broker.Shared.EventTab.html",
    "title": "Namespace FS.Hosting.Broker.Shared.EventTab",
    "keywords": "Namespace FS.Hosting.Broker.Shared.EventTab Classes FrameworkButtonClickEventArgs FrameworkCancelEventEventArgs FrameworkCellCancelEventArgs FrameworkCellDoubleClickEventArgs Spezialisierung von FrameworkEventArgs. FrameworkCheckBoxClickEventArgs FrameworkColumnChangedEventArgs !TODO FrameworkDoubleClickEventArgs Spezialisierung von FrameworkEventArgs. FrameworkEventArgs Alle FormMethod-EventHandler haben als (einziger) Parameter ein Objekt vom Typ FrameworkEventArgs (oder einer Ableitung). FrameworkEventArgs stellt selbst noch keine besondere Funktionalität bereit, dies kann aber von Ableitungen gemacht werden. So ist es möglich, dem EventHandler weitere Informationen zu übergeben. FrameworkOnCanDropEventArgs Spezialisierung von FrameworkEventArgs. FrameworkOnDragEventArgs Spezialisierung von FrameworkCancelEventEventArgs. FrameworkOnDropEventArgs Spezialisierung von FrameworkEventArgs. Bietet die Möglichkeit die DragAndDrop Daten aus OnDropActions heraus abzurufen. FrameworkOnItemActivatedEventArgs FrameworkOnLeaveEventArgs Spezialisierung von FrameworkEventArgs. FrameworkOnLinkClickEventArgs FrameworkOnReloadEventArgs Spezialisierung von FrameworkEventArgs. FrameworkSelectionChangedEventArgs Enums OnLeaveActivator Delegates FrameworkOnDropActionHandler Bei diesem Delegat handelt es sich um ein Pseudo-Ereignis."
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.CloseForm.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.CloseForm.html",
    "title": "Method CloseForm",
    "keywords": "Method CloseForm Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll CloseForm() Weist den Client an, das Formular zu schliessen, sobald dieser wieder ein XmlResponse erhält. public void CloseForm()"
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.GetGeoLocation.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.GetGeoLocation.html",
    "title": "Method GetGeoLocation",
    "keywords": "Method GetGeoLocation Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll GetGeoLocation(Action<IFrameworkGeoLocationInfo>) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. public void GetGeoLocation(Action<IFrameworkGeoLocationInfo> callback) Parameters callback Action<IFrameworkGeoLocationInfo> Die Methode, die nach dem Vorgang aufgerufen werden soll. Remarks Siehe Standortbestimmung GetGeoLocation(Action<IFrameworkGeoLocationInfo>, string) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. public void GetGeoLocation(Action<IFrameworkGeoLocationInfo> callback, string identifier) Parameters callback Action<IFrameworkGeoLocationInfo> Die Methode, die nach dem Vorgang aufgerufen werden soll. identifier string Dieser string wird in IFrameworkGeoLocationInfo dem Callback übergeben. Wird dieselbe Callback-Methode für verschiedene Standortbestimmungen in einem Form verwendet, dann können diese mithlife des Identifiers auseinandergehalten werden. Remarks Siehe Standortbestimmung"
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.HidePermanent.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.HidePermanent.html",
    "title": "Method HidePermanent",
    "keywords": "Method HidePermanent Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll HidePermanent(FrameworkControlActionBase) Versteckt ein control vollständig, indem sichergestellt wird, dass es niemals an den Client gesendet wird. Auf der Oberfläche ist der Effekt dessen gleich Collapsed. public void HidePermanent(FrameworkControlActionBase Control) Parameters Control FrameworkControlActionBase"
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.IsApplicationQuitAllowed.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.IsApplicationQuitAllowed.html",
    "title": "Method IsApplicationQuitAllowed",
    "keywords": "Method IsApplicationQuitAllowed Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll IsApplicationQuitAllowed(FSAppCloseInfo) Wird aufgerufen, wenn ein Beenden der Applikation veranlasst wurde, während dieses Form geöffnet ist. Erlaubt es, das Schließen der Anwendung ggfs. zu verhindern. public virtual void IsApplicationQuitAllowed(FSAppCloseInfo info) Parameters info FSAppCloseInfo Ein Sammelobjekt, welches in alle offenen Forms gereicht wird. Hier lassen sich warnings hinterlegen, oder das Schließen der Anwendung abbrechen."
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.ResetClientLayout.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.ResetClientLayout.html",
    "title": "Method ResetClientLayout",
    "keywords": "Method ResetClientLayout Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll ResetClientLayout() Weist den Client an, sämtliche gespeicherten Layout-Informationen zu verwerfen. public void ResetClientLayout()"
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.ScanBarcode.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.ScanBarcode.html",
    "title": "Method ScanBarcode",
    "keywords": "Method ScanBarcode Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. public void ScanBarcode(Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat) Parameters callback Action<IFrameworkBarcodeScanInfo> Die Methode, die nach dem Scan-Vorgang aufgerufen werden soll. allowedFormat BarcodeFormat Ein oder mehrere zulässige Formate. Umso qualifizierter das Format eingschränkt wird, desto geringer ist die Anfälligkeit für Fehler. Mit ALL sind alle bekannten Formate zulässig. Remarks Siehe Barcode ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, string) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. Diese Überladung bietet zusätzlich einen Identifier. public void ScanBarcode(Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat, string identifier) Parameters callback Action<IFrameworkBarcodeScanInfo> Die Methode, die nach dem Scan-Vorgang aufgerufen werden soll. allowedFormat BarcodeFormat Ein oder mehrere zulässige Formate. Umso qualifizierter das Format eingschränkt wird, desto geringer ist die Anfälligkeit für Fehler. Mit ALL sind alle bekannten Formate zulässig. identifier string Dieser string wird in IFrameworkBarcodeScanInfo dem Callback übergeben. Wird dieselbe Callback-Methode für verschiedene Scan-Aufrufe in einem Form verwendet, dann können diese mithlife des Identifiers auseinandergehalten werden. Remarks Siehe Barcode"
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.SetApplicationTitle.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.SetApplicationTitle.html",
    "title": "Method SetApplicationTitle",
    "keywords": "Method SetApplicationTitle Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll SetApplicationTitle(string) Setzt den Titel der Application im Client zur Laufzeit. public void SetApplicationTitle(string title) Parameters title string"
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.SetTitle.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.SetTitle.html",
    "title": "Method SetTitle",
    "keywords": "Method SetTitle Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll SetTitle(string) Setzt den Titel des Formulars. Wenn null übergeben wird, wird der Titel auf den Standardwert zurückgesetzt. public void SetTitle(string title) Parameters title string Der neue Titel des Forms"
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.TakePhoto.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.TakePhoto.html",
    "title": "Method TakePhoto",
    "keywords": "Method TakePhoto Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) Über diese Action wird im Mobile-Client ein das erstellen eines Fotos auf dem Endgerät eingeleitet. public void TakePhoto(Action<IFrameworkPhotoInfo> callback, CameraSource source) Parameters callback Action<IFrameworkPhotoInfo> Die Methode, die nach dem Vorgang aufgerufen werden soll. source CameraSource Bestimmt, ob ein neues Foto mit der Kamera erstellt oder ein bestehendes Foto von der Bildergalerie ausgewählt werden soll. Remarks Siehe Kamera TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource, string) Über diese Action wird im Mobile-Client ein das erstellen eines Fotos auf dem Endgerät eingeleitet. public void TakePhoto(Action<IFrameworkPhotoInfo> callback, CameraSource source, string identifier) Parameters callback Action<IFrameworkPhotoInfo> Die Methode, die nach dem Vorgang aufgerufen werden soll. source CameraSource Bestimmt, ob ein neues Foto mit der Kamera erstellt oder ein bestehendes Foto von der Bildergalerie ausgewählt werden soll. identifier string Dieser string wird in IFrameworkPhotoInfo dem Callback übergeben. Wird dieselbe Callback-Methode für verschiedene Vorgänge in einem Form verwendet, dann können diese mithlife des Identifiers auseinandergehalten werden. Remarks Siehe Kamera"
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.ViewDocument.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.ViewDocument.html",
    "title": "Method ViewDocument",
    "keywords": "Method ViewDocument Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll ViewDocument(string) Sendet eine Action an den Client zum Öffnen eines Dokuments über eine URL protected void ViewDocument(string url) Parameters url string Remarks Bei Web-Adressen sollte in jedem Fall http:// bzw. https:// vorangestellt werden, ansonsten ist bei einem Java-Client unter Windows die Länge der URL auf ca. 260 Zeichen begrenzt. Auch muss es eine korrekt formatierte URL ohne Sonderzeichen und Leerzeichen sein. Wird die URL programmatisch erstellt, dann empfiehlt es sich, die Klasse UriBuilder zu verwenden. Einzelne Argumente können auch mit UrlEncode(string) korrekt codiert werden. Erkennt der Java-Client keine gültige URL, dann wird der Aufruf an das Betriebssystem weitergeleitet. So können auch lokale Dateien geöffnet werden. Die Arbeitsweise ist dann analog zum Befehl Ausführen unter Windows (Windows-Taste + R) Mit Hilfe des Schemas fsbroker:// kann die Broker eigene URL referenziert werden. Und damit bspw. Dateien über den Broker zur Verfügung stellen. Beispielweise könnte die folgende URL fsbroker://documents/legal.pdf in http://fsbroker/HOSTNAME_DEMO_user1/FSDemoApplication/documents/legal.pdf übersetzt werden."
  },
  "api/FS.Hosting.Broker.Shared.GeneratedForm.html": {
    "href": "api/FS.Hosting.Broker.Shared.GeneratedForm.html",
    "title": "Class GeneratedForm",
    "keywords": "Class GeneratedForm Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll Basisklasse eines vom FrameworkStudio generierten Formulars. An dieser Klasse werden die Actions auf Form-Ebene angeboten. public abstract class GeneratedForm : IDisposable, INotifyPropertyChanged Inheritance object GeneratedForm Implements IDisposable INotifyPropertyChanged Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CloseForm() Weist den Client an, das Formular zu schliessen, sobald dieser wieder ein XmlResponse erhält. GetGeoLocation(Action<IFrameworkGeoLocationInfo>) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. GetGeoLocation(Action<IFrameworkGeoLocationInfo>, string) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. HidePermanent(FrameworkControlActionBase) Versteckt ein control vollständig, indem sichergestellt wird, dass es niemals an den Client gesendet wird. Auf der Oberfläche ist der Effekt dessen gleich Collapsed. IsApplicationQuitAllowed(FSAppCloseInfo) Wird aufgerufen, wenn ein Beenden der Applikation veranlasst wurde, während dieses Form geöffnet ist. Erlaubt es, das Schließen der Anwendung ggfs. zu verhindern. ResetClientLayout() Weist den Client an, sämtliche gespeicherten Layout-Informationen zu verwerfen. ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, string) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. Diese Überladung bietet zusätzlich einen Identifier. SetApplicationTitle(string) Setzt den Titel der Application im Client zur Laufzeit. SetTitle(string) Setzt den Titel des Formulars. Wenn null übergeben wird, wird der Titel auf den Standardwert zurückgesetzt. TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) Über diese Action wird im Mobile-Client ein das erstellen eines Fotos auf dem Endgerät eingeleitet. TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource, string) Über diese Action wird im Mobile-Client ein das erstellen eines Fotos auf dem Endgerät eingeleitet. ViewDocument(string) Sendet eine Action an den Client zum Öffnen eines Dokuments über eine URL"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.-ctor.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.-ctor.html",
    "title": "Constructor GridColumnDefinition",
    "keywords": "Constructor GridColumnDefinition Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll GridColumnDefinition() public GridColumnDefinition()"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.Caption.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. public string Caption { get; set; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ColumnSortOrder.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ColumnSortOrder.html",
    "title": "Enum GridColumnDefinition.ColumnSortOrder",
    "keywords": "Enum GridColumnDefinition.ColumnSortOrder Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll public enum GridColumnDefinition.ColumnSortOrder Fields Ascending = 1 Descending = 2 Unsorted = 0"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ColumnTextAlign.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ColumnTextAlign.html",
    "title": "Enum GridColumnDefinition.ColumnTextAlign",
    "keywords": "Enum GridColumnDefinition.ColumnTextAlign Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll public enum GridColumnDefinition.ColumnTextAlign Fields Center = 1 Left = 0 Right = 2"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ComponentType.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ComponentType.html",
    "title": "Property ComponentType",
    "keywords": "Property ComponentType Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. public Type ComponentType { get; set; } Property Value Type"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.DependsDataSourceOnRowData.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.DependsDataSourceOnRowData.html",
    "title": "Property DependsDataSourceOnRowData",
    "keywords": "Property DependsDataSourceOnRowData Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. public bool? DependsDataSourceOnRowData { get; set; } Property Value bool?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.EditStyle.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll EditStyle Gibt den zu verwendenden Combobox-Typ (FreeTextInput, ListValuesInput) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. public ComboEditStyle? EditStyle { get; set; } Property Value ComboEditStyle?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.EditorStyle.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.EditorStyle.html",
    "title": "Property EditorStyle",
    "keywords": "Property EditorStyle Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll EditorStyle Gibt den zu verwendenden Darstellungstyp (Editfield, CheckBox, ...) zurück oder legt diesen fest. public EditorStyle? EditorStyle { get; set; } Property Value EditorStyle?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.Format.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. public FrameworkFormatMask? Format { get; set; } Property Value FrameworkFormatMask?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.FormatPattern.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. public string FormatPattern { get; set; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.IsEditable.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. public bool? IsEditable { get; set; } Property Value bool?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.IsVisible.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.IsVisible.html",
    "title": "Property IsVisible",
    "keywords": "Property IsVisible Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. public bool? IsVisible { get; set; } Property Value bool?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.List.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.List.html",
    "title": "Property List",
    "keywords": "Property List Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. public ColumnListDataSource List { get; set; } Property Value ColumnListDataSource"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ListSortOrder.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ListSortOrder.html",
    "title": "Property ListSortOrder",
    "keywords": "Property ListSortOrder Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. public GridColumnDefinition.ColumnSortOrder ListSortOrder { get; set; } Property Value GridColumnDefinition.ColumnSortOrder"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.MLCaption.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. public DevMLString MLCaption { get; set; } Property Value DevMLString"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.MLToolTip.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.MLToolTip.html",
    "title": "Property MLToolTip",
    "keywords": "Property MLToolTip Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. public DevMLString MLToolTip { get; set; } Property Value DevMLString"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.MaxScale.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.MaxScale.html",
    "title": "Property MaxScale",
    "keywords": "Property MaxScale Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. public int? MaxScale { get; set; } Property Value int?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.MaxSize.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. public int? MaxSize { get; set; } Property Value int?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.Property.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.Property.html",
    "title": "Property Property",
    "keywords": "Property Property Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. public string Property { get; set; } Property Value string Examples Werden im Grid Elemente vom Typ cDynObj angezeigt, so bedeutet Property=\"oDevObj.sName\", dass die Spalte Daten des Propertys sName des Unterobjekts oDevObj an cDynObj darstellt."
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.PropertyMdt.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.PropertyMdt.html",
    "title": "Property PropertyMdt",
    "keywords": "Property PropertyMdt Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. public MLContainer PropertyMdt { get; set; } Property Value MLContainer Remarks Wenn die Eigenschaft ComponentType nicht gesetzt werden muss, muss diese Eigenschaft ebenfalls nicht gesetzt werden. Die Werte können dann automatisch über Reflection ermittelt werden."
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.TextAlign.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. public GridColumnDefinition.ColumnTextAlign? TextAlign { get; set; } Property Value GridColumnDefinition.ColumnTextAlign?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ToolTip.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.ToolTip.html",
    "title": "Property ToolTip",
    "keywords": "Property ToolTip Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. public string ToolTip { get; set; } Property Value string"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.Width.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.Width.html",
    "title": "Property Width",
    "keywords": "Property Width Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll Width Gibt die initiale Spaltenbreite zurück oder legt diese fest. public int? Width { get; set; } Property Value int?"
  },
  "api/FS.Hosting.Broker.Shared.GridColumnDefinition.html": {
    "href": "api/FS.Hosting.Broker.Shared.GridColumnDefinition.html",
    "title": "Class GridColumnDefinition",
    "keywords": "Class GridColumnDefinition Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. public class GridColumnDefinition Inheritance object GridColumnDefinition Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GridColumnDefinition() Properties Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. EditStyle Gibt den zu verwendenden Combobox-Typ (FreeTextInput, ListValuesInput) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. EditorStyle Gibt den zu verwendenden Darstellungstyp (Editfield, CheckBox, ...) zurück oder legt diesen fest. Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. Width Gibt die initiale Spaltenbreite zurück oder legt diese fest."
  },
  "api/FS.Hosting.Broker.Shared.MsgBoxButtons.html": {
    "href": "api/FS.Hosting.Broker.Shared.MsgBoxButtons.html",
    "title": "Enum MsgBoxButtons",
    "keywords": "Enum MsgBoxButtons Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll public enum MsgBoxButtons Fields AbortRetryIgnore = 2 OK = 0 OKCancel = 1 RetryCancel = 5 YesNo = 4 YesNoCancel = 3"
  },
  "api/FS.Hosting.Broker.Shared.MsgBoxIcons.html": {
    "href": "api/FS.Hosting.Broker.Shared.MsgBoxIcons.html",
    "title": "Enum MsgBoxIcons",
    "keywords": "Enum MsgBoxIcons Namespace FS.Hosting.Broker.Shared Assembly FS.Hosting.Broker.Shared.dll public enum MsgBoxIcons Fields Error = 16 Exclamation = 48 Information = 64 None = 0 Question = 32"
  },
  "api/FS.Hosting.Broker.Shared.html": {
    "href": "api/FS.Hosting.Broker.Shared.html",
    "title": "Namespace FS.Hosting.Broker.Shared",
    "keywords": "Namespace FS.Hosting.Broker.Shared Classes ColumnListDataSource Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid (List). GeneratedForm Basisklasse eines vom FrameworkStudio generierten Formulars. An dieser Klasse werden die Actions auf Form-Ebene angeboten. GridColumnDefinition Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. Enums GridColumnDefinition.ColumnSortOrder GridColumnDefinition.ColumnTextAlign MsgBoxButtons MsgBoxIcons"
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReport.ExportToBytes.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReport.ExportToBytes.html",
    "title": "Method ExportToBytes",
    "keywords": "Method ExportToBytes Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ExportToBytes(ExportFormat) Exportiert den Report ins gegebene Format. public byte[] ExportToBytes(ExportFormat format) Parameters format ExportFormat Das Format, in dem der Report exportiert werden soll. Returns byte[] Die bytes des exportierten reports."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReport.ExportToDisk.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReport.ExportToDisk.html",
    "title": "Method ExportToDisk",
    "keywords": "Method ExportToDisk Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ExportToDisk(ExportFormat, string) Exportiert den Report ins gegebene Format und schreibt ihn in den angegebenen Pfad. public void ExportToDisk(ExportFormat format, string fileName) Parameters format ExportFormat Das Format, in dem der Report exportiert werden soll. fileName string Der Pfad, in den der Report geschrieben werden soll."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReport.GetSupportedCultures.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReport.GetSupportedCultures.html",
    "title": "Method GetSupportedCultures",
    "keywords": "Method GetSupportedCultures Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetSupportedCultures() Liefert die vom Report zusätzlich unterstützten Cultures zurück. Die \"Default\"-Culture des Reports ist nicht enthalten. public IEnumerable<string> GetSupportedCultures() Returns IEnumerable<string>"
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReport.Load.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReport.Load.html",
    "title": "Method Load",
    "keywords": "Method Load Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Load(string) Lädt das layout eines reports aus einer Xml-Datei. public void Load(string fileName) Parameters fileName string Der Pfad der Datei, die geladen werden soll. Load(byte[]) Lädt das layout eines reports aus direkter Binärform. public void Load(byte[] bytes) Parameters bytes byte[] Exceptions ArgumentNullException es wurden keine bytes übergeben"
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReport.SetCulture.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReport.SetCulture.html",
    "title": "Method SetCulture",
    "keywords": "Method SetCulture Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll SetCulture(string) Definiert die Culture mit welcher der Report erzeugt werden soll. public void SetCulture(string culture) Parameters culture string Remarks Die Culture beeinflusst sowohl die Sprache als auch die Datums- und Zahlen-Formatierungen. Wird keine Culture angegeben, dann wird der Report mit der \"Default\"-Culture erzeugt und für Datums- und Zahlen-Formatierungen wird die am Server konfigurierte Culture verwendet. Die Culture muss vor dem Aufruf von Print() oder ExportReport(ExportFormat) gesetzt werden."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReport.SetDatasource.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReport.SetDatasource.html",
    "title": "Method SetDatasource",
    "keywords": "Method SetDatasource Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll SetDatasource(ReportDocument) Setzt die Datenquelle des Reports. public void SetDatasource(ReportDocument reportWithData) Parameters reportWithData ReportDocument Das ReportDocument, das als Datenquelle genutzt werden soll."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReport.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReport.html",
    "title": "Class DevExpressReport",
    "keywords": "Class DevExpressReport Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Der direkte FS-Wrapper für interfacing mit einer DevExpress.XtraReports.UI.XtraReport-Datei. Greift direkt auf XtraReport-Methoden zu und sollte intern als logische Repräsentation dessen betrachtet werden. public class DevExpressReport : IDisposable Inheritance object DevExpressReport Implements IDisposable Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods ExportToBytes(ExportFormat) Exportiert den Report ins gegebene Format. ExportToDisk(ExportFormat, string) Exportiert den Report ins gegebene Format und schreibt ihn in den angegebenen Pfad. GetSupportedCultures() Liefert die vom Report zusätzlich unterstützten Cultures zurück. Die \"Default\"-Culture des Reports ist nicht enthalten. Load(byte[]) Lädt das layout eines reports aus direkter Binärform. Load(string) Lädt das layout eines reports aus einer Xml-Datei. SetCulture(string) Definiert die Culture mit welcher der Report erzeugt werden soll. SetDatasource(ReportDocument) Setzt die Datenquelle des Reports."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.Adapter.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.Adapter.html",
    "title": "Field Adapter",
    "keywords": "Field Adapter Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Name des PrintService-Adapters. public const string Adapter = \"DEVEXPRESS\" Returns string Name des PrintService-Adapters."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.ExportToBytes.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.ExportToBytes.html",
    "title": "Method ExportToBytes",
    "keywords": "Method ExportToBytes Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ExportToBytes(ExportFormat) Exportiert den DevExpressReport ins gegebene Format. public override byte[] ExportToBytes(ExportFormat format) Parameters format ExportFormat Das ExportFormat, in dem der DevExpressReport exportiert werden soll. Returns byte[] Die bytes des exportierten DevExpressReport."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.ExportToDisk.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.ExportToDisk.html",
    "title": "Method ExportToDisk",
    "keywords": "Method ExportToDisk Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ExportToDisk(ExportFormat, string) Exportiert den DevExpressReport und speichert die erzeugte Datei unter dem angegebenen Namen. public override void ExportToDisk(ExportFormat format, string filename) Parameters format ExportFormat Das ExportFormat, in das exportiert werden soll. filename string Der Dateiname, unter dem der exportierte DevExpressReport gespeichert werden soll."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.Load.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.Load.html",
    "title": "Method Load",
    "keywords": "Method Load Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Load(string, bool) Lädt eine DevExpressReport-Datei von der Festplatte. public override void Load(string filename, bool deleteOnDispose) Parameters filename string Der Name der zu ladenden Datei. deleteOnDispose bool Ob die Datei filename beim FS.Hosting.Core.Reporting.DevExpressReportDocument.Dispose() gelöscht werden soll."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.SetCulture.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.SetCulture.html",
    "title": "Method SetCulture",
    "keywords": "Method SetCulture Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll SetCulture(string) Definiert die Culture mit welcher der Report erzeugt werden soll. public void SetCulture(string culture) Parameters culture string Remarks Die Culture beeinflusst sowohl die Sprache als auch die Datums- und Zahlen-Formatierungen. Wird keine Culture angegeben, dann wird der Report mit der \"Default\"-Culture erzeugt und für Datums- und Zahlen-Formatierungen wird die am Server konfigurierte Culture verwendet. Die Culture muss vor dem Aufruf von Print() oder ExportReport(ExportFormat) gesetzt werden."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.SetDatasource.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.SetDatasource.html",
    "title": "Method SetDatasource",
    "keywords": "Method SetDatasource Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll SetDatasource(ReportDocument) Setzt die Datenquelle des DevExpressReport. public void SetDatasource(ReportDocument reportWithData) Parameters reportWithData ReportDocument Das ReportDocument, das als Datenquelle genutzt werden soll."
  },
  "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.html": {
    "href": "api/FS.Hosting.Core.Reporting.DevExpressReportDocument.html",
    "title": "Class DevExpressReportDocument",
    "keywords": "Class DevExpressReportDocument Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Logische Repräsentation eines DevExpress XtraReports im Code. Wrapped einen DevExpressReport, welcher direktes interfacing mit der Runtime übernimmt. public class DevExpressReportDocument : FSReportDocument, IDisposable Inheritance object FSReportDocument DevExpressReportDocument Implements IDisposable Inherited Members FSReportDocument.PaperOrientation FSReportDocument.Load(string) FSReportDocument.Load(byte[]) object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Fields Adapter Name des PrintService-Adapters. Methods ExportToBytes(ExportFormat) Exportiert den DevExpressReport ins gegebene Format. ExportToDisk(ExportFormat, string) Exportiert den DevExpressReport und speichert die erzeugte Datei unter dem angegebenen Namen. Load(string, bool) Lädt eine DevExpressReport-Datei von der Festplatte. SetCulture(string) Definiert die Culture mit welcher der Report erzeugt werden soll. SetDatasource(ReportDocument) Setzt die Datenquelle des DevExpressReport."
  },
  "api/FS.Hosting.Core.Reporting.FSReportDocument.ExportToBytes.html": {
    "href": "api/FS.Hosting.Core.Reporting.FSReportDocument.ExportToBytes.html",
    "title": "Method ExportToBytes",
    "keywords": "Method ExportToBytes Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ExportToBytes(ExportFormat) Exportiert den Report und gibt die erzeugte Datei als Byte-Array zurück. public abstract byte[] ExportToBytes(ExportFormat format) Parameters format ExportFormat Returns byte[]"
  },
  "api/FS.Hosting.Core.Reporting.FSReportDocument.ExportToDisk.html": {
    "href": "api/FS.Hosting.Core.Reporting.FSReportDocument.ExportToDisk.html",
    "title": "Method ExportToDisk",
    "keywords": "Method ExportToDisk Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ExportToDisk(ExportFormat, string) Exportiert den Report und speichert die erzeugte Datei unter dem angegebenen Namen. public abstract void ExportToDisk(ExportFormat format, string filename) Parameters format ExportFormat Das ExportFormat, in das exportiert werden soll. filename string Der Dateiname, unter dem der exportierte Report gespeichert werden soll."
  },
  "api/FS.Hosting.Core.Reporting.FSReportDocument.Load.html": {
    "href": "api/FS.Hosting.Core.Reporting.FSReportDocument.Load.html",
    "title": "Method Load",
    "keywords": "Method Load Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Load(string) Lädt eine Report-Datei von der Festplatte. public void Load(string filename) Parameters filename string Load(string, bool) Lädt eine Report-Datei von der Festplatte. public abstract void Load(string filename, bool deleteOnDispose) Parameters filename string Der Name der zu ladenden Datei. deleteOnDispose bool Ob die Datei filename beim FS.Hosting.Core.Reporting.FSReportDocument.Dispose() gelöscht werden soll. Load(byte[]) Lädt einen Report in Binärform in das ReportDocument. public virtual void Load(byte[] bytes) Parameters bytes byte[] Die bytes des zu ladenden Reports. Remarks Um File-Konflikte zu verhindern, wird eventuell eine temporäre Datei generiert, aus der stattdessen geladen wird."
  },
  "api/FS.Hosting.Core.Reporting.FSReportDocument.PaperOrientation.html": {
    "href": "api/FS.Hosting.Core.Reporting.FSReportDocument.PaperOrientation.html",
    "title": "Property PaperOrientation",
    "keywords": "Property PaperOrientation Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll PaperOrientation Die Orientation, in welcher der Report gedruckt werden soll. public virtual Orientation PaperOrientation { get; } Property Value Orientation"
  },
  "api/FS.Hosting.Core.Reporting.FSReportDocument.html": {
    "href": "api/FS.Hosting.Core.Reporting.FSReportDocument.html",
    "title": "Class FSReportDocument",
    "keywords": "Class FSReportDocument Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Eine Basis für Wrapper tatsächlicher Report-Dateien. public abstract class FSReportDocument : IDisposable Inheritance object FSReportDocument Implements IDisposable Derived DevExpressReportDocument Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties PaperOrientation Die Orientation, in welcher der Report gedruckt werden soll. Methods ExportToBytes(ExportFormat) Exportiert den Report und gibt die erzeugte Datei als Byte-Array zurück. ExportToDisk(ExportFormat, string) Exportiert den Report und speichert die erzeugte Datei unter dem angegebenen Namen. Load(byte[]) Lädt einen Report in Binärform in das ReportDocument. Load(string) Lädt eine Report-Datei von der Festplatte. Load(string, bool) Lädt eine Report-Datei von der Festplatte."
  },
  "api/FS.Hosting.Core.Reporting.FSReportDocumentFactory.Create.html": {
    "href": "api/FS.Hosting.Core.Reporting.FSReportDocumentFactory.Create.html",
    "title": "Method Create",
    "keywords": "Method Create Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Create(ReportingSoftware) Erzeugt abhängig von der übergebenen Reporting-Software eine passende FSReportDocument Instanz. public static FSReportDocument Create(ReportingSoftware software) Parameters software ReportingSoftware Returns FSReportDocument"
  },
  "api/FS.Hosting.Core.Reporting.FSReportDocumentFactory.FromBytes.html": {
    "href": "api/FS.Hosting.Core.Reporting.FSReportDocumentFactory.FromBytes.html",
    "title": "Method FromBytes",
    "keywords": "Method FromBytes Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll FromBytes(byte[]) Erkennt anhand der übergebenen Bytes die Reporting-Software und gibt einen geladenes DevExpressReportDocument zurück. public static FSReportDocument FromBytes(byte[] bytes) Parameters bytes byte[] Returns FSReportDocument"
  },
  "api/FS.Hosting.Core.Reporting.FSReportDocumentFactory.html": {
    "href": "api/FS.Hosting.Core.Reporting.FSReportDocumentFactory.html",
    "title": "Class FSReportDocumentFactory",
    "keywords": "Class FSReportDocumentFactory Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll public static class FSReportDocumentFactory Inheritance object FSReportDocumentFactory Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods Create(ReportingSoftware) Erzeugt abhängig von der übergebenen Reporting-Software eine passende FSReportDocument Instanz. FromBytes(byte[]) Erkennt anhand der übergebenen Bytes die Reporting-Software und gibt einen geladenes DevExpressReportDocument zurück."
  },
  "api/FS.Hosting.Core.Reporting.ReportDesignSession.DesignerUrl.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDesignSession.DesignerUrl.html",
    "title": "Property DesignerUrl",
    "keywords": "Property DesignerUrl Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll DesignerUrl Liefert die URL des Designers zurück. public string DesignerUrl { get; } Property Value string"
  },
  "api/FS.Hosting.Core.Reporting.ReportDesignSession.Dispose.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDesignSession.Dispose.html",
    "title": "Method Dispose",
    "keywords": "Method Dispose Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Dispose() Verwirft die gespeicherten Session Informationen. public void Dispose()"
  },
  "api/FS.Hosting.Core.Reporting.ReportDesignSession.GetBytes.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDesignSession.GetBytes.html",
    "title": "Method GetBytes",
    "keywords": "Method GetBytes Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetBytes() Liefert den serialisierten Report zurück, dieser müssen anschließend selbst in das ReportBytes eingefügt werden. public byte[] GetBytes() Returns byte[]"
  },
  "api/FS.Hosting.Core.Reporting.ReportDesignSession.IsModified.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDesignSession.IsModified.html",
    "title": "Method IsModified",
    "keywords": "Method IsModified Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll IsModified() Liefert true, wenn der Benutzer den Report im Designer gespeichert hat; andernfalls false. public bool IsModified() Returns bool"
  },
  "api/FS.Hosting.Core.Reporting.ReportDesignSession.ShowDesigner.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDesignSession.ShowDesigner.html",
    "title": "Method ShowDesigner",
    "keywords": "Method ShowDesigner Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ShowDesigner() Zeigt den Designer an, indem die DesignerUrl in einem Browser geöffnet wird. public void ShowDesigner()"
  },
  "api/FS.Hosting.Core.Reporting.ReportDesignSession.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDesignSession.html",
    "title": "Class ReportDesignSession",
    "keywords": "Class ReportDesignSession Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Die ReportDesignSession Klasse erlaubt das Verwalten einer Report Designer Session. Die Klasse kann nur über CreateDesigner(ReportEnum) erzeugt werden. Über die Funktionen in der Klasse kann der Report Designer geöffnet werden, auf Veränderungen geprüft werden oder der geänderte Report zurückgeliefert werden. public class ReportDesignSession : IDisposable Inheritance object ReportDesignSession Implements IDisposable Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties DesignerUrl Liefert die URL des Designers zurück. Methods Dispose() Verwirft die gespeicherten Session Informationen. GetBytes() Liefert den serialisierten Report zurück, dieser müssen anschließend selbst in das ReportBytes eingefügt werden. IsModified() Liefert true, wenn der Benutzer den Report im Designer gespeichert hat; andernfalls false. ShowDesigner() Zeigt den Designer an, indem die DesignerUrl in einem Browser geöffnet wird."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.-ctor.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.-ctor.html",
    "title": "Constructor ReportDocument",
    "keywords": "Constructor ReportDocument Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ReportDocument(IGlobalObjects, ExportFormat) public ReportDocument(IGlobalObjects globalObj, ExportFormat exportFormat) Parameters globalObj IGlobalObjects exportFormat ExportFormat ReportDocument(IGlobalObjects, ReportEnum, ExportFormat) public ReportDocument(IGlobalObjects globalObj, ReportEnum selectedReport, ExportFormat exportFormat) Parameters globalObj IGlobalObjects selectedReport ReportEnum exportFormat ExportFormat"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.AddAdditionalReport.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.AddAdditionalReport.html",
    "title": "Method AddAdditionalReport",
    "keywords": "Method AddAdditionalReport Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll AddAdditionalReport(ReportEnum) Fügt eine zusätzliche Report-Definition hinzu. So können individuelle Report-Dateien zur Laufzeit ergänzt werden. public void AddAdditionalReport(ReportEnum report) Parameters report ReportEnum"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.ClearAdditionalReports.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.ClearAdditionalReports.html",
    "title": "Method ClearAdditionalReports",
    "keywords": "Method ClearAdditionalReports Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ClearAdditionalReports() Setzt die Liste mit den zusätzlichen Report-Definitionen zurück. public void ClearAdditionalReports()"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.ConvertFileNameToReportsEnum.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.ConvertFileNameToReportsEnum.html",
    "title": "Method ConvertFileNameToReportsEnum",
    "keywords": "Method ConvertFileNameToReportsEnum Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ConvertFileNameToReportsEnum(string) Diese Methode kann verwendet werden, um einen ReportEnum mit einem bestimmten Datei-Namen zu finden. Es wird nach DevExpressFileName gesucht. public ReportEnum ConvertFileNameToReportsEnum(string fileName) Parameters fileName string Returns ReportEnum Der gefundene ReportEnum. null wenn kein ReportEnum gefunden wurde."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.CreateDesigner.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.CreateDesigner.html",
    "title": "Method CreateDesigner",
    "keywords": "Method CreateDesigner Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll CreateDesigner(ReportEnum) Erstellt eine Session für den Report Designer und liefert das zugehörige Objekt zurück. public ReportDesignSession CreateDesigner(ReportEnum report = null) Parameters report ReportEnum Report oder null, wenn der SelectedReport verwendet werden soll. Returns ReportDesignSession"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.Culture.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.Culture.html",
    "title": "Property Culture",
    "keywords": "Property Culture Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Culture Definiert die Culture mit welcher der Report erzeugt werden soll. [Browsable(false)] public string Culture { get; set; } Property Value string Remarks Die Culture beeinflusst sowohl die Sprache als auch die Datums- und Zahlen-Formatierungen. Wird keine Culture angegeben, dann wird der Report mit der \"Default\"-Culture erzeugt und für Datums- und Zahlen-Formatierungen wird die am Server konfigurierte Culture verwendet. Die Culture muss vor dem Aufruf von Print() oder ExportReport(ExportFormat) gesetzt werden."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.ExportFormat.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.ExportFormat.html",
    "title": "Property ExportFormat",
    "keywords": "Property ExportFormat Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ExportFormat Das Format, in dem der Report mit Print() ausgegeben werden soll. Diese Einstellung wird ignoriert, wenn der Report auf einem Drucker ausgegeben werden soll. [Browsable(false)] public ExportFormat ExportFormat { get; set; } Property Value ExportFormat Remarks Es gibt verschiedene Wege, das ExportFormat des Reports zu definieren: 1.) Über den Konstruktur: rptReport myRptReport = new rptReport(this.Global, rptReport.Reports.SpecialReport1, ExportFormat.PDF ); 2.) Durch setzen des Properties vor den Druck: myRptReport.ExportFormat = ExportFormat.Html40; 3.) Durch Angabe direkt in der Methode Print(ExportFormat) myRptReport.Print(ExportFormat.Rtf);"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.ExportReport.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.ExportReport.html",
    "title": "Method ExportReport",
    "keywords": "Method ExportReport Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ExportReport(ExportFormat) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. public byte[] ExportReport(ExportFormat format) Parameters format ExportFormat Returns byte[] ExportReport(ExportFormat, out ReportingSoftware) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. Dabei wird die verwendete Reporting-Software zurückgegeben. public byte[] ExportReport(ExportFormat format, out ReportingSoftware software) Parameters format ExportFormat software ReportingSoftware Gibt die für den Export verwendete Reporting-Software zurück. Returns byte[] ExportReport(ExportFormat, guid) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. public byte[] ExportReport(ExportFormat format, guid printJobID) Parameters format ExportFormat printJobID guid wird zu Protokollierungs-Zwecken benötigt Returns byte[]"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.GetAdditionalReports.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.GetAdditionalReports.html",
    "title": "Method GetAdditionalReports",
    "keywords": "Method GetAdditionalReports Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetAdditionalReports() Gibt eine Liste mit den zusätzlichen Report-Definitionen zurück. public List<ReportEnum> GetAdditionalReports() Returns List<ReportEnum> Remarks Es wird bei jedem Aufruf eine neue Liste zurückgegeben. Änderungen in dieser Liste haben keine Auswirkung auf die gespeicherten Report-Definitionen. Zum Bearbeiten der Report-Definitionen müssen die Methoden AddAdditionalReport(ReportEnum) und ClearAdditionalReports() verwendet werden."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.GetDatasource.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.GetDatasource.html",
    "title": "Method GetDatasource",
    "keywords": "Method GetDatasource Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetDatasource(string) Gibt den Wert eines bestimmten Datasources zurück. public virtual object GetDatasource(string dsName) Parameters dsName string Der Name des Datasources Returns object Exceptions PropertyNotFoundException Wird geworfen, wenn der Name des Datasources ungültig ist."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.GetDatasources.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.GetDatasources.html",
    "title": "Method GetDatasources",
    "keywords": "Method GetDatasources Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetDatasources() Gibt die Namen der Datasources zurück. public StringCollection GetDatasources() Returns StringCollection"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.GetReportEnums.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.GetReportEnums.html",
    "title": "Method GetReportEnums",
    "keywords": "Method GetReportEnums Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetReportEnums() Gibt eine Liste mit allen Report-Definitionen zurück. Es sind die mit AddAdditionalReport(ReportEnum) hinzugefügten Report-Definitionen enthalten. public List<ReportEnum> GetReportEnums() Returns List<ReportEnum> Eine Liste mit Reports. Es wird bei jedem Aufruf eine neue Instanz zurückgegeben. Remarks Die Liste beinhaltet je nach Angabe im ReportDocument ggf. auch die in der Basis definierten Reports. Existieren mehrere ReportEnums mit demselben ReportName dann wird jeweils nur eines davon zurückgegeben. Dabei gewinnt das ReportEnum, welches zuletzt mit AddAdditionalReport(ReportEnum) hinzugefügt wurde."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.Print.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.Print.html",
    "title": "Method Print",
    "keywords": "Method Print Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Print() Erzeugt einen Druck für die Anzeige am Client. public void Print() Print(ExportFormat) Erzeugt einen Druck für die Anzeige am Client. public void Print(ExportFormat export) Parameters export ExportFormat"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.PrintToPrinter.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.PrintToPrinter.html",
    "title": "Method PrintToPrinter",
    "keywords": "Method PrintToPrinter Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll PrintToPrinter(int, bool, int, int, guid, guid) Druckt das Dokument über einen Drucker am Print-Server. Dieser Druck erzeugt eine Transaktion und schließt diese sofort. public guid PrintToPrinter(int copies, bool isCollated, int startPage, int endPage, guid printServerId, guid printerId) Parameters copies int Anzahl der Kopien. isCollated bool startPage int 0 = alle Seiten. endPage int 0 = alle Seiten. printServerId guid Eindutige ID des Print-Servers. printerId guid Eindeutige ID des Printers im Print-Server. Returns guid Die eindeutige ID des PrintJobs. Diese kann verwendet werden, um den Status des DruckJobs zu ermitteln. siehe PrintQueue.GetState(IGlobalObjects, guid)."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.PrintToTransaction.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.PrintToTransaction.html",
    "title": "Method PrintToTransaction",
    "keywords": "Method PrintToTransaction Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll PrintToTransaction(int, bool, int, int, int, guid, guid) Druckt das Dokument in eine offene Transaktion. public guid PrintToTransaction(int copies, bool isCollated, int startPage, int endPage, int orderID, guid printerId, guid transactionID) Parameters copies int Anzahl der Kopien. isCollated bool startPage int 0 = alle Seiten. endPage int 0 = alle Seiten. orderID int Laufende Nummer des Jobs in der Transaktion. Der PrintServer druckt alle jobs einer Transaction sortiert nach dieser OrderID. printerId guid Eideutige ID des Druckers. Diese kann mit PrintServer.GetPrinters() ermittelt werden. transactionID guid ID der Transaktion. Diese kann mit PrintServer.CreateTransaction() erzeugt werden. Returns guid Die eindeutige ID des PrintJobs. Diese kann verwendet werden, um den Status des DruckJobs zu ermitteln. siehe PrintQueue.GetState(IGlobalObjects, guid)."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.ReportDir.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.ReportDir.html",
    "title": "Property ReportDir",
    "keywords": "Property ReportDir Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ReportDir Gibt den Pfad des Dateiordners zurück, in dem die Reports abgelegt sind. [Browsable(false)] public string ReportDir { get; } Property Value string"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.Reports.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.Reports.html",
    "title": "Field Reports",
    "keywords": "Field Reports Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Eine Instanz, die alle, im Report-Document-Type definierten Crystal Reports, als Properties beinhaltet. public static readonly ReportDocument.ReportEnumList Reports Returns ReportDocument.ReportEnumList Eine Instanz, die alle, im Report-Document-Type definierten Crystal Reports, als Properties beinhaltet. Remarks Verwenden dieses Properties: 1.) bei der Instanziierung des Reports rptReport myRptReport = new rptReport(this.Global, rptReport.Reports.SpecialReport1, ExportFormat.PDF ); 2.) Nachträglich setzen myRptReport.SelectedReport = rptReport.Reports.SpecialReport2; Mithilfe der Methode GetReportEnums() können alle verfügbaren Reports ermittelt werden."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.SelectedReport.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.SelectedReport.html",
    "title": "Property SelectedReport",
    "keywords": "Property SelectedReport Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll SelectedReport Der aktuell ausgewählte Report. Die vorhandenen Reports können über das Statische Property Reports ermittelt werden. [Browsable(false)] public ReportEnum SelectedReport { get; set; } Property Value ReportEnum"
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.SetDatasource.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.SetDatasource.html",
    "title": "Method SetDatasource",
    "keywords": "Method SetDatasource Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll SetDatasource(string, object) Setzt den Wert eines Datasources. public virtual void SetDatasource(string dsName, object value) Parameters dsName string Der Name des Datasources value object Der Wert, der gesetzt werden soll. Der Typ des Werts muss dem Typ des Datasources entsprechen oder eine Ableitung davon sein. Exceptions PropertyNotFoundException Wird geworfen, wenn der Name des Datasources ungültig ist. InvalidCastException Wird geworfen, wenn der Typ des Values nicht zum Typ des Datasources passt."
  },
  "api/FS.Hosting.Core.Reporting.ReportDocument.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportDocument.html",
    "title": "Class ReportDocument",
    "keywords": "Class ReportDocument Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Diese Klasse ist die Basis-Klasse aller Report Document Types, die mit Framework-Studio entwickelt werden. public class ReportDocument Inheritance object ReportDocument Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Constructors ReportDocument(IGlobalObjects, ReportEnum, ExportFormat) ReportDocument(IGlobalObjects, ExportFormat) Fields Reports Eine Instanz, die alle, im Report-Document-Type definierten Crystal Reports, als Properties beinhaltet. Properties Culture Definiert die Culture mit welcher der Report erzeugt werden soll. ExportFormat Das Format, in dem der Report mit Print() ausgegeben werden soll. Diese Einstellung wird ignoriert, wenn der Report auf einem Drucker ausgegeben werden soll. ReportDir Gibt den Pfad des Dateiordners zurück, in dem die Reports abgelegt sind. SelectedReport Der aktuell ausgewählte Report. Die vorhandenen Reports können über das Statische Property Reports ermittelt werden. Methods AddAdditionalReport(ReportEnum) Fügt eine zusätzliche Report-Definition hinzu. So können individuelle Report-Dateien zur Laufzeit ergänzt werden. ClearAdditionalReports() Setzt die Liste mit den zusätzlichen Report-Definitionen zurück. ConvertFileNameToReportsEnum(string) Diese Methode kann verwendet werden, um einen ReportEnum mit einem bestimmten Datei-Namen zu finden. Es wird nach DevExpressFileName gesucht. CreateDesigner(ReportEnum) Erstellt eine Session für den Report Designer und liefert das zugehörige Objekt zurück. ExportReport(ExportFormat) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. ExportReport(ExportFormat, out ReportingSoftware) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. Dabei wird die verwendete Reporting-Software zurückgegeben. ExportReport(ExportFormat, guid) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. GetAdditionalReports() Gibt eine Liste mit den zusätzlichen Report-Definitionen zurück. GetDatasource(string) Gibt den Wert eines bestimmten Datasources zurück. GetDatasources() Gibt die Namen der Datasources zurück. GetReportEnums() Gibt eine Liste mit allen Report-Definitionen zurück. Es sind die mit AddAdditionalReport(ReportEnum) hinzugefügten Report-Definitionen enthalten. Print() Erzeugt einen Druck für die Anzeige am Client. Print(ExportFormat) Erzeugt einen Druck für die Anzeige am Client. PrintToPrinter(int, bool, int, int, guid, guid) Druckt das Dokument über einen Drucker am Print-Server. Dieser Druck erzeugt eine Transaktion und schließt diese sofort. PrintToTransaction(int, bool, int, int, int, guid, guid) Druckt das Dokument in eine offene Transaktion. SetDatasource(string, object) Setzt den Wert eines Datasources."
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.-ctor.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.-ctor.html",
    "title": "Constructor ReportEnum",
    "keywords": "Constructor ReportEnum Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ReportEnum(ReportEnumList, guid, string, Orientation, DevMLString, ReportingSoftware) Dieser Konstruktor wird im generierten Code verwendet. public ReportEnum(ReportDocument.ReportEnumList enumList, guid id, string reportName, Orientation orientation, DevMLString mlCaption, ReportingSoftware software) Parameters enumList ReportDocument.ReportEnumList id guid reportName string orientation Orientation mlCaption DevMLString software ReportingSoftware ReportEnum(guid, string, byte[], string, ReportingSoftware?) Erzeugt eine individuelle Report-Definition. public ReportEnum(guid id, string reportName, byte[] reportBytes, string caption, ReportingSoftware? software = null) Parameters id guid Wird null übergeben, dann wird eine neue guid erzeugt. reportName string Name des Reports. Dieser wird als Dateiname verwendet. Ungültige Zeichen werden durch '_' ersetzt. Wird kein Name übergeben, dann wird die ID als Name verwendet. reportBytes byte[] Die Definition einer Layout-Datei der angegebenen ReportingSoftware im binär-Format. caption string Eine zusätzliche Bezeichnung des Enums für die Oberfläche. software ReportingSoftware? (optional) Eine Angabe, in welchem Format die reportBytes sind. ReportEnum(guid, string, byte[], string, Orientation, ReportingSoftware?) Erzeugt eine individuelle Report-Definition. public ReportEnum(guid id, string reportName, byte[] reportBytes, string caption, Orientation orientation, ReportingSoftware? software = null) Parameters id guid Wird null übergeben, dann wird eine neue guid erzeugt. reportName string Name des Reports. Dieser wird als Dateiname verwendet. Ungültige Zeichen werden durch '_' ersetzt. Wird kein Name übergeben, dann wird die ID als Name verwendet. reportBytes byte[] Die Definition einer Layout-Datei der angegebenen ReportingSoftware im binär-Format. caption string Eine zusätzliche Bezeichnung des Enums für die Oberfläche. orientation Orientation Die vorgesehene Orientierung des Reports beim Druck. software ReportingSoftware? (optional) Eine Angabe, in welchem Format die reportBytes sind. Wird keine ReportingSoftware angegeben, dann wird der Wert aus den reportBytes ermittelt."
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.Caption.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Caption Individuelle Beschriftung des Reports. Diese hat höhere Priorität als MLCaption. Wird für Custom Report-Definitionen verwendet. public string Caption { get; set; } Property Value string See Also GetCaption(IGlobalObjects)"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.DevExpressFileName.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.DevExpressFileName.html",
    "title": "Property DevExpressFileName",
    "keywords": "Property DevExpressFileName Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll DevExpressFileName Liefert den Datei-Namen des Report für DevExpress - ohne Pfad, aber mit qualifiziertem \\Report\\ -Unterordner. public string DevExpressFileName { get; } Property Value string"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.GetCaption.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.GetCaption.html",
    "title": "Method GetCaption",
    "keywords": "Method GetCaption Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetCaption(IGlobalObjects) Gibt die Beschriftung des Reports zurück in der Sprache der aktuellen Session. Dabei gelten folgende Prioritäten: Caption MLCaption public string GetCaption(IGlobalObjects globalObj) Parameters globalObj IGlobalObjects Returns string"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.GetFileName.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.GetFileName.html",
    "title": "Method GetFileName",
    "keywords": "Method GetFileName Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetFileName(ReportingSoftware) Ermittelt den Dateinamen des Reports auf Basis der angegebenen ReportingSoftware. public string GetFileName(ReportingSoftware software) Parameters software ReportingSoftware Die ReportingSoftware, für die der Name der Report-Datei ermittelt werden soll. Returns string Den ermittelten Dateinamen. (ohne Pfad)"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.GetPreferredFileName.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.GetPreferredFileName.html",
    "title": "Method GetPreferredFileName",
    "keywords": "Method GetPreferredFileName Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetPreferredFileName(IGlobalObjects) Liefert die ReportingSoftware und den FileName abhängig von der in ReportingSoftware favorisierten ReportingSoftware. Ist die favorisierte ReportingSoftware nicht verfügbar, dann wird jeweils die andere zurückgegeben. public (ReportingSoftware software, string fileName) GetPreferredFileName(IGlobalObjects global) Parameters global IGlobalObjects Returns (ReportingSoftware software, string fileName)"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.ID.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.ID.html",
    "title": "Property ID",
    "keywords": "Property ID Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ID Eindeutige ID des Reports. Bei Reports, die in der IDE angelegt wurden, entspricht diese ID der internen ID. Bei Custom-Reports wird eine neue ID generiert. public guid ID { get; } Property Value guid"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.MLCaption.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll MLCaption Mehrsprachige Beschriftung des Reports. public DevMLString MLCaption { get; } Property Value DevMLString See Also GetCaption(IGlobalObjects)"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.Orientation.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.Orientation.html",
    "title": "Property Orientation",
    "keywords": "Property Orientation Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Orientation Die Orientierung des Reports. Wird bei der Code-Generierung aus der Crystal Report-Datei ermittelt. public Orientation Orientation { get; } Property Value Orientation"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.ReportBytes.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.ReportBytes.html",
    "title": "Property ReportBytes",
    "keywords": "Property ReportBytes Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ReportBytes Binär-Daten einer rpt-Datei. Diese haben höhere Priorität als FS.Hosting.Core.Reporting.ReportEnum.ReportFileName. Wird für Custom Report-Definitionen verwendet. public byte[] ReportBytes { get; set; } Property Value byte[] Remarks Warning DevExpress-Reports, welche hier zuegwiesen werden, dürfen keine Scripte enthalten. Siehe auch Report-Scripting"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.ReportName.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.ReportName.html",
    "title": "Property ReportName",
    "keywords": "Property ReportName Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ReportName Der Name des Reports. public string ReportName { get; } Property Value string"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.ReportingSoftware.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.ReportingSoftware.html",
    "title": "Property ReportingSoftware",
    "keywords": "Property ReportingSoftware Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll ReportingSoftware Flags mit jeder nutzbarer Reporting-Software, mit der dieser Report gedruckt werden kann. public ReportingSoftware ReportingSoftware { get; } Property Value ReportingSoftware"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnum.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnum.html",
    "title": "Class ReportEnum",
    "keywords": "Class ReportEnum Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll Diese Klasse repräsentiert einen im Report Document Type definierten Report-File. public class ReportEnum Inheritance object ReportEnum Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Extension Methods ReportEnumExtensions.GetSupportedCultures(ReportEnum) Examples Beispiel für die Verwendung von ReportEnum: foreach( ReportEnum oReportEnum in rptDocumentP.GetReportEnums() ) { cPrintReportName oPrintReportName = new cPrintReportName(this.Global); oPrintReportName.sReportName = oReportEnum.ReportName; oPrintReportName.sReportCaption = oReportEnum.GetCaption( this.Global ); oPrintReportName.sReportFileName = rptDocumentP.ReportDir + \"\\\\\" + oReportEnum.ReportFileName; oPrintReportName.oReportName = oReportEnum; oPrintReportName.intPaperOrientaion = (int)oReportEnum.Orientation; this.Add(oPrintReportName); } Constructors ReportEnum(ReportEnumList, guid, string, Orientation, DevMLString, ReportingSoftware) Dieser Konstruktor wird im generierten Code verwendet. ReportEnum(guid, string, byte[], string, Orientation, ReportingSoftware?) Erzeugt eine individuelle Report-Definition. ReportEnum(guid, string, byte[], string, ReportingSoftware?) Erzeugt eine individuelle Report-Definition. Properties Caption Individuelle Beschriftung des Reports. Diese hat höhere Priorität als MLCaption. Wird für Custom Report-Definitionen verwendet. DevExpressFileName Liefert den Datei-Namen des Report für DevExpress - ohne Pfad, aber mit qualifiziertem \\Report\\ -Unterordner. ID Eindeutige ID des Reports. Bei Reports, die in der IDE angelegt wurden, entspricht diese ID der internen ID. Bei Custom-Reports wird eine neue ID generiert. MLCaption Mehrsprachige Beschriftung des Reports. Orientation Die Orientierung des Reports. Wird bei der Code-Generierung aus der Crystal Report-Datei ermittelt. ReportBytes Binär-Daten einer rpt-Datei. Diese haben höhere Priorität als FS.Hosting.Core.Reporting.ReportEnum.ReportFileName. Wird für Custom Report-Definitionen verwendet. ReportName Der Name des Reports. ReportingSoftware Flags mit jeder nutzbarer Reporting-Software, mit der dieser Report gedruckt werden kann. Methods GetCaption(IGlobalObjects) Gibt die Beschriftung des Reports zurück in der Sprache der aktuellen Session. Dabei gelten folgende Prioritäten: Caption MLCaption GetFileName(ReportingSoftware) Ermittelt den Dateinamen des Reports auf Basis der angegebenen ReportingSoftware. GetPreferredFileName(IGlobalObjects) Liefert die ReportingSoftware und den FileName abhängig von der in ReportingSoftware favorisierten ReportingSoftware. Ist die favorisierte ReportingSoftware nicht verfügbar, dann wird jeweils die andere zurückgegeben."
  },
  "api/FS.Hosting.Core.Reporting.ReportEnumExtensions.GetSupportedCultures.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnumExtensions.GetSupportedCultures.html",
    "title": "Method GetSupportedCultures",
    "keywords": "Method GetSupportedCultures Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll GetSupportedCultures(ReportEnum) Liefert die vom Report zusätzlich unterstützten Cultures zurück. Die \"Default\"-Culture des Reports ist nicht enthalten. public static IEnumerable<string> GetSupportedCultures(this ReportEnum reportEnum) Parameters reportEnum ReportEnum Returns IEnumerable<string>"
  },
  "api/FS.Hosting.Core.Reporting.ReportEnumExtensions.html": {
    "href": "api/FS.Hosting.Core.Reporting.ReportEnumExtensions.html",
    "title": "Class ReportEnumExtensions",
    "keywords": "Class ReportEnumExtensions Namespace FS.Hosting.Core.Reporting Assembly FS.Hosting.Core.dll public static class ReportEnumExtensions Inheritance object ReportEnumExtensions Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods GetSupportedCultures(ReportEnum) Liefert die vom Report zusätzlich unterstützten Cultures zurück. Die \"Default\"-Culture des Reports ist nicht enthalten."
  },
  "api/FS.Hosting.Core.Reporting.html": {
    "href": "api/FS.Hosting.Core.Reporting.html",
    "title": "Namespace FS.Hosting.Core.Reporting",
    "keywords": "Namespace FS.Hosting.Core.Reporting Classes DevExpressReport Der direkte FS-Wrapper für interfacing mit einer DevExpress.XtraReports.UI.XtraReport-Datei. Greift direkt auf XtraReport-Methoden zu und sollte intern als logische Repräsentation dessen betrachtet werden. DevExpressReportDocument Logische Repräsentation eines DevExpress XtraReports im Code. Wrapped einen DevExpressReport, welcher direktes interfacing mit der Runtime übernimmt. FSReportDocument Eine Basis für Wrapper tatsächlicher Report-Dateien. FSReportDocumentFactory ReportDesignSession Die ReportDesignSession Klasse erlaubt das Verwalten einer Report Designer Session. Die Klasse kann nur über CreateDesigner(ReportEnum) erzeugt werden. Über die Funktionen in der Klasse kann der Report Designer geöffnet werden, auf Veränderungen geprüft werden oder der geänderte Report zurückgeliefert werden. ReportDocument Diese Klasse ist die Basis-Klasse aller Report Document Types, die mit Framework-Studio entwickelt werden. ReportEnum Diese Klasse repräsentiert einen im Report Document Type definierten Report-File. ReportEnumExtensions"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.AuthenticationEnabled.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.AuthenticationEnabled.html",
    "title": "Property AuthenticationEnabled",
    "keywords": "Property AuthenticationEnabled Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. public bool AuthenticationEnabled { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.ChangePassword.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.ChangePassword.html",
    "title": "Method ChangePassword",
    "keywords": "Method ChangePassword Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll ChangePassword(string, string) Ändert das Passwort des momentan angemeldeten Benutzers. public void ChangePassword(string oldPassword, string newPassword) Parameters oldPassword string newPassword string"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.ChangePasswordChecked.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.ChangePasswordChecked.html",
    "title": "Method ChangePasswordChecked",
    "keywords": "Method ChangePasswordChecked Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll ChangePasswordChecked(string, string, string, out Message, string) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. public void ChangePasswordChecked(string username, string oldPassword, string newPassword, out Message message, string loginInfo) Parameters username string oldPassword string newPassword string message Message loginInfo string beliebiger Text, der vom Authentication Service geloggt wird, darf null sein ChangePasswordChecked(string, byte[], string, out Message, string) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. public void ChangePasswordChecked(string username, byte[] oldHashSign, string newPassword, out Message message, string loginInfo) Parameters username string oldHashSign byte[] Der Hashwert des alten Passwortes. newPassword string message Message loginInfo string beliebiger Text, der vom Authentication Service geloggt wird, darf null sein"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.GetApplicationRoles.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.GetApplicationRoles.html",
    "title": "Method GetApplicationRoles",
    "keywords": "Method GetApplicationRoles Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll GetApplicationRoles(bool) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. public List<string> GetApplicationRoles(bool reload) Parameters reload bool Mit true wird ein neues Laden der Rollen vom Authentication Service erzwungen. Returns List<string> GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. public List<string> GetApplicationRoles() Returns List<string>"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.GetPackages.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.GetPackages.html",
    "title": "Method GetPackages",
    "keywords": "Method GetPackages Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. public List<AUHelper.PackageInfo> GetPackages() Returns List<AUHelper.PackageInfo> Remarks Das SystemPackage ist in der Liste nicht enthalten. Die Liste beginnt mit dem DefaultPackage und endet mit dem obersten CustomizingPackage. Die Klasse AUHelper.PackageInfo enthält über ein Package die Informationen ID, Name, Version und Hersteller (Manufacturer)."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.GetRoleCaption.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.GetRoleCaption.html",
    "title": "Method GetRoleCaption",
    "keywords": "Method GetRoleCaption Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll GetRoleCaption(string) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. public string GetRoleCaption(string roleName) Parameters roleName string Returns string"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.GetRoleDescription.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.GetRoleDescription.html",
    "title": "Method GetRoleDescription",
    "keywords": "Method GetRoleDescription Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll GetRoleDescription(string) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. public string GetRoleDescription(string roleName) Parameters roleName string Returns string"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.GetUserRoles.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.GetUserRoles.html",
    "title": "Method GetUserRoles",
    "keywords": "Method GetUserRoles Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. public List<string> GetUserRoles() Returns List<string>"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.GetUserUnits.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.GetUserUnits.html",
    "title": "Method GetUserUnits",
    "keywords": "Method GetUserUnits Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. public List<string> GetUserUnits() Returns List<string>"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.Granted.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.Granted.html",
    "title": "Method Granted",
    "keywords": "Method Granted Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. public bool Granted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit type AUPermissionType Returns bool Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1, AUPermissionType.Delete ) ) { //Delete granted } if ( this.Global.Granted(AUList.aufrmForm1, AUPermissionType.Insert) ) { //Insert granted } Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten. Prüft OnLicenseGranted(AccessUnit, AUPermissionType), wenn die übergebene accessUnit erlaubt ist. Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. public bool Granted(AccessUnit accessUnit) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList. Returns bool Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1 ) ) { //Access granted } Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.IdentifyDefaultUser.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.IdentifyDefaultUser.html",
    "title": "Method IdentifyDefaultUser",
    "keywords": "Method IdentifyDefaultUser Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. public bool IdentifyDefaultUser() Returns bool Gibt bei Erfolg true und bei einem Fehler false zurück. IdentifyDefaultUser(out Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. public bool IdentifyDefaultUser(out Message msg) Parameters msg Message Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. Returns bool Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.IdentifyUnit.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.IdentifyUnit.html",
    "title": "Method IdentifyUnit",
    "keywords": "Method IdentifyUnit Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll IdentifyUnit(string) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. public void IdentifyUnit(string unitKey) Parameters unitKey string"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.IdentifyUser.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.IdentifyUser.html",
    "title": "Method IdentifyUser",
    "keywords": "Method IdentifyUser Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll IdentifyUser(out Message, string, string, ref string, bool) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. public bool IdentifyUser(out Message msg, string username, string password, ref string loginInfo, bool includeRolesInToken) Parameters msg Message Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. username string password string loginInfo string Der Parameter LoginIngo wird ausgelesen und vom Authentication Service geloggt. Zurückgegeben wird die zuletzt geloggte Information. includeRolesInToken bool Der letzte Parameter gibt an, ob die Rollen im Token kommuniziert werden sollen - Standardwert true Returns bool Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.IsDefaultUser.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.IsDefaultUser.html",
    "title": "Property IsDefaultUser",
    "keywords": "Property IsDefaultUser Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. public bool IsDefaultUser { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.LicenseGranted.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.LicenseGranted.html",
    "title": "Method LicenseGranted",
    "keywords": "Method LicenseGranted Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. Prüft OnLicenseGranted(AccessUnit, AUPermissionType), wenn die übergebene accessUnit erlaubt ist. public bool LicenseGranted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList. type AUPermissionType Eine AUPermissionType Returns bool Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access } Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt. LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt Prüft OnLicenseGranted(AccessUnit, AUPermissionType), wenn die übergebene accessUnit erlaubt ist. public bool LicenseGranted(AccessUnit accessUnit) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList. Returns bool Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access } Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.LicenseGrantedInFile.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.LicenseGrantedInFile.html",
    "title": "Method LicenseGrantedInFile",
    "keywords": "Method LicenseGrantedInFile Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll LicenseGrantedInFile(AccessUnit, AUPermissionType) Gibt zurück, ob die vorhandene Lizenz-Datei den Zugriff auf die übergebene AccessUnit erlaubt. OnLicenseGranted(AccessUnit, AUPermissionType) wird dabei nicht geprüft. public bool LicenseGrantedInFile(AccessUnit accessUnit, AUPermissionType type = AUPermissionType.Access) Parameters accessUnit AccessUnit type AUPermissionType Returns bool"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.LicenseVerifier.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.LicenseVerifier.html",
    "title": "Property LicenseVerifier",
    "keywords": "Property LicenseVerifier Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll LicenseVerifier Liefert den LicenseVerifier für die Verwaltung der ausgewerteten Lizenzen zurück. public LicenseVerifier LicenseVerifier { get; } Property Value LicenseVerifier"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html",
    "title": "Field AssemblyPrefix",
    "keywords": "Field AssemblyPrefix Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. public readonly string AssemblyPrefix Returns string Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.ID.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.ID.html",
    "title": "Field ID",
    "keywords": "Field ID Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Die eindeutige ID des Packages. public readonly guid ID Returns guid Die eindeutige ID des Packages."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.LastCompileDate.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.LastCompileDate.html",
    "title": "Field LastCompileDate",
    "keywords": "Field LastCompileDate Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Zeitpunkt des letzten Compiles. public readonly DateTime LastCompileDate Returns DateTime Zeitpunkt des letzten Compiles."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.Manufacturer.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.Manufacturer.html",
    "title": "Field Manufacturer",
    "keywords": "Field Manufacturer Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Der im Package definierte Hersteller. public readonly string Manufacturer Returns string Der im Package definierte Hersteller."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.Name.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.Name.html",
    "title": "Field Name",
    "keywords": "Field Name Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Der Name des Packages. public readonly string Name Returns string Der Name des Packages."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.ProductName.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.ProductName.html",
    "title": "Field ProductName",
    "keywords": "Field ProductName Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Der an der Package-Version definierte Product Name. public readonly string ProductName Returns string Der an der Package-Version definierte Product Name."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.PublicKey.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.PublicKey.html",
    "title": "Field PublicKey",
    "keywords": "Field PublicKey Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Der öffenliche Schlüssel des Packages. public readonly RSAKeyPair PublicKey Returns RSAKeyPair Der öffenliche Schlüssel des Packages."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.Version.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.Version.html",
    "title": "Field Version",
    "keywords": "Field Version Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Die Version des Packages. public readonly string Version Returns string Die Version des Packages."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html",
    "title": "Field WasLastCompileBugFix",
    "keywords": "Field WasLastCompileBugFix Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat. public readonly bool WasLastCompileBugFix Returns bool Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.PackageInfo.html",
    "title": "Class AUHelper.PackageInfo",
    "keywords": "Class AUHelper.PackageInfo Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden. [Serializable] public sealed class AUHelper.PackageInfo Inheritance object AUHelper.PackageInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Warning Die Klasse darf nicht im eigenen Code instanziiert werden. Fields AssemblyPrefix Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. ID Die eindeutige ID des Packages. LastCompileDate Zeitpunkt des letzten Compiles. Manufacturer Der im Package definierte Hersteller. Name Der Name des Packages. ProductName Der an der Package-Version definierte Product Name. PublicKey Der öffenliche Schlüssel des Packages. Version Die Version des Packages. WasLastCompileBugFix Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat."
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.RegisterUnits.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.RegisterUnits.html",
    "title": "Method RegisterUnits",
    "keywords": "Method RegisterUnits Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll RegisterUnits(IEnumerable<KeyValuePair<string, string>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service. public void RegisterUnits(IEnumerable<KeyValuePair<string, string>> units) Parameters units IEnumerable<KeyValuePair<string, string>> Key = unit id / Value = unit name"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.UnitKey.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.UnitKey.html",
    "title": "Property UnitKey",
    "keywords": "Property UnitKey Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(string)) angemeldet wurde. public string UnitKey { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.Units.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.Units.html",
    "title": "Property Units",
    "keywords": "Property Units Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. public IEnumerable<KeyValuePair<string, string>> Units { get; } Property Value IEnumerable<KeyValuePair<string, string>> Remarks KeyValuePair.Key = Schlüsselwert der Unit (Geschäftseinheit) KeyValuePair.Value = Name der Unit"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.UserTokenAsString.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.UserTokenAsString.html",
    "title": "Property UserTokenAsString",
    "keywords": "Property UserTokenAsString Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. public string UserTokenAsString { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.Username.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.Username.html",
    "title": "Property Username",
    "keywords": "Property Username Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. public string Username { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.AccessControl.AUHelper.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUHelper.html",
    "title": "Class AUHelper",
    "keywords": "Class AUHelper Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. [Serializable] public sealed class AUHelper Inheritance object AUHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Examples this.Global.AUHelper.ChangePassword( sOld, sNew ); Properties AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. LicenseVerifier Liefert den LicenseVerifier für die Verwaltung der ausgewerteten Lizenzen zurück. UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(string)) angemeldet wurde. Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Methods ChangePassword(string, string) Ändert das Passwort des momentan angemeldeten Benutzers. ChangePasswordChecked(string, byte[], string, out Message, string) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. ChangePasswordChecked(string, string, string, out Message, string) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetApplicationRoles(bool) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. GetRoleCaption(string) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetRoleDescription(string) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyDefaultUser(out Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyUnit(string) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. IdentifyUser(out Message, string, string, ref string, bool) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt Prüft OnLicenseGranted(AccessUnit, AUPermissionType), wenn die übergebene accessUnit erlaubt ist. LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. Prüft OnLicenseGranted(AccessUnit, AUPermissionType), wenn die übergebene accessUnit erlaubt ist. LicenseGrantedInFile(AccessUnit, AUPermissionType) Gibt zurück, ob die vorhandene Lizenz-Datei den Zugriff auf die übergebene AccessUnit erlaubt. OnLicenseGranted(AccessUnit, AUPermissionType) wird dabei nicht geprüft. RegisterUnits(IEnumerable<KeyValuePair<string, string>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service."
  },
  "api/FS.Hosting.Shared.AccessControl.AUPermissionType.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AUPermissionType.html",
    "title": "Enum AUPermissionType",
    "keywords": "Enum AUPermissionType Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Das AUPermissionType Enum kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden. [Serializable] public enum AUPermissionType Fields Access = 2 Is general access allowed? AccessDerived = 1 Is access of an AccessUnit, which is derived from this AccessUnit, possible? Delete = 5 Is deleting allowed? Insert = 3 Is inserting allowed? Update = 4 Is updating allowed?"
  },
  "api/FS.Hosting.Shared.AccessControl.AccessUnit.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.AccessUnit.html",
    "title": "Class AccessUnit",
    "keywords": "Class AccessUnit Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Die AccessUnit Klasse enthält die ID und Name einer AccessUnit. [Serializable] public sealed class AccessUnit Inheritance object AccessUnit Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Shared.AccessControl.LicenseSerializer.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.LicenseSerializer.html",
    "title": "Class LicenseSerializer",
    "keywords": "Class LicenseSerializer Namespace FS.Hosting.Shared.AccessControl Assembly FS.Hosting.Shared.dll Die LicenseSerializer Klasse implementiert einen Serialisierter für die License und License2 Klassen. public class LicenseSerializer Inheritance object LicenseSerializer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples // Allgemeine Lizenz Informationen reinschreiben License2 license = new License2(); license.LicenseID = guid.NewGuid(); license.LicenseName = \"Test License\"; license.LicenseType = LicenseTypes.Customer; license.Customer = \"NV\"; license.ValidFrom = DateTime.MinValue; license.ValidTo = new DateTime(2022, 12, 31); license.UserLimit = 25; license.Category = \"\"; license.Addition = \"\"; // Ein oder mehrere Packages hinzufügen license.Packages.Add(new LicensePackage { PackageID = new guid(\"fde6193cb96842aaaf0d5e005b1a0c8d\"), PackageName = \"FSDemo\", LabelID = new guid(\"59c39232d37c4107b99f423a2a56da8e\"), LabelName = \"4.3\", VersionFrom = null, VersionTo = new Version(4, 3), CustomInfos = new Dictionary<string, string> { { \"Key\", \"Value\" }, { \"Base64Data\", \"SGFsbG8gV2VsdA==\" }, } }); // Alle exklusiven AccessUnits mit ihren Ids hinzufügen foreach (guid exclusiveAccessUnitId in new guid[] { new guid(\"c8954266da5e4f0dbd0e2177393ee60c\") }) { license.ExclusiveAccessUnits.Add(exclusiveAccessUnitId); } // Alle berechtigten AccessUnits hinzufügen foreach (guid allowedAccessUnitId in new guid[] { new guid(\"AccessUnitRoot\"), new guid(\"36c417a410da4644bbfa5cc16fd0a4aa\") }) { license.AccessUnits.Set(allowedAccessUnitId, AUPermission.Allowed); } // PackageName / PrivateKey Repository, die PrivateKeys werden für die Signierung benötigt. Dictionary<string, RSAKeyPair> packageNamePrivateKeyRelation = new Dictionary<string, RSAKeyPair>(); packageNamePrivateKeyRelation.Add(\"FSDemo\", new RSAKeyPair()); // Hier wird in einen string geschrieben, möglich ist aber auch ein XDocument Objekt. string xmlText = LicenseSerializer.ToText(license, packageID => packageNamePrivateKeyRelation[packageID]); // Deserialisierung (ohne Verifikation) ILicense license = LicenseSerializer.FromText(xmlText);"
  },
  "api/FS.Hosting.Shared.AccessControl.html": {
    "href": "api/FS.Hosting.Shared.AccessControl.html",
    "title": "Namespace FS.Hosting.Shared.AccessControl",
    "keywords": "Namespace FS.Hosting.Shared.AccessControl Classes AUHelper Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. AUHelper.PackageInfo Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden. AccessUnit Die AccessUnit Klasse enthält die ID und Name einer AccessUnit. LicenseSerializer Die LicenseSerializer Klasse implementiert einen Serialisierter für die License und License2 Klassen. Enums AUPermissionType Das AUPermissionType Enum kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden."
  },
  "api/FS.Hosting.Shared.AdoptMode.html": {
    "href": "api/FS.Hosting.Shared.AdoptMode.html",
    "title": "Enum AdoptMode",
    "keywords": "Enum AdoptMode Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Gibt an, wie sich die Methoden Clone(AdoptMode) und AdoptValues(IDevFrameworkBaseObject, AdoptMode) verhalten. [Flags] public enum AdoptMode Fields Deep = 0 (Wert = 0) Das Flag Flat ist nicht gesetzt. Default = 0 (Wert = 0) Standard-Wert = Deep Flat = 1 (Wert = 0x1) Es wird eine flache Kopie durch geführt. Ist dieses Flag nicht gesetzt, dann wird eine tiefe Kopie erzeugt, d.h. für alle eingebetteten Objekte wird eine Kopie erzeugt. NoHistory = 2 (Wert = 0x2) Die Information IsHistorical wird nicht übertragen. Bei neu erzeugten Kopien hat das Property den Wert false."
  },
  "api/FS.Hosting.Shared.BarcodeFormat.html": {
    "href": "api/FS.Hosting.Shared.BarcodeFormat.html",
    "title": "Enum BarcodeFormat",
    "keywords": "Enum BarcodeFormat Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll [Flags] public enum BarcodeFormat Fields ALL = AZTEC | CODABAR | CODE_39 | CODE_93 | CODE_128 | DATA_MATRIX | EAN_8 | EAN_13 | ITF | PDF_417 | QR_CODE | UPC_A | UPC_E Es werden alle Barcode-Formate unterstützt. AZTEC = 1 CODABAR = 2 CODE_128 = 16 CODE_39 = 4 CODE_93 = 8 DATA_MATRIX = 32 EAN_13 = 128 EAN_8 = 64 ITF = 256 NONE = 0 Der Scan-Vorgang hat keinen Barcode ermittelt. PDF_417 = 512 QR_CODE = 1024 UPC_A = 2048 UPC_E = 4096"
  },
  "api/FS.Hosting.Shared.BrowserCommand.BROKER_TAG.html": {
    "href": "api/FS.Hosting.Shared.BrowserCommand.BROKER_TAG.html",
    "title": "Field BROKER_TAG",
    "keywords": "Field BROKER_TAG Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. public const string BROKER_TAG = \"fsbroker://\" Returns string Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Remarks Ressourcen mit fsbroker://RelativerPfad werden von dem Browser ausgewertet und durch den absoluten Pfad ersetzt."
  },
  "api/FS.Hosting.Shared.BrowserCommand.CreateArgument.html": {
    "href": "api/FS.Hosting.Shared.BrowserCommand.CreateArgument.html",
    "title": "Method CreateArgument",
    "keywords": "Method CreateArgument Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll CreateArgument(string, object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. public static KeyValuePair<string, string> CreateArgument(string key, object value) Parameters key string value object Returns KeyValuePair<string, string> Remarks So können z.B. die FS-Datentypen wie in dem nachfolgenden Beispiel als Wert übergeben werden: string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); Die FrameworkOnLinkClickEventArgs bieten Methoden GetArgument-Methoden (z.B. GetArgumentFSlong) um mit dem richtigen Schlüssel einen Wert im entsprechenden FSTyp wieder auszulesen. Auslesen der Argumente im Browser-Event OnLinkClick: if (e.IsCommand && e.Command == \"TestCommand\") { FSlong lngDocumentID = e.GetArgumentFSlong(\"Belegnummer\"); FSstring sDocumentType = e.GetArgumentFSstring(\"Belegart\"); FSDateTime dtDate = e.GetArgumentFSDateTime(\"Datum\"); }"
  },
  "api/FS.Hosting.Shared.BrowserCommand.CreateCommand.html": {
    "href": "api/FS.Hosting.Shared.BrowserCommand.CreateCommand.html",
    "title": "Method CreateCommand",
    "keywords": "Method CreateCommand Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll CreateCommand(string, IDictionary<string, string>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. public static string CreateCommand(string commandName, IDictionary<string, string> args = null) Parameters commandName string args IDictionary<string, string> Returns string Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando (commandName) und über eine beliebige Anzahl von Argumenten (args). Die Argumente bestehen immer aus einem Schlüssel (Key) und einem Wert (Value) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: //Command-Args erstellen Dictionary<string, string> linkCommandArgs = new Dictionary<string, string>(); linkCommandArgs.Add(\"Key1\", \"1235\"); linkCommandArgs.Add(\"Key2\", \"Test\"); linkCommandArgs.Add(\"Key3\", \"Test 1234\"); // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", linkCommandArgs); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\";</code></pre></example> CreateCommand(string, params KeyValuePair<string, string>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. public static string CreateCommand(string commandName, params KeyValuePair<string, string>[] args) Parameters commandName string args KeyValuePair<string, string>[] Returns string Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando (commandName) und über eine beliebige Anzahl von Argumenten (args). Die Argumente bestehen immer aus einem Schlüssel (Key) und einem Wert (Value) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die einzelnen Argumente können mit der Methode CreateArgument(string, object) erzeugt werden, um die Konvertierung verschiedener Typen korrekt vorzunehmen. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", new KeyValuePair<string, string>(\"Key1\", \"Wert1\"), BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\";</code></pre></example>"
  },
  "api/FS.Hosting.Shared.BrowserCommand.CreateRessourcesUrl.html": {
    "href": "api/FS.Hosting.Shared.BrowserCommand.CreateRessourcesUrl.html",
    "title": "Method CreateRessourcesUrl",
    "keywords": "Method CreateRessourcesUrl Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll CreateRessourcesUrl(string) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. public static string CreateRessourcesUrl(string relativePath) Parameters relativePath string Returns string Remarks Diese Url kann dann, wie im nachfolgendem Beispiel, in Verbindung mit HTML z.B. als Link zu einer Datei verwendet warden: // Link zu einer CSS-Datei sStyle = \"<link rel=\"stylesheet\" type=\"text/css\" href=\"\" + BrowserCommand.CreateRessourcesUrl(\"test.css\") + \"\" />\";"
  },
  "api/FS.Hosting.Shared.BrowserCommand.TryParseCommand.html": {
    "href": "api/FS.Hosting.Shared.BrowserCommand.TryParseCommand.html",
    "title": "Method TryParseCommand",
    "keywords": "Method TryParseCommand Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll TryParseCommand(string, out string, out Dictionary<string, string>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(string, IDictionary<string, string>) und extrahiert, falls es sich bei dem übergebenen Link (url) um ein Link-Kommando handelt, das Kommando (commandName) und die Argumente (args). Andernfalls wird false zurückgegeben. public static bool TryParseCommand(string url, out string commandName, out Dictionary<string, string> args) Parameters url string commandName string args Dictionary<string, string> Returns bool"
  },
  "api/FS.Hosting.Shared.BrowserCommand.html": {
    "href": "api/FS.Hosting.Shared.BrowserCommand.html",
    "title": "Class BrowserCommand",
    "keywords": "Class BrowserCommand Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. public class BrowserCommand Inheritance object BrowserCommand Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BROKER_TAG Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Methods CreateArgument(string, object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. CreateCommand(string, IDictionary<string, string>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateCommand(string, params KeyValuePair<string, string>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateRessourcesUrl(string) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. TryParseCommand(string, out string, out Dictionary<string, string>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(string, IDictionary<string, string>) und extrahiert, falls es sich bei dem übergebenen Link (url) um ein Link-Kommando handelt, das Kommando (commandName) und die Argumente (args). Andernfalls wird false zurückgegeben."
  },
  "api/FS.Hosting.Shared.CameraSource.html": {
    "href": "api/FS.Hosting.Shared.CameraSource.html",
    "title": "Enum CameraSource",
    "keywords": "Enum CameraSource Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum CameraSource Fields CAMERA = 1 Öffnet auf dem Endgerät die Kamera zum erstellen eines neuen Fotos GALLERY = 0 Öffnet auf dem Endgerät die Bildergalerie zur Auswahl eines Fotos"
  },
  "api/FS.Hosting.Shared.ComboEditStyle.html": {
    "href": "api/FS.Hosting.Shared.ComboEditStyle.html",
    "title": "Enum ComboEditStyle",
    "keywords": "Enum ComboEditStyle Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum ComboEditStyle Fields FreeTextInput = 1 ListValuesInput = 2"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServiceDescription.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServiceDescription.html",
    "title": "Property AppServiceDescription",
    "keywords": "Property AppServiceDescription Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AppServiceDescription Gibt die Beschreibung der Application zurück. Diese wird dem dem Authentication-Service migeteilt. string AppServiceDescription { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServiceId.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServiceId.html",
    "title": "Property AppServiceId",
    "keywords": "Property AppServiceId Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AppServiceId Gibt die ID zurück mit der sich die Application am Authentication-Service registriert. guid AppServiceId { get; } Property Value guid"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServiceName.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServiceName.html",
    "title": "Property AppServiceName",
    "keywords": "Property AppServiceName Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AppServiceName Gibt den Namen der Application zurück. Dieser wird dem dem Authentication-Service migeteilt. string AppServiceName { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServicePrivateKey.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServicePrivateKey.html",
    "title": "Property AppServicePrivateKey",
    "keywords": "Property AppServicePrivateKey Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AppServicePrivateKey Gibt den Private Key der Application als byte[] zurück. Der Authentication-Service besitzt den Public teil dieses Keys und validiert damit Nachrichten von der Application. byte[] AppServicePrivateKey { get; } Property Value byte[]"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServicePrivateKeyHex.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServicePrivateKeyHex.html",
    "title": "Property AppServicePrivateKeyHex",
    "keywords": "Property AppServicePrivateKeyHex Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AppServicePrivateKeyHex Gibt den Private Key der Application als Hex-String zurück. Der Authentication-Service besitzt den Public teil dieses Keys und validiert damit Nachrichten von der Application. string AppServicePrivateKeyHex { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServiceTitle.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AppServiceTitle.html",
    "title": "Property AppServiceTitle",
    "keywords": "Property AppServiceTitle Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AppServiceTitle Gibt den Titel der Application zurück. Dieser wird in der Titelleiste im Client angezeigt. string AppServiceTitle { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AuthServiceDefaultUserName.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AuthServiceDefaultUserName.html",
    "title": "Property AuthServiceDefaultUserName",
    "keywords": "Property AuthServiceDefaultUserName Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AuthServiceDefaultUserName Gibt den Namen des Users zurück, mit dem sich defaultmäßig am Authentication Service angemeldet werden soll. string AuthServiceDefaultUserName { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AuthServiceDefaultUserPassword.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AuthServiceDefaultUserPassword.html",
    "title": "Property AuthServiceDefaultUserPassword",
    "keywords": "Property AuthServiceDefaultUserPassword Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AuthServiceDefaultUserPassword Gibt das Password des Default-Users AuthServiceDefaultUserName zurück. string AuthServiceDefaultUserPassword { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AuthServicePublicKey.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AuthServicePublicKey.html",
    "title": "Property AuthServicePublicKey",
    "keywords": "Property AuthServicePublicKey Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AuthServicePublicKey Gibt den Public Key des Authentication-Service als byte[] zurück. byte[] AuthServicePublicKey { get; } Property Value byte[]"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AuthServicePublicKeyHex.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.AuthServicePublicKeyHex.html",
    "title": "Property AuthServicePublicKeyHex",
    "keywords": "Property AuthServicePublicKeyHex Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll AuthServicePublicKeyHex Gibt den Public Key des Authentication-Service als Hex-String zurück. string AuthServicePublicKeyHex { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.BrokerIdentifier.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.BrokerIdentifier.html",
    "title": "Property BrokerIdentifier",
    "keywords": "Property BrokerIdentifier Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll BrokerIdentifier Gibt den dem Tenant zugeordneten BrokerIdentifier zurück.. Wird nicht mit einem BrokerIdentifier gearbeitet, dann wird null zurückgegeben. string BrokerIdentifier { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.ExistsLicense.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.ExistsLicense.html",
    "title": "Property ExistsLicense",
    "keywords": "Property ExistsLicense Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll ExistsLicense true, wenn eine Lizenz für den Tenant existiert. bool ExistsLicense { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.ExpirationState.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.ExpirationState.html",
    "title": "Property ExpirationState",
    "keywords": "Property ExpirationState Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll ExpirationState Gibt den Gültigkeits-Status des Tenant zurück. TenantExpirationState ExpirationState { get; } Property Value TenantExpirationState"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.GetConnectionString.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.GetConnectionString.html",
    "title": "Method GetConnectionString",
    "keywords": "Method GetConnectionString Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll GetConnectionString(string) Gibt den ConnectionString für eine Connection-Group zurück. string GetConnectionString(string connectionGroupName) Parameters connectionGroupName string Name der Connection-Group. Reservierter Name: \"RuntimeConnection\" Returns string Exceptions ApplicationException Connection-String für die ConnectionGroup nicht gefunden See Also GetRuntimeConnectionString(IRuntimeConfigProvider)"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.GetLicenseXml.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.GetLicenseXml.html",
    "title": "Method GetLicenseXml",
    "keywords": "Method GetLicenseXml Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll GetLicenseXml(guid) Gibt das Lizenz-Xml für ein Package zurück. XElement GetLicenseXml(guid packageId) Parameters packageId guid Eindeutige ID des Packages Returns XElement Lizenz-Xml - der Knoten \"License\". Remarks Es wird bei jedem Aufruf eine neue Instanz des XML-Knoten zurückgegeben. Bei mehrfachen Zugriffen ist ein lokales Caching empfehlenswert. Exceptions ApplicationException Es gibt keine Lizenz für das Package."
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.GetServiceHostEnabled.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.GetServiceHostEnabled.html",
    "title": "Method GetServiceHostEnabled",
    "keywords": "Method GetServiceHostEnabled Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll GetServiceHostEnabled(string) Gibt die BaseAddress eines Service Hosts zurück. bool GetServiceHostEnabled(string hostFullName) Parameters hostFullName string Der FullName das FS Service Hosts. Returns bool true, wenn die Adresse angegeben ist."
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.IsAuthenticationEnabled.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.IsAuthenticationEnabled.html",
    "title": "Property IsAuthenticationEnabled",
    "keywords": "Property IsAuthenticationEnabled Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll IsAuthenticationEnabled Gibt zurück, ob die Authentication aktiviert ist. bool IsAuthenticationEnabled { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.IsReadonly.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.IsReadonly.html",
    "title": "Property IsReadonly",
    "keywords": "Property IsReadonly Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll IsReadonly Gibt an, ob die Konfigurations-Informationen geschrieben werden können. bool IsReadonly { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.RuntimeSupervisorEnabled.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.RuntimeSupervisorEnabled.html",
    "title": "Property RuntimeSupervisorEnabled",
    "keywords": "Property RuntimeSupervisorEnabled Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll RuntimeSupervisorEnabled Gibt zurück, ob der Runtime-Supervisor aktiviert ist. bool RuntimeSupervisorEnabled { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.RuntimeSupervisorUri.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.RuntimeSupervisorUri.html",
    "title": "Property RuntimeSupervisorUri",
    "keywords": "Property RuntimeSupervisorUri Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll RuntimeSupervisorUri Gibt die Url des Runtime Supervisor Uri RuntimeSupervisorUri { get; } Property Value Uri"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.SetLicenseXml.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.SetLicenseXml.html",
    "title": "Method SetLicenseXml",
    "keywords": "Method SetLicenseXml Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll SetLicenseXml(guid, XElement) Schreibt die Lizenz-Information für ein Package. Diese Methode kann nur aufgerufen werden, wenn nicht IsReadonly. void SetLicenseXml(guid packageId, XElement xeLicense) Parameters packageId guid Eindeutige ID des Packages xeLicense XElement Lizenz-Xml - der Knoten \"License\" Exceptions InvalidOperationException Bei Aufruf trotz IsReadonly"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.Tenant.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.Tenant.html",
    "title": "Property Tenant",
    "keywords": "Property Tenant Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll Tenant Gibt den Namen des Tanant zurück. Wird nicht mit Tenants gearbeitet, dann wird null zurückgegeben. string Tenant { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.TryGetServiceProxyAddress.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.TryGetServiceProxyAddress.html",
    "title": "Method TryGetServiceProxyAddress",
    "keywords": "Method TryGetServiceProxyAddress Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll TryGetServiceProxyAddress(string, out string) Gibt die Adresse eines Service-Endpoints zurück. bool TryGetServiceProxyAddress(string proxyFullName, out string address) Parameters proxyFullName string Der FullName das FS Service Proxy. address string Gibt die Addresse zurück, wenn diese angegeben ist. Returns bool true, wenn die Adresse angegeben ist."
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.IRuntimeConfigProvider.html",
    "title": "Interface IRuntimeConfigProvider",
    "keywords": "Interface IRuntimeConfigProvider Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll Managed die Runtime-Konfigurationen. Eine Instanz kann über das statische Property RuntimeConfig.Get abgerufen werden. public interface IRuntimeConfigProvider Extension Methods RuntimeConfigExtensions.GetRuntimeConnectionString(IRuntimeConfigProvider) Properties AppServiceDescription Gibt die Beschreibung der Application zurück. Diese wird dem dem Authentication-Service migeteilt. AppServiceId Gibt die ID zurück mit der sich die Application am Authentication-Service registriert. AppServiceName Gibt den Namen der Application zurück. Dieser wird dem dem Authentication-Service migeteilt. AppServicePrivateKey Gibt den Private Key der Application als byte[] zurück. Der Authentication-Service besitzt den Public teil dieses Keys und validiert damit Nachrichten von der Application. AppServicePrivateKeyHex Gibt den Private Key der Application als Hex-String zurück. Der Authentication-Service besitzt den Public teil dieses Keys und validiert damit Nachrichten von der Application. AppServiceTitle Gibt den Titel der Application zurück. Dieser wird in der Titelleiste im Client angezeigt. AuthServiceDefaultUserName Gibt den Namen des Users zurück, mit dem sich defaultmäßig am Authentication Service angemeldet werden soll. AuthServiceDefaultUserPassword Gibt das Password des Default-Users AuthServiceDefaultUserName zurück. AuthServicePublicKey Gibt den Public Key des Authentication-Service als byte[] zurück. AuthServicePublicKeyHex Gibt den Public Key des Authentication-Service als Hex-String zurück. BrokerIdentifier Gibt den dem Tenant zugeordneten BrokerIdentifier zurück.. Wird nicht mit einem BrokerIdentifier gearbeitet, dann wird null zurückgegeben. ExistsLicense true, wenn eine Lizenz für den Tenant existiert. ExpirationState Gibt den Gültigkeits-Status des Tenant zurück. IsAuthenticationEnabled Gibt zurück, ob die Authentication aktiviert ist. IsReadonly Gibt an, ob die Konfigurations-Informationen geschrieben werden können. RuntimeSupervisorEnabled Gibt zurück, ob der Runtime-Supervisor aktiviert ist. RuntimeSupervisorUri Gibt die Url des Runtime Supervisor Tenant Gibt den Namen des Tanant zurück. Wird nicht mit Tenants gearbeitet, dann wird null zurückgegeben. Methods GetConnectionString(string) Gibt den ConnectionString für eine Connection-Group zurück. GetLicenseXml(guid) Gibt das Lizenz-Xml für ein Package zurück. GetServiceHostEnabled(string) Gibt die BaseAddress eines Service Hosts zurück. SetLicenseXml(guid, XElement) Schreibt die Lizenz-Information für ein Package. Diese Methode kann nur aufgerufen werden, wenn nicht IsReadonly. TryGetServiceProxyAddress(string, out string) Gibt die Adresse eines Service-Endpoints zurück."
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.RuntimeConfig.Get.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.RuntimeConfig.Get.html",
    "title": "Property Get",
    "keywords": "Property Get Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll Get Liefert die aktuelle Instanz der Runtime-Konfiguration. public static IRuntimeConfigProvider Get { get; } Property Value IRuntimeConfigProvider"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.RuntimeConfig.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.RuntimeConfig.html",
    "title": "Class RuntimeConfig",
    "keywords": "Class RuntimeConfig Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll Statische Klasse für den Einstieg in die Runtime-Konfiguration. public static class RuntimeConfig Inheritance object RuntimeConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Get Liefert die aktuelle Instanz der Runtime-Konfiguration."
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.RuntimeConfigExtensions.GetRuntimeConnectionString.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.RuntimeConfigExtensions.GetRuntimeConnectionString.html",
    "title": "Method GetRuntimeConnectionString",
    "keywords": "Method GetRuntimeConnectionString Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll GetRuntimeConnectionString(IRuntimeConfigProvider) Gibt den ConnectionString für die \"RuntimeConnection\" zurück. public static string GetRuntimeConnectionString(this IRuntimeConfigProvider provider) Parameters provider IRuntimeConfigProvider Returns string"
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.RuntimeConfigExtensions.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.RuntimeConfigExtensions.html",
    "title": "Class RuntimeConfigExtensions",
    "keywords": "Class RuntimeConfigExtensions Namespace FS.Hosting.Shared.Configuration.Runtime Assembly FS.Hosting.Shared.dll public static class RuntimeConfigExtensions Inheritance object RuntimeConfigExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetRuntimeConnectionString(IRuntimeConfigProvider) Gibt den ConnectionString für die \"RuntimeConnection\" zurück."
  },
  "api/FS.Hosting.Shared.Configuration.Runtime.html": {
    "href": "api/FS.Hosting.Shared.Configuration.Runtime.html",
    "title": "Namespace FS.Hosting.Shared.Configuration.Runtime",
    "keywords": "Namespace FS.Hosting.Shared.Configuration.Runtime Classes RuntimeConfig Statische Klasse für den Einstieg in die Runtime-Konfiguration. RuntimeConfigExtensions Interfaces IRuntimeConfigProvider Managed die Runtime-Konfigurationen. Eine Instanz kann über das statische Property RuntimeConfig.Get abgerufen werden."
  },
  "api/FS.Hosting.Shared.Converter.IXmlConverter-1.FromXml.html": {
    "href": "api/FS.Hosting.Shared.Converter.IXmlConverter-1.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll FromXml(string) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T T FromXml(string xml) Parameters xml string Returns T"
  },
  "api/FS.Hosting.Shared.Converter.IXmlConverter-1.ToXml.html": {
    "href": "api/FS.Hosting.Shared.Converter.IXmlConverter-1.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. string ToXml(T value) Parameters value T Returns string"
  },
  "api/FS.Hosting.Shared.Converter.IXmlConverter-1.html": {
    "href": "api/FS.Hosting.Shared.Converter.IXmlConverter-1.html",
    "title": "Interface IXmlConverter<T>",
    "keywords": "Interface IXmlConverter<T> Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T. public interface IXmlConverter<T> Type Parameters T Methods FromXml(string) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. See Also XmlConverter"
  },
  "api/FS.Hosting.Shared.Converter.XmlConverter.DateTimeNumberFormat.html": {
    "href": "api/FS.Hosting.Shared.Converter.XmlConverter.DateTimeNumberFormat.html",
    "title": "Field DateTimeNumberFormat",
    "keywords": "Field DateTimeNumberFormat Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. public static readonly CultureInfo DateTimeNumberFormat Returns CultureInfo Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden."
  },
  "api/FS.Hosting.Shared.Converter.XmlConverter.FromXml.html": {
    "href": "api/FS.Hosting.Shared.Converter.XmlConverter.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll FromXml<T>(string) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T. Nicht unterstützte Datentypen (Unterstützte Typen) führen zu einer NotImplementedException. public T FromXml<T>(string xml) Parameters xml string Returns T Type Parameters T"
  },
  "api/FS.Hosting.Shared.Converter.XmlConverter.Get.html": {
    "href": "api/FS.Hosting.Shared.Converter.XmlConverter.Get.html",
    "title": "Property Get",
    "keywords": "Property Get Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. public static XmlConverter Get { get; } Property Value XmlConverter"
  },
  "api/FS.Hosting.Shared.Converter.XmlConverter.IsConvertible.html": {
    "href": "api/FS.Hosting.Shared.Converter.XmlConverter.IsConvertible.html",
    "title": "Method IsConvertible",
    "keywords": "Method IsConvertible Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können (Unterstützte Typen). public bool IsConvertible(Type type) Parameters type Type Returns bool IsConvertible(string) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können (Unterstützte Typen). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long) als auch deren .NET-Klassen (z.B. Int64), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. public bool IsConvertible(string typeName) Parameters typeName string Returns bool"
  },
  "api/FS.Hosting.Shared.Converter.XmlConverter.ToXml.html": {
    "href": "api/FS.Hosting.Shared.Converter.XmlConverter.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen (Unterstützte Typen) führen zu einer NotImplementedException. public string ToXml<T>(T value) Parameters value T Returns string Type Parameters T ToXml(object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen (Unterstützte Typen) führen zu einer NotImplementedException. public string ToXml(object value) Parameters value object Returns string"
  },
  "api/FS.Hosting.Shared.Converter.XmlConverter.XMLNumberFormat.html": {
    "href": "api/FS.Hosting.Shared.Converter.XmlConverter.XMLNumberFormat.html",
    "title": "Field XMLNumberFormat",
    "keywords": "Field XMLNumberFormat Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. public static readonly CultureInfo XMLNumberFormat Returns CultureInfo Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden."
  },
  "api/FS.Hosting.Shared.Converter.XmlConverter.XML_NULL.html": {
    "href": "api/FS.Hosting.Shared.Converter.XmlConverter.XML_NULL.html",
    "title": "Field XML_NULL",
    "keywords": "Field XML_NULL Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll Definiert die String-Repräsentation eines null-Wertes im Xml. public const string XML_NULL = \"\" Returns string Definiert die String-Repräsentation eines null-Wertes im Xml."
  },
  "api/FS.Hosting.Shared.Converter.XmlConverter.html": {
    "href": "api/FS.Hosting.Shared.Converter.XmlConverter.html",
    "title": "Class XmlConverter",
    "keywords": "Class XmlConverter Namespace FS.Hosting.Shared.Converter Assembly FS.Hosting.Shared.dll Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. public class XmlConverter : IXmlConverter<FSbool>, IXmlConverter<FSbyte>, IXmlConverter<FSbyteArray>, IXmlConverter<FSDateTime>, IXmlConverter<FSdecimal>, IXmlConverter<FSdouble>, IXmlConverter<FSfloat>, IXmlConverter<FSint>, IXmlConverter<FSlong>, IXmlConverter<FSshort>, IXmlConverter<FSstring>, IXmlConverter<FSSystemGuid>, IXmlConverter<bool>, IXmlConverter<byte>, IXmlConverter<byte[]>, IXmlConverter<DateTime>, IXmlConverter<decimal>, IXmlConverter<double>, IXmlConverter<float>, IXmlConverter<int>, IXmlConverter<long>, IXmlConverter<short>, IXmlConverter<string>, IXmlConverter<Guid> Inheritance object XmlConverter Implements IXmlConverter<FSbool> IXmlConverter<FSbyte> IXmlConverter<FSbyteArray> IXmlConverter<FSDateTime> IXmlConverter<FSdecimal> IXmlConverter<FSdouble> IXmlConverter<FSfloat> IXmlConverter<FSint> IXmlConverter<FSlong> IXmlConverter<FSshort> IXmlConverter<FSstring> IXmlConverter<FSSystemGuid> IXmlConverter<bool> IXmlConverter<byte> IXmlConverter<byte[]> IXmlConverter<DateTime> IXmlConverter<decimal> IXmlConverter<double> IXmlConverter<float> IXmlConverter<int> IXmlConverter<long> IXmlConverter<short> IXmlConverter<string> IXmlConverter<Guid> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Ein Objekt dieser Klasse wird als Singleton-Instanz angeboten. Note Im Java-Client gibt es ein entsprechendes Gegenstück, die Klasse FrameworkSystems.FSJavaClient.UIWrapper.DotNetTypes, welche statische Methoden zum Umwandeln von Objekten in einen String und umgekehrt anbietet. Unterstützte Typen Die Klasse unterstützt die Konvertierung ausschließlich für die im Folgenden aufgeführten Typen und implementiert für jeden der Typen T das entsprechende Interface IXmlConverter<T>: FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring FSSystemGuid bool byte byte[] DateTime decimal double float int long short string Guid Fields DateTimeNumberFormat Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. XMLNumberFormat Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. XML_NULL Definiert die String-Repräsentation eines null-Wertes im Xml. Properties Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. Methods FromXml<T>(string) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T. Nicht unterstützte Datentypen (Unterstützte Typen) führen zu einer NotImplementedException. IsConvertible(string) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können (Unterstützte Typen). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long) als auch deren .NET-Klassen (z.B. Int64), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können (Unterstützte Typen). ToXml(object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen (Unterstützte Typen) führen zu einer NotImplementedException. ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen (Unterstützte Typen) führen zu einer NotImplementedException."
  },
  "api/FS.Hosting.Shared.Converter.html": {
    "href": "api/FS.Hosting.Shared.Converter.html",
    "title": "Namespace FS.Hosting.Shared.Converter",
    "keywords": "Namespace FS.Hosting.Shared.Converter Classes XmlConverter Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. Interfaces IXmlConverter<T> Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T."
  },
  "api/FS.Hosting.Shared.DelegateChangeToken.-ctor.html": {
    "href": "api/FS.Hosting.Shared.DelegateChangeToken.-ctor.html",
    "title": "Constructor DelegateChangeToken",
    "keywords": "Constructor DelegateChangeToken Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll DelegateChangeToken(Func<bool>) public DelegateChangeToken(Func<bool> hasChangedDelegate) Parameters hasChangedDelegate Func<bool> DelegateChangeToken(TimeSpan, Func<bool>) public DelegateChangeToken(TimeSpan checkInterval, Func<bool> hasChangedDelegate) Parameters checkInterval TimeSpan hasChangedDelegate Func<bool>"
  },
  "api/FS.Hosting.Shared.DelegateChangeToken.CheckInterval.html": {
    "href": "api/FS.Hosting.Shared.DelegateChangeToken.CheckInterval.html",
    "title": "Property CheckInterval",
    "keywords": "Property CheckInterval Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll CheckInterval Das im Konstruktor übergebene Intervall in dem die Prüfung anschlägt. public TimeSpan? CheckInterval { get; } Property Value TimeSpan?"
  },
  "api/FS.Hosting.Shared.DelegateChangeToken.HasChanged.html": {
    "href": "api/FS.Hosting.Shared.DelegateChangeToken.HasChanged.html",
    "title": "Property HasChanged",
    "keywords": "Property HasChanged Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll HasChanged Gibt zurück, ob ein Change stattgefunden hat. public bool HasChanged { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.DelegateChangeToken.html": {
    "href": "api/FS.Hosting.Shared.DelegateChangeToken.html",
    "title": "Class DelegateChangeToken",
    "keywords": "Class DelegateChangeToken Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Ein IChangeToken, der mithilfe eines Delegate die Change-Information zurückgeben kann. public class DelegateChangeToken Inheritance object DelegateChangeToken Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Kann z.B. im FSCache verwendet werden, um die Aktualität von Cache-Einträgen zu prüfen. FSCache.Instance.Static().GetOrCreate(\"Parameter\", entry => { var parameterData = LoadParameter(); // Mit HasDbChanged() wird alle 2 Minuten geprüft, ob die Daten noch aktuell sind. entry.AddExpirationToken(new DelegateChangeToken(TimeSpan.FromMinutes(2), () => { return FSGlobal.Current != null && parameterData.HasDbChanged(); })); return parameterData; }); Constructors DelegateChangeToken(Func<bool>) DelegateChangeToken(TimeSpan, Func<bool>) Properties CheckInterval Das im Konstruktor übergebene Intervall in dem die Prüfung anschlägt. HasChanged Gibt zurück, ob ein Change stattgefunden hat."
  },
  "api/FS.Hosting.Shared.DevFrameworkBaseObject.ComponentProperties.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkBaseObject.ComponentProperties.html",
    "title": "Property ComponentProperties",
    "keywords": "Property ComponentProperties Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ComponentProperties Siehe ComponentProperties im Interface IDevFrameworkBaseObject public StringCollection ComponentProperties { get; } Property Value StringCollection"
  },
  "api/FS.Hosting.Shared.DevFrameworkBaseObject.Freeze.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkBaseObject.Freeze.html",
    "title": "Method Freeze",
    "keywords": "Method Freeze Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Freeze() Sperrt das Objekt für weitere Änderungen. Wird bei einem frozen Objekt versucht Werte zu verändern, wird eine InvalidOperationException geworfen. [HideForOverride] public virtual void Freeze()"
  },
  "api/FS.Hosting.Shared.DevFrameworkBaseObject.GetProperty.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkBaseObject.GetProperty.html",
    "title": "Method GetProperty",
    "keywords": "Method GetProperty Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetProperty(string) Gibt den Wert des Properties mit dem übergebenen propertyName zurück. [HideForOverride] public virtual object GetProperty(string propertyName) Parameters propertyName string Name des zu ermittelnden Properties. Returns object Remarks Es darf nur auf public oder internal Properties zugegriffen werden. Exceptions PropertyNotFoundException Das übergebene Property existiert nicht oder dessen Zugriffsmodifizierer erlaubt keinen Zugriff."
  },
  "api/FS.Hosting.Shared.DevFrameworkBaseObject.IsComponentProperty.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkBaseObject.IsComponentProperty.html",
    "title": "Method IsComponentProperty",
    "keywords": "Method IsComponentProperty Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll IsComponentProperty(string) Siehe IsComponentProperty(string) im Interface IDevFrameworkBaseObject public bool IsComponentProperty(string propertyName) Parameters propertyName string Returns bool"
  },
  "api/FS.Hosting.Shared.DevFrameworkBaseObject.IsFrozen.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkBaseObject.IsFrozen.html",
    "title": "Property IsFrozen",
    "keywords": "Property IsFrozen Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll IsFrozen Gibt zurück, ob das Objekt mittels der Methode Freeze() für Änderungen gesperrt wurde. public bool IsFrozen { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.DevFrameworkBaseObject.OnPropertyChanged.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkBaseObject.OnPropertyChanged.html",
    "title": "Method OnPropertyChanged",
    "keywords": "Method OnPropertyChanged Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll OnPropertyChanged(string) Diese Methode löst unmittelbar das event FS.Hosting.Shared.DevFrameworkBaseObject.PropertyChanged aus. Sie kann in der Component überschrieben werden. protected virtual void OnPropertyChanged(string propertyName) Parameters propertyName string Der Name des geänderten Properties. Bei null oder String.Empty sind alle Properties geändert. Remarks Warning Wird bei einer Überschreibung kein base-Aufruf ausgeführt, dann wird das Event nicht gefeuert."
  },
  "api/FS.Hosting.Shared.DevFrameworkBaseObject.SetProperty.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkBaseObject.SetProperty.html",
    "title": "Method SetProperty",
    "keywords": "Method SetProperty Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll SetProperty(string, object) Setzt das Property mit dem übergebenen propertyName auf den Wert value. [HideForOverride] public virtual void SetProperty(string propertyName, object value) Parameters propertyName string Name des zu setzenden Properties. value object Zu setzender Wert. Exceptions MissingMemberException Das property existiert nicht."
  },
  "api/FS.Hosting.Shared.DevFrameworkBaseObject.ThrowIfFrozen.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkBaseObject.ThrowIfFrozen.html",
    "title": "Method ThrowIfFrozen",
    "keywords": "Method ThrowIfFrozen Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ThrowIfFrozen() protected void ThrowIfFrozen()"
  },
  "api/FS.Hosting.Shared.DevFrameworkBaseObject.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkBaseObject.html",
    "title": "Class DevFrameworkBaseObject",
    "keywords": "Class DevFrameworkBaseObject Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Basisklasse für DevFrameworkObject und DevFrameworkObjectColl public abstract class DevFrameworkBaseObject : IDevFrameworkBaseObject, INotifyPropertyChanged, ICloneable Inheritance object DevFrameworkBaseObject Implements IDevFrameworkBaseObject INotifyPropertyChanged ICloneable Derived DevFrameworkObject Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ComponentProperties Siehe ComponentProperties im Interface IDevFrameworkBaseObject IsFrozen Gibt zurück, ob das Objekt mittels der Methode Freeze() für Änderungen gesperrt wurde. Methods Freeze() Sperrt das Objekt für weitere Änderungen. Wird bei einem frozen Objekt versucht Werte zu verändern, wird eine InvalidOperationException geworfen. GetProperty(string) Gibt den Wert des Properties mit dem übergebenen propertyName zurück. IsComponentProperty(string) Siehe IsComponentProperty(string) im Interface IDevFrameworkBaseObject OnPropertyChanged(string) Diese Methode löst unmittelbar das event FS.Hosting.Shared.DevFrameworkBaseObject.PropertyChanged aus. Sie kann in der Component überschrieben werden. SetProperty(string, object) Setzt das Property mit dem übergebenen propertyName auf den Wert value. ThrowIfFrozen()"
  },
  "api/FS.Hosting.Shared.DevFrameworkObject.DeferRecursiveSaves.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkObject.DeferRecursiveSaves.html",
    "title": "Method DeferRecursiveSaves",
    "keywords": "Method DeferRecursiveSaves Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll DeferRecursiveSaves() Gibt zurück, ob alle Save-Aufrufe an dieser Instanz, die während eines laufenden Save-Aufrufs an dieser Instanz erfolgen, direkt abgebrochen werden sollen und stattdessen nach dem initialen Save-Aufruf (innerhalb der Transaktion) ein weiterer Save-Aufruf erfolgen soll. Standardmäßig gibt die Methode \"false\" zurück. Der Mechanismus kann aktiviert werden, in dem die Methode mit \"return true\" überschrieben wird. protected virtual bool DeferRecursiveSaves() Returns bool Examples protected override bool DeferRecursiveSaves() { return true; }"
  },
  "api/FS.Hosting.Shared.DevFrameworkObject.OnTrackChange.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkObject.OnTrackChange.html",
    "title": "Method OnTrackChange",
    "keywords": "Method OnTrackChange Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll OnTrackChange(string) Diese Methode wird aufgerufen, wenn der Wert eines Properties geändert wird. [HideForIntellisense] [HideForOverride] protected virtual void OnTrackChange(string propertyName) Parameters propertyName string Der Name des geänderten Properties. Remarks Eine Überschreibung dieser Methode wird automatisch in den Code jeder Component generiert. Im Debugger kann man damit einen Breakpoint setzen, der bei einer Änderung der Component anschlägt. Die Methode kann in Framework Studio nicht überschrieben werden. Alternativ kann aber die Methode OnPropertyChanged(string) überschrieben werden."
  },
  "api/FS.Hosting.Shared.DevFrameworkObject.Save.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkObject.Save.html",
    "title": "Method Save",
    "keywords": "Method Save Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Save(SaveEntryPoints) Speichert diese Component in der Datenbank ab. Das entsprechende SqlStatement muss in der SaveAction zusammengebaut und ausgeführt werden. Falls keine gestartete Transaktion existiert, wird automatisch eine Transaktion aufgebaut. In diesem Fall wird anschliessend ein Commit ausgeführt. Zuerst wird FS.Hosting.Shared.DevFrameworkObject.OnBeforeSave(), anschließend die SaveAction und abschließend FS.Hosting.Shared.DevFrameworkObject.OnAfterSave() aufgerufen. public void Save(SaveEntryPoints saveEntryPoints) Parameters saveEntryPoints SaveEntryPoints Wenn true, dann werden die EntryPoints auch aufgerufen, falls die Komponente nicht geändert wurde."
  },
  "api/FS.Hosting.Shared.DevFrameworkObject.State.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkObject.State.html",
    "title": "Property State",
    "keywords": "Property State Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll State Aktueller Status des IDevFrameworkObjects. public FrameworkComponentState State { get; set; } Property Value FrameworkComponentState Remarks Änderungen werden über das Event PropertyChanged gemeldet."
  },
  "api/FS.Hosting.Shared.DevFrameworkObject.html": {
    "href": "api/FS.Hosting.Shared.DevFrameworkObject.html",
    "title": "Class DevFrameworkObject",
    "keywords": "Class DevFrameworkObject Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Basisklasse für alle Components, die über FrameworkStudio erzeugt werden. [ComVisible(false)] public abstract class DevFrameworkObject : DevFrameworkBaseObject, ICloneable, IDevFrameworkObject, IDevFrameworkBaseObject, INotifyPropertyChanged Inheritance object DevFrameworkBaseObject DevFrameworkObject Implements ICloneable IDevFrameworkObject IDevFrameworkBaseObject INotifyPropertyChanged Derived cGlobalBase Inherited Members DevFrameworkBaseObject.IsFrozen DevFrameworkBaseObject.Freeze() DevFrameworkBaseObject.ThrowIfFrozen() DevFrameworkBaseObject.GetProperty(string) DevFrameworkBaseObject.SetProperty(string, object) DevFrameworkBaseObject.ComponentProperties DevFrameworkBaseObject.IsComponentProperty(string) DevFrameworkBaseObject.OnPropertyChanged(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties State Aktueller Status des IDevFrameworkObjects. Methods DeferRecursiveSaves() Gibt zurück, ob alle Save-Aufrufe an dieser Instanz, die während eines laufenden Save-Aufrufs an dieser Instanz erfolgen, direkt abgebrochen werden sollen und stattdessen nach dem initialen Save-Aufruf (innerhalb der Transaktion) ein weiterer Save-Aufruf erfolgen soll. Standardmäßig gibt die Methode \"false\" zurück. Der Mechanismus kann aktiviert werden, in dem die Methode mit \"return true\" überschrieben wird. OnTrackChange(string) Diese Methode wird aufgerufen, wenn der Wert eines Properties geändert wird. Save(SaveEntryPoints) Speichert diese Component in der Datenbank ab. Das entsprechende SqlStatement muss in der SaveAction zusammengebaut und ausgeführt werden. Falls keine gestartete Transaktion existiert, wird automatisch eine Transaktion aufgebaut. In diesem Fall wird anschliessend ein Commit ausgeführt. Zuerst wird FS.Hosting.Shared.DevFrameworkObject.OnBeforeSave(), anschließend die SaveAction und abschließend FS.Hosting.Shared.DevFrameworkObject.OnAfterSave() aufgerufen."
  },
  "api/FS.Hosting.Shared.DevTextAlign.html": {
    "href": "api/FS.Hosting.Shared.DevTextAlign.html",
    "title": "Enum DevTextAlign",
    "keywords": "Enum DevTextAlign Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Gibt die Ausrichtung des Textes an. public enum DevTextAlign Fields Center = 1 Zentriert DatatypeDefault = 4 Inherit = 3 Erbt von Vater-Control Left = 0 Linksbündig Right = 2 Rechtsbündig"
  },
  "api/FS.Hosting.Shared.DockPanelOrientation.html": {
    "href": "api/FS.Hosting.Shared.DockPanelOrientation.html",
    "title": "Enum DockPanelOrientation",
    "keywords": "Enum DockPanelOrientation Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll [HideForIntellisense] public enum DockPanelOrientation Fields Horizontal = 1 HorizontalOrVertical = 2 Vertical = 0"
  },
  "api/FS.Hosting.Shared.DockPanelScrolling.html": {
    "href": "api/FS.Hosting.Shared.DockPanelScrolling.html",
    "title": "Enum DockPanelScrolling",
    "keywords": "Enum DockPanelScrolling Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll [HideForIntellisense] public enum DockPanelScrolling Fields None = 0 Normal = 1 VerticalOverlay = 2"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html",
    "title": "Method GetBestTextFlavorData",
    "keywords": "Method GetBestTextFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat (TextFlavorData) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. public TextFlavorData GetBestTextFlavorData() Returns TextFlavorData"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html",
    "title": "Method GetBestTextFlavorType",
    "keywords": "Method GetBestTextFlavorType Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. public string GetBestTextFlavorType() Returns string Remarks Zu dem Daten zur Verfügung gestellt werden: TextXml TextHtml TextUriList TextPlain Ein unbekanntes Textformat, soweit eines unterstützt wird null, falls gar kein Textformat unterstützt wird"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html",
    "title": "Method GetFileListFlavorData",
    "keywords": "Method GetFileListFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste (FileListFlavorData) zurückgegeben, andernfalls null. public FileListFlavorData GetFileListFlavorData() Returns FileListFlavorData"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetFlavorData.html",
    "title": "Method GetFlavorData",
    "keywords": "Method GetFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetFlavorData(string) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData) zurückgegeben, andernfalls null. public FlavorData GetFlavorData(string flavorType) Parameters flavorType string Returns FlavorData"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html",
    "title": "Method GetImageFlavorData",
    "keywords": "Method GetImageFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten (ImageFlavorData) zurückgegeben, andernfalls null. public ImageFlavorData GetImageFlavorData() Returns ImageFlavorData"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html",
    "title": "Method GetSupportedFlavorTypes",
    "keywords": "Method GetSupportedFlavorTypes Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. public IEnumerable<string> GetSupportedFlavorTypes() Returns IEnumerable<string>"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html",
    "title": "Method GetSupportedTextFlavorTypes",
    "keywords": "Method GetSupportedTextFlavorTypes Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. public IEnumerable<string> GetSupportedTextFlavorTypes() Returns IEnumerable<string>"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html",
    "title": "Method GetTextFlavorData",
    "keywords": "Method GetTextFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetTextFlavorData(string) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null. public TextFlavorData GetTextFlavorData(string textFlavorType) Parameters textFlavorType string Returns TextFlavorData"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html",
    "title": "Method GetUriListFlavorData",
    "keywords": "Method GetUriListFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste (UriListFlavorData) zurückgegeben, ansonsten null. public UriListFlavorData GetUriListFlavorData() Returns UriListFlavorData"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html",
    "title": "Method IsFlavorTypeSupported",
    "keywords": "Method IsFlavorTypeSupported Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll IsFlavorTypeSupported(string) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können. public bool IsFlavorTypeSupported(string flavorType) Parameters flavorType string Returns bool"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ExternalTransferObject.html",
    "title": "Class ExternalTransferObject",
    "keywords": "Class ExternalTransferObject Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. public class ExternalTransferObject Inheritance object ExternalTransferObject Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples ExternalTransferObject oExternalTransferObject = e.TransferObject as ExternalTransferObject; if (oExternalTransferObject != null) { // Drag&Drop-Vorgang von außerhalb der Applikation } else { // Drag&Drop-Vorgang innerhalb der Applikation } Remarks Die Klasse bietet Methoden, mit denen ermittelt werden kann, welche FlavorTypes (FlavorType) unterstützt werden, also in welchen Formaten Daten zur Verfügung stehen. Außerdem können zu jedem FlavorType die entsprechenden Daten (FlavorData) abgefragt werden. In den Events OnCanDrop und OnDrop kann eindeutig erkannt werden, ob es sich um einen internen oder einen externen Drag&Drop-Vorgang handelt, indem überprüft wird, ob das TransferObject vom Typ ExternalTransferObject ist. Methods GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat (TextFlavorData) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste (FileListFlavorData) zurückgegeben, andernfalls null. GetFlavorData(string) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData) zurückgegeben, andernfalls null. GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten (ImageFlavorData) zurückgegeben, andernfalls null. GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. GetTextFlavorData(string) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null. GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste (UriListFlavorData) zurückgegeben, ansonsten null. IsFlavorTypeSupported(string) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.Content.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.Content.html",
    "title": "Property Content",
    "keywords": "Property Content Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. public byte[] Content { get; protected set; } Property Value byte[]"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.FileType.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.FileType.html",
    "title": "Enum FileFlavorData.FileType",
    "keywords": "Enum FileFlavorData.FileType Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Der Dateityp, der Verzeichnis oder Datei ist. public enum FileFlavorData.FileType Fields Directory = 1 Ordner / Verzeichnis. File = 0 Datei."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.FullName.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.FullName.html",
    "title": "Property FullName",
    "keywords": "Property FullName Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll FullName Gibt den Dateinamen inklusive Pfad zurück. public string FullName { get; protected set; } Property Value string"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.LastModified.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.LastModified.html",
    "title": "Property LastModified",
    "keywords": "Property LastModified Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll LastModified Gibt das letzte Änderungsdatum der Datei zurück. public DateTime LastModified { get; protected set; } Property Value DateTime"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.Name.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Name Gibt den Dateinamen (inkl. Dateiendung) zurück. public string Name { get; protected set; } Property Value string"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.Size.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.Size.html",
    "title": "Property Size",
    "keywords": "Property Size Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. public long Size { get; protected set; } Property Value long"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.Type.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.Type.html",
    "title": "Property Type",
    "keywords": "Property Type Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Type Gibt den Typ der Datei zurück. public FileFlavorData.FileType Type { get; protected set; } Property Value FileFlavorData.FileType Remarks Mögliche Werte sind : File : Datei Directory : Verzeichnis"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileFlavorData.html",
    "title": "Class FileFlavorData",
    "keywords": "Class FileFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien (FileListFlavorData). public class FileFlavorData Inheritance object FileFlavorData Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. FullName Gibt den Dateinamen inklusive Pfad zurück. LastModified Gibt das letzte Änderungsdatum der Datei zurück. Name Gibt den Dateinamen (inkl. Dateiendung) zurück. Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. Type Gibt den Typ der Datei zurück."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileListFlavorData.Count.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Count Gibt die Anzahl der enthaltenen Dateien zurück. public int Count { get; } Property Value int"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileListFlavorData.GetEnumerator.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück. public IEnumerator<FileFlavorData> GetEnumerator() Returns IEnumerator<FileFlavorData> Examples FileListFlavorData oFileListFlavorData = oExternalTransferObject.GetFileListFlavorData(); foreach (FileFlavorData oFileFlavorData in oFileListFlavorData) { String sFileName = oFileFlavorData.Name; // ... }"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FileListFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FileListFlavorData.html",
    "title": "Class FileListFlavorData",
    "keywords": "Class FileListFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar (IEnumerator<FileFlavorData>) und eine Spezialisierung von FlavorData. public class FileListFlavorData : FlavorData, IEnumerable<FileFlavorData>, IEnumerable Inheritance object FlavorData FileListFlavorData Implements IEnumerable<FileFlavorData> IEnumerable Inherited Members FlavorData.FillOnDrop() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Die Enumeration enthält (auch im Event OnCanDrop) immer mindestens ein Objekt vom Typ FileFlavorData. Properties Count Gibt die Anzahl der enthaltenen Dateien zurück. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorData.FillOnDrop.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorData.FillOnDrop.html",
    "title": "Method FillOnDrop",
    "keywords": "Method FillOnDrop Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. public virtual void FillOnDrop() Remarks Hintergrund: Einige Datenformate bringen unter Umständen sehr große Datenmengen mit sich. Beispielsweise können Dateien sehr groß sein. Daher werden beim ersten Request des Clients (OnCanDrop) nur Informationen wie der Speicherort, Name, Größe usw. übertragen und nur dann, wenn der Inhalt tatsächlich im OnDrop benötigt wird (und deshalb FillOnDrop() aufgerufen wurde), werden die ggf. großen Daten ausgelesen und übertragen."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorData.html",
    "title": "Class FlavorData",
    "keywords": "Class FlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Die Daten, welche am externen Transferobjekt (ExternalTransferObject) bei einem Drag&Drop-Vorgang in einem bestimmten Format (FlavorType) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. public abstract class FlavorData Inheritance object FlavorData Derived FileListFlavorData ImageFlavorData TextFlavorData Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Die Klasse bietet die Methode FillOnDrop(). Durch den Aufruf dieser Methode wird gesteuert, dass beim Drop-Vorgang alle Daten vollständig gefüllt werden sollen. Methods FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. See Also FileFlavorData FileListFlavorData ImageFlavorData TextFlavorData UriListFlavorData"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorType.FileList.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorType.FileList.html",
    "title": "Field FileList",
    "keywords": "Field FileList Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Stellt Dateien dar. public const string FileList = \"application/x-java-file-list\" Returns string Stellt Dateien dar."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorType.Image.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorType.Image.html",
    "title": "Field Image",
    "keywords": "Field Image Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Stellt ein Bild dar. public const string Image = \"image/x-java-image\" Returns string Stellt ein Bild dar."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorType.IsTextFlavor.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorType.IsTextFlavor.html",
    "title": "Method IsTextFlavor",
    "keywords": "Method IsTextFlavor Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll IsTextFlavor(string) Gibt zurück, ob das übergebene Format ein Textformat ist. public static bool IsTextFlavor(string flavorType) Parameters flavorType string Returns bool"
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextHtml.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextHtml.html",
    "title": "Field TextHtml",
    "keywords": "Field TextHtml Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Stellt Text im HTML-Format dar. public const string TextHtml = \"text/html\" Returns string Stellt Text im HTML-Format dar."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextPlain.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextPlain.html",
    "title": "Field TextPlain",
    "keywords": "Field TextPlain Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Stellt unformatierten Text dar. public const string TextPlain = \"text/plain\" Returns string Stellt unformatierten Text dar."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextRtf.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextRtf.html",
    "title": "Field TextRtf",
    "keywords": "Field TextRtf Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Stellt Text im RTF-Format dar. public const string TextRtf = \"text/rtf\" Returns string Stellt Text im RTF-Format dar."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextUriList.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextUriList.html",
    "title": "Field TextUriList",
    "keywords": "Field TextUriList Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. public const string TextUriList = \"text/uri-list\" Returns string Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextXml.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorType.TextXml.html",
    "title": "Field TextXml",
    "keywords": "Field TextXml Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Stellt Text im XML-Format dar. public const string TextXml = \"text/xml\" Returns string Stellt Text im XML-Format dar."
  },
  "api/FS.Hosting.Shared.DragAndDrop.FlavorType.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.FlavorType.html",
    "title": "Class FlavorType",
    "keywords": "Class FlavorType Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop (\uF0E0 Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject (ExternalTransferObject) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. public static class FlavorType Inheritance object FlavorType Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Diese Klasse stellt primär Konstanten für alle von Framework Studio bekannten Datenformate zur Verfügung. Die Konstanten sind vom Typ String. So kann das externe Transferobjekt grundsätzlich auch unbekannte Datenformate unterstützen. Fields FileList Stellt Dateien dar. Image Stellt ein Bild dar. TextHtml Stellt Text im HTML-Format dar. TextPlain Stellt unformatierten Text dar. TextRtf Stellt Text im RTF-Format dar. TextUriList Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. TextXml Stellt Text im XML-Format dar. Methods IsTextFlavor(string) Gibt zurück, ob das übergebene Format ein Textformat ist."
  },
  "api/FS.Hosting.Shared.DragAndDrop.ImageFlavorData.ImageByteArray.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ImageFlavorData.ImageByteArray.html",
    "title": "Property ImageByteArray",
    "keywords": "Property ImageByteArray Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde. public byte[] ImageByteArray { get; } Property Value byte[]"
  },
  "api/FS.Hosting.Shared.DragAndDrop.ImageFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.ImageFlavorData.html",
    "title": "Class ImageFlavorData",
    "keywords": "Class ImageFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. public class ImageFlavorData : FlavorData Inheritance object FlavorData ImageFlavorData Inherited Members FlavorData.FillOnDrop() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FS.Hosting.Shared.DragAndDrop.TextFlavorData.Text.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.TextFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde. public virtual string Text { get; protected set; } Property Value string Remarks Lediglich die Texte in den Formaten TextPlain und TextUriList werden schon im OnCanDrop gefüllt."
  },
  "api/FS.Hosting.Shared.DragAndDrop.TextFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.TextFlavorData.html",
    "title": "Class TextFlavorData",
    "keywords": "Class TextFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. public class TextFlavorData : FlavorData Inheritance object FlavorData TextFlavorData Derived UriListFlavorData Inherited Members FlavorData.FillOnDrop() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks In einem Drag&Drop-Vorgang können mehrere TextFlavorData Objekte (zu unterschiedlichen Textformaten) enthalten sein. Properties Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FS.Hosting.Shared.DragAndDrop.UriListFlavorData.Count.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.UriListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Count Gibt die Anzahl der enthaltenen URIs zurück. public int Count { get; } Property Value int"
  },
  "api/FS.Hosting.Shared.DragAndDrop.UriListFlavorData.GetEnumerator.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.UriListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück. public IEnumerator<string> GetEnumerator() Returns IEnumerator<string> Examples UriListFlavorData oUriListFlavorData = oExternalTransferObject.GetUriListFlavordata(); foreach (string sUri in oUriListFlavorData) { // ... }"
  },
  "api/FS.Hosting.Shared.DragAndDrop.UriListFlavorData.Text.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.UriListFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. public override string Text { get; protected set; } Property Value string"
  },
  "api/FS.Hosting.Shared.DragAndDrop.UriListFlavorData.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.UriListFlavorData.html",
    "title": "Class UriListFlavorData",
    "keywords": "Class UriListFlavorData Namespace FS.Hosting.Shared.DragAndDrop Assembly FS.Hosting.Shared.dll Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. public class UriListFlavorData : TextFlavorData, IEnumerable<string>, IEnumerable Inheritance object FlavorData TextFlavorData UriListFlavorData Implements IEnumerable<string> IEnumerable Inherited Members FlavorData.FillOnDrop() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Die Klasse ist enumerierbar (IEnumerator<String>). Diese Klasse ist eine Spezialisierung von TextFlavorData, da der URI-Listen-Flavor ein spezieller Text-Flavor ist. Properties Count Gibt die Anzahl der enthaltenen URIs zurück. Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück."
  },
  "api/FS.Hosting.Shared.DragAndDrop.html": {
    "href": "api/FS.Hosting.Shared.DragAndDrop.html",
    "title": "Namespace FS.Hosting.Shared.DragAndDrop",
    "keywords": "Namespace FS.Hosting.Shared.DragAndDrop Classes ExternalTransferObject Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. FileFlavorData Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien (FileListFlavorData). FileListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar (IEnumerator<FileFlavorData>) und eine Spezialisierung von FlavorData. FlavorData Die Daten, welche am externen Transferobjekt (ExternalTransferObject) bei einem Drag&Drop-Vorgang in einem bestimmten Format (FlavorType) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. FlavorType Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop (\uF0E0 Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject (ExternalTransferObject) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. ImageFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. TextFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. UriListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. Enums FileFlavorData.FileType Der Dateityp, der Verzeichnis oder Datei ist."
  },
  "api/FS.Hosting.Shared.EditorStyle.html": {
    "href": "api/FS.Hosting.Shared.EditorStyle.html",
    "title": "Enum EditorStyle",
    "keywords": "Enum EditorStyle Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum EditorStyle Fields CheckBox = 1 ComboBox = 2 Editfield = 0 MultilineEditfield = 3"
  },
  "api/FS.Hosting.Shared.ExtendedShortcut.html": {
    "href": "api/FS.Hosting.Shared.ExtendedShortcut.html",
    "title": "Enum ExtendedShortcut",
    "keywords": "Enum ExtendedShortcut Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ExtendedShortcut contains the same properties as the System.Windows.Forms.Shortcut enumeration. Furthermore it is extended by: Esc = 27 [HideForIntellisense] public enum ExtendedShortcut Fields Alt0 = 262192 Alt1 = 262193 Alt2 = 262194 Alt3 = 262195 Alt4 = 262196 Alt5 = 262197 Alt6 = 262198 Alt7 = 262199 Alt8 = 262200 Alt9 = 262201 AltBksp = 262152 AltDownArrow = 262184 AltF1 = 262256 AltF10 = 262265 AltF11 = 262266 AltF12 = 262267 AltF2 = 262257 AltF3 = 262258 AltF4 = 262259 AltF5 = 262260 AltF6 = 262261 AltF7 = 262262 AltF8 = 262263 AltF9 = 262264 AltLeftArrow = 262181 AltRightArrow = 262183 AltUpArrow = 262182 Ctrl0 = 131120 Ctrl1 = 131121 Ctrl2 = 131122 Ctrl3 = 131123 Ctrl4 = 131124 Ctrl5 = 131125 Ctrl6 = 131126 Ctrl7 = 131127 Ctrl8 = 131128 Ctrl9 = 131129 CtrlA = 131137 CtrlB = 131138 CtrlC = 131139 CtrlD = 131140 CtrlDel = 131118 CtrlE = 131141 CtrlF = 131142 CtrlF1 = 131184 CtrlF10 = 131193 CtrlF11 = 131194 CtrlF12 = 131195 CtrlF2 = 131185 CtrlF3 = 131186 CtrlF4 = 131187 CtrlF5 = 131188 CtrlF6 = 131189 CtrlF7 = 131190 CtrlF8 = 131191 CtrlF9 = 131192 CtrlG = 131143 CtrlH = 131144 CtrlI = 131145 CtrlIns = 131117 CtrlJ = 131146 CtrlK = 131147 CtrlL = 131148 CtrlM = 131149 CtrlN = 131150 CtrlO = 131151 CtrlP = 131152 CtrlQ = 131153 CtrlR = 131154 CtrlS = 131155 CtrlShift0 = 196656 CtrlShift1 = 196657 CtrlShift2 = 196658 CtrlShift3 = 196659 CtrlShift4 = 196660 CtrlShift5 = 196661 CtrlShift6 = 196662 CtrlShift7 = 196663 CtrlShift8 = 196664 CtrlShift9 = 196665 CtrlShiftA = 196673 CtrlShiftB = 196674 CtrlShiftC = 196675 CtrlShiftD = 196676 CtrlShiftE = 196677 CtrlShiftF = 196678 CtrlShiftF1 = 196720 CtrlShiftF10 = 196729 CtrlShiftF11 = 196730 CtrlShiftF12 = 196731 CtrlShiftF2 = 196721 CtrlShiftF3 = 196722 CtrlShiftF4 = 196723 CtrlShiftF5 = 196724 CtrlShiftF6 = 196725 CtrlShiftF7 = 196726 CtrlShiftF8 = 196727 CtrlShiftF9 = 196728 CtrlShiftG = 196679 CtrlShiftH = 196680 CtrlShiftI = 196681 CtrlShiftJ = 196682 CtrlShiftK = 196683 CtrlShiftL = 196684 CtrlShiftM = 196685 CtrlShiftN = 196686 CtrlShiftO = 196687 CtrlShiftP = 196688 CtrlShiftQ = 196689 CtrlShiftR = 196690 CtrlShiftS = 196691 CtrlShiftT = 196692 CtrlShiftU = 196693 CtrlShiftV = 196694 CtrlShiftW = 196695 CtrlShiftX = 196696 CtrlShiftY = 196697 CtrlShiftZ = 196698 CtrlT = 131156 CtrlU = 131157 CtrlV = 131158 CtrlW = 131159 CtrlX = 131160 CtrlY = 131161 CtrlZ = 131162 Del = 46 Esc = 27 F1 = 112 F10 = 121 F11 = 122 F12 = 123 F2 = 113 F3 = 114 F4 = 115 F5 = 116 F6 = 117 F7 = 118 F8 = 119 F9 = 120 Ins = 45 None = 0 ShiftDel = 65582 ShiftF1 = 65648 ShiftF10 = 65657 ShiftF11 = 65658 ShiftF12 = 65659 ShiftF2 = 65649 ShiftF3 = 65650 ShiftF4 = 65651 ShiftF5 = 65652 ShiftF6 = 65653 ShiftF7 = 65654 ShiftF8 = 65655 ShiftF9 = 65656 ShiftIns = 65581"
  },
  "api/FS.Hosting.Shared.FSCache.GetTokenFor.html": {
    "href": "api/FS.Hosting.Shared.FSCache.GetTokenFor.html",
    "title": "Method GetTokenFor",
    "keywords": "Method GetTokenFor Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetTokenFor<T>(IFSCache) Gibt für den übergebenen Type einen IChangeToken zurück. public static IChangeToken GetTokenFor<T>(this IFSCache cache) Parameters cache IFSCache Returns IChangeToken Type Parameters T Remarks Bei der Arbeit mit Components sollte immer das Component-Interface für den einzelnen Record übergeben werden. Beispiel: return FSCache.Instance.Static().GetOrCreate(\"Countries\", entry => { entry.AddExpirationToken(FSCache.Instance.GetTokenFor<IcdCountry>() ); var countries = cdCountryCollFactory.Create(); countries.Load(); return countries; }); See Also GetTokenForKey(object) Invalidate<T>(IFSCache)"
  },
  "api/FS.Hosting.Shared.FSCache.Instance.html": {
    "href": "api/FS.Hosting.Shared.FSCache.Instance.html",
    "title": "Field Instance",
    "keywords": "Field Instance Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Singleton Instance des IFSCache. public static readonly IFSCache Instance Returns IFSCache Singleton Instance des ."
  },
  "api/FS.Hosting.Shared.FSCache.Invalidate.html": {
    "href": "api/FS.Hosting.Shared.FSCache.Invalidate.html",
    "title": "Method Invalidate",
    "keywords": "Method Invalidate Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Invalidate<T>(IFSCache) Invalidiert den aktuellen IChangeToken für den übergebenen Type. public static void Invalidate<T>(this IFSCache cache) Parameters cache IFSCache Type Parameters T Remarks Bei der Arbeit mit Components sollte immer das Component-Interface für den einzelnen Record übergeben werden. Beispiel: protected override void OnAfterSave() { FSCache.Instance.Invalidate<IcdCountry>() } See Also InvalidateKey(object) GetTokenFor<T>(IFSCache)"
  },
  "api/FS.Hosting.Shared.FSCache.Request.html": {
    "href": "api/FS.Hosting.Shared.FSCache.Request.html",
    "title": "Method Request",
    "keywords": "Method Request Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Request(IFSCache) Liefert den MemoryCache für den aktuellen Request. Die zum Request gehörende Session wird mithilfe des Token vom GlobalContext identifiziert. Der Cache wird verworfen, wenn am Ende eines Requests RequestCancellationToken abgebrochen wird public static IMemoryCache Request(this IFSCache cache) Parameters cache IFSCache Returns IMemoryCache Exceptions InvalidOperationException Es ist kein GlobalContext vorhanden oder das aktuelle Global wurde disposed."
  },
  "api/FS.Hosting.Shared.FSCache.Session.html": {
    "href": "api/FS.Hosting.Shared.FSCache.Session.html",
    "title": "Method Session",
    "keywords": "Method Session Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Session(IFSCache) Liefert den MemoryCache für die aktuelle Session. Die Session wird mithilfe des Token vom GlobalContext identifiziert. Der Cache wird verworfen, wenn Am Ende einer Session SessionCancellationToken abgebrochen wird oder public static IMemoryCache Session(this IFSCache cache) Parameters cache IFSCache Returns IMemoryCache Exceptions InvalidOperationException Es ist kein GlobalContext vorhanden oder das aktuelle Global wurde disposed."
  },
  "api/FS.Hosting.Shared.FSCache.Static.html": {
    "href": "api/FS.Hosting.Shared.FSCache.Static.html",
    "title": "Method Static",
    "keywords": "Method Static Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Static(IFSCache) Liefert den MemoryCache für den Static-Scope. public static IMemoryCache Static(this IFSCache cache) Parameters cache IFSCache Returns IMemoryCache"
  },
  "api/FS.Hosting.Shared.FSCache.html": {
    "href": "api/FS.Hosting.Shared.FSCache.html",
    "title": "Class FSCache",
    "keywords": "Class FSCache Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public static class FSCache Inheritance object FSCache Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Instance Singleton Instance des IFSCache. Methods GetTokenFor<T>(IFSCache) Gibt für den übergebenen Type einen IChangeToken zurück. Invalidate<T>(IFSCache) Invalidiert den aktuellen IChangeToken für den übergebenen Type. Request(IFSCache) Liefert den MemoryCache für den aktuellen Request. Die zum Request gehörende Session wird mithilfe des Token vom GlobalContext identifiziert. Der Cache wird verworfen, wenn am Ende eines Requests RequestCancellationToken abgebrochen wird Session(IFSCache) Liefert den MemoryCache für die aktuelle Session. Die Session wird mithilfe des Token vom GlobalContext identifiziert. Der Cache wird verworfen, wenn Am Ende einer Session SessionCancellationToken abgebrochen wird oder Static(IFSCache) Liefert den MemoryCache für den Static-Scope."
  },
  "api/FS.Hosting.Shared.FSDialogResult.html": {
    "href": "api/FS.Hosting.Shared.FSDialogResult.html",
    "title": "Enum FSDialogResult",
    "keywords": "Enum FSDialogResult Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum FSDialogResult Fields Abort = 3 Cancel = 2 Ignore = 5 No = 7 None = 0 OK = 1 Retry = 4 Yes = 6"
  },
  "api/FS.Hosting.Shared.FSVisibility.html": {
    "href": "api/FS.Hosting.Shared.FSVisibility.html",
    "title": "Enum FSVisibility",
    "keywords": "Enum FSVisibility Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum FSVisibility Fields Collapsed = 2 Das Control wird komplett ausgeblendet und benötigt keinen Platz. Im Form-Designer ist das Control sichtbar und wird mit einem schwarzen Schleier dargestellt. Hidden = 1 Das Control wird nicht angezeigt, es reserviert aber trotzdem Platz. Im Form-Designer ist das Control sichtbar und wird mit einem weißen Schleier dargestellt. Visible = 0 Das Control ist sichtbar. (Standardwert)"
  },
  "api/FS.Hosting.Shared.FieldRowLabelMode.html": {
    "href": "api/FS.Hosting.Shared.FieldRowLabelMode.html",
    "title": "Enum FieldRowLabelMode",
    "keywords": "Enum FieldRowLabelMode Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum FieldRowLabelMode Fields Generated = 0 Generated_Merged = 1 None = 2 None_Aligned = 3 Das erste Control wird in die Label-Spalte platziert. None_Fill = 4"
  },
  "api/FS.Hosting.Shared.FrameworkCloseMode.html": {
    "href": "api/FS.Hosting.Shared.FrameworkCloseMode.html",
    "title": "Enum FrameworkCloseMode",
    "keywords": "Enum FrameworkCloseMode Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Definiert den Modus mit dem die Application beendet werden soll. [Flags] public enum FrameworkCloseMode Fields Close = 0 KeepUserLogin = 2 Restart = 1"
  },
  "api/FS.Hosting.Shared.FrameworkComponentState.html": {
    "href": "api/FS.Hosting.Shared.FrameworkComponentState.html",
    "title": "Enum FrameworkComponentState",
    "keywords": "Enum FrameworkComponentState Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Status des Objektes. public enum FrameworkComponentState Fields Changed = 1 Das Objekt wurde verändert und die Änderungen wurden noch nicht gespeichert Deleted = 3 Das Objekt wurde gelöscht (und aus der Collection entfernt!) New = 2 Das Objekt wurde neu erzeugt, aber noch nicht gespeichert NewButDeleted = 4 Das Objekt wurde zwar neu erzeugt aber inzwischen schon wieder gelöscht (und aus der Collection entfernt!) Unchanged = 0 Das Objekt wurde seit dem Laden bzw. dem letzten Speichern nicht mehr verändert. UnchangedButDeleted = 6 Das Objekt wurde gelöscht und in der Datenbank gespeichert. So gilt er als Unchanged und Deleted"
  },
  "api/FS.Hosting.Shared.FrameworkFormatMask.html": {
    "href": "api/FS.Hosting.Shared.FrameworkFormatMask.html",
    "title": "Enum FrameworkFormatMask",
    "keywords": "Enum FrameworkFormatMask Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum FrameworkFormatMask Fields DateOnlyLong = 3 DateOnlyMedium = 2 DateOnlyShort = 1 DateTimeLong = 6 DateTimeMedium = 5 DateTimeShort = 4 Decimal = 10 Integer = 11 LowerCase = 14 NegativeInteger = 13 None = 0 PositiveInteger = 12 TimeOnlyLong = 9 TimeOnlyMedium = 8 TimeOnlyShort = 7 UpperCase = 15 UserDefined = 16"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.-ctor.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.-ctor.html",
    "title": "Constructor FrameworkProgress",
    "keywords": "Constructor FrameworkProgress Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll FrameworkProgress() public FrameworkProgress()"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.CanCancel.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.CanCancel.html",
    "title": "Property CanCancel",
    "keywords": "Property CanCancel Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true. public bool CanCancel { get; set; } Property Value bool"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.Canceled.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.Canceled.html",
    "title": "Property Canceled",
    "keywords": "Property Canceled Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. public bool Canceled { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.DetailText.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.DetailText.html",
    "title": "Property DetailText",
    "keywords": "Property DetailText Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. public string DetailText { get; set; } Property Value string"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.Dispose.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.Dispose.html",
    "title": "Method Dispose",
    "keywords": "Method Dispose Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client. public void Dispose()"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.Id.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.Id.html",
    "title": "Property Id",
    "keywords": "Property Id Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. public guid Id { get; } Property Value guid"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.MaxValue.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.MaxValue.html",
    "title": "Property MaxValue",
    "keywords": "Property MaxValue Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll MaxValue Der Maximalwert des Fortschrittsbalken. public long MaxValue { get; set; } Property Value long"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.Text.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Text Der Text, der über dem ProgressBar angezeigt werden soll. public string Text { get; set; } Property Value string"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.Value.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue. public long Value { get; set; } Property Value long"
  },
  "api/FS.Hosting.Shared.FrameworkProgress.html": {
    "href": "api/FS.Hosting.Shared.FrameworkProgress.html",
    "title": "Class FrameworkProgress",
    "keywords": "Class FrameworkProgress Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. public class FrameworkProgress : IDisposable Inheritance object FrameworkProgress Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples using(FrameworkProgress progress = new FrameworkProgress()) { // gibt an, ob der Cancel-Button überhaupt angezeigt werden soll progress.CanCancel = true; // sonstige Eigenschaften progress.Text = \"Fortschritt ...\"; progress.MaxValue = 1000; for(int i = 0; i <= progress.MaxValue; i++) { // breche ab, falls progress.Canceled = true if(progress.Canceled) { break; } progress.Value = i; progress.DetailText = \"i hat den Wert \" + i; // Aktion ... } } Anzeige auf dem Client: Remarks Es können auch mehrere FrameworkProgress Objekte zeitgleich verwendet werden. Die angezeigten Balken werden untereinander angeordnet. Constructors FrameworkProgress() Properties CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true. Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. MaxValue Der Maximalwert des Fortschrittsbalken. Text Der Text, der über dem ProgressBar angezeigt werden soll. Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue. Methods Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client."
  },
  "api/FS.Hosting.Shared.FrameworkQueryOptions.CommandTimeout.html": {
    "href": "api/FS.Hosting.Shared.FrameworkQueryOptions.CommandTimeout.html",
    "title": "Property CommandTimeout",
    "keywords": "Property CommandTimeout Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll CommandTimeout Überschreibt für die Ausführung der Abfrage die Eigenschaft CommandTimeout. public int? CommandTimeout { get; set; } Property Value int? Exceptions ArgumentException Der zugewiesene Wert ist kleiner als 0."
  },
  "api/FS.Hosting.Shared.FrameworkQueryOptions.Condition.html": {
    "href": "api/FS.Hosting.Shared.FrameworkQueryOptions.Condition.html",
    "title": "Property Condition",
    "keywords": "Property Condition Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Condition Zusätzliche zur in der Component-Query definierten Where-Klausel. public string Condition { get; set; } Property Value string"
  },
  "api/FS.Hosting.Shared.FrameworkQueryOptions.Count.html": {
    "href": "api/FS.Hosting.Shared.FrameworkQueryOptions.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Count Maximale Anzahl der Datensätze die zurückgegeben werden. public int? Count { get; set; } Property Value int?"
  },
  "api/FS.Hosting.Shared.FrameworkQueryOptions.Having.html": {
    "href": "api/FS.Hosting.Shared.FrameworkQueryOptions.Having.html",
    "title": "Property Having",
    "keywords": "Property Having Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Having Ersetzt die in der Component-Query definierte Having-Klausel. public string Having { get; set; } Property Value string"
  },
  "api/FS.Hosting.Shared.FrameworkQueryOptions.Offset.html": {
    "href": "api/FS.Hosting.Shared.FrameworkQueryOptions.Offset.html",
    "title": "Property Offset",
    "keywords": "Property Offset Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Offset Anzahl der Datensätze die übersprungen werden sollen. Zusammen mit der Eigenschaft Count kann man ein Paging realisieren. public int? Offset { get; set; } Property Value int?"
  },
  "api/FS.Hosting.Shared.FrameworkQueryOptions.OrderBy.html": {
    "href": "api/FS.Hosting.Shared.FrameworkQueryOptions.OrderBy.html",
    "title": "Property OrderBy",
    "keywords": "Property OrderBy Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll OrderBy Ersetzt die in der Component-Query definierte OrderBy-Klausel. public string OrderBy { get; set; } Property Value string"
  },
  "api/FS.Hosting.Shared.FrameworkQueryOptions.html": {
    "href": "api/FS.Hosting.Shared.FrameworkQueryOptions.html",
    "title": "Class FrameworkQueryOptions",
    "keywords": "Class FrameworkQueryOptions Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public class FrameworkQueryOptions Inheritance object FrameworkQueryOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CommandTimeout Überschreibt für die Ausführung der Abfrage die Eigenschaft CommandTimeout. Condition Zusätzliche zur in der Component-Query definierten Where-Klausel. Count Maximale Anzahl der Datensätze die zurückgegeben werden. Having Ersetzt die in der Component-Query definierte Having-Klausel. Offset Anzahl der Datensätze die übersprungen werden sollen. Zusammen mit der Eigenschaft Count kann man ein Paging realisieren. OrderBy Ersetzt die in der Component-Query definierte OrderBy-Klausel."
  },
  "api/FS.Hosting.Shared.FromControlWrapperProcessedState.html": {
    "href": "api/FS.Hosting.Shared.FromControlWrapperProcessedState.html",
    "title": "Enum FromControlWrapperProcessedState",
    "keywords": "Enum FromControlWrapperProcessedState Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Verarbeitungsstatus der in einem Grid verwendeten Objekte public enum FromControlWrapperProcessedState Fields ProcessedChanged = 1 ProcessedDeleted = 4 ProcessedNew = 3 ProcessedUnchanged = 2 Unprocessed = 0"
  },
  "api/FS.Hosting.Shared.GlobalObj.ContentDownload.CleanupAction.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.ContentDownload.CleanupAction.html",
    "title": "Property CleanupAction",
    "keywords": "Property CleanupAction Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll CleanupAction Diese Methode wird aufgerufen, wenn der Eintrag verworfen wird. Als Parameter wird der Wert von FS.Hosting.Shared.GlobalObj.ContentDownload.Argument übergeben. public Action<object> CleanupAction { get; set; } Property Value Action<object>"
  },
  "api/FS.Hosting.Shared.GlobalObj.ContentDownload.Content.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.ContentDownload.Content.html",
    "title": "Property Content",
    "keywords": "Property Content Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll Content Der Inhalt der Datei. Alternativ kann die Methode ContentFactory verwendet werden. public byte[] Content { get; set; } Property Value byte[]"
  },
  "api/FS.Hosting.Shared.GlobalObj.ContentDownload.ContentFactory.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.ContentDownload.ContentFactory.html",
    "title": "Property ContentFactory",
    "keywords": "Property ContentFactory Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll ContentFactory Eine Methode, die beim Aufruf des Endpoints den Inhalt zurückgibt. Als Parameter wird der Wert von FS.Hosting.Shared.GlobalObj.ContentDownload.Argument übergeben. Wird diese Methode angegeben, darf das Property Content nicht gefüllt werden. public Func<object, byte[]> ContentFactory { get; set; } Property Value Func<object, byte[]>"
  },
  "api/FS.Hosting.Shared.GlobalObj.ContentDownload.ContentType.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.ContentDownload.ContentType.html",
    "title": "Property ContentType",
    "keywords": "Property ContentType Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll ContentType public string ContentType { get; set; } Property Value string"
  },
  "api/FS.Hosting.Shared.GlobalObj.ContentDownload.DownloadFileName.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.ContentDownload.DownloadFileName.html",
    "title": "Property DownloadFileName",
    "keywords": "Property DownloadFileName Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll DownloadFileName Wird der DownloadFileName angegeben, wird durch den Browser ein Download mit diesem Dateinamen initiiert. public string DownloadFileName { get; set; } Property Value string"
  },
  "api/FS.Hosting.Shared.GlobalObj.ContentDownload.ExpirationTimeout.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.ContentDownload.ExpirationTimeout.html",
    "title": "Property ExpirationTimeout",
    "keywords": "Property ExpirationTimeout Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll ExpirationTimeout Abweichender Timeout. Wenn nicht angegeben, dann zieht automatisch ein Timeout von 10 Minuten. Der Wert muss größer als 0 sein. public TimeSpan? ExpirationTimeout { get; set; } Property Value TimeSpan?"
  },
  "api/FS.Hosting.Shared.GlobalObj.ContentDownload.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.ContentDownload.html",
    "title": "Class ContentDownload",
    "keywords": "Class ContentDownload Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll public class ContentDownload Inheritance object ContentDownload Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CleanupAction Diese Methode wird aufgerufen, wenn der Eintrag verworfen wird. Als Parameter wird der Wert von FS.Hosting.Shared.GlobalObj.ContentDownload.Argument übergeben. Content Der Inhalt der Datei. Alternativ kann die Methode ContentFactory verwendet werden. ContentFactory Eine Methode, die beim Aufruf des Endpoints den Inhalt zurückgibt. Als Parameter wird der Wert von FS.Hosting.Shared.GlobalObj.ContentDownload.Argument übergeben. Wird diese Methode angegeben, darf das Property Content nicht gefüllt werden. ContentType DownloadFileName Wird der DownloadFileName angegeben, wird durch den Browser ein Download mit diesem Dateinamen initiiert. ExpirationTimeout Abweichender Timeout. Wenn nicht angegeben, dann zieht automatisch ein Timeout von 10 Minuten. Der Wert muss größer als 0 sein."
  },
  "api/FS.Hosting.Shared.GlobalObj.ContentDownloadManager.CreateContent.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.ContentDownloadManager.CreateContent.html",
    "title": "Method CreateContent",
    "keywords": "Method CreateContent Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll CreateContent(IGlobalObjects, ContentDownload) Erzeugt für den übergebenen Content einen Download. Dieser kann innerhalb zehn Minuten über die zurückgegebene Url abgerufen werden. Die Url beginnt mit den Platzhalter \"fsbroker://\", welche im Client durch die korrekte Adresse des Brokers ersetzt wird. Die Url kann zum Beispiel in folgenden Szenarien verwendet werden: in der ViewDocument(string url) Action, als Url im Browser-Control oder als Datasource für ein Picture-Control. string url = this.Global.CreateContent(new ContentDownload() { Content = System.IO.File.ReadAllBytes(\"C:\\\\temp\\\\Beispiel.pdf\"), ContentType = \"application/pdf\", DownloadFileName= \"MyDownload.pdf\" }); ViewDocument(url); public static string CreateContent(this IGlobalObjects global, ContentDownload content) Parameters global IGlobalObjects content ContentDownload Returns string Die Url"
  },
  "api/FS.Hosting.Shared.GlobalObj.ContentDownloadManager.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.ContentDownloadManager.html",
    "title": "Class ContentDownloadManager",
    "keywords": "Class ContentDownloadManager Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll public static class ContentDownloadManager Inheritance object ContentDownloadManager Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CreateContent(IGlobalObjects, ContentDownload) Erzeugt für den übergebenen Content einen Download. Dieser kann innerhalb zehn Minuten über die zurückgegebene Url abgerufen werden. Die Url beginnt mit den Platzhalter \"fsbroker://\", welche im Client durch die korrekte Adresse des Brokers ersetzt wird. Die Url kann zum Beispiel in folgenden Szenarien verwendet werden: in der ViewDocument(string url) Action, als Url im Browser-Control oder als Datasource für ein Picture-Control. string url = this.Global.CreateContent(new ContentDownload() { Content = System.IO.File.ReadAllBytes(\"C:\\\\temp\\\\Beispiel.pdf\"), ContentType = \"application/pdf\", DownloadFileName= \"MyDownload.pdf\" }); ViewDocument(url);"
  },
  "api/FS.Hosting.Shared.GlobalObj.DropMode.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.DropMode.html",
    "title": "Enum DropMode",
    "keywords": "Enum DropMode Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll Spezifiziert den Drop-Modus. [Flags] public enum DropMode Fields BetweenRows = 2 Bei einem Grid oder einem TreeView kann der Drop zwichen Zeilen bzw. Knoten erfolgen. FullControl = 1073741824 Der Drop erfolgt auf dem ganzen Control. FullRow = 1 Bei einem Grid oder einem TreeView kann der Drop auf einer Zeile bzw. einem Knoten erfolgen."
  },
  "api/FS.Hosting.Shared.GlobalObj.GlobalContext.Context.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.GlobalContext.Context.html",
    "title": "Method Context",
    "keywords": "Method Context Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll Context(IGlobalObjects) Spannt einen Ambient Context mit dem übergeben GlobalObject auf. public static IDisposable Context(IGlobalObjects global) Parameters global IGlobalObjects Returns IDisposable Remarks Dieser Aufruf sollte immer in Verbindung mit einem using verwendet werden. using(GlobalObjects localGlobal = FS.Hosting.Broker.Base.GlobalObjectManager.CreateGlobalObject(guid.NewGuid().Value)) { using(GlobalContext.Context(localGlobal)) { // FSGlobal.Current hat hier den Wert localGlobal } }"
  },
  "api/FS.Hosting.Shared.GlobalObj.GlobalContext.Current.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.GlobalContext.Current.html",
    "title": "Property Current",
    "keywords": "Property Current Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll Current Liefert das im aktuellen Context gültige Global. public static IGlobalObjects Current { get; } Property Value IGlobalObjects Remarks Der Rückgabe-Typ ist das Basis-Interface IGlobalObjects. Um auf den korrekten Typ FSGlobalObjects zuzugreifen kann stattdessen FSGlobal.Current verwendet werden."
  },
  "api/FS.Hosting.Shared.GlobalObj.GlobalContext.EnsureCurrent.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.GlobalContext.EnsureCurrent.html",
    "title": "Method EnsureCurrent",
    "keywords": "Method EnsureCurrent Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll EnsureCurrent() Stellt sicher, dass ein Context verfügbar ist und gibt diesen Zurück. Wirft eine NoGlobalContextException wenn der Code außerhalb eines GlobalContext ausgeführt wird. public static IGlobalObjects EnsureCurrent() Returns IGlobalObjects Das aktuelle GlobalObject Remarks Der Rückgabe-Typ ist das Basis-Interface IGlobalObjects. Um auf den korrekten Typ FSGlobalObjects zuzugreifen kann stattdessen FSGlobal.EnsureCurrent() verwendet werden. Exceptions NoGlobalContextException Es ist aktuell kein GlobalContext vohanden."
  },
  "api/FS.Hosting.Shared.GlobalObj.GlobalContext.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.GlobalContext.html",
    "title": "Class GlobalContext",
    "keywords": "Class GlobalContext Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll public class GlobalContext Inheritance object GlobalContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Current Liefert das im aktuellen Context gültige Global. Methods Context(IGlobalObjects) Spannt einen Ambient Context mit dem übergeben GlobalObject auf. EnsureCurrent() Stellt sicher, dass ein Context verfügbar ist und gibt diesen Zurück. Wirft eine NoGlobalContextException wenn der Code außerhalb eines GlobalContext ausgeführt wird."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.AUHelper.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.AUHelper.html",
    "title": "Property AUHelper",
    "keywords": "Property AUHelper Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. AUHelper AUHelper { get; } Property Value AUHelper"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.AllLanguages.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.AllLanguages.html",
    "title": "Property AllLanguages",
    "keywords": "Property AllLanguages Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll AllLanguages Gibt die Iso-Codes von allen gepflegten Sprachen zurück. IEnumerable<string> AllLanguages { get; } Property Value IEnumerable<string> Remarks Es ist entscheidend, dass in der jeweiligen Sprache mindestens ein Eintrag im Wörterbuch gepflegt ist und sich die Wörterbuch-Dateien im Broker-Verzeichnis befinden."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.CancelRequestCancellationToken.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.CancelRequestCancellationToken.html",
    "title": "Method CancelRequestCancellationToken",
    "keywords": "Method CancelRequestCancellationToken Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll CancelRequestCancellationToken() Bricht den aktuellen RequestCancellationToken ab und startet sofort einen neuen für den folgenden Request. void CancelRequestCancellationToken() Remarks Ist das GlobalObject disposed, dann ist diese Funktion wirkunslos. In diesem Fall ist der RequestCancellationToken bereits abgebrochen und es gibt keinen neuen RequestCancellationToken mehr. Der Aufruf erfolgt mit CloseConnection(). In einer Broker-Application wird der RequestCancellationToken dadurch Ende des Client-Requests automatisch abgebrochen. Im Service-Context wird das GlobalObject manuell verwaltet - z.B. in einem Service-Host. Dort sollte am Ende einer Verarbeitung auch die Methode CloseConnection() aufgerufen werden, damit der RequestCancellationToken abgebrochen wird (aber auch, damit die DB-Connections nicht dauerhaft blockiert werden). Im Regelfall muss dort also kein Extra Code für den RequestCancellationToken geschrieben werden."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ClearDynamicDragSources.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ClearDynamicDragSources.html",
    "title": "Method ClearDynamicDragSources",
    "keywords": "Method ClearDynamicDragSources Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll ClearDynamicDragSources() void ClearDynamicDragSources()"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ClientInfos.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ClientInfos.html",
    "title": "Property ClientInfos",
    "keywords": "Property ClientInfos Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll ClientInfos In diesem Dictionary sind Informationen abgelegt, die der Client beim Start der Anwendung an den Broker übertragen hat. Dictionary<string, string> ClientInfos { get; } Property Value Dictionary<string, string>"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.CloseApplication.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.CloseApplication.html",
    "title": "Method CloseApplication",
    "keywords": "Method CloseApplication Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. void CloseApplication() Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin. Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. void CloseApplication(FrameworkCloseMode closeMode) Parameters closeMode FrameworkCloseMode Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. CloseApplication(string) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. void CloseApplication(string message) Parameters message string Die Meldung die am Client angezeigt werden soll. Wird String.Empty übergeben, wird die Anwendung ohne Meldung beendet. Wird null übergeben, verhält sich die Methode wie die parameterlose CloseApplication(). Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.CloseConnection.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.CloseConnection.html",
    "title": "Method CloseConnection",
    "keywords": "Method CloseConnection Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll CloseConnection() Schließt die Connections. Im Service-Context sollte diese Methode am Ende eines Requests aufgerufen werden, damit die DB-Connections nicht dauerhaft blockiert werden. [HideForIntellisense] void CloseConnection()"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.CreateComponent.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.CreateComponent.html",
    "title": "Method CreateComponent",
    "keywords": "Method CreateComponent Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll CreateComponent(string) Erzeugt eine neue Component mit dem übergebenen Namen. object CreateComponent(string componentName) Parameters componentName string Returns object Remarks Das zurückgegebene Objekt muss ggf. in einen anderen Typ umgewandelt werden, damit eine Weiterverarbeitung möglich ist. DevFrameworkObject oObject = this.Global.CreateComponent(\"Namespace.cdComponent\") as DevFrameworkObject; DevFrameworkObjectColl oColl = this.Global.CreateComponent(\"Namespace.cdComponentColl\") as DevFrameworkObjectColl; Der ComponentName entspricht dem FullName des Typs. Dieser kann auch zur Laufzeit ermittelt werden. sComponentName = oComponent.GetType().FullName; Warning Da der übergebene Parameter nicht kompiliert ist, sollte diese Funktion nur in Ausnahmefällen eingesetzt werden, um z.B. verallgemeinerte Logik umzusetzen."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.EndSafeInitialize.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.EndSafeInitialize.html",
    "title": "Method EndSafeInitialize",
    "keywords": "Method EndSafeInitialize Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll EndSafeInitialize() Deaktiviert den SafeInitializing Modus. void EndSafeInitialize()"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.GetCodeDirectory.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.GetCodeDirectory.html",
    "title": "Method GetCodeDirectory",
    "keywords": "Method GetCodeDirectory Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft. string GetCodeDirectory() Returns string"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.LanguageHierarchy.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.LanguageHierarchy.html",
    "title": "Property LanguageHierarchy",
    "keywords": "Property LanguageHierarchy Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. Das sind die Sprachen in der Reihenfolge der Auswahl im Client Start. IEnumerable<string> LanguageHierarchy { get; set; } Property Value IEnumerable<string> Remarks Beim Setzen kann jeder Typ zugewiesen werden, der von IEnumerable<string> erbt. Es ist jedoch empfehlenswert, mit einer ReadOnlyCollection<string> zu arbeiten, um Manipulationen an dieser Liste zu verhindern. Diese kann zum Beispiel mit der Methode Liste<string>.AsReadOnly() erzeugt werden. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.MLColumnLanguage.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.MLColumnLanguage.html",
    "title": "Property MLColumnLanguage",
    "keywords": "Property MLColumnLanguage Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll MLColumnLanguage Gibt den Iso-Code der Sprache zurück, die aktuell für die MLColumn-Properties verwendet wird. Normalerweise handelt es sich dabei um die SelectedLanguage. Mit der Methode UseMLColumnLanguage(string, Action) kann die Sprache vorrübergebend geändert werden. string MLColumnLanguage { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ProgressOwner.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ProgressOwner.html",
    "title": "Property ProgressOwner",
    "keywords": "Property ProgressOwner Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll ProgressOwner Sammelt die Informationen zu laufenden FrameworkProgress. IProgressOwner ProgressOwner { get; } Property Value IProgressOwner"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.RemoveDynamicDragSource.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.RemoveDynamicDragSource.html",
    "title": "Method RemoveDynamicDragSource",
    "keywords": "Method RemoveDynamicDragSource Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll RemoveDynamicDragSource(MLContainer) bool RemoveDynamicDragSource(MLContainer mdt) Parameters mdt MLContainer Returns bool"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ReportingSoftware.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ReportingSoftware.html",
    "title": "Property ReportingSoftware",
    "keywords": "Property ReportingSoftware Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll ReportingSoftware Welche Software beim Druck bevorzugt wird. ReportingSoftware ReportingSoftware { get; set; } Property Value ReportingSoftware Remarks Es muss entweder FS.Hosting.Shared.Reporting.ReportingSoftware.CrystalReports oder DevExpress angegeben werden. Eine Kombination oder ein anderer Wert sind nicht zulässig. Exceptions ArgumentOutOfRangeException Es wurde ein ungültiger Wert übergeben."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.RequestCancellationToken.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.RequestCancellationToken.html",
    "title": "Property RequestCancellationToken",
    "keywords": "Property RequestCancellationToken Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll RequestCancellationToken Dieser CancellationToken wird abgebrochen wenn der aktuelle Request beendet bzw. das GlobalObject disposed wird. Wird der aktuelle Token mit dem Ende des Requests abgebrochen wird anschließend ein neuer Token für den nachfolgenden Request zurückgegeben. CancellationToken RequestCancellationToken { get; } Property Value CancellationToken"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SafeInitializing.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SafeInitializing.html",
    "title": "Property SafeInitializing",
    "keywords": "Property SafeInitializing Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. bool SafeInitializing { get; } Property Value bool Examples try { [Aktion] } catch (Exception ex) { if (this.Global.SafeInitializing) { [Fehler behandeln] } else { // Exception weiter werfen. throw; } } Remarks Der Modus kann mithilfe der Methode EndSafeInitialize() zurückgesetzt werden. Wenn diese Methode einmal aufgerufen wurde, dann ist es nicht mehr möglich, den Modus wieder zu aktivieren. Wenn dieser Modus aktiv ist, dann können z.B. in einer Update-Sitation Exceptions unterbunden werden, die den Start der Anwendung verhindern würden."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SelectedLanguage.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SelectedLanguage.html",
    "title": "Property SelectedLanguage",
    "keywords": "Property SelectedLanguage Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. string SelectedLanguage { get; set; } Property Value string Remarks Beim Setzen der SelectedLanguage gibt es 2 Möglichkeiten: 1.) Es wird nur ein ISO-Code übergeben.Dieser wird an die erste Stelle der LanguageHierarchy gesetzt. Wenn dieser Code schon in der Hierarchie enthalten ist, dann wird dieser an die erste Stelle verschoben. 2.) Es wird eine Komma-separierte Liste von ISO-Codes übergeben.In diesem Fall wird aus dieser Liste eine neue LanguageHierarchy aufgebaut. Die Sprache wird beim Start im Client festgelegt. Der Broker wechselt beim Start der Anwendung ggf. auf die Default-Sprache der Anwendung, wenn die vom Client angefragte Sprache nicht zur Verfügung steht. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SessionCancellationToken.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SessionCancellationToken.html",
    "title": "Property SessionCancellationToken",
    "keywords": "Property SessionCancellationToken Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll SessionCancellationToken Dieser CancellationToken wird abgebrochen wenn die Session beendet bzw. das GlobalObject disposed wird. CancellationToken SessionCancellationToken { get; } Property Value CancellationToken"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SessionData.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SessionData.html",
    "title": "Property SessionData",
    "keywords": "Property SessionData Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll SessionData Speichert verschlüsselte Schlüssel-Werte-Paare für den aktuellen Client. ISessionData SessionData { get; } Property Value ISessionData Remarks Detailierte Informationen gibt es unter ISessionData."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SetDynamicDragSource.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.SetDynamicDragSource.html",
    "title": "Method SetDynamicDragSource",
    "keywords": "Method SetDynamicDragSource Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll SetDynamicDragSource(MLContainer, Func<IDevFrameworkBaseObject, object>) void SetDynamicDragSource(MLContainer mdt, Func<IDevFrameworkBaseObject, object> getterDelegate) Parameters mdt MLContainer getterDelegate Func<IDevFrameworkBaseObject, object>"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.Token.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.Token.html",
    "title": "Property Token",
    "keywords": "Property Token Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll Token Eindeutige ID der Session. string Token { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.UseHistory.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.UseHistory.html",
    "title": "Property UseHistory",
    "keywords": "Property UseHistory Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll UseHistory Gibt an, ob historische Daten berücksichtigt werden sollen. D.h., bei Tabellen, zu denen es eine Historientabelle gibt, werden die Daten nicht aus der Originaltabelle geladen sondern aus dem View, der die Originaltabelle mit der Historientabelle vereint. bool UseHistory { get; set; } Property Value bool"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.UseMLColumnLanguage.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.UseMLColumnLanguage.html",
    "title": "Method UseMLColumnLanguage",
    "keywords": "Method UseMLColumnLanguage Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll UseMLColumnLanguage(string, Action) Verwendet für MLColumn-Properties während der übergenenen Action die angegebene Sprache. void UseMLColumnLanguage(string iso, Action action) Parameters iso string action Action"
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.html",
    "title": "Interface IGlobalObjects",
    "keywords": "Interface IGlobalObjects Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten. [ComVisible(false)] public interface IGlobalObjects Extension Methods ContentDownloadManager.CreateContent(IGlobalObjects, ContentDownload) Properties AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. AllLanguages Gibt die Iso-Codes von allen gepflegten Sprachen zurück. ClientInfos In diesem Dictionary sind Informationen abgelegt, die der Client beim Start der Anwendung an den Broker übertragen hat. LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. Das sind die Sprachen in der Reihenfolge der Auswahl im Client Start. MLColumnLanguage Gibt den Iso-Code der Sprache zurück, die aktuell für die MLColumn-Properties verwendet wird. Normalerweise handelt es sich dabei um die SelectedLanguage. Mit der Methode UseMLColumnLanguage(string, Action) kann die Sprache vorrübergebend geändert werden. ProgressOwner Sammelt die Informationen zu laufenden FrameworkProgress. ReportingSoftware Welche Software beim Druck bevorzugt wird. RequestCancellationToken Dieser CancellationToken wird abgebrochen wenn der aktuelle Request beendet bzw. das GlobalObject disposed wird. Wird der aktuelle Token mit dem Ende des Requests abgebrochen wird anschließend ein neuer Token für den nachfolgenden Request zurückgegeben. SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. SessionCancellationToken Dieser CancellationToken wird abgebrochen wenn die Session beendet bzw. das GlobalObject disposed wird. SessionData Speichert verschlüsselte Schlüssel-Werte-Paare für den aktuellen Client. Token Eindeutige ID der Session. UseHistory Gibt an, ob historische Daten berücksichtigt werden sollen. D.h., bei Tabellen, zu denen es eine Historientabelle gibt, werden die Daten nicht aus der Originaltabelle geladen sondern aus dem View, der die Originaltabelle mit der Historientabelle vereint. ocGlobal Methods CancelRequestCancellationToken() Bricht den aktuellen RequestCancellationToken ab und startet sofort einen neuen für den folgenden Request. ClearDynamicDragSources() CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin. Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. CloseApplication(string) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. CloseConnection() Schließt die Connections. Im Service-Context sollte diese Methode am Ende eines Requests aufgerufen werden, damit die DB-Connections nicht dauerhaft blockiert werden. CreateComponent(string) Erzeugt eine neue Component mit dem übergebenen Namen. EndSafeInitialize() Deaktiviert den SafeInitializing Modus. GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft. RemoveDynamicDragSource(MLContainer) SetDynamicDragSource(MLContainer, Func<IDevFrameworkBaseObject, object>) UseMLColumnLanguage(string, Action) Verwendet für MLColumn-Properties während der übergenenen Action die angegebene Sprache."
  },
  "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ocGlobal.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IGlobalObjects.ocGlobal.html",
    "title": "Property ocGlobal",
    "keywords": "Property ocGlobal Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll ocGlobal IcGlobalBase ocGlobal { get; } Property Value IcGlobalBase"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GetClientCulture.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GetClientCulture.html",
    "title": "Method GetClientCulture",
    "keywords": "Method GetClientCulture Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GetClientCulture() Liefert die Culture des Clients zurück. Diese Methode kann in der Component FSGeneral.cGlobal überschrieben werden. CultureInfo GetClientCulture() Returns CultureInfo Remarks Die FS-seitige Implementierung der Methode ermittelt die Culture anhand der ClientInfos am Global Object. Dabei greifen die folgenden Prioritäten Aus der Angabe \"Locale\" Aus den Angaben \"UserLanguage\" und \"UserCountry\" Die CurrentCulture, die in der Regel der Culture des Broker-Servers entspricht. Wird die Methode überschrieben, muss die ermittelte Culture ggf. in einem eigenen Property zwischengespeichert werden."
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalGetMLText.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalGetMLText.html",
    "title": "Method GlobalGetMLText",
    "keywords": "Method GlobalGetMLText Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalGetMLText(MLKey, string) Jedes mal, wenn aus einem MLKey einen Text erzeugt wird, wird diese Methode aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. string GlobalGetMLText(MLKey mlkey, string iso) Parameters mlkey MLKey iso string Returns string Remarks Die Sprach-Hierarchie der Session, welche am GlobalObject hinterlegt ist, wird außerhalb dieser Methode aufgelöst. Besteht die Hierarchie aus mehreren Fallbacks(z.B. fr, en, de), wird diese Methode auch ggf.mehrfach nacheinander mit den unterschiedlichen Iso-Codes aufgerufen. Liefert die Methode einen Wert ungleich null oder String.Empty zurück, wird dieser als Text verwendet und es erfolgt kein weiterer Aufruf. Durch die Überschreibung dieser Methode ist es möglich die Ermittlung der Texte zu beeinflussen oder zu überwachen. Warning Diese Methode muss sehr performant gestaltet werden. Komplexe Logik kann die Performance der kompletten Anwendung sehr negativ beeinflussen. Der Basis-Aufruf muss sichergestellt werden. Ansonsten wird das komplette Wörterbuch ausgehebelt und es werden gar keine Texte mehr ermittelt."
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalIsApplicationQuitAllowed.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalIsApplicationQuitAllowed.html",
    "title": "Method GlobalIsApplicationQuitAllowed",
    "keywords": "Method GlobalIsApplicationQuitAllowed Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalIsApplicationQuitAllowed() Diese Methode wird vom Broker bei einem vom Client gesendeten QuitApplication-Request aufgerufen. bool GlobalIsApplicationQuitAllowed() Returns bool Eine Rückgabe von false verhindert das Beenden der Applikation."
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnAfterHandleRequest.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnAfterHandleRequest.html",
    "title": "Method GlobalOnAfterHandleRequest",
    "keywords": "Method GlobalOnAfterHandleRequest Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnAfterHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die eigentliche Brokerlogik (Eventauswertung) durchgeführt wurde, bevor die Daten an den Client übermittelt werden. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. void GlobalOnAfterHandleRequest() Remarks Warning Wird die Methode überschrieben, dann muss dafür gesorgt werden, dass der base-Aufruf in jedem Fall erfolgt!"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnAfterSaveAction.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnAfterSaveAction.html",
    "title": "Method GlobalOnAfterSaveAction",
    "keywords": "Method GlobalOnAfterSaveAction Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnAfterSaveAction(DevFrameworkObject) Diese Methode wird nach jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. void GlobalOnAfterSaveAction(DevFrameworkObject obj) Parameters obj DevFrameworkObject"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnBeforeHandleRequest.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnBeforeHandleRequest.html",
    "title": "Method GlobalOnBeforeHandleRequest",
    "keywords": "Method GlobalOnBeforeHandleRequest Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnBeforeHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die übertragenen Daten eingelesen wurden, bevor die eigentliche Brokerlogik (Eventauswertung) ausgeführt wird. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. void GlobalOnBeforeHandleRequest() Remarks Warning Wird die Methode überschrieben, dann muss dafür gesorgt werden, dass der base-Aufruf in jedem Fall erfolgt!"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnBeforeLoad.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnBeforeLoad.html",
    "title": "Method GlobalOnBeforeLoad",
    "keywords": "Method GlobalOnBeforeLoad Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnBeforeLoad(DevFrameworkObject, ref string, ref string, ref string) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf ein Einzelobjekt aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. void GlobalOnBeforeLoad(DevFrameworkObject obj, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) Parameters obj DevFrameworkObject Component auf die der Load abgesetzt wurde. loadCondition string replacingHavingClause string replacingOrderClause string GlobalOnBeforeLoad(DevFrameworkObjectColl, ref string, ref string, ref string) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf eine Collection aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. void GlobalOnBeforeLoad(DevFrameworkObjectColl coll, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) Parameters coll DevFrameworkObjectColl Collection auf der der Load abgesetzt wurde. loadCondition string replacingHavingClause string replacingOrderClause string"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnBeforePrintSubreport.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnBeforePrintSubreport.html",
    "title": "Method GlobalOnBeforePrintSubreport",
    "keywords": "Method GlobalOnBeforePrintSubreport Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnBeforePrintSubreport(string) Diese Methode wird vor dem Druck eines verlinkten DevExpress-SubReports aufgerufen. Es kann ein byte[] zurückgegeben werden, welches die Daten einer repx-Datei beinhaltet. Dieses überschreibt die ursprüngliche mit der url übergebenen Datei. byte[] GlobalOnBeforePrintSubreport(string url) Parameters url string relative url im Format \"RDT.FullName\\filname.repx\" Returns byte[] Binär-Daten der alternativen Report-Datei. null wenn die Original-Datei verwendet werden soll."
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnBeforeSaveAction.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnBeforeSaveAction.html",
    "title": "Method GlobalOnBeforeSaveAction",
    "keywords": "Method GlobalOnBeforeSaveAction Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnBeforeSaveAction(DevFrameworkObject) Diese Methode wird vor jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. void GlobalOnBeforeSaveAction(DevFrameworkObject obj) Parameters obj DevFrameworkObject"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnGetDynamicDragSource.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnGetDynamicDragSource.html",
    "title": "Method GlobalOnGetDynamicDragSource",
    "keywords": "Method GlobalOnGetDynamicDragSource Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnGetDynamicDragSource(MLContainer, string, Func<IDevFrameworkBaseObject>) Diese Methode wird aufgerufen, wenn für die Controls eines Forms ermittelt wird, ob eine Drag-Operation möglich ist und noch kein anderer DragSource oder ein OnDrag-Event am Control definiert wurde. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Func<IDevFrameworkBaseObject, object> GlobalOnGetDynamicDragSource(MLContainer mdt, string propertyName, Func<IDevFrameworkBaseObject> objectGetter) Parameters mdt MLContainer Der Metadatentyp des Properties propertyName string Der Name des Properties objectGetter Func<IDevFrameworkBaseObject> Übergibt ein Delegate, welches das aktuelle im Datasource gesetzte Objekt zurückgibt. Returns Func<IDevFrameworkBaseObject, object> Ein Delegate, welches das Objekt entgegennimmt aus welchem der DragSource ermittelt und zurückgegeben werden kann Remarks Innerhalb einer Sitzung erfolgt pro Metadatentyp nur ein Aufruf. Das zurückgegebene Delegate wird gecached. Am this.Global gibt es Methoden, um diesen Cache zu bearbeiten: ClearDynamicDragSources() SetDynamicDragSource(MLContainer, Func<IDevFrameworkBaseObject, object>) RemoveDynamicDragSource(MLContainer)"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnHandleException.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnHandleException.html",
    "title": "Method GlobalOnHandleException",
    "keywords": "Method GlobalOnHandleException Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnHandleException(Exception) Diese Methode wird vom Broker für alle Exceptions aufgerufen die er selber abfängt (ohne MsgBox-Exceptions!) void GlobalOnHandleException(Exception ex) Parameters ex Exception Remarks Evtl. auftauchende Fehler werden verschluckt!"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnHandlingException.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnHandlingException.html",
    "title": "Method GlobalOnHandlingException",
    "keywords": "Method GlobalOnHandlingException Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnHandlingException(ref Exception) void GlobalOnHandlingException(ref Exception ex) Parameters ex Exception"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnIsDatabaseUpdateRequired.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnIsDatabaseUpdateRequired.html",
    "title": "Method GlobalOnIsDatabaseUpdateRequired",
    "keywords": "Method GlobalOnIsDatabaseUpdateRequired Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnIsDatabaseUpdateRequired() int GlobalOnIsDatabaseUpdateRequired() Returns int"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnRegisterAuthServiceUnits.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.GlobalOnRegisterAuthServiceUnits.html",
    "title": "Method GlobalOnRegisterAuthServiceUnits",
    "keywords": "Method GlobalOnRegisterAuthServiceUnits Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalOnRegisterAuthServiceUnits() Diese Methode wird vom AUHelper aufgerufen, wenn mit Authentifizierung gearbeitet wird und (statisch einmalig) noch keine Registrierung der Units (Mandanten) am Auth Service erfolgt ist. Wird ein Enumerable zurückgegeben, so werden die angegebenen Units registriert. Wird \"null\" zurückgegeben, so wird keine Registrierung durchgeführt. Die Units werden durch KeyValuesPairs mit Key = ID (Primärschlüssel), Value = Name/Bezeichnung definiert. IEnumerable<KeyValuePair<string, string>> GlobalOnRegisterAuthServiceUnits() Returns IEnumerable<KeyValuePair<string, string>>"
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.OnLicenseGranted.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.OnLicenseGranted.html",
    "title": "Method OnLicenseGranted",
    "keywords": "Method OnLicenseGranted Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll OnLicenseGranted(AccessUnit, AUPermissionType) Mit diesem EntryPoint kann eine Lizenz-Freigabe programmatisch eingeschränkt werden. Diese Methode wird aufgerufen, wenn LicenseGranted(AccessUnit) aufgerufen wird und die verwendete Lizenz-Datei den Zugriff auf die AccessUnit erlaubt. bool OnLicenseGranted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit type AUPermissionType Returns bool Remarks Die Methode wird nur aufgerufen, wenn die Lizenz den Zugriff erlaubt. Freischalten einer verbotenen Lizenz ist nicht möglich. Granted(AccessUnit) für die Rollen-Berechtigung mündet ebenfalls durch LicenseGranted(AccessUnit) in dieser Methode. Die Methode wird sehr oft aufgerufen. Eine Überschreibung sollte daher möglichst performant implementiert werden."
  },
  "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.IcGlobalBase.html",
    "title": "Interface IcGlobalBase",
    "keywords": "Interface IcGlobalBase Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll Bereits im SystemPackage existiert im Namespace FSGeneral eine Component mit dem Namen cGlobal. Diese Component kann customized werden. Aus Forms oder Components heraus kann eine Instanz dieser Component mit this.Global.ocGlobal angesprochen werden. public interface IcGlobalBase Methods GetClientCulture() Liefert die Culture des Clients zurück. Diese Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalGetMLText(MLKey, string) Jedes mal, wenn aus einem MLKey einen Text erzeugt wird, wird diese Methode aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalIsApplicationQuitAllowed() Diese Methode wird vom Broker bei einem vom Client gesendeten QuitApplication-Request aufgerufen. GlobalOnAfterHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die eigentliche Brokerlogik (Eventauswertung) durchgeführt wurde, bevor die Daten an den Client übermittelt werden. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnAfterSaveAction(DevFrameworkObject) Diese Methode wird nach jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnBeforeHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die übertragenen Daten eingelesen wurden, bevor die eigentliche Brokerlogik (Eventauswertung) ausgeführt wird. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnBeforeLoad(DevFrameworkObject, ref string, ref string, ref string) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf ein Einzelobjekt aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. GlobalOnBeforeLoad(DevFrameworkObjectColl, ref string, ref string, ref string) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf eine Collection aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. GlobalOnBeforePrintSubreport(string) Diese Methode wird vor dem Druck eines verlinkten DevExpress-SubReports aufgerufen. Es kann ein byte[] zurückgegeben werden, welches die Daten einer repx-Datei beinhaltet. Dieses überschreibt die ursprüngliche mit der url übergebenen Datei. GlobalOnBeforeSaveAction(DevFrameworkObject) Diese Methode wird vor jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnGetDynamicDragSource(MLContainer, string, Func<IDevFrameworkBaseObject>) Diese Methode wird aufgerufen, wenn für die Controls eines Forms ermittelt wird, ob eine Drag-Operation möglich ist und noch kein anderer DragSource oder ein OnDrag-Event am Control definiert wurde. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnHandleException(Exception) Diese Methode wird vom Broker für alle Exceptions aufgerufen die er selber abfängt (ohne MsgBox-Exceptions!) GlobalOnHandlingException(ref Exception) GlobalOnIsDatabaseUpdateRequired() GlobalOnRegisterAuthServiceUnits() Diese Methode wird vom AUHelper aufgerufen, wenn mit Authentifizierung gearbeitet wird und (statisch einmalig) noch keine Registrierung der Units (Mandanten) am Auth Service erfolgt ist. Wird ein Enumerable zurückgegeben, so werden die angegebenen Units registriert. Wird \"null\" zurückgegeben, so wird keine Registrierung durchgeführt. Die Units werden durch KeyValuesPairs mit Key = ID (Primärschlüssel), Value = Name/Bezeichnung definiert. OnLicenseGranted(AccessUnit, AUPermissionType) Mit diesem EntryPoint kann eine Lizenz-Freigabe programmatisch eingeschränkt werden. Diese Methode wird aufgerufen, wenn LicenseGranted(AccessUnit) aufgerufen wird und die verwendete Lizenz-Datei den Zugriff auf die AccessUnit erlaubt."
  },
  "api/FS.Hosting.Shared.GlobalObj.NoGlobalContextException.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.NoGlobalContextException.html",
    "title": "Class NoGlobalContextException",
    "keywords": "Class NoGlobalContextException Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll Diese Exception wird ausgelöst, wenn kein GlobalContext verfügbar ist. public class NoGlobalContextException : FrameworkException, ISerializable Inheritance object Exception FrameworkException NoGlobalContextException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object)"
  },
  "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.GlobalGetStaticCacheMode.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.GlobalGetStaticCacheMode.html",
    "title": "Method GlobalGetStaticCacheMode",
    "keywords": "Method GlobalGetStaticCacheMode Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalGetStaticCacheMode(IDevFrameworkDataObject) Diese Methode wird pro Component-Typ einmalig mit einer Instanz der Component bei der ersten Benutzung des statischen Caches aufgerufen, um den gewünschten Arbeitsmodus des statischen Caches zu ermitteln. Standardwert ist Broker. protected virtual StaticCacheMode GlobalGetStaticCacheMode(IDevFrameworkDataObject oDevFrameworkDataObjectP) Parameters oDevFrameworkDataObjectP IDevFrameworkDataObject Eine Instanz des Component-Typs, für welchen der gewünschte Arbeitsmodus des statischen Caches ermittelt werden soll. Returns StaticCacheMode Gibt den Arbeitsmodus zurück, in dem der statische Cache arbeiten soll. Remarks Hilfreich ist dies z.B., wenn für bestimmte Typen (z.B. weil Tabellen-Filter definiert sind) das durchlaufen der Einsprungspunkte GlobalOnBeforeLoad(DevFrameworkObject, ref string, ref string, ref string) und OnBeforeLoad(ref string, ref string, ref string, bool) dringend nötig ist und daher der Arbeitsmodus Session gewünscht ist. Der Arbeitsmodus Session ist außerdem dann relevant, wenn Einschränkungen auf Eigenschaften erfolgen sollen, die zwar als Datenbankspalte existieren, jedoch an der Component nicht als Property hinzugefügt wurden (z.B. bei distinct und groupBy Components)."
  },
  "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.GlobalGetSubreportDirectory.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.GlobalGetSubreportDirectory.html",
    "title": "Method GlobalGetSubreportDirectory",
    "keywords": "Method GlobalGetSubreportDirectory Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalGetSubreportDirectory() Diese Methode wird beim Druck eines externen, verlinkten Subreports aufgerufen, falls es sich um einen DevExpress-Report handelt. Hierbei wird davon ausgegangen, dass der fragliche Subreport über einen relativen Pfad referenziert ist. Dies ist nützlich, um z.B. im Customizing eine Umleitung auf die eigenen Subreports zu erzwingen. Falls keine passende Datei im angegebenen Pfad zu finden ist, wird auf DevExpress.XtraReports.Configuration.Settings.Default.StorageOptions.RootDirectory zurückgegriffen. Diese Einstellung verweist standardmäßig auf das in der Anwendungskonfiguration angegebene Reportverzeichnis: FrameworkSystems.FrameworkBase.Configuration.Application.ApplicationConfig.Get.ReportDirectory. public virtual string GlobalGetSubreportDirectory() Returns string Der absolute Pfad zu dem Verzeichnis, in welchem nach Subreports gesucht werden soll. Remarks Bei einem verlinkten Subreport mit dem Beispielpfad '~\\Report\\FSDemo.Article\\Subreport.repx' gibt diese Methode den Teil des Pfades zurück, welcher in diesem Beispiel mit ~ gemeint ist; z.B. 'C:\\FS\\Compile'."
  },
  "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.GlobalWhereStaticCache.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.GlobalWhereStaticCache.html",
    "title": "Method GlobalWhereStaticCache",
    "keywords": "Method GlobalWhereStaticCache Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll GlobalWhereStaticCache(IStaticCacheObject) Diese Methode wird von den Statischen Caches aufgerufen, um abhängig vom Global Datensätze generell filtern zu können. Dieser Einsprungpunkt wird nur durchlaufen, wenn die Methode GlobalGetStaticCacheMode(IDevFrameworkDataObject) für den entsprechenden IDevFrameworkDataObject-Typ den Wert Broker zurück gegeben hat.\"/> protected virtual bool GlobalWhereStaticCache(IStaticCacheObject oStaticCacheObjectP) Parameters oStaticCacheObjectP IStaticCacheObject Der Datensatz vom Typ IStaticCache, für das entschieden werden soll, ob er für dieses Global zurück gegeben werden soll.\"/> Returns bool Gibt zurück, ob der Datensatz von einem statischen Cache für dieses Global zurückgegeben werden soll. Remarks Hilfreich ist dies z.B., wenn mit Mandanten gearbeitet wird und nur die Datensätze zur aktuellen Geschäftseinheit vom Cache zurückgegeben werden sollen."
  },
  "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.OnLicenseGranted.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.OnLicenseGranted.html",
    "title": "Method OnLicenseGranted",
    "keywords": "Method OnLicenseGranted Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll OnLicenseGranted(AccessUnit, AUPermissionType) Mit diesem EntryPoint kann eine Lizenz-Freigabe programmatisch eingeschränkt werden. Diese Methode wird aufgerufen, wenn LicenseGranted(AccessUnit) aufgerufen wird und die verwendete Lizenz-Datei den Zugriff auf die AccessUnit erlaubt. public virtual bool OnLicenseGranted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit type AUPermissionType Returns bool Remarks Die Methode wird nur aufgerufen, wenn die Lizenz den Zugriff erlaubt. Freischalten einer verbotenen Lizenz ist nicht möglich. Granted(AccessUnit) für die Rollen-Berechtigung mündet ebenfalls durch LicenseGranted(AccessUnit) in dieser Methode. Die Methode wird sehr oft aufgerufen. Eine Überschreibung sollte daher möglichst performant implementiert werden."
  },
  "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.cGlobalBase.html",
    "title": "Class cGlobalBase",
    "keywords": "Class cGlobalBase Namespace FS.Hosting.Shared.GlobalObj Assembly FS.Hosting.Shared.dll Basisklasse für das Property FS.Hosting.Shared.GlobalObj.GlobalObjects.ocGlobal. public class cGlobalBase : DevFrameworkObject, ICloneable, IDevFrameworkObject, IDevFrameworkBaseObject, INotifyPropertyChanged, IcGlobalBase Inheritance object DevFrameworkBaseObject DevFrameworkObject cGlobalBase Implements ICloneable IDevFrameworkObject IDevFrameworkBaseObject INotifyPropertyChanged IcGlobalBase Inherited Members DevFrameworkObject.DeferRecursiveSaves() DevFrameworkObject.Save(SaveEntryPoints) DevFrameworkObject.State DevFrameworkObject.OnTrackChange(string) DevFrameworkBaseObject.IsFrozen DevFrameworkBaseObject.Freeze() DevFrameworkBaseObject.ThrowIfFrozen() DevFrameworkBaseObject.GetProperty(string) DevFrameworkBaseObject.SetProperty(string, object) DevFrameworkBaseObject.ComponentProperties DevFrameworkBaseObject.IsComponentProperty(string) DevFrameworkBaseObject.OnPropertyChanged(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GlobalGetStaticCacheMode(IDevFrameworkDataObject) Diese Methode wird pro Component-Typ einmalig mit einer Instanz der Component bei der ersten Benutzung des statischen Caches aufgerufen, um den gewünschten Arbeitsmodus des statischen Caches zu ermitteln. Standardwert ist Broker. GlobalGetSubreportDirectory() Diese Methode wird beim Druck eines externen, verlinkten Subreports aufgerufen, falls es sich um einen DevExpress-Report handelt. Hierbei wird davon ausgegangen, dass der fragliche Subreport über einen relativen Pfad referenziert ist. Dies ist nützlich, um z.B. im Customizing eine Umleitung auf die eigenen Subreports zu erzwingen. Falls keine passende Datei im angegebenen Pfad zu finden ist, wird auf DevExpress.XtraReports.Configuration.Settings.Default.StorageOptions.RootDirectory zurückgegriffen. Diese Einstellung verweist standardmäßig auf das in der Anwendungskonfiguration angegebene Reportverzeichnis: FrameworkSystems.FrameworkBase.Configuration.Application.ApplicationConfig.Get.ReportDirectory. GlobalWhereStaticCache(IStaticCacheObject) Diese Methode wird von den Statischen Caches aufgerufen, um abhängig vom Global Datensätze generell filtern zu können. Dieser Einsprungpunkt wird nur durchlaufen, wenn die Methode GlobalGetStaticCacheMode(IDevFrameworkDataObject) für den entsprechenden IDevFrameworkDataObject-Typ den Wert Broker zurück gegeben hat.\"/> OnLicenseGranted(AccessUnit, AUPermissionType) Mit diesem EntryPoint kann eine Lizenz-Freigabe programmatisch eingeschränkt werden. Diese Methode wird aufgerufen, wenn LicenseGranted(AccessUnit) aufgerufen wird und die verwendete Lizenz-Datei den Zugriff auf die AccessUnit erlaubt."
  },
  "api/FS.Hosting.Shared.GlobalObj.html": {
    "href": "api/FS.Hosting.Shared.GlobalObj.html",
    "title": "Namespace FS.Hosting.Shared.GlobalObj",
    "keywords": "Namespace FS.Hosting.Shared.GlobalObj Classes ContentDownload ContentDownloadManager GlobalContext NoGlobalContextException Diese Exception wird ausgelöst, wenn kein GlobalContext verfügbar ist. cGlobalBase Basisklasse für das Property FS.Hosting.Shared.GlobalObj.GlobalObjects.ocGlobal. Interfaces IGlobalObjects Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten. IcGlobalBase Bereits im SystemPackage existiert im Namespace FSGeneral eine Component mit dem Namen cGlobal. Diese Component kann customized werden. Aus Forms oder Components heraus kann eine Instanz dieser Component mit this.Global.ocGlobal angesprochen werden. Enums DropMode Spezifiziert den Drop-Modus."
  },
  "api/FS.Hosting.Shared.GridRowHeader.html": {
    "href": "api/FS.Hosting.Shared.GridRowHeader.html",
    "title": "Enum GridRowHeader",
    "keywords": "Enum GridRowHeader Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum GridRowHeader Fields DisplayRowNumber = 0 DisplayRowStatus = 1 DisplayRowStatusAndNumber = 2 Inherit = -1"
  },
  "api/FS.Hosting.Shared.HorizontalAlignment.html": {
    "href": "api/FS.Hosting.Shared.HorizontalAlignment.html",
    "title": "Enum HorizontalAlignment",
    "keywords": "Enum HorizontalAlignment Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum HorizontalAlignment Fields Center = 1 Left = 0 Right = 2 Stretch = 3"
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.AcceptChanges.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.AcceptChanges.html",
    "title": "Method AcceptChanges",
    "keywords": "Method AcceptChanges Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll AcceptChanges() Übernimmt alle Änderungen. Sollte in allen Subclasses überschrieben werden, sodass die aktuellen Werte in die Membervariablen mit den Orginalwerten übernommen werden, damit ein späterer Rollback wieder den aktuellen Zustand herstellen kann. void AcceptChanges()"
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.AdoptValues.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.AdoptValues.html",
    "title": "Method AdoptValues",
    "keywords": "Method AdoptValues Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll AdoptValues(IDevFrameworkBaseObject) void AdoptValues(IDevFrameworkBaseObject fromComponent) Parameters fromComponent IDevFrameworkBaseObject AdoptValues(IDevFrameworkBaseObject, AdoptMode) void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptMode mode) Parameters fromComponent IDevFrameworkBaseObject mode AdoptMode"
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.CanFreeze.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.CanFreeze.html",
    "title": "Method CanFreeze",
    "keywords": "Method CanFreeze Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll CanFreeze() Gibt zurück, ob der Aufruf der Methode Freeze() möglich ist. bool CanFreeze() Returns bool"
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.Clone.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.Clone.html",
    "title": "Method Clone",
    "keywords": "Method Clone Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Clone() IDevFrameworkBaseObject Clone() Returns IDevFrameworkBaseObject Clone(AdoptMode) IDevFrameworkBaseObject Clone(AdoptMode mode) Parameters mode AdoptMode Returns IDevFrameworkBaseObject"
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.ComponentProperties.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.ComponentProperties.html",
    "title": "Property ComponentProperties",
    "keywords": "Property ComponentProperties Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ComponentProperties Gibt eine Liste mit den Namen aller public oder internal Properties zurück, die vom Entwickler in der IDE definiert wurden. RowID und RowVersion sind nicht enthalten. [Browsable(false)] StringCollection ComponentProperties { get; } Property Value StringCollection"
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.Freeze.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.Freeze.html",
    "title": "Method Freeze",
    "keywords": "Method Freeze Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Freeze() Sperrt das Objekt für weitere Änderungen. Wird bei einem frozen Objekt versucht Werte zu verändern, wird eine InvalidOperationException geworfen. void Freeze()"
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.GetDefaultLabel.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.GetDefaultLabel.html",
    "title": "Method GetDefaultLabel",
    "keywords": "Method GetDefaultLabel Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetDefaultLabel(string) Gibt des Default-Label eines bestimmten Properties zurück. Falls es das Property nicht gibt, wird Empty zurückgegeben. string GetDefaultLabel(string propertyName) Parameters propertyName string Returns string"
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.GetProperty.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.GetProperty.html",
    "title": "Method GetProperty",
    "keywords": "Method GetProperty Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetProperty(string) Gibt den Wert des Properties mit dem übergebenen propertyName zurück. object GetProperty(string propertyName) Parameters propertyName string Name des zu ermittelnden Properties. Returns object Remarks Es darf nur auf public oder internal Properties zugegriffen werden. Exceptions PropertyNotFoundException Das übergebene Property existiert nicht oder dessen Zugriffsmodifizierer erlaubt keinen Zugriff."
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.GetPropertyMdt.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.GetPropertyMdt.html",
    "title": "Method GetPropertyMdt",
    "keywords": "Method GetPropertyMdt Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetPropertyMdt(string) Ermittelt den Metadatentypen eines properties. MLContainer GetPropertyMdt(string propertyName) Parameters propertyName string Der Name des properties, dessen Metadatentyp ermittelt werden soll. Returns MLContainer Eine Instanz des Metadatentyps des properties."
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.IsComponentProperty.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.IsComponentProperty.html",
    "title": "Method IsComponentProperty",
    "keywords": "Method IsComponentProperty Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll IsComponentProperty(string) Prüft, ob der übergebene propertyName in ComponentProperties enthalten ist. bool IsComponentProperty(string propertyName) Parameters propertyName string Name des Properties. Returns bool Remarks So kann man z.B. bei der Behandlung des Events PropertyChanged prüfen, ob das Property vom Entwickler angelegt wurde. Andernfalls handelt es sich ggf. um ein von Framework Studio bereitgestelltes Property wie z.B. State. Die Methode liefert true bei public oder internal Properties. Bei RowID und RowVersion wird false zurückgegeben."
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.IsFrozen.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.IsFrozen.html",
    "title": "Property IsFrozen",
    "keywords": "Property IsFrozen Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll IsFrozen Gibt zurück, ob das Objekt mittels der Methode Freeze() für Änderungen gesperrt wurde. bool IsFrozen { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.SetProperty.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.SetProperty.html",
    "title": "Method SetProperty",
    "keywords": "Method SetProperty Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll SetProperty(string, object) Setzt das Property mit dem übergebenen propertyName auf den Wert value. void SetProperty(string propertyName, object value) Parameters propertyName string Name des zu setzenden Properties. value object Zu setzender Wert. Exceptions MissingMemberException Das property existiert nicht."
  },
  "api/FS.Hosting.Shared.IDevFrameworkBaseObject.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkBaseObject.html",
    "title": "Interface IDevFrameworkBaseObject",
    "keywords": "Interface IDevFrameworkBaseObject Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll [ComVisible(false)] public interface IDevFrameworkBaseObject : INotifyPropertyChanged Inherited Members INotifyPropertyChanged.PropertyChanged Properties ComponentProperties Gibt eine Liste mit den Namen aller public oder internal Properties zurück, die vom Entwickler in der IDE definiert wurden. RowID und RowVersion sind nicht enthalten. IsFrozen Gibt zurück, ob das Objekt mittels der Methode Freeze() für Änderungen gesperrt wurde. Methods AcceptChanges() Übernimmt alle Änderungen. Sollte in allen Subclasses überschrieben werden, sodass die aktuellen Werte in die Membervariablen mit den Orginalwerten übernommen werden, damit ein späterer Rollback wieder den aktuellen Zustand herstellen kann. AdoptValues(IDevFrameworkBaseObject) AdoptValues(IDevFrameworkBaseObject, AdoptMode) CanFreeze() Gibt zurück, ob der Aufruf der Methode Freeze() möglich ist. Clone() Clone(AdoptMode) Freeze() Sperrt das Objekt für weitere Änderungen. Wird bei einem frozen Objekt versucht Werte zu verändern, wird eine InvalidOperationException geworfen. GetDefaultLabel(string) Gibt des Default-Label eines bestimmten Properties zurück. Falls es das Property nicht gibt, wird Empty zurückgegeben. GetProperty(string) Gibt den Wert des Properties mit dem übergebenen propertyName zurück. GetPropertyMdt(string) Ermittelt den Metadatentypen eines properties. IsComponentProperty(string) Prüft, ob der übergebene propertyName in ComponentProperties enthalten ist. SetProperty(string, object) Setzt das Property mit dem übergebenen propertyName auf den Wert value."
  },
  "api/FS.Hosting.Shared.IDevFrameworkDataObject.Exists.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkDataObject.Exists.html",
    "title": "Method Exists",
    "keywords": "Method Exists Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Exists(string) bool Exists(string condition) Parameters condition string Returns bool"
  },
  "api/FS.Hosting.Shared.IDevFrameworkDataObject.GetFetchNext.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkDataObject.GetFetchNext.html",
    "title": "Method GetFetchNext",
    "keywords": "Method GetFetchNext Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetFetchNext() IEnumerable<IDevFrameworkDataObject> GetFetchNext() Returns IEnumerable<IDevFrameworkDataObject> GetFetchNext(FrameworkQueryOptions) IEnumerable<IDevFrameworkDataObject> GetFetchNext(FrameworkQueryOptions options) Parameters options FrameworkQueryOptions Returns IEnumerable<IDevFrameworkDataObject> GetFetchNext(string) IEnumerable<IDevFrameworkDataObject> GetFetchNext(string loadCondition) Parameters loadCondition string Returns IEnumerable<IDevFrameworkDataObject> GetFetchNext(string, string) IEnumerable<IDevFrameworkDataObject> GetFetchNext(string loadCondition, string replacingOrderByClause) Parameters loadCondition string replacingOrderByClause string Returns IEnumerable<IDevFrameworkDataObject> GetFetchNext(string, string, string) IEnumerable<IDevFrameworkDataObject> GetFetchNext(string loadCondition, string replacingHavingClause, string replacingOrderByClause) Parameters loadCondition string replacingHavingClause string replacingOrderByClause string Returns IEnumerable<IDevFrameworkDataObject>"
  },
  "api/FS.Hosting.Shared.IDevFrameworkDataObject.HasDbChanged.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkDataObject.HasDbChanged.html",
    "title": "Method HasDbChanged",
    "keywords": "Method HasDbChanged Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll HasDbChanged() bool HasDbChanged() Returns bool"
  },
  "api/FS.Hosting.Shared.IDevFrameworkDataObject.IsHistorical.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkDataObject.IsHistorical.html",
    "title": "Property IsHistorical",
    "keywords": "Property IsHistorical Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll IsHistorical Gibt an, ob es sich bei dem Datensatz um einen historischen Beleg handelt. bool IsHistorical { get; } Property Value bool Remarks Wenn UseHistory aktiv ist, werden auch Datensätze aus den Historie-Tabellen eingelesen. Historische Datensätze können nicht gespeichert werden. Diese Eigenschaft wird nur bei Components gesetzt, die nicht als \"readonly\" markiert sind. (Join Components sind zwangsweise readonly.) Bei den Methoden Clone(AdoptMode) und AdoptValues(IDevFrameworkBaseObject, AdoptMode) kann bei AdoptMode das Flag NoHistory gesetzt werden, um zu verhindern, dass die Kopie als historisiert gilt. var orderCopy = (IcdOrder)oHistoricalOrder.Clone(AdoptMode.Deep | AdoptMode.NoHistory); orderCopy.OrderId = FSlong.Null;"
  },
  "api/FS.Hosting.Shared.IDevFrameworkDataObject.LoadCount.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkDataObject.LoadCount.html",
    "title": "Method LoadCount",
    "keywords": "Method LoadCount Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll LoadCount(string) int LoadCount(string condition) Parameters condition string Returns int"
  },
  "api/FS.Hosting.Shared.IDevFrameworkDataObject.ReloadData.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkDataObject.ReloadData.html",
    "title": "Method ReloadData",
    "keywords": "Method ReloadData Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ReloadData() int ReloadData() Returns int"
  },
  "api/FS.Hosting.Shared.IDevFrameworkDataObject.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkDataObject.html",
    "title": "Interface IDevFrameworkDataObject",
    "keywords": "Interface IDevFrameworkDataObject Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll [ComVisible(false)] public interface IDevFrameworkDataObject : IDevFrameworkObject, IDevFrameworkBaseObject, INotifyPropertyChanged Inherited Members IDevFrameworkObject.ObjectRowID IDevFrameworkObject.Load() IDevFrameworkObject.Load(string) IDevFrameworkObject.Load(string, string) IDevFrameworkObject.Load(string, string, string) IDevFrameworkObject.Save() IDevFrameworkObject.Save(SaveEntryPoints) IDevFrameworkObject.SaveCallEntryPointsAllways() IDevFrameworkObject.Delete() IDevFrameworkObject.DeleteMarkedObject() IDevFrameworkObject.GetPropertyOrgValue(string) IDevFrameworkObject.RollbackChanges() IDevFrameworkObject.State IDevFrameworkObject.StateBeforeFirstSaveEntryInTransaction IDevFrameworkObject.StateBeforeUpdate IDevFrameworkObject.IsMarkedForDeletion IDevFrameworkObject.IsDeleted IDevFrameworkObject.IsModified IDevFrameworkObject.TrackVersion IDevFrameworkObject.GetTableName(string) IDevFrameworkObject.GetTableName() IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject) IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject, AdoptMode) IDevFrameworkBaseObject.Clone() IDevFrameworkBaseObject.Clone(AdoptMode) IDevFrameworkBaseObject.GetDefaultLabel(string) IDevFrameworkBaseObject.GetPropertyMdt(string) IDevFrameworkBaseObject.AcceptChanges() IDevFrameworkBaseObject.GetProperty(string) IDevFrameworkBaseObject.SetProperty(string, object) IDevFrameworkBaseObject.ComponentProperties IDevFrameworkBaseObject.IsComponentProperty(string) IDevFrameworkBaseObject.IsFrozen IDevFrameworkBaseObject.CanFreeze() IDevFrameworkBaseObject.Freeze() INotifyPropertyChanged.PropertyChanged Properties IsHistorical Gibt an, ob es sich bei dem Datensatz um einen historischen Beleg handelt. Methods Exists(string) GetFetchNext() GetFetchNext(FrameworkQueryOptions) GetFetchNext(string) GetFetchNext(string, string) GetFetchNext(string, string, string) HasDbChanged() LoadCount(string) ReloadData()"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.Delete.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.Delete.html",
    "title": "Method Delete",
    "keywords": "Method Delete Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Delete() Löscht den verknüpften Datensatz aus der Datenbank. void Delete()"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.DeleteMarkedObject.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.DeleteMarkedObject.html",
    "title": "Method DeleteMarkedObject",
    "keywords": "Method DeleteMarkedObject Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll DeleteMarkedObject() Führt die Löschung eines per FS.Hosting.Shared.IDevFrameworkObject.MarkForDeletion() markierten Objekts durch. void DeleteMarkedObject()"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.GetPropertyOrgValue.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.GetPropertyOrgValue.html",
    "title": "Method GetPropertyOrgValue",
    "keywords": "Method GetPropertyOrgValue Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetPropertyOrgValue(string) Ermittelt den OrgValue des Properties propertyName. object GetPropertyOrgValue(string propertyName) Parameters propertyName string Name des Properties OHNE \"OrgValue\" Returns object"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.GetTableName.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.GetTableName.html",
    "title": "Method GetTableName",
    "keywords": "Method GetTableName Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetTableName(string) Gibt den Tabellennamen eines bestimmten Properties zurück. Falls es das Property nicht gibt bzw. das Property nicht mit einer Datenbankspalte verknüpft ist, wird Empty zurückgegeben. string GetTableName(string propertyName) Parameters propertyName string Returns string GetTableName() Gibt den Tabellennamen zurück. Dabei wird nur die erste Tabelle berücksichtigt. Im Falle einer Join-Component muss GetTableName(string) verwendet werden. string GetTableName() Returns string"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.IsDeleted.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.IsDeleted.html",
    "title": "Property IsDeleted",
    "keywords": "Property IsDeleted Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll IsDeleted Gibt an, ob das Objekt gelöscht wurde. [Browsable(false)] bool IsDeleted { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.IsMarkedForDeletion.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.IsMarkedForDeletion.html",
    "title": "Property IsMarkedForDeletion",
    "keywords": "Property IsMarkedForDeletion Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll IsMarkedForDeletion Wenn true, ist das Objekt zum Löschen vorgemerkt. Vor einem Save wird an der Collection FS.Hosting.Shared.IDevFrameworkObjectColl.DeleteMarkedObjects() aufgerufen und so dann an allen markierten Objekten Delete aufgerufen. Wenn Save() direkt am Objekt aufgerufen wird, wird DeleteMarkedObject() am Objekt aufgerufen. [Browsable(false)] bool IsMarkedForDeletion { get; set; } Property Value bool Remarks Änderungen werden über das Event PropertyChanged gemeldet."
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.IsModified.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.IsModified.html",
    "title": "Property IsModified",
    "keywords": "Property IsModified Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll IsModified Gibt an, ob das Objekt geändert wurde. [Browsable(false)] bool IsModified { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.Load.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.Load.html",
    "title": "Method Load",
    "keywords": "Method Load Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Load() Lädt Daten in das Objekt anhand der übergebenen loadCondition. Falls mehr als ein Datensatz gelesen wird, wird der Erste verwendet. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. int Load() Returns int Anzahl der Datensätze, die geladen wurden. Load(string) Lädt Daten in das Objekt anhand der übergebenen loadCondition. Falls mehr als ein Datensatz gelesen wird, wird der Erste verwendet. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. int Load(string loadCondition) Parameters loadCondition string Die Where-clause, auf dessen Basis das Objekt geladen wird. Returns int Anzahl der Datensätze, die geladen wurden. Load(string, string) Lädt Daten in das Objekt anhand der übergebenen loadCondition. Falls mehr als ein Datensatz gelesen wird, wird der Erste verwendet. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. int Load(string loadCondition, string replacingOrderByClause) Parameters loadCondition string Die Where-clause, auf dessen Basis das Objekt geladen wird. replacingOrderByClause string Falls != null, wird die OrderByClause beim load hierdurch ersetzt. Returns int Anzahl der Datensätze, die geladen wurden. Load(string, string, string) Lädt Daten in das Objekt anhand der übergebenen loadCondition. Falls mehr als ein Datensatz gelesen wird, wird der Erste verwendet. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. int Load(string loadCondition, string replacingHavingClause, string replacingOrderByClause) Parameters loadCondition string Die Where-clause, auf dessen Basis das Objekt geladen wird. replacingHavingClause string Falls != null, wird die HavingClause beim load hierdurch ersetzt. replacingOrderByClause string Falls != null, wird die OrderByClause beim load hierdurch ersetzt. Returns int Anzahl der Datensätze, die geladen wurden."
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.ObjectRowID.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.ObjectRowID.html",
    "title": "Property ObjectRowID",
    "keywords": "Property ObjectRowID Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ObjectRowID Eindeutige ID vom Typ guid des Objektes. [Browsable(false)] guid ObjectRowID { get; } Property Value guid"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.RollbackChanges.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.RollbackChanges.html",
    "title": "Method RollbackChanges",
    "keywords": "Method RollbackChanges Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll RollbackChanges() Überschreibt alle aktuellen Werte mit den Werten, die durch den Loadbefehl bzw. einen Aufruf von AcceptChanges festgehalten worden sind. Sollte in allen Subclasses überschrieben werden! void RollbackChanges()"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.Save.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.Save.html",
    "title": "Method Save",
    "keywords": "Method Save Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Save() Speichert diese Component in der Datenbank ab. Das entsprechende SqlStatement muss in der SaveAction zusammengebaut und ausgeführt werden. Falls keine gestartete Transaktion existiert, wird automatisch eine Transaktion aufgebaut. In diesem Fall wird anschliessend ein Commit ausgeführt. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. void Save() Save(SaveEntryPoints) Speichert diese Component in der Datenbank ab. Das entsprechende SqlStatement muss in der SaveAction zusammengebaut und ausgeführt werden. Falls keine gestartete Transaktion existiert, wird automatisch eine Transaktion aufgebaut. In diesem Fall wird anschliessend ein Commit ausgeführt. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. void Save(SaveEntryPoints saveEntryPoints) Parameters saveEntryPoints SaveEntryPoints Wenn true, dann werden die EntryPoints auch aufgerufen, falls die Komponente nicht geändert wurde."
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.SaveCallEntryPointsAllways.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.SaveCallEntryPointsAllways.html",
    "title": "Method SaveCallEntryPointsAllways",
    "keywords": "Method SaveCallEntryPointsAllways Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll SaveCallEntryPointsAllways() Ruft Save() auf und stellt dabei sicher, dass alle EntryPoints aufgerufen werden. void SaveCallEntryPointsAllways()"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.State.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.State.html",
    "title": "Property State",
    "keywords": "Property State Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll State Aktueller Status des IDevFrameworkObjects. [Browsable(false)] FrameworkComponentState State { get; set; } Property Value FrameworkComponentState Remarks Änderungen werden über das Event PropertyChanged gemeldet."
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.StateBeforeFirstSaveEntryInTransaction.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.StateBeforeFirstSaveEntryInTransaction.html",
    "title": "Property StateBeforeFirstSaveEntryInTransaction",
    "keywords": "Property StateBeforeFirstSaveEntryInTransaction Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll StateBeforeFirstSaveEntryInTransaction Der Wert von State vor dem ersten Save. [Browsable(false)] FrameworkComponentState StateBeforeFirstSaveEntryInTransaction { get; } Property Value FrameworkComponentState"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.StateBeforeUpdate.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.StateBeforeUpdate.html",
    "title": "Property StateBeforeUpdate",
    "keywords": "Property StateBeforeUpdate Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll StateBeforeUpdate Der Wert von State vor dem letzten Update. [Browsable(false)] FrameworkComponentState StateBeforeUpdate { get; set; } Property Value FrameworkComponentState"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.TrackVersion.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.TrackVersion.html",
    "title": "Property TrackVersion",
    "keywords": "Property TrackVersion Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll TrackVersion Bei der Änderung eines generated Properties wird dieser Wert hochgezählt. [Browsable(false)] int TrackVersion { get; } Property Value int"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObject.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObject.html",
    "title": "Interface IDevFrameworkObject",
    "keywords": "Interface IDevFrameworkObject Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll [ComVisible(false)] public interface IDevFrameworkObject : IDevFrameworkBaseObject, INotifyPropertyChanged Inherited Members IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject) IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject, AdoptMode) IDevFrameworkBaseObject.Clone() IDevFrameworkBaseObject.Clone(AdoptMode) IDevFrameworkBaseObject.GetDefaultLabel(string) IDevFrameworkBaseObject.GetPropertyMdt(string) IDevFrameworkBaseObject.AcceptChanges() IDevFrameworkBaseObject.GetProperty(string) IDevFrameworkBaseObject.SetProperty(string, object) IDevFrameworkBaseObject.ComponentProperties IDevFrameworkBaseObject.IsComponentProperty(string) IDevFrameworkBaseObject.IsFrozen IDevFrameworkBaseObject.CanFreeze() IDevFrameworkBaseObject.Freeze() INotifyPropertyChanged.PropertyChanged Remarks Alle Business-Objekte, die im Developement Framework verwendet werden sollen, müssen dieses Interface einbinden. Properties IsDeleted Gibt an, ob das Objekt gelöscht wurde. IsMarkedForDeletion Wenn true, ist das Objekt zum Löschen vorgemerkt. Vor einem Save wird an der Collection FS.Hosting.Shared.IDevFrameworkObjectColl.DeleteMarkedObjects() aufgerufen und so dann an allen markierten Objekten Delete aufgerufen. Wenn Save() direkt am Objekt aufgerufen wird, wird DeleteMarkedObject() am Objekt aufgerufen. IsModified Gibt an, ob das Objekt geändert wurde. ObjectRowID Eindeutige ID vom Typ guid des Objektes. State Aktueller Status des IDevFrameworkObjects. StateBeforeFirstSaveEntryInTransaction Der Wert von State vor dem ersten Save. StateBeforeUpdate Der Wert von State vor dem letzten Update. TrackVersion Bei der Änderung eines generated Properties wird dieser Wert hochgezählt. Methods Delete() Löscht den verknüpften Datensatz aus der Datenbank. DeleteMarkedObject() Führt die Löschung eines per FS.Hosting.Shared.IDevFrameworkObject.MarkForDeletion() markierten Objekts durch. GetPropertyOrgValue(string) Ermittelt den OrgValue des Properties propertyName. GetTableName() Gibt den Tabellennamen zurück. Dabei wird nur die erste Tabelle berücksichtigt. Im Falle einer Join-Component muss GetTableName(string) verwendet werden. GetTableName(string) Gibt den Tabellennamen eines bestimmten Properties zurück. Falls es das Property nicht gibt bzw. das Property nicht mit einer Datenbankspalte verknüpft ist, wird Empty zurückgegeben. Load() Lädt Daten in das Objekt anhand der übergebenen loadCondition. Falls mehr als ein Datensatz gelesen wird, wird der Erste verwendet. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. Load(string) Lädt Daten in das Objekt anhand der übergebenen loadCondition. Falls mehr als ein Datensatz gelesen wird, wird der Erste verwendet. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. Load(string, string) Lädt Daten in das Objekt anhand der übergebenen loadCondition. Falls mehr als ein Datensatz gelesen wird, wird der Erste verwendet. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. Load(string, string, string) Lädt Daten in das Objekt anhand der übergebenen loadCondition. Falls mehr als ein Datensatz gelesen wird, wird der Erste verwendet. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. RollbackChanges() Überschreibt alle aktuellen Werte mit den Werten, die durch den Loadbefehl bzw. einen Aufruf von AcceptChanges festgehalten worden sind. Sollte in allen Subclasses überschrieben werden! Save() Speichert diese Component in der Datenbank ab. Das entsprechende SqlStatement muss in der SaveAction zusammengebaut und ausgeführt werden. Falls keine gestartete Transaktion existiert, wird automatisch eine Transaktion aufgebaut. In diesem Fall wird anschliessend ein Commit ausgeführt. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. Save(SaveEntryPoints) Speichert diese Component in der Datenbank ab. Das entsprechende SqlStatement muss in der SaveAction zusammengebaut und ausgeführt werden. Falls keine gestartete Transaktion existiert, wird automatisch eine Transaktion aufgebaut. In diesem Fall wird anschliessend ein Commit ausgeführt. Verknüpfung zwischen Properties und DB-Columns erfolgt über Repository. SaveCallEntryPointsAllways() Ruft Save() auf und stellt dabei sicher, dass alle EntryPoints aufgerufen werden."
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectColl.Count.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectColl.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Count Gibt die Anzahl der Einträge in der Collection zurück. int Count { get; } Property Value int"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectColl.CountLoadedEntries.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectColl.CountLoadedEntries.html",
    "title": "Property CountLoadedEntries",
    "keywords": "Property CountLoadedEntries Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll CountLoadedEntries Gibt die Anzahl der vollständig geladenen Einträge in der Collection zurück. int CountLoadedEntries { get; } Property Value int"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectColl.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectColl.html",
    "title": "Interface IDevFrameworkObjectColl",
    "keywords": "Interface IDevFrameworkObjectColl Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public interface IDevFrameworkObjectColl : IDevFrameworkBaseObject, INotifyPropertyChanged, IEnumerable<IDevFrameworkObject>, IEnumerable, IDisposable Inherited Members IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject) IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject, AdoptMode) IDevFrameworkBaseObject.Clone() IDevFrameworkBaseObject.Clone(AdoptMode) IDevFrameworkBaseObject.GetDefaultLabel(string) IDevFrameworkBaseObject.GetPropertyMdt(string) IDevFrameworkBaseObject.AcceptChanges() IDevFrameworkBaseObject.GetProperty(string) IDevFrameworkBaseObject.SetProperty(string, object) IDevFrameworkBaseObject.ComponentProperties IDevFrameworkBaseObject.IsComponentProperty(string) IDevFrameworkBaseObject.IsFrozen IDevFrameworkBaseObject.CanFreeze() IDevFrameworkBaseObject.Freeze() INotifyPropertyChanged.PropertyChanged IEnumerable<IDevFrameworkObject>.GetEnumerator() IDisposable.Dispose() Properties Count Gibt die Anzahl der Einträge in der Collection zurück. CountLoadedEntries Gibt die Anzahl der vollständig geladenen Einträge in der Collection zurück."
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.GetText.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.GetText.html",
    "title": "Method GetText",
    "keywords": "Method GetText Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetText(string) Liefert den Text in der übergebenen Sprache. Es erfolgt keine Fallback auf eine andere Sprache. string GetText(string iso) Parameters iso string 2-Zeichen iso-Code Returns string Remarks Wird der Text in der Sprache bzw. der Sprach-Hierarchie der aktuellen Sitzung benötigt, sollte das Property Text verwendet werden."
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.ID.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.ID.html",
    "title": "Property ID",
    "keywords": "Property ID Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ID ID des TextCollection-Eintrages. int ID { get; set; } Property Value int"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.Text.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Text Text in der aktuellen Sprache bzw. Sprach-Hierarchie. string Text { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.Value.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Value Der mehrsprachige Text des TextCollection-Eintrages. DevMLString Value { get; } Property Value DevMLString"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectMLString.html",
    "title": "Interface IDevFrameworkObjectMLString",
    "keywords": "Interface IDevFrameworkObjectMLString Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Repräsentiert den Eintrag einer TextCollection. [ComVisible(false)] public interface IDevFrameworkObjectMLString : IDevFrameworkObject, IDevFrameworkBaseObject, INotifyPropertyChanged Inherited Members IDevFrameworkObject.ObjectRowID IDevFrameworkObject.Load() IDevFrameworkObject.Load(string) IDevFrameworkObject.Load(string, string) IDevFrameworkObject.Load(string, string, string) IDevFrameworkObject.Save() IDevFrameworkObject.Save(SaveEntryPoints) IDevFrameworkObject.SaveCallEntryPointsAllways() IDevFrameworkObject.Delete() IDevFrameworkObject.DeleteMarkedObject() IDevFrameworkObject.GetPropertyOrgValue(string) IDevFrameworkObject.RollbackChanges() IDevFrameworkObject.State IDevFrameworkObject.StateBeforeFirstSaveEntryInTransaction IDevFrameworkObject.StateBeforeUpdate IDevFrameworkObject.IsMarkedForDeletion IDevFrameworkObject.IsDeleted IDevFrameworkObject.IsModified IDevFrameworkObject.TrackVersion IDevFrameworkObject.GetTableName(string) IDevFrameworkObject.GetTableName() IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject) IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject, AdoptMode) IDevFrameworkBaseObject.Clone() IDevFrameworkBaseObject.Clone(AdoptMode) IDevFrameworkBaseObject.GetDefaultLabel(string) IDevFrameworkBaseObject.GetPropertyMdt(string) IDevFrameworkBaseObject.AcceptChanges() IDevFrameworkBaseObject.GetProperty(string) IDevFrameworkBaseObject.SetProperty(string, object) IDevFrameworkBaseObject.ComponentProperties IDevFrameworkBaseObject.IsComponentProperty(string) IDevFrameworkBaseObject.IsFrozen IDevFrameworkBaseObject.CanFreeze() IDevFrameworkBaseObject.Freeze() INotifyPropertyChanged.PropertyChanged Properties ID ID des TextCollection-Eintrages. Text Text in der aktuellen Sprache bzw. Sprach-Hierarchie. Value Der mehrsprachige Text des TextCollection-Eintrages. Methods GetText(string) Liefert den Text in der übergebenen Sprache. Es erfolgt keine Fallback auf eine andere Sprache."
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.Drop.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.Drop.html",
    "title": "Method Drop",
    "keywords": "Method Drop Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Drop(FSlong) Entfernt aus der Textcollection den Eintrag mit der übergebenen ID. bool Drop(FSlong id) Parameters id FSlong Die ID des Eintrags. Es kann auch eine Constant Name übergeben werden. Returns bool true, wenn der Eintrag gelöscht wurde. false, wenn der Eintrag nicht vorhanden ist."
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.GetOnID.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.GetOnID.html",
    "title": "Method GetOnID",
    "keywords": "Method GetOnID Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetOnID(int) IDevFrameworkObjectMLString GetOnID(int ID) Parameters ID int Returns IDevFrameworkObjectMLString GetOnID(long) IDevFrameworkObjectMLString GetOnID(long ID) Parameters ID long Returns IDevFrameworkObjectMLString"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.GetTextOnID.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.GetTextOnID.html",
    "title": "Method GetTextOnID",
    "keywords": "Method GetTextOnID Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetTextOnID(int, string) string GetTextOnID(int ID, string defaultText) Parameters ID int defaultText string Returns string GetTextOnID(long, string) string GetTextOnID(long ID, string defaultText) Parameters ID long defaultText string Returns string"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.Item.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.Item.html",
    "title": "Property this",
    "keywords": "Property this Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll this[int] IDevFrameworkObjectMLString this[int index] { get; } Parameters index int Property Value IDevFrameworkObjectMLString"
  },
  "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.html": {
    "href": "api/FS.Hosting.Shared.IDevFrameworkObjectTextColl.html",
    "title": "Interface IDevFrameworkObjectTextColl",
    "keywords": "Interface IDevFrameworkObjectTextColl Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll [ComVisible(false)] public interface IDevFrameworkObjectTextColl : IDevFrameworkObjectColl, IDevFrameworkBaseObject, INotifyPropertyChanged, IEnumerable<IDevFrameworkObject>, IEnumerable, IDisposable Inherited Members IDevFrameworkObjectColl.Count IDevFrameworkObjectColl.CountLoadedEntries IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject) IDevFrameworkBaseObject.AdoptValues(IDevFrameworkBaseObject, AdoptMode) IDevFrameworkBaseObject.Clone() IDevFrameworkBaseObject.Clone(AdoptMode) IDevFrameworkBaseObject.GetDefaultLabel(string) IDevFrameworkBaseObject.GetPropertyMdt(string) IDevFrameworkBaseObject.AcceptChanges() IDevFrameworkBaseObject.GetProperty(string) IDevFrameworkBaseObject.SetProperty(string, object) IDevFrameworkBaseObject.ComponentProperties IDevFrameworkBaseObject.IsComponentProperty(string) IDevFrameworkBaseObject.IsFrozen IDevFrameworkBaseObject.CanFreeze() IDevFrameworkBaseObject.Freeze() INotifyPropertyChanged.PropertyChanged IEnumerable<IDevFrameworkObject>.GetEnumerator() IDisposable.Dispose() Properties this[int] Methods Drop(FSlong) Entfernt aus der Textcollection den Eintrag mit der übergebenen ID. GetOnID(int) GetOnID(long) GetTextOnID(int, string) GetTextOnID(long, string)"
  },
  "api/FS.Hosting.Shared.IFSCache.GetTokenForKey.html": {
    "href": "api/FS.Hosting.Shared.IFSCache.GetTokenForKey.html",
    "title": "Method GetTokenForKey",
    "keywords": "Method GetTokenForKey Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll GetTokenForKey(object) Gibt für den übergebenen Key einen IChangeToken zurück. IChangeToken GetTokenForKey(object key) Parameters key object Returns IChangeToken Remarks Beim Aufruf von Reset() werden alle aktiven Tokens invalidiert. Beim anschließenden Neuaufbau des Caches werden neue Tokens generiert. Nach Möglichkeit sollten spezielle Methoden verwendet werden, die den Key kontrolliert übergeben: GetTokenFor<T>(IFSCache)"
  },
  "api/FS.Hosting.Shared.IFSCache.InvalidateKey.html": {
    "href": "api/FS.Hosting.Shared.IFSCache.InvalidateKey.html",
    "title": "Method InvalidateKey",
    "keywords": "Method InvalidateKey Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll InvalidateKey(object) Invalidiert den aktuellen IChangeToken für den übergebenen Key. Dadurch werden alle Cache-Einträge, die diesen Token hängen, invalidiert. void InvalidateKey(object key) Parameters key object Remarks Der aktuelle Token wird aus der internen Liste entfernt. Beim nächsten Aufruf von GetTokenForKey(object) wird ein neuer Token erzeugt. Nach Möglichkeit sollten spezielle Methoden verwendet werden, die den Key kontrolliert übergeben: Invalidate<T>(IFSCache)"
  },
  "api/FS.Hosting.Shared.IFSCache.Reset.html": {
    "href": "api/FS.Hosting.Shared.IFSCache.Reset.html",
    "title": "Method Reset",
    "keywords": "Method Reset Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Reset() Setzt die komplette Cache-Infrastruktur zurück. Alle Scopes werden entfernt - auch die Caches in anderen Broker-Sitzungen im aktuellen Prozess. Im Anschluss bauen sich alle Caches wieder neu auf. void Reset() Remarks Warning Diese Methode sollte nur in Ausnahmefällen aufgerufen werden. Ein Aufruf im normalen Anwendungs-Ablauf würde alle Vorteile Caches zunichte machen. Beispiel: public void FE_btnResetAllCaches_OnClick(FrameworkButtonClickEventArgs e) { FSCache.Instance.Reset(); }"
  },
  "api/FS.Hosting.Shared.IFSCache.Scope.html": {
    "href": "api/FS.Hosting.Shared.IFSCache.Scope.html",
    "title": "Method Scope",
    "keywords": "Method Scope Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Scope(object, Action<ICacheEntry>) Liefert für den übergebenen Scope den Memory-Cache zurück. Beim ersten Aufruf wird der Memory-Cache für den Scope erzeugt. IMemoryCache Scope(object scopeKey, Action<ICacheEntry> configureEntry = null) Parameters scopeKey object Eindeutiger Identifier für den Scope. Idealerweise werden Strings verwendet, es sind aber auch andere Typen möglich, solange sie einen eindeutigen Key representieren. configureEntry Action<ICacheEntry> (optional) Der Cache selber wird in einem CacheEntry in einem MemoryCache gespeichert. Der Lifecycle des Entries kann mithilfe dieser Action konfiguriert werden. Returns IMemoryCache Der entsprechende Cache. Remarks Warning Im Alltag sollte diese Methode nicht verwendet werden sondern die speziellen Scope-Methoden wie Static(IFSCache) oder Session(IFSCache)."
  },
  "api/FS.Hosting.Shared.IFSCache.html": {
    "href": "api/FS.Hosting.Shared.IFSCache.html",
    "title": "Interface IFSCache",
    "keywords": "Interface IFSCache Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Infrastruktur zum mehrstufige Cachen von Informationen. Siehe auch FSCache. public interface IFSCache Extension Methods FSCache.GetTokenFor<T>(IFSCache) FSCache.Invalidate<T>(IFSCache) FSCache.Request(IFSCache) FSCache.Session(IFSCache) FSCache.Static(IFSCache) Methods GetTokenForKey(object) Gibt für den übergebenen Key einen IChangeToken zurück. InvalidateKey(object) Invalidiert den aktuellen IChangeToken für den übergebenen Key. Dadurch werden alle Cache-Einträge, die diesen Token hängen, invalidiert. Reset() Setzt die komplette Cache-Infrastruktur zurück. Alle Scopes werden entfernt - auch die Caches in anderen Broker-Sitzungen im aktuellen Prozess. Im Anschluss bauen sich alle Caches wieder neu auf. Scope(object, Action<ICacheEntry>) Liefert für den übergebenen Scope den Memory-Cache zurück. Beim ersten Aufruf wird der Memory-Cache für den Scope erzeugt."
  },
  "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.Cancelled.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.Cancelled.html",
    "title": "Property Cancelled",
    "keywords": "Property Cancelled Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Cancelled true wenn der Scanvorgang am Client abgebrochen wurde bool Cancelled { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.ErrorMessage.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.ErrorMessage.html",
    "title": "Property ErrorMessage",
    "keywords": "Property ErrorMessage Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ErrorMessage Fehlermeldung bei einem gescheiterten Scanvorgang string ErrorMessage { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.Format.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Format Das Format des gescannten Barcodes. NONE, wenn kein Barcode gescannt wurde. BarcodeFormat Format { get; } Property Value BarcodeFormat"
  },
  "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.HasError.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.HasError.html",
    "title": "Property HasError",
    "keywords": "Property HasError Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll HasError true wenn beim Scanvorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. bool HasError { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.Identifier.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.Identifier.html",
    "title": "Property Identifier",
    "keywords": "Property Identifier Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.ScanBarcode(System.Action{FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo},FrameworkSystems.FrameworkBase.BarcodeFormat,System.String) übergebene Wert, sonst null. string Identifier { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.Value.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Value Der Wert des gescannten Barcodes string Value { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkBarcodeScanInfo.html",
    "title": "Interface IFrameworkBarcodeScanInfo",
    "keywords": "Interface IFrameworkBarcodeScanInfo Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Eine Instanz dieses Typs wird nach einem mit der Action FrameworkSystems.FrameworkControls.GeneratedForm.ScanBarcode(System.Action{FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo},FrameworkSystems.FrameworkBase.BarcodeFormat) ausgelösten Scan-Vorgang der Callback-Methode übergeben. Sie beinhaltet die Ergebisse des Scan-Vorgangs. public interface IFrameworkBarcodeScanInfo Properties Cancelled true wenn der Scanvorgang am Client abgebrochen wurde ErrorMessage Fehlermeldung bei einem gescheiterten Scanvorgang Format Das Format des gescannten Barcodes. NONE, wenn kein Barcode gescannt wurde. HasError true wenn beim Scanvorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.ScanBarcode(System.Action{FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo},FrameworkSystems.FrameworkBase.BarcodeFormat,System.String) übergebene Wert, sonst null. Value Der Wert des gescannten Barcodes"
  },
  "api/FS.Hosting.Shared.IFrameworkControlActionBase.ControlName.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkControlActionBase.ControlName.html",
    "title": "Property ControlName",
    "keywords": "Property ControlName Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ControlName string ControlName { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IFrameworkControlActionBase.Form.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkControlActionBase.Form.html",
    "title": "Property Form",
    "keywords": "Property Form Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Form IGeneratedForm Form { get; } Property Value IGeneratedForm"
  },
  "api/FS.Hosting.Shared.IFrameworkControlActionBase.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkControlActionBase.html",
    "title": "Interface IFrameworkControlActionBase",
    "keywords": "Interface IFrameworkControlActionBase Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public interface IFrameworkControlActionBase Properties ControlName Form"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Accuracy.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Accuracy.html",
    "title": "Property Accuracy",
    "keywords": "Property Accuracy Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Accuracy Genauigkeit für die Werte Latitude und Logitude in Metern int? Accuracy { get; } Property Value int?"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Altitude.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Altitude.html",
    "title": "Property Altitude",
    "keywords": "Property Altitude Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Altitude Höhe in Metern über dem Meeresspiegel int? Altitude { get; } Property Value int?"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.ErrorMessage.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.ErrorMessage.html",
    "title": "Property ErrorMessage",
    "keywords": "Property ErrorMessage Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ErrorMessage Fehlermeldung, wenn der Standort nicht bestimmt werden konnte string ErrorMessage { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.HasError.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.HasError.html",
    "title": "Property HasError",
    "keywords": "Property HasError Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll HasError true wenn beim Bestimmen des Standortes ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. bool HasError { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Heading.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Heading.html",
    "title": "Property Heading",
    "keywords": "Property Heading Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Heading Bewegungsrichtung in Grad relativ zum Norden (im Uhrzeigersinn) int? Heading { get; } Property Value int?"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Identifier.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Identifier.html",
    "title": "Property Identifier",
    "keywords": "Property Identifier Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation(System.Action{FrameworkSystems.FrameworkBase.IFrameworGeoLocationInfo},System.String) übergebene Wert, sonst null. string Identifier { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Latitude.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Latitude.html",
    "title": "Property Latitude",
    "keywords": "Property Latitude Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Latitude Breitengrad z.B. 47.8477500 double? Latitude { get; } Property Value double?"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Longitude.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Longitude.html",
    "title": "Property Longitude",
    "keywords": "Property Longitude Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Longitude Längengrad z.B. 9.0057000 double? Longitude { get; } Property Value double?"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Speed.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Speed.html",
    "title": "Property Speed",
    "keywords": "Property Speed Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Speed Geschwindigkeit des Getätes in m/s int? Speed { get; } Property Value int?"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Timestamp.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.Timestamp.html",
    "title": "Property Timestamp",
    "keywords": "Property Timestamp Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Timestamp Zeitstempel der Standortbestimmung long? Timestamp { get; } Property Value long?"
  },
  "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkGeoLocationInfo.html",
    "title": "Interface IFrameworkGeoLocationInfo",
    "keywords": "Interface IFrameworkGeoLocationInfo Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Eine Instanz dieses Typs wird nach einem mit der Action FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation(System.Action{FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo}) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet alle Informationen zum derzeitigen Standort des Endgeräts. public interface IFrameworkGeoLocationInfo Properties Accuracy Genauigkeit für die Werte Latitude und Logitude in Metern Altitude Höhe in Metern über dem Meeresspiegel ErrorMessage Fehlermeldung, wenn der Standort nicht bestimmt werden konnte HasError true wenn beim Bestimmen des Standortes ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Heading Bewegungsrichtung in Grad relativ zum Norden (im Uhrzeigersinn) Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation(System.Action{FrameworkSystems.FrameworkBase.IFrameworGeoLocationInfo},System.String) übergebene Wert, sonst null. Latitude Breitengrad z.B. 47.8477500 Longitude Längengrad z.B. 9.0057000 Speed Geschwindigkeit des Getätes in m/s Timestamp Zeitstempel der Standortbestimmung"
  },
  "api/FS.Hosting.Shared.IFrameworkPhotoInfo.ErrorMessage.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkPhotoInfo.ErrorMessage.html",
    "title": "Property ErrorMessage",
    "keywords": "Property ErrorMessage Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ErrorMessage Fehlermeldung bei einem gescheiterten Vorgang string ErrorMessage { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IFrameworkPhotoInfo.HasError.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkPhotoInfo.HasError.html",
    "title": "Property HasError",
    "keywords": "Property HasError Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll HasError true wenn beim Vorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. bool HasError { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.IFrameworkPhotoInfo.Identifier.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkPhotoInfo.Identifier.html",
    "title": "Property Identifier",
    "keywords": "Property Identifier Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto(System.Action{FrameworkSystems.FrameworkBase.IFrameworPhotoInfo},FrameworkSystems.FrameworkBase.CameraSource,System.String) übergebene Wert, sonst null. string Identifier { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IFrameworkPhotoInfo.ImageBase64.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkPhotoInfo.ImageBase64.html",
    "title": "Property ImageBase64",
    "keywords": "Property ImageBase64 Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ImageBase64 Das Bild im JPG-Format encodiert als Base64-String string ImageBase64 { get; } Property Value string"
  },
  "api/FS.Hosting.Shared.IFrameworkPhotoInfo.ImageBytes.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkPhotoInfo.ImageBytes.html",
    "title": "Property ImageBytes",
    "keywords": "Property ImageBytes Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ImageBytes Das Bild im JPG-Format als Byte-Array byte[] ImageBytes { get; } Property Value byte[]"
  },
  "api/FS.Hosting.Shared.IFrameworkPhotoInfo.html": {
    "href": "api/FS.Hosting.Shared.IFrameworkPhotoInfo.html",
    "title": "Interface IFrameworkPhotoInfo",
    "keywords": "Interface IFrameworkPhotoInfo Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Eine Instanz dieses Typs wird nach einem mit der Action FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto(System.Action{FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo},FrameworkSystems.FrameworkBase.CameraSource) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet die Bilddaten des neuen oder ausgewählten Bildes und Zusatzinformationen. public interface IFrameworkPhotoInfo Properties ErrorMessage Fehlermeldung bei einem gescheiterten Vorgang HasError true wenn beim Vorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto(System.Action{FrameworkSystems.FrameworkBase.IFrameworPhotoInfo},FrameworkSystems.FrameworkBase.CameraSource,System.String) übergebene Wert, sonst null. ImageBase64 Das Bild im JPG-Format encodiert als Base64-String ImageBytes Das Bild im JPG-Format als Byte-Array"
  },
  "api/FS.Hosting.Shared.IGridView.Collection.html": {
    "href": "api/FS.Hosting.Shared.IGridView.Collection.html",
    "title": "Property Collection",
    "keywords": "Property Collection Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Collection Gibt die (ungefilterte) Collection zurück, auf die der View aufsetzt. DevFrameworkObjectColl Collection { get; } Property Value DevFrameworkObjectColl"
  },
  "api/FS.Hosting.Shared.IGridView.Count.html": {
    "href": "api/FS.Hosting.Shared.IGridView.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Count Anzahl der Records. int Count { get; } Property Value int"
  },
  "api/FS.Hosting.Shared.IGridView.EntriesSortedOrFiltered.html": {
    "href": "api/FS.Hosting.Shared.IGridView.EntriesSortedOrFiltered.html",
    "title": "Event EntriesSortedOrFiltered",
    "keywords": "Event EntriesSortedOrFiltered Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Mit diesem Event kann man die sortierte/gefilterte Liste der ObjectRowIDs anpassen. event EventHandler<List<guid>> EntriesSortedOrFiltered Returns EventHandler<List<guid>> Mit diesem Event kann man die sortierte/gefilterte Liste der ObjectRowIDs anpassen. Examples protected virtual void FE_frmArticle_DefaultVariant_OnLoad(FrameworkEventArgs e) { this.grd.GetView().EntriesSortedOrFiltered += (sender, idList) => { // Die erste Zeile der Collection soll immer angezeigt werden - am Anfang des Grids stehen var coll = this.grd.GetView().Collection; if (coll != null && coll.Count > 1) { var firstRowId = coll.ObjectRowIDOf(0); var sortedIndex = idList.IndexOf(firstRowId); if (sortedIndex != 0) // nichts machen, wenn schon die erste Zeile. { if (sortedIndex > 0) idList.RemoveAt(sortedIndex); idList.Insert(0, firstRowId); } } }; } Remarks Dieses Event wird nach jedem Sortier-/Filter-Vorgang aufgerufen."
  },
  "api/FS.Hosting.Shared.IGridView.IndexOf.html": {
    "href": "api/FS.Hosting.Shared.IGridView.IndexOf.html",
    "title": "Method IndexOf",
    "keywords": "Method IndexOf Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll IndexOf(IDevFrameworkObject) Liefert den Index des übergebenen Objektes im View. int IndexOf(IDevFrameworkObject obj) Parameters obj IDevFrameworkObject Returns int Index; -1 wenn nicht gefunden IndexOf(guid) Liefert den Index der übergebenen Objekt-ID im View. int IndexOf(guid id) Parameters id guid Returns int Index; -1 wenn nicht gefunden"
  },
  "api/FS.Hosting.Shared.IGridView.Item.html": {
    "href": "api/FS.Hosting.Shared.IGridView.Item.html",
    "title": "Property this",
    "keywords": "Property this Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll this[int] Gibt den Record zum angegebenen Index zurück. DevFrameworkObject this[int index] { get; } Parameters index int Property Value DevFrameworkObject this[guid] Gibt den Record mit der übergebenen ID zurück. DevFrameworkObject this[guid id] { get; } Parameters id guid Property Value DevFrameworkObject null, wenn der Record nicht gefunden wurde."
  },
  "api/FS.Hosting.Shared.IGridView.ObjectRowIDOf.html": {
    "href": "api/FS.Hosting.Shared.IGridView.ObjectRowIDOf.html",
    "title": "Method ObjectRowIDOf",
    "keywords": "Method ObjectRowIDOf Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ObjectRowIDOf(int) Ermittelt die rowID des enthaltnenen Records zum dem angegebenen Index. guid ObjectRowIDOf(int index) Parameters index int Returns guid Remarks Der Record muss nicht aus der Datenbank gelesen werden, wenn er noch nicht bekannt ist."
  },
  "api/FS.Hosting.Shared.IGridView.RedoSortAndFilter.html": {
    "href": "api/FS.Hosting.Shared.IGridView.RedoSortAndFilter.html",
    "title": "Method RedoSortAndFilter",
    "keywords": "Method RedoSortAndFilter Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll RedoSortAndFilter() Wendet die Sortierung und die Filter erneut an - z.B. nachdem Änderungen an der Collection vorgenommen wurden. void RedoSortAndFilter()"
  },
  "api/FS.Hosting.Shared.IGridView.ResetSortAndFilter.html": {
    "href": "api/FS.Hosting.Shared.IGridView.ResetSortAndFilter.html",
    "title": "Method ResetSortAndFilter",
    "keywords": "Method ResetSortAndFilter Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ResetSortAndFilter() Setzt die Sortierung und die Filter zurück. void ResetSortAndFilter()"
  },
  "api/FS.Hosting.Shared.IGridView.html": {
    "href": "api/FS.Hosting.Shared.IGridView.html",
    "title": "Interface IGridView",
    "keywords": "Interface IGridView Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Ein Grid zeigt immer Daten einer Collection an. Um mit den Daten zu arbeiten, muss auf die Collection zugegriffen werden, die an das entsprechende Grid gebunden ist. [ComVisible(false)] public interface IGridView : IEnumerable<DevFrameworkObject>, IEnumerable Inherited Members IEnumerable<DevFrameworkObject>.GetEnumerator() Remarks Wenn über den Client die Daten im Grid sortiert oder gefiltert werden, dann stimmt die Reihenfolge der Elemente in der Collection nicht mehr mit der Anzeige überein. Um auf die den Filterkriterien entsprechenden Elemente in der angezeigten Reihenfolge zugreifen zu können, stellt FrameworkStudio einen View zur Verfügung. Dieser kann am Grid mit der Funktion FrameworkSystems.FrameworkControls.Actions.GridControlAction.GetView abgerufen werden: IGridView gridView = this.grdTableXyz.GetView(); IGridView kann zum einen enumeriert werden, also zum Beispiel mit foreach durchlaufen werden. Zum anderen kann über den Index gezielt auf das x-te Element der Collection zugegriffen werden. IGridView arbeitet mit der Basis-Klasse DevFrameworkObject. Ggf. müssen die ermittelten Elemente mit dem entsprechenden Cast in das gewünschte Format konvertiert werden. // Liste durchlaufen foreach(IcdCustomer oCustomer in gridView) { // Satz verarbeiten [...] } // gezielt einen Satz holen, Cast in entsprchenden Typ IcdCustomer oCustomer = (IcdCustomer) gridView[intIndex]; Properties Collection Gibt die (ungefilterte) Collection zurück, auf die der View aufsetzt. Count Anzahl der Records. this[guid] Gibt den Record mit der übergebenen ID zurück. this[int] Gibt den Record zum angegebenen Index zurück. Methods IndexOf(IDevFrameworkObject) Liefert den Index des übergebenen Objektes im View. IndexOf(guid) Liefert den Index der übergebenen Objekt-ID im View. ObjectRowIDOf(int) Ermittelt die rowID des enthaltnenen Records zum dem angegebenen Index. RedoSortAndFilter() Wendet die Sortierung und die Filter erneut an - z.B. nachdem Änderungen an der Collection vorgenommen wurden. ResetSortAndFilter() Setzt die Sortierung und die Filter zurück. Events EntriesSortedOrFiltered Mit diesem Event kann man die sortierte/gefilterte Liste der ObjectRowIDs anpassen."
  },
  "api/FS.Hosting.Shared.IProgressOwner.Add.html": {
    "href": "api/FS.Hosting.Shared.IProgressOwner.Add.html",
    "title": "Method Add",
    "keywords": "Method Add Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Add(FrameworkProgress) void Add(FrameworkProgress progress) Parameters progress FrameworkProgress"
  },
  "api/FS.Hosting.Shared.IProgressOwner.Cancel.html": {
    "href": "api/FS.Hosting.Shared.IProgressOwner.Cancel.html",
    "title": "Method Cancel",
    "keywords": "Method Cancel Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Cancel(string) void Cancel(string progressId) Parameters progressId string"
  },
  "api/FS.Hosting.Shared.IProgressOwner.Items.html": {
    "href": "api/FS.Hosting.Shared.IProgressOwner.Items.html",
    "title": "Method Items",
    "keywords": "Method Items Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Items() IEnumerable<FrameworkProgress> Items() Returns IEnumerable<FrameworkProgress>"
  },
  "api/FS.Hosting.Shared.IProgressOwner.Remove.html": {
    "href": "api/FS.Hosting.Shared.IProgressOwner.Remove.html",
    "title": "Method Remove",
    "keywords": "Method Remove Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Remove(FrameworkProgress) void Remove(FrameworkProgress progress) Parameters progress FrameworkProgress"
  },
  "api/FS.Hosting.Shared.IProgressOwner.html": {
    "href": "api/FS.Hosting.Shared.IProgressOwner.html",
    "title": "Interface IProgressOwner",
    "keywords": "Interface IProgressOwner Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Sammelt die Informationen zu laufenden FrameworkProgress im IGlobalObjects. public interface IProgressOwner Methods Add(FrameworkProgress) Cancel(string) Items() Remove(FrameworkProgress)"
  },
  "api/FS.Hosting.Shared.IStaticCache-2.ContainsKey.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.ContainsKey.html",
    "title": "Method ContainsKey",
    "keywords": "Method ContainsKey Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ContainsKey(TPK) Liefert true, wenn der übergebene Schlüssel in dem Cache bereits existiert; andernfalls false. bool ContainsKey(TPK pk) Parameters pk TPK Schlüssel Returns bool True, wenn existent; andernfalls false."
  },
  "api/FS.Hosting.Shared.IStaticCache-2.FillCollection.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.FillCollection.html",
    "title": "Method FillCollection",
    "keywords": "Method FillCollection Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll FillCollection<TColl>(TColl) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. int FillCollection<TColl>(TColl value) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl Returns int Type Parameters TColl FillCollection<TColl>(TColl, Func<TObj, bool>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Where-Bedingung wird vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. int FillCollection<TColl>(TColl value, Func<TObj, bool> where) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl where Func<TObj, bool> Returns int Type Parameters TColl FillCollection<TColl>(TColl, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache unter Berücksichtigung der angegebenen Sortierung. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Sortierung wird vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte durchgeführt. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. int FillCollection<TColl>(TColl value, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl orderBy Func<IEnumerable<TObj>, IEnumerable<TObj>> Returns int Type Parameters TColl Examples cdCurrencyCache.Get(this.Global).FillCollection(this.oCurrencyColl, (currencies) => currencies.OrderBy(currency => currency.sName). FillCollection<TColl>(TColl, Func<TObj, bool>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Leert und befüllt die übergebene Collection unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Where-Bedingung und die Sortierung werden vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. int FillCollection<TColl>(TColl value, Func<TObj, bool> where, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl where Func<TObj, bool> orderBy Func<IEnumerable<TObj>, IEnumerable<TObj>> Returns int Type Parameters TColl"
  },
  "api/FS.Hosting.Shared.IStaticCache-2.FillObject.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.FillObject.html",
    "title": "Method FillObject",
    "keywords": "Method FillObject Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll FillObject(TObj, TPK) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. int FillObject(TObj value, TPK pk) Parameters value TObj pk TPK Returns int FillObject(TObj, TPK, Func<TObj, bool>) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert und die übergebene Where-Einschränkung erfüllt, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. int FillObject(TObj value, TPK pk, Func<TObj, bool> where) Parameters value TObj pk TPK where Func<TObj, bool> Returns int FillObject(TObj, Func<TObj, bool>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. int FillObject(TObj value, Func<TObj, bool> where) Parameters value TObj where Func<TObj, bool> Returns int Remarks Hinweis: Wenn die Where-Einschränkung den PK enthält, sollte dieser explizit angegeben werden, also die Überladung dieser Methode mit PK genutzt werden, da diese performanter arbeiten kann. FillObject(TObj, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Füllt das Objekt mit dem ersten Datensatz in der angegebenen Sortierung, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. int FillObject(TObj value, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) Parameters value TObj orderBy Func<IEnumerable<TObj>, IEnumerable<TObj>> Returns int FillObject(TObj, Func<TObj, bool>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt (unter Berücksichtigung der angegebenen Sortierung), soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. int FillObject(TObj value, Func<TObj, bool> where, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) Parameters value TObj where Func<TObj, bool> orderBy Func<IEnumerable<TObj>, IEnumerable<TObj>> Returns int"
  },
  "api/FS.Hosting.Shared.IStaticCache-2.Global.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.Global.html",
    "title": "Property Global",
    "keywords": "Property Global Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Global GlobalObjects Global { get; } Property Value GlobalObjects"
  },
  "api/FS.Hosting.Shared.IStaticCache-2.Invalidate.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.Invalidate.html",
    "title": "Method Invalidate",
    "keywords": "Method Invalidate Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Invalidate() Markiert alle Daten des Caches als veraltet, sodass diese beim nächsten Zugriff neu von der Datenbank gelesen werden müssen. void Invalidate()"
  },
  "api/FS.Hosting.Shared.IStaticCache-2.Item.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.Item.html",
    "title": "Property this",
    "keywords": "Property this Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll this[TPK] Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird aus diesem ein Objekt erzeugt, daran die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen und das Objekt zurückgegeben, sonst null. TObj this[TPK pk] { get; } Parameters pk TPK Property Value TObj"
  },
  "api/FS.Hosting.Shared.IStaticCache-2.ToCollection.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.ToCollection.html",
    "title": "Method ToCollection",
    "keywords": "Method ToCollection Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ToCollection<TColl>() Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TColl ToCollection<TColl>() where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Returns TColl Type Parameters TColl ToCollection<TColl>(Func<TObj, bool>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TColl ToCollection<TColl>(Func<TObj, bool> where) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters where Func<TObj, bool> Returns TColl Type Parameters TColl ToCollection<TColl>(Func<IEnumerable<TObj>, IEnumerable<TObj>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TColl ToCollection<TColl>(Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters orderBy Func<IEnumerable<TObj>, IEnumerable<TObj>> Returns TColl Type Parameters TColl ToCollection<TColl>(Func<TObj, bool>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TColl ToCollection<TColl>(Func<TObj, bool> where, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters where Func<TObj, bool> orderBy Func<IEnumerable<TObj>, IEnumerable<TObj>> Returns TColl Type Parameters TColl"
  },
  "api/FS.Hosting.Shared.IStaticCache-2.TryGet.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.TryGet.html",
    "title": "Method TryGet",
    "keywords": "Method TryGet Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll TryGet(TPK, out TObj) Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird dazu ein Objekt erzeugt, daran die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen, das Objekt der out-Variable \"value\" zugeordnet und \"true\" zurück gegeben. Andernfalls ist \"value\" null und es wird \"false\" zurück gegeben. bool TryGet(TPK pk, out TObj value) Parameters pk TPK value TObj Returns bool"
  },
  "api/FS.Hosting.Shared.IStaticCache-2.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.html",
    "title": "Interface IStaticCache<TObj, TPK>",
    "keywords": "Interface IStaticCache<TObj, TPK> Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Schnittstelle eines statischen Caches für Elemente vom Typ TObj, die über den Primärschlüssel vom Typ TPK eindeutig identifiziert werden können. Der Cache implementiert IEnumerable<TObj>. Der Cache ist NICHT Thread-Save. Methoden dürfen nur aus dem Thread des übergebenen GlobalObjects heraus aufgerufen werden. public interface IStaticCache<TObj, TPK> : IEnumerable<TObj>, IEnumerable where TObj : IDevFrameworkObject Type Parameters TObj Interface-Typ der Components, welche vom Cache verwaltet werden. TPK Typ des/der Primärschlüssel-Properties. Bei mehreren Properties ValueTuple der Properties in alphabetischer Reihenfolge. Inherited Members IEnumerable<TObj>.GetEnumerator() Properties Global this[TPK] Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird aus diesem ein Objekt erzeugt, daran die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen und das Objekt zurückgegeben, sonst null. lngMaxAgeSeconds Zeitraum seit dem letzten befüllen des Caches aus der Datenbank in Sekunden, nach deren Verstreichen der Cache als veraltet gilt und daher bei lesenden Anfragen zunächst seine Daten erneut aus der Datenbank befüllt. Methods ContainsKey(TPK) Liefert true, wenn der übergebene Schlüssel in dem Cache bereits existiert; andernfalls false. FillCollection<TColl>(TColl) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache unter Berücksichtigung der angegebenen Sortierung. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Sortierung wird vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte durchgeführt. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<TObj, bool>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Where-Bedingung wird vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<TObj, bool>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Leert und befüllt die übergebene Collection unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Where-Bedingung und die Sortierung werden vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillObject(TObj, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Füllt das Objekt mit dem ersten Datensatz in der angegebenen Sortierung, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(TObj, Func<TObj, bool>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(TObj, Func<TObj, bool>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt (unter Berücksichtigung der angegebenen Sortierung), soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(TObj, TPK) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. FillObject(TObj, TPK, Func<TObj, bool>) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert und die übergebene Where-Einschränkung erfüllt, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. Invalidate() Markiert alle Daten des Caches als veraltet, sodass diese beim nächsten Zugriff neu von der Datenbank gelesen werden müssen. ToCollection<TColl>() Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<IEnumerable<TObj>, IEnumerable<TObj>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<TObj, bool>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<TObj, bool>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TryGet(TPK, out TObj) Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird dazu ein Objekt erzeugt, daran die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen, das Objekt der out-Variable \"value\" zugeordnet und \"true\" zurück gegeben. Andernfalls ist \"value\" null und es wird \"false\" zurück gegeben."
  },
  "api/FS.Hosting.Shared.IStaticCache-2.lngMaxAgeSeconds.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache-2.lngMaxAgeSeconds.html",
    "title": "Property lngMaxAgeSeconds",
    "keywords": "Property lngMaxAgeSeconds Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll lngMaxAgeSeconds Zeitraum seit dem letzten befüllen des Caches aus der Datenbank in Sekunden, nach deren Verstreichen der Cache als veraltet gilt und daher bei lesenden Anfragen zunächst seine Daten erneut aus der Datenbank befüllt. long lngMaxAgeSeconds { get; set; } Property Value long"
  },
  "api/FS.Hosting.Shared.IStaticCache.ContainsKey.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.ContainsKey.html",
    "title": "Method ContainsKey",
    "keywords": "Method ContainsKey Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ContainsKey(object) Liefert true, wenn der übergebene Schlüssel in dem Cache bereits existiert; andernfalls false. bool ContainsKey(object pk) Parameters pk object Schlüssel Returns bool True, wenn existent; andernfalls false."
  },
  "api/FS.Hosting.Shared.IStaticCache.FillCollection.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.FillCollection.html",
    "title": "Method FillCollection",
    "keywords": "Method FillCollection Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll FillCollection<TColl>(TColl) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. int FillCollection<TColl>(TColl value) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl Returns int Type Parameters TColl FillCollection<TColl>(TColl, Func<IDevFrameworkObject, bool>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Where-Bedingung wird vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. int FillCollection<TColl>(TColl value, Func<IDevFrameworkObject, bool> where) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl where Func<IDevFrameworkObject, bool> Returns int Type Parameters TColl FillCollection<TColl>(TColl, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache unter Berücksichtigung der angegebenen Sortierung. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Sortierung wird vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte durchgeführt. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. int FillCollection<TColl>(TColl value, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl orderBy Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> Returns int Type Parameters TColl Examples cdCurrencyCache.Get(this.Global).FillCollection(this.oCurrencyColl, (currencies) => currencies.OrderBy(currency => currency.sName). FillCollection<TColl>(TColl, Func<IDevFrameworkObject, bool>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Leert und befüllt die übergebene Collection unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Where-Bedingung und die Sortierung werden vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. int FillCollection<TColl>(TColl value, Func<IDevFrameworkObject, bool> where, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl where Func<IDevFrameworkObject, bool> orderBy Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> Returns int Type Parameters TColl"
  },
  "api/FS.Hosting.Shared.IStaticCache.FillObject.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.FillObject.html",
    "title": "Method FillObject",
    "keywords": "Method FillObject Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll FillObject(IDevFrameworkObject, object) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. int FillObject(IDevFrameworkObject value, object pk) Parameters value IDevFrameworkObject pk object Returns int FillObject(IDevFrameworkObject, object, Func<object, bool>) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert und die übergebene Where-Einschränkung erfüllt, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. int FillObject(IDevFrameworkObject value, object pk, Func<object, bool> where) Parameters value IDevFrameworkObject pk object where Func<object, bool> Returns int FillObject(IDevFrameworkObject, Func<IDevFrameworkObject, bool>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. int FillObject(IDevFrameworkObject value, Func<IDevFrameworkObject, bool> where) Parameters value IDevFrameworkObject where Func<IDevFrameworkObject, bool> Returns int Remarks Hinweis: Wenn die Where-Einschränkung den PK enthält, sollte dieser explizit angegeben werden, also die Überladung dieser Methode mit PK genutzt werden, da diese performanter arbeiten kann. FillObject(IDevFrameworkObject, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Füllt das Objekt mit dem ersten Datensatz in der angegebenen Sortierung, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. int FillObject(IDevFrameworkObject value, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) Parameters value IDevFrameworkObject orderBy Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> Returns int FillObject(IDevFrameworkObject, Func<IDevFrameworkObject, bool>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt (unter Berücksichtigung der angegebenen Sortierung), soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. int FillObject(IDevFrameworkObject value, Func<IDevFrameworkObject, bool> where, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) Parameters value IDevFrameworkObject where Func<IDevFrameworkObject, bool> orderBy Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> Returns int"
  },
  "api/FS.Hosting.Shared.IStaticCache.Global.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.Global.html",
    "title": "Property Global",
    "keywords": "Property Global Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Global GlobalObjects Global { get; } Property Value GlobalObjects"
  },
  "api/FS.Hosting.Shared.IStaticCache.Invalidate.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.Invalidate.html",
    "title": "Method Invalidate",
    "keywords": "Method Invalidate Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Invalidate() Markiert alle Daten des Caches als veraltet, sodass diese beim nächsten Zugriff neu von der Datenbank gelesen werden müssen. void Invalidate()"
  },
  "api/FS.Hosting.Shared.IStaticCache.Item.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.Item.html",
    "title": "Property this",
    "keywords": "Property this Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll this[object] Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird aus diesem ein Objekt erzeugt, daran die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen und das Objekt zurückgegeben, sonst null. IDevFrameworkObject this[object pk] { get; } Parameters pk object Property Value IDevFrameworkObject"
  },
  "api/FS.Hosting.Shared.IStaticCache.ToCollection.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.ToCollection.html",
    "title": "Method ToCollection",
    "keywords": "Method ToCollection Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll ToCollection<TColl>() Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TColl ToCollection<TColl>() where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Returns TColl Type Parameters TColl ToCollection<TColl>(Func<IDevFrameworkObject, bool>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TColl ToCollection<TColl>(Func<IDevFrameworkObject, bool> where) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters where Func<IDevFrameworkObject, bool> Returns TColl Type Parameters TColl ToCollection<TColl>(Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TColl ToCollection<TColl>(Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters orderBy Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> Returns TColl Type Parameters TColl ToCollection<TColl>(Func<IDevFrameworkObject, bool>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TColl ToCollection<TColl>(Func<IDevFrameworkObject, bool> where, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters where Func<IDevFrameworkObject, bool> orderBy Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> Returns TColl Type Parameters TColl"
  },
  "api/FS.Hosting.Shared.IStaticCache.TryGet.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.TryGet.html",
    "title": "Method TryGet",
    "keywords": "Method TryGet Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll TryGet(object, out IDevFrameworkObject) Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird dazu ein Objekt erzeugt, daran die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen, das Objekt der out-Variable \"value\" zugeordnet und \"true\" zurück gegeben. Andernfalls ist \"value\" null und es wird \"false\" zurück gegeben. bool TryGet(object pk, out IDevFrameworkObject value) Parameters pk object value IDevFrameworkObject Returns bool"
  },
  "api/FS.Hosting.Shared.IStaticCache.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.html",
    "title": "Interface IStaticCache",
    "keywords": "Interface IStaticCache Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Schnittstelle eines statischen, untypisierten Caches für Elemente vom Typ IDevFrameworkObject, die über einen untypisierten Primärschlüssel eindeutig identifiziert werden können. Der Cache implementiert IEnumerable (untypisiert). public interface IStaticCache : IEnumerable Inherited Members IEnumerable.GetEnumerator() Properties Global this[object] Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird aus diesem ein Objekt erzeugt, daran die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen und das Objekt zurückgegeben, sonst null. lngMaxAgeSeconds Zeitraum seit dem letzten befüllen des Caches aus der Datenbank in Sekunden, nach deren Verstreichen der Cache als veraltet gilt und daher bei lesenden Anfragen zunächst seine Daten erneut aus der Datenbank befüllt. Methods ContainsKey(object) Liefert true, wenn der übergebene Schlüssel in dem Cache bereits existiert; andernfalls false. FillCollection<TColl>(TColl) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<IDevFrameworkObject, bool>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Where-Bedingung wird vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<IDevFrameworkObject, bool>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Leert und befüllt die übergebene Collection unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Where-Bedingung und die Sortierung werden vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache unter Berücksichtigung der angegebenen Sortierung. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Die Sortierung wird vor dem Aufruf der Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() der Objekte durchgeführt. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillObject(IDevFrameworkObject, Func<IDevFrameworkObject, bool>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(IDevFrameworkObject, Func<IDevFrameworkObject, bool>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt (unter Berücksichtigung der angegebenen Sortierung), soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(IDevFrameworkObject, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Füllt das Objekt mit dem ersten Datensatz in der angegebenen Sortierung, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(IDevFrameworkObject, object) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. FillObject(IDevFrameworkObject, object, Func<object, bool>) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert und die übergebene Where-Einschränkung erfüllt, sonst mit einem leeren Objekt. Die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. Invalidate() Markiert alle Daten des Caches als veraltet, sodass diese beim nächsten Zugriff neu von der Datenbank gelesen werden müssen. ToCollection<TColl>() Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<IDevFrameworkObject, bool>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<IDevFrameworkObject, bool>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TryGet(object, out IDevFrameworkObject) Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird dazu ein Objekt erzeugt, daran die Methode FS.Hosting.Shared.DevFrameworkBaseObject.OnAfterLoad() aufgerufen, das Objekt der out-Variable \"value\" zugeordnet und \"true\" zurück gegeben. Andernfalls ist \"value\" null und es wird \"false\" zurück gegeben."
  },
  "api/FS.Hosting.Shared.IStaticCache.lngMaxAgeSeconds.html": {
    "href": "api/FS.Hosting.Shared.IStaticCache.lngMaxAgeSeconds.html",
    "title": "Property lngMaxAgeSeconds",
    "keywords": "Property lngMaxAgeSeconds Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll lngMaxAgeSeconds Zeitraum seit dem letzten befüllen des Caches aus der Datenbank in Sekunden, nach deren Verstreichen der Cache als veraltet gilt und daher bei lesenden Anfragen zunächst seine Daten erneut aus der Datenbank befüllt. long lngMaxAgeSeconds { get; set; } Property Value long"
  },
  "api/FS.Hosting.Shared.IStaticCacheObject.DummyComponent.html": {
    "href": "api/FS.Hosting.Shared.IStaticCacheObject.DummyComponent.html",
    "title": "Property DummyComponent",
    "keywords": "Property DummyComponent Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll DummyComponent Gibt ein leeres Objekt des Typs zurück, welcher instanziiert wird, wenn der Cache aus diesem IStaticCacheObject ein Object erstellt. Dieses Objekt dient ausschließlich zum Abfragen von Typ-spezifischen Informationen (wie z.B. Tabellennamen). Das Objekt darf nicht geändert werden. Es wird insbesondere nicht als Prototyp bei der Erstellung neuer Objekte verwendet! IDevFrameworkDataObject DummyComponent { get; } Property Value IDevFrameworkDataObject"
  },
  "api/FS.Hosting.Shared.IStaticCacheObject.TryGetPropertyValue.html": {
    "href": "api/FS.Hosting.Shared.IStaticCacheObject.TryGetPropertyValue.html",
    "title": "Method TryGetPropertyValue",
    "keywords": "Method TryGetPropertyValue Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll TryGetPropertyValue(string, out object) Füllt die out-Variable \"value\" mit dem Wert des Properties \"name\" und gibt \"true\" zurück, wenn das Property existiert und einen Datenbankbezug hat. Andernfalls ist \"value\" null und die Methode gibt \"false\" zurück. bool TryGetPropertyValue(string name, out object value) Parameters name string Name des angefragten Datenbank-Properties value object Ermittelter Wert des Properties Returns bool Existiert das Datenbank-Property"
  },
  "api/FS.Hosting.Shared.IStaticCacheObject.html": {
    "href": "api/FS.Hosting.Shared.IStaticCacheObject.html",
    "title": "Interface IStaticCacheObject",
    "keywords": "Interface IStaticCacheObject Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Stellt eine Schnittstelle zu einem Objekt im Cache dar. Über die Methode TryGetPropertyValue(string, out object) kann der Wert von Datenbank-Properties abgefragt werden. public interface IStaticCacheObject Properties DummyComponent Gibt ein leeres Objekt des Typs zurück, welcher instanziiert wird, wenn der Cache aus diesem IStaticCacheObject ein Object erstellt. Dieses Objekt dient ausschließlich zum Abfragen von Typ-spezifischen Informationen (wie z.B. Tabellennamen). Das Objekt darf nicht geändert werden. Es wird insbesondere nicht als Prototyp bei der Erstellung neuer Objekte verwendet! Methods TryGetPropertyValue(string, out object) Füllt die out-Variable \"value\" mit dem Wert des Properties \"name\" und gibt \"true\" zurück, wenn das Property existiert und einen Datenbankbezug hat. Andernfalls ist \"value\" null und die Methode gibt \"false\" zurück."
  },
  "api/FS.Hosting.Shared.ListSortOrder.html": {
    "href": "api/FS.Hosting.Shared.ListSortOrder.html",
    "title": "Enum ListSortOrder",
    "keywords": "Enum ListSortOrder Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Sortierar public enum ListSortOrder Fields Ascending = 1 Aufsteigend Descending = 2 Absteigend Inherit = 3 Erbt von Vater-Control Unsorted = 0 Unsortiert"
  },
  "api/FS.Hosting.Shared.ListViewHorizontalContentAlignment.html": {
    "href": "api/FS.Hosting.Shared.ListViewHorizontalContentAlignment.html",
    "title": "Enum ListViewHorizontalContentAlignment",
    "keywords": "Enum ListViewHorizontalContentAlignment Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum ListViewHorizontalContentAlignment Fields Center = 1 Fill = 3 Left = 0 Right = 2"
  },
  "api/FS.Hosting.Shared.ListViewItemArrangement.html": {
    "href": "api/FS.Hosting.Shared.ListViewItemArrangement.html",
    "title": "Enum ListViewItemArrangement",
    "keywords": "Enum ListViewItemArrangement Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum ListViewItemArrangement Fields List = 0 Wrap = 1"
  },
  "api/FS.Hosting.Shared.ListViewSelectionMode.html": {
    "href": "api/FS.Hosting.Shared.ListViewSelectionMode.html",
    "title": "Enum ListViewSelectionMode",
    "keywords": "Enum ListViewSelectionMode Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum ListViewSelectionMode Fields Multiple = 2 Es können mehrere ListItems gleichzeitig selektiert werden None = 0 ListItems können nicht selektiert werden. Single = 1 Es kann immer nur ein einziges ListItem gleichzeitig selektiert werden."
  },
  "api/FS.Hosting.Shared.ListViewSelectorPosition.html": {
    "href": "api/FS.Hosting.Shared.ListViewSelectorPosition.html",
    "title": "Enum ListViewSelectorPosition",
    "keywords": "Enum ListViewSelectorPosition Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum ListViewSelectorPosition Fields BottomLeft = 4 BottomRight = 5 MiddleLeft = 2 MiddleRight = 3 TopLeft = 0 TopRight = 1"
  },
  "api/FS.Hosting.Shared.ListViewTemplateVariableDataSourceOrigin.html": {
    "href": "api/FS.Hosting.Shared.ListViewTemplateVariableDataSourceOrigin.html",
    "title": "Enum ListViewTemplateVariableDataSourceOrigin",
    "keywords": "Enum ListViewTemplateVariableDataSourceOrigin Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum ListViewTemplateVariableDataSourceOrigin Fields Form = 1 ListItem = 0"
  },
  "api/FS.Hosting.Shared.ListViewVerticalContentAlignment.html": {
    "href": "api/FS.Hosting.Shared.ListViewVerticalContentAlignment.html",
    "title": "Enum ListViewVerticalContentAlignment",
    "keywords": "Enum ListViewVerticalContentAlignment Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum ListViewVerticalContentAlignment Fields Bottom = 2 Fill = 3 Middle = 1 Top = 0"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSDateTime.Now.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSDateTime.Now.html",
    "title": "Property Now",
    "keywords": "Property Now Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time. public static FSDateTime Now { get; } Property Value FSDateTime"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSDateTime.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSDateTime.html",
    "title": "Struct FSDateTime",
    "keywords": "Struct FSDateTime Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSDateTime : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen Properties Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time."
  },
  "api/FS.Hosting.Shared.Metadatatype.FSSystemGuid.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSSystemGuid.html",
    "title": "Struct FSSystemGuid",
    "keywords": "Struct FSSystemGuid Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSSystemGuid : IFSType, IComparable Implements IFSType IComparable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSbool.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSbool.html",
    "title": "Struct FSbool",
    "keywords": "Struct FSbool Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSbool : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSbyte.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSbyte.html",
    "title": "Struct FSbyte",
    "keywords": "Struct FSbyte Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSbyte : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSbyteArray.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSbyteArray.html",
    "title": "Struct FSbyteArray",
    "keywords": "Struct FSbyteArray Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSbyteArray : IFSType, IComparable Implements IFSType IComparable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSdecimal.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSdecimal.html",
    "title": "Struct FSdecimal",
    "keywords": "Struct FSdecimal Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSdecimal : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSdouble.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSdouble.html",
    "title": "Struct FSdouble",
    "keywords": "Struct FSdouble Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSdouble : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSfloat.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSfloat.html",
    "title": "Struct FSfloat",
    "keywords": "Struct FSfloat Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSfloat : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSint.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSint.html",
    "title": "Struct FSint",
    "keywords": "Struct FSint Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSint : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSlong.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSlong.html",
    "title": "Struct FSlong",
    "keywords": "Struct FSlong Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSlong : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSshort.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSshort.html",
    "title": "Struct FSshort",
    "keywords": "Struct FSshort Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSshort : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.FSstring.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.FSstring.html",
    "title": "Struct FSstring",
    "keywords": "Struct FSstring Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll [Serializable] [ComVisible(false)] [DataContract] public struct FSstring : IFSType, IComparable, IConvertible Implements IFSType IComparable IConvertible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Siehe auch: FS-Datentypen"
  },
  "api/FS.Hosting.Shared.Metadatatype.MLContainer.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.MLContainer.html",
    "title": "Class MLContainer",
    "keywords": "Class MLContainer Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll Ein Container, der alle nötigen Eigenschaften beinhaltet, um eine Spalte zu beschreiben. public class MLContainer Inheritance object MLContainer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Shared.Metadatatype.Nonable-1.HasValue.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.Nonable-1.HasValue.html",
    "title": "Property HasValue",
    "keywords": "Property HasValue Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll HasValue public bool HasValue { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.Metadatatype.Nonable-1.IsNone.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.Nonable-1.IsNone.html",
    "title": "Property IsNone",
    "keywords": "Property IsNone Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll IsNone public bool IsNone { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.Metadatatype.Nonable-1.Value.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.Nonable-1.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll Value public T Value { get; } Property Value T"
  },
  "api/FS.Hosting.Shared.Metadatatype.Nonable-1.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.Nonable-1.html",
    "title": "Struct Nonable<T>",
    "keywords": "Struct Nonable<T> Namespace FS.Hosting.Shared.Metadatatype Assembly FS.Hosting.Shared.dll public struct Nonable<T> where T : struct Type Parameters T Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties HasValue IsNone Value"
  },
  "api/FS.Hosting.Shared.Metadatatype.html": {
    "href": "api/FS.Hosting.Shared.Metadatatype.html",
    "title": "Namespace FS.Hosting.Shared.Metadatatype",
    "keywords": "Namespace FS.Hosting.Shared.Metadatatype Classes MLContainer Ein Container, der alle nötigen Eigenschaften beinhaltet, um eine Spalte zu beschreiben. Structs FSDateTime FSSystemGuid FSbool FSbyte FSbyteArray FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring Nonable<T>"
  },
  "api/FS.Hosting.Shared.MultiLanguage.DevMLString.GetKey.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.DevMLString.GetKey.html",
    "title": "Method GetKey",
    "keywords": "Method GetKey Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll GetKey() Liefert den zugeordneten MLKey. Ist kein MLKey zgeordnet, dann wird null zurückgegeben. public MLKey GetKey() Returns MLKey"
  },
  "api/FS.Hosting.Shared.MultiLanguage.DevMLString.GetString.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.DevMLString.GetString.html",
    "title": "Method GetString",
    "keywords": "Method GetString Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll GetString(IGlobalObjects, string) Ermittelt den Text in der übergebenen Sprache. Ist für diese Sprache kein Text vorhaden, wird string.Empty zurügkgegeben. Es erfolgt kein Fallback auf die Default-Sprache.. public string GetString(IGlobalObjects global, string iso) Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global iso string Der 2-stellige Sprach-Iso-Code - z.B. \"en\" Returns string Der gefundene Text oder string.Empty GetString(IGlobalObjects, IEnumerable<string>) Ermittelt den Text für die übergebene Sprach-Hierarchie. Dabei wird für jede Sprache eine Ermittlung wie in GetString(IGlobalObjects, string) vorgenommen und der erste gefundene Text zurückgegeben. Es erfolgt kein Fallback auf die Default-Sprache. public string GetString(IGlobalObjects global, IEnumerable<string> languageHierarchy) Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global languageHierarchy IEnumerable<string> Enumeration mit 2-Selligen Sprach-Iso-Codes. Returns string Der gefundene Text oder string.Empty GetString(IGlobalObjects) Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy). Diese beinhaltet immer einen Fallback auf die Default-Sprache. public string GetString(IGlobalObjects global) Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global Returns string Der gefundene Text oder string.Empty"
  },
  "api/FS.Hosting.Shared.MultiLanguage.DevMLString.HasKey.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.DevMLString.HasKey.html",
    "title": "Property HasKey",
    "keywords": "Property HasKey Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll HasKey Gibt zurück, ob dem DevMLString ein MLKey zugeordnet ist. public bool HasKey { get; } Property Value bool"
  },
  "api/FS.Hosting.Shared.MultiLanguage.DevMLString.Item.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.DevMLString.Item.html",
    "title": "Property this",
    "keywords": "Property this Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll this[IGlobalObjects] Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy). Diese beinhaltet immer einen Fallback auf die Default-Sprache. public string this[IGlobalObjects global] { get; } Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global Property Value string Der gefundene Text oder string.Empty"
  },
  "api/FS.Hosting.Shared.MultiLanguage.DevMLString.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.DevMLString.html",
    "title": "Class DevMLString",
    "keywords": "Class DevMLString Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll Diese Klasse beschreibt einen mehrsprachigen String. Darüber können die in den Designern und im Wörterbuch gesetzten Texte zur Laufzeit ermittelt werden. public class DevMLString Inheritance object DevMLString Derived DevMLStringWithGlobal Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties HasKey Gibt zurück, ob dem DevMLString ein MLKey zugeordnet ist. this[IGlobalObjects] Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy). Diese beinhaltet immer einen Fallback auf die Default-Sprache. Methods GetKey() Liefert den zugeordneten MLKey. Ist kein MLKey zgeordnet, dann wird null zurückgegeben. GetString(IGlobalObjects) Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy). Diese beinhaltet immer einen Fallback auf die Default-Sprache. GetString(IGlobalObjects, IEnumerable<string>) Ermittelt den Text für die übergebene Sprach-Hierarchie. Dabei wird für jede Sprache eine Ermittlung wie in GetString(IGlobalObjects, string) vorgenommen und der erste gefundene Text zurückgegeben. Es erfolgt kein Fallback auf die Default-Sprache. GetString(IGlobalObjects, string) Ermittelt den Text in der übergebenen Sprache. Ist für diese Sprache kein Text vorhaden, wird string.Empty zurügkgegeben. Es erfolgt kein Fallback auf die Default-Sprache.."
  },
  "api/FS.Hosting.Shared.MultiLanguage.DevMLStringWithGlobal.GetString.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.DevMLStringWithGlobal.GetString.html",
    "title": "Method GetString",
    "keywords": "Method GetString Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll GetString(string) Gibt den Text in der gewünschten Sprache zurück. public override string GetString(string iso) Parameters iso string Returns string Remarks Note Ein Aufruf mit this.Global.SelectedLanguage ist zu vermeiden. Stattdessen sollte dafür GetString(IGlobalObjects) verwendet werden."
  },
  "api/FS.Hosting.Shared.MultiLanguage.DevMLStringWithGlobal.Item.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.DevMLStringWithGlobal.Item.html",
    "title": "Property this",
    "keywords": "Property this Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll this[string] Gibt den Text in der gewünschten Sprache zurück. public override string this[string iso] { get; } Parameters iso string Property Value string Remarks Note Ein Aufruf mit this.Global.SelectedLanguage ist zu vermeiden. Stattdessen sollte dafür FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.Item(FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects) verwendet werden."
  },
  "api/FS.Hosting.Shared.MultiLanguage.DevMLStringWithGlobal.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.DevMLStringWithGlobal.html",
    "title": "Class DevMLStringWithGlobal",
    "keywords": "Class DevMLStringWithGlobal Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll Eine Spezialisierung von DevMLString, die in in den TextCollection-Einträgen (IDevFrameworkObjectMLString) verwendet wird. Über den Eintrag besitzt diese Instanz das GlobalObject (this.Global). public class DevMLStringWithGlobal : DevMLString Inheritance object DevMLString DevMLStringWithGlobal Inherited Members DevMLString.GetKey() DevMLString.HasKey DevMLString.GetString(IGlobalObjects, string) DevMLString.GetString(IGlobalObjects, IEnumerable<string>) DevMLString.GetString(IGlobalObjects) DevMLString.this[IGlobalObjects] object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties this[string] Gibt den Text in der gewünschten Sprache zurück. Methods GetString(string) Gibt den Text in der gewünschten Sprache zurück."
  },
  "api/FS.Hosting.Shared.MultiLanguage.MLUtil.FormatMLKeyText.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.MLUtil.FormatMLKeyText.html",
    "title": "Method FormatMLKeyText",
    "keywords": "Method FormatMLKeyText Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll FormatMLKeyText(MLKey, params object[]) Gibt ein MLKeyText-Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String.Format(string, params object[]) mit den übergebenen Argumenten ausgeführt. public static MLKeyText FormatMLKeyText(MLKey mlkey, params object[] args) Parameters mlkey MLKey MLKey aus dem Wörterbuch. args object[] Returns MLKeyText Examples Diese Methode wird z.B. für die Code-Messages benutzt: // FSCodeMessage: Please specify {0} throw new FrameworkApplicationException(MLUtil.FormatMLKeyText(MLKeys.MSG_24979a3d247546318dc673c5501d3b15, this.sName), 0); Remarks Für die Formatierung der übergebenen Argumente wird die Client-Culture (FS.Hosting.Shared.GlobalObj.cGlobalBase.GetClientCulture()) verwendet. See Also GetClientCulture() FormatMLKeyText(IFormatProvider, MLKey, params object[]) Gibt ein MLKeyText-Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String.Format(string, params object[]) mit den übergebenen Argumenten ausgeführt. public static MLKeyText FormatMLKeyText(IFormatProvider culture, MLKey mlkey, params object[] args) Parameters culture IFormatProvider Die zu verwendende Culture. Bei null erfolgt ein Fallback auf die Client-Culture mlkey MLKey MLKey aus dem Wörterbuch. args object[] Returns MLKeyText Remarks Für die Formatierung der übergebenen Argumente wird die Client-Culture (FS.Hosting.Shared.GlobalObj.cGlobalBase.GetClientCulture()) verwendet."
  },
  "api/FS.Hosting.Shared.MultiLanguage.MLUtil.FormatMLText.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.MLUtil.FormatMLText.html",
    "title": "Method FormatMLText",
    "keywords": "Method FormatMLText Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll FormatMLText(MLKey, params object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String.Format(string, params object[]) mit den übergebenen Argumenten ausgeführt. public static string FormatMLText(MLKey mlkey, params object[] args) Parameters mlkey MLKey MLKey aus dem Wörterbuch args object[] Returns string Formatierter Text Examples FSstring sFormattedText = MLUtil.FormatMLText( MLKeys.LBL_MitFormat, \"Text1\", lngAmount ); Remarks Für die Formatierung der übergebenen Argumente wird die Client-Culture (FS.Hosting.Shared.GlobalObj.cGlobalBase.GetClientCulture()) verwendet. See Also GetClientCulture() FormatMLText(IFormatProvider, MLKey, params object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String.Format(string, params object[]) mit den übergebenen Arumenten ausgeführt. public static string FormatMLText(IFormatProvider culture, MLKey mlkey, params object[] args) Parameters culture IFormatProvider Die zu verwendende Culture. Bei null erfolgt ein Fallback auf die Client-Culture mlkey MLKey MLKey aus dem Wörterbuch args object[] Returns string Remarks Für die Formatierung der übergebenen Argumente wird die Client-Culture (FS.Hosting.Shared.GlobalObj.cGlobalBase.GetClientCulture()) verwendet."
  },
  "api/FS.Hosting.Shared.MultiLanguage.MLUtil.FormatText.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.MLUtil.FormatText.html",
    "title": "Method FormatText",
    "keywords": "Method FormatText Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll FormatText<T>(int, params object[]) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück und formatiert diesen mit string.Format(string, params object[]). public static string FormatText<T>(int id, params object[] args) where T : IDevFrameworkObjectTextColl Parameters id int Die ID des Texcollection-Eintrages args object[] Argumente für die Formatierung Returns string Der formatierte Text. null, wenn der Eintrag nicht gefunden wurde. Type Parameters T Interface- oder Klassen-Typ einer Text-Collection Remarks Für die Formatierung der übergebenen Argumente wird die Client-Culture (FS.Hosting.Shared.GlobalObj.cGlobalBase.GetClientCulture()) verwendet. FormatText<T>(IFormatProvider, int, params object[]) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück und formatiert diesen mit string.Format(string, params object[]). public static string FormatText<T>(IFormatProvider culture, int id, params object[] args) where T : IDevFrameworkObjectTextColl Parameters culture IFormatProvider Mit dieser Culture erfolgt Formatierung der übergebenen Argumente. Wird null übergeben, zieht ein Fallback auf die Client-Culture (FS.Hosting.Shared.GlobalObj.cGlobalBase.GetClientCulture()). id int Die ID des Texcollection-Eintrages args object[] Argumente für die Formatierung Returns string Der formatierte Text. null, wenn der Eintrag nicht gefunden wurde. Type Parameters T Interface- oder Klassen-Typ einer Text-Collection FormatText(string, int, params object[]) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück und formatiert diesen mit string.Format(string, params object[]). public static string FormatText(string typeFullName, int id, params object[] args) Parameters typeFullName string Fullname des Interface- oder Klassen-Typs einer Text-Collection id int Die ID des Texcollection-Eintrages args object[] Argumente für die Formatierung Returns string Der formatierte Text. null, wenn der Eintrag nicht gefunden wurde. Remarks Als FormatProvider wird FS.Hosting.Shared.GlobalObj.cGlobalBase.GetClientCulture() verwendet. FormatText(string, IFormatProvider, int, params object[]) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück und formatiert diesen mit string.Format(string, params object[]). public static string FormatText(string typeFullName, IFormatProvider culture, int id, params object[] args) Parameters typeFullName string Fullname des Interface- oder Klassen-Typs einer Text-Collection culture IFormatProvider Mit dieser Culture erfolgt Formatierung der übergebenen Argumente. Wird null übergeben, zieht ein Fallback auf die Client-Culture (FS.Hosting.Shared.GlobalObj.cGlobalBase.GetClientCulture()). id int Die ID des Texcollection-Eintrages args object[] Argumente für die Formatierung Returns string Der formatierte Text. null, wenn der Eintrag nicht gefunden wurde. Remarks Als FormatProvider wird FS.Hosting.Shared.GlobalObj.cGlobalBase.GetClientCulture() verwendet."
  },
  "api/FS.Hosting.Shared.MultiLanguage.MLUtil.GetMLKeyText.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.MLUtil.GetMLKeyText.html",
    "title": "Method GetMLKeyText",
    "keywords": "Method GetMLKeyText Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll GetMLKeyText(MLKey) Diese Methode gibt ein MLKeyText-Objekt zurück, welches neben dem Text auch den übergebenen MLKey beinhaltet. Das kann hilfreich sein, wenn der MLKey interessant ist, um ihn z.B. als Fehler-Code zu verwenden. public static MLKeyText GetMLKeyText(MLKey mlkey) Parameters mlkey MLKey Returns MLKeyText Examples Diese Methode wird z.B. für die Code-Messages benutzt: // FSCodeMessage: Please select only one article. throw new FrameworkApplicationException(MLUtil.GetMLKeyText(MLKeys.MSG_1b6b9bea43304e2082d1162d75d9e317), 0);"
  },
  "api/FS.Hosting.Shared.MultiLanguage.MLUtil.GetMLText.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.MLUtil.GetMLText.html",
    "title": "Method GetMLText",
    "keywords": "Method GetMLText Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll GetMLText(MLKey) Ermittelt für den übergebenen MLKey den Text. Es wird die aktuell in der Session gesetzte Sprach-Hierarchie verwendet. public static string GetMLText(MLKey mlkey) Parameters mlkey MLKey Returns string Examples FSstring sArticleLabel = MLUtil.GetMLText( MLKeys.LBL_Article ); GetMLText(MLKey, string) Diese Methode ermittelt für den übergebenen MLKey den Text für die übergebene Sprache. Es erfolgt kein Fallback auf eine andere Sprache. public static string GetMLText(MLKey mlkey, string iso = null) Parameters mlkey MLKey iso string Iso-Code der Sprache. Returns string Examples FSString sAmountEn = MLUtil.GetMLText( MLKeys.LBL_Amount, \"en\" );"
  },
  "api/FS.Hosting.Shared.MultiLanguage.MLUtil.GetOnID.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.MLUtil.GetOnID.html",
    "title": "Method GetOnID",
    "keywords": "Method GetOnID Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll GetOnID<T>(int) Liefert für eine TextCollection den MLText mit der übergebenen id zurück. public static IDevFrameworkObjectMLString GetOnID<T>(int id) where T : IDevFrameworkObjectTextColl Parameters id int Die ID des Texcollection-Eintrages Returns IDevFrameworkObjectMLString Der Text. Wenn die id nicht gefunden wird, wird null zurückgegeben. Type Parameters T Interface- oder Klassen-Typ einer Text-Collection GetOnID(string, int) Liefert für eine TextCollection den MLText mit der übergebenen id zurück. public static IDevFrameworkObjectMLString GetOnID(string typeFullName, int id) Parameters typeFullName string Fullname des Interface- oder Klassen-Typs einer Text-Collection id int Die ID des Texcollection-Eintrages Returns IDevFrameworkObjectMLString Der Text. Wenn die id nicht gefunden wird, wird null zurückgegeben."
  },
  "api/FS.Hosting.Shared.MultiLanguage.MLUtil.GetText.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.MLUtil.GetText.html",
    "title": "Method GetText",
    "keywords": "Method GetText Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll GetText<T>(int, string) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück. public static string GetText<T>(int id, string defaultText = \"\") where T : IDevFrameworkObjectTextColl Parameters id int Die ID des Texcollection-Eintrages defaultText string Fallback-Text, falls die id nicht gefunden wird. Returns string Text in aktueller Sprache. Type Parameters T Interface- oder Klassen-Typ einer Text-Collection GetText(string, int, string) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück. public static string GetText(string typeFullName, int id, string defaultText = \"\") Parameters typeFullName string Fullname des Interface- oder Klassen-Typs einer Text-Collection id int Die ID des Texcollection-Eintrages defaultText string Fallback-Text, falls die id nicht gefunden wird. Returns string Text in aktueller Sprache."
  },
  "api/FS.Hosting.Shared.MultiLanguage.MLUtil.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.MLUtil.html",
    "title": "Class MLUtil",
    "keywords": "Class MLUtil Namespace FS.Hosting.Shared.MultiLanguage Assembly FS.Hosting.Shared.dll public static class MLUtil Inheritance object MLUtil Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods FormatMLKeyText(MLKey, params object[]) Gibt ein MLKeyText-Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String.Format(string, params object[]) mit den übergebenen Argumenten ausgeführt. FormatMLKeyText(IFormatProvider, MLKey, params object[]) Gibt ein MLKeyText-Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String.Format(string, params object[]) mit den übergebenen Argumenten ausgeführt. FormatMLText(MLKey, params object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String.Format(string, params object[]) mit den übergebenen Argumenten ausgeführt. FormatMLText(IFormatProvider, MLKey, params object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String.Format(string, params object[]) mit den übergebenen Arumenten ausgeführt. FormatText(string, IFormatProvider, int, params object[]) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück und formatiert diesen mit string.Format(string, params object[]). FormatText(string, int, params object[]) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück und formatiert diesen mit string.Format(string, params object[]). FormatText<T>(IFormatProvider, int, params object[]) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück und formatiert diesen mit string.Format(string, params object[]). FormatText<T>(int, params object[]) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück und formatiert diesen mit string.Format(string, params object[]). GetMLKeyText(MLKey) Diese Methode gibt ein MLKeyText-Objekt zurück, welches neben dem Text auch den übergebenen MLKey beinhaltet. Das kann hilfreich sein, wenn der MLKey interessant ist, um ihn z.B. als Fehler-Code zu verwenden. GetMLText(MLKey) Ermittelt für den übergebenen MLKey den Text. Es wird die aktuell in der Session gesetzte Sprach-Hierarchie verwendet. GetMLText(MLKey, string) Diese Methode ermittelt für den übergebenen MLKey den Text für die übergebene Sprache. Es erfolgt kein Fallback auf eine andere Sprache. GetOnID(string, int) Liefert für eine TextCollection den MLText mit der übergebenen id zurück. GetOnID<T>(int) Liefert für eine TextCollection den MLText mit der übergebenen id zurück. GetText(string, int, string) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück. GetText<T>(int, string) Liefert für eine TextCollection den Text mit der übergebenen id zurück in der aktuellen Sprache zurück."
  },
  "api/FS.Hosting.Shared.MultiLanguage.html": {
    "href": "api/FS.Hosting.Shared.MultiLanguage.html",
    "title": "Namespace FS.Hosting.Shared.MultiLanguage",
    "keywords": "Namespace FS.Hosting.Shared.MultiLanguage Classes DevMLString Diese Klasse beschreibt einen mehrsprachigen String. Darüber können die in den Designern und im Wörterbuch gesetzten Texte zur Laufzeit ermittelt werden. DevMLStringWithGlobal Eine Spezialisierung von DevMLString, die in in den TextCollection-Einträgen (IDevFrameworkObjectMLString) verwendet wird. Über den Eintrag besitzt diese Instanz das GlobalObject (this.Global). MLUtil"
  },
  "api/FS.Hosting.Shared.PictureScaleMode.html": {
    "href": "api/FS.Hosting.Shared.PictureScaleMode.html",
    "title": "Enum PictureScaleMode",
    "keywords": "Enum PictureScaleMode Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll used for Picture.ScaleMode public enum PictureScaleMode Fields Center = 1 In der originalen Größe zentrieren. Inherit = -1 Use editor type from base, if base != null, otherwise default editor type Normal = 6 Bild oben links zeichnen (ohne Anpassung). ScaleDown = 4 ScaleDown Bild, wenn es zu groß ist, proportional herunter skalieren. Kleinere Bilder behalten ihre Größe. ScaleDownCenter = 5 Bild, wenn es zu groß ist, proportional herunter skalieren. Kleinere Bilder behalten ihre Größe. Bild in Control zentrieren. Stretch = 0 Bild mit beiden Achsen auf die Größe des Controls skalieren. Das ist das Standardverhalten. Zoom = 2 Bild proportional vergrößern oder verkleinern, so dass es gerade so in das Control passt. ZoomCenter = 3 ZoomCenter Bild proportional vergrößern oder verkleinern, so dass es gerade so in das Control passt und im Control zentrieren."
  },
  "api/FS.Hosting.Shared.PropertyNotFoundException.-ctor.html": {
    "href": "api/FS.Hosting.Shared.PropertyNotFoundException.-ctor.html",
    "title": "Constructor PropertyNotFoundException",
    "keywords": "Constructor PropertyNotFoundException Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll PropertyNotFoundException(string) Exception wird ausgelöst, wenn ein Property angefordert wird, welches nicht existiert, z.B. über die Methode IDevFrameworkBaseObject.GetProperty(). public PropertyNotFoundException(string info) Parameters info string PropertyNotFoundException(string, Exception) public PropertyNotFoundException(string info, Exception ex) Parameters info string ex Exception"
  },
  "api/FS.Hosting.Shared.PropertyNotFoundException.html": {
    "href": "api/FS.Hosting.Shared.PropertyNotFoundException.html",
    "title": "Class PropertyNotFoundException",
    "keywords": "Class PropertyNotFoundException Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Diese Exception wir geworfen, wenn bei einem Property-Zugriff über die Methode IDevFrameworkBaseObject.GetProperty() der Property-Name nicht gefunden wurde. [Serializable] public class PropertyNotFoundException : FrameworkException, ISerializable Inheritance object Exception FrameworkException PropertyNotFoundException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors PropertyNotFoundException(string) Exception wird ausgelöst, wenn ein Property angefordert wird, welches nicht existiert, z.B. über die Methode IDevFrameworkBaseObject.GetProperty(). PropertyNotFoundException(string, Exception)"
  },
  "api/FS.Hosting.Shared.Reporting.ExportFormat.html": {
    "href": "api/FS.Hosting.Shared.Reporting.ExportFormat.html",
    "title": "Enum ExportFormat",
    "keywords": "Enum ExportFormat Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Format für den Export eines ReportDocument. public enum ExportFormat Fields Excel = 4 Html32 = 6 Html40 = 7 PDF = 5 ReportFileWithData = 1 Es wird eine Report-Datei inklusive Daten erzeugt. Je nach Ausgangs-Format wird eine Crystal-Report-Datei (Endung CrystalReportFileExtension) oder eine DevExpress-Report-Datei (Endung DevExpressWithDataFileExtension) erzeugt. RichText = 2 Word = 3"
  },
  "api/FS.Hosting.Shared.Reporting.Orientation.html": {
    "href": "api/FS.Hosting.Shared.Reporting.Orientation.html",
    "title": "Enum Orientation",
    "keywords": "Enum Orientation Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll public enum Orientation Fields Default = 0 Landscape = 2 Querformat Portrait = 1 Hochformat"
  },
  "api/FS.Hosting.Shared.Reporting.PrintQueue.Delete.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintQueue.Delete.html",
    "title": "Method Delete",
    "keywords": "Method Delete Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Delete(IGlobalObjects, guid) Diese Methode löscht den Datensatz aus der Print-Queue. Handelt es sich dabei um den letzten Eintrag für eine Transaktion wird diese ebenfalls mit gelöscht. Der Status des Print-Job muss 3 (grdruckt) oder 4 (Fehler) sein. public static void Delete(IGlobalObjects global, guid printJobId) Parameters global IGlobalObjects printJobId guid Examples if (PrintQueue.GetStatus(this.Global, guid(sPrintJobID)) == 3 ) { PrintQueue.Delete(this.Global, new guid(sPrintJobID)); }"
  },
  "api/FS.Hosting.Shared.Reporting.PrintQueue.GetDocumentOut.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintQueue.GetDocumentOut.html",
    "title": "Method GetDocumentOut",
    "keywords": "Method GetDocumentOut Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll GetDocumentOut(IGlobalObjects, guid) Diese Methode liefert das herausgeschriebene Dokument. Dazu muss der Druck mit dem Kommando Out ausgeführt worden sein und der Status des Druck-Jobs muss 3 (Gedruckt) sein. public static byte[] GetDocumentOut(IGlobalObjects global, guid printJobId) Parameters global IGlobalObjects printJobId guid Returns byte[] Examples byte[] pdfBytes = PrintQueue.GetDocumentOut(this.Global, new guid(sPrintJobID));"
  },
  "api/FS.Hosting.Shared.Reporting.PrintQueue.GetState.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintQueue.GetState.html",
    "title": "Method GetState",
    "keywords": "Method GetState Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll GetState(IGlobalObjects, guid) Diese Methode liefert den Status des Druckauftrags mit der übergebenen PrintJobID zurück.Dabei wird der Status der den Druckauftrag umklammernden Transaktion zurückgegeben. public static int GetState(IGlobalObjects global, guid printJobId) Parameters global IGlobalObjects printJobId guid Eindeutige ID des Print-Jobs Returns int -1 = PrintJob not found 0 = Transaktion ist offen. Es können weitere Druckaufträge zur Transaktion hinzugefügt werden. 1 = Transaktion ist bereit zu drucken. Alle Druckaufträge sind hinzugefügt und der Printserver kann mit dem Druck beginnen. 2 = Der Druck läuft gerade. 3 = Druckauftrag ist abgeschlossen. 4 = Der Druckauftrag wurde mit einem Fehler beendet. Examples int Status = PrintQueue.GetState(this.Global, new guid(sPrintJobID));"
  },
  "api/FS.Hosting.Shared.Reporting.PrintQueue.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintQueue.html",
    "title": "Class PrintQueue",
    "keywords": "Class PrintQueue Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Diese Klasse bietet Methoden an, mit denen die Print-Queue ausgewertet und bearbeitet werden kann. public class PrintQueue Inheritance object PrintQueue Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Delete(IGlobalObjects, guid) Diese Methode löscht den Datensatz aus der Print-Queue. Handelt es sich dabei um den letzten Eintrag für eine Transaktion wird diese ebenfalls mit gelöscht. Der Status des Print-Job muss 3 (grdruckt) oder 4 (Fehler) sein. GetDocumentOut(IGlobalObjects, guid) Diese Methode liefert das herausgeschriebene Dokument. Dazu muss der Druck mit dem Kommando Out ausgeführt worden sein und der Status des Druck-Jobs muss 3 (Gedruckt) sein. GetState(IGlobalObjects, guid) Diese Methode liefert den Status des Druckauftrags mit der übergebenen PrintJobID zurück.Dabei wird der Status der den Druckauftrag umklammernden Transaktion zurückgegeben."
  },
  "api/FS.Hosting.Shared.Reporting.PrintServer.CommitTransaction.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintServer.CommitTransaction.html",
    "title": "Method CommitTransaction",
    "keywords": "Method CommitTransaction Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll CommitTransaction(guid) Bestätigt die Print-Transaktion. public void CommitTransaction(guid transactionId) Parameters transactionId guid ID der Print-Transaktion. See Also CreateTransaction()"
  },
  "api/FS.Hosting.Shared.Reporting.PrintServer.CreateTransaction.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintServer.CreateTransaction.html",
    "title": "Method CreateTransaction",
    "keywords": "Method CreateTransaction Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll CreateTransaction() Erzeugt eine neue Print-Transaktion. public guid CreateTransaction() Returns guid Die ID der Transaktion. Diese muss in weitere Methoden übergeben werden. Examples guid transactionID = server.CreateTransaction(); try { // einer oder mehrere Ausdrucke // ... server.CommitTransaction(transactionID); } catch { server.RollbackTransaction(transactionID); See Also CommitTransaction(guid) RollbackTransaction(guid)"
  },
  "api/FS.Hosting.Shared.Reporting.PrintServer.GetPrintServers.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintServer.GetPrintServers.html",
    "title": "Method GetPrintServers",
    "keywords": "Method GetPrintServers Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll GetPrintServers(IGlobalObjects) Liefert eine Liste der im Runtime-Datenbank registrierten Print-Server zurück. public static List<PrintServer> GetPrintServers(IGlobalObjects global) Parameters global IGlobalObjects GlobalObject für die Verbinding zur Runtime-Datenbank. Returns List<PrintServer> Remarks Bei jedem Aufruf dieser Methode wird eine neue Liste aus der Runtime-Datenbank gelesen."
  },
  "api/FS.Hosting.Shared.Reporting.PrintServer.GetPrinters.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintServer.GetPrinters.html",
    "title": "Method GetPrinters",
    "keywords": "Method GetPrinters Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll GetPrinters(IGlobalObjects, guid) Liefert eine Liste mit Druckern des Print-Servers, die in der Runtime-Datenbank registriert sind. Als gelöscht markierte Drucker werden nicht zurückgegeben. public static List<Printer> GetPrinters(IGlobalObjects global, guid printServerId) Parameters global IGlobalObjects GlobalObject für die Verbinding zur Runtime-Datenbank. printServerId guid ID des PrintServers. Returns List<Printer> GetPrinters() Liefert eine Liste mit Druckern des Print-Servers, die in der Runtime-Datenbank registriert sind. Als gelöscht markierte Drucker werden nicht zurückgegeben. public List<Printer> GetPrinters() Returns List<Printer>"
  },
  "api/FS.Hosting.Shared.Reporting.PrintServer.RollbackTransaction.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintServer.RollbackTransaction.html",
    "title": "Method RollbackTransaction",
    "keywords": "Method RollbackTransaction Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll RollbackTransaction(guid) Rollt die Print-Transaktion zurück. public void RollbackTransaction(guid transactionId) Parameters transactionId guid ID der Print-Transaktion. See Also CreateTransaction()"
  },
  "api/FS.Hosting.Shared.Reporting.PrintServer.html": {
    "href": "api/FS.Hosting.Shared.Reporting.PrintServer.html",
    "title": "Class PrintServer",
    "keywords": "Class PrintServer Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Diese Klasse dient dazu die bestehenden Print-Server zu ermitteln und Transaktionen an einem Print-Server zu steuern. public class PrintServer Inheritance object PrintServer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CommitTransaction(guid) Bestätigt die Print-Transaktion. CreateTransaction() Erzeugt eine neue Print-Transaktion. GetPrintServers(IGlobalObjects) Liefert eine Liste der im Runtime-Datenbank registrierten Print-Server zurück. GetPrinters() Liefert eine Liste mit Druckern des Print-Servers, die in der Runtime-Datenbank registriert sind. Als gelöscht markierte Drucker werden nicht zurückgegeben. GetPrinters(IGlobalObjects, guid) Liefert eine Liste mit Druckern des Print-Servers, die in der Runtime-Datenbank registriert sind. Als gelöscht markierte Drucker werden nicht zurückgegeben. RollbackTransaction(guid) Rollt die Print-Transaktion zurück."
  },
  "api/FS.Hosting.Shared.Reporting.Printer.Global.html": {
    "href": "api/FS.Hosting.Shared.Reporting.Printer.Global.html",
    "title": "Property Global",
    "keywords": "Property Global Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Global Global Object of the Application. public IGlobalObjects Global { get; } Property Value IGlobalObjects Remarks Filled with the Constructor."
  },
  "api/FS.Hosting.Shared.Reporting.Printer.Name.html": {
    "href": "api/FS.Hosting.Shared.Reporting.Printer.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Name The Name of the Printer. public string Name { get; } Property Value string Remarks Filled with the Constructor."
  },
  "api/FS.Hosting.Shared.Reporting.Printer.Path.html": {
    "href": "api/FS.Hosting.Shared.Reporting.Printer.Path.html",
    "title": "Property Path",
    "keywords": "Property Path Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Path The physical path of the Printer from the view of the Server. public string Path { get; } Property Value string Remarks Filled with the Constructor."
  },
  "api/FS.Hosting.Shared.Reporting.Printer.PrinterId.html": {
    "href": "api/FS.Hosting.Shared.Reporting.Printer.PrinterId.html",
    "title": "Property PrinterId",
    "keywords": "Property PrinterId Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll PrinterId The UniqueId of the Printer. You can use that Id to print a Report to that Printer. public guid PrinterId { get; } Property Value guid Remarks Filled with the Constructor."
  },
  "api/FS.Hosting.Shared.Reporting.Printer.html": {
    "href": "api/FS.Hosting.Shared.Reporting.Printer.html",
    "title": "Class Printer",
    "keywords": "Class Printer Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Represents a Printer from a PrintServer. All Properties are filled with the Constructor. public class Printer Inheritance object Printer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Global Global Object of the Application. Name The Name of the Printer. Path The physical path of the Printer from the view of the Server. PrinterId The UniqueId of the Printer. You can use that Id to print a Report to that Printer."
  },
  "api/FS.Hosting.Shared.Reporting.ReportConstants.CrystalReportFileExtension.html": {
    "href": "api/FS.Hosting.Shared.Reporting.ReportConstants.CrystalReportFileExtension.html",
    "title": "Field CrystalReportFileExtension",
    "keywords": "Field CrystalReportFileExtension Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Liefert die von FS.Hosting.Shared.Reporting.ReportingSoftware.CrystalReports genutzte Dateiendung für Report-Dateien. [Obsolete(\"Crystal Reports is no longer supported\")] public const string CrystalReportFileExtension = \".rpt\" Returns string Liefert die von genutzte Dateiendung für Report-Dateien."
  },
  "api/FS.Hosting.Shared.Reporting.ReportConstants.DevExpressLayoutFileExtension.html": {
    "href": "api/FS.Hosting.Shared.Reporting.ReportConstants.DevExpressLayoutFileExtension.html",
    "title": "Field DevExpressLayoutFileExtension",
    "keywords": "Field DevExpressLayoutFileExtension Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Liefert die von DevExpress genutzte Dateiendung für Report-Layout-Dateien (ohne Daten). public const string DevExpressLayoutFileExtension = \".repx\" Returns string Liefert die von genutzte Dateiendung für Report-Layout-Dateien (ohne Daten). Remarks Der Inhalt der Datei kann theoretisch als xml oder C#-Code aufgebaut sein, ist aber immer in UTF-8 codiert."
  },
  "api/FS.Hosting.Shared.Reporting.ReportConstants.DevExpressWithDataFileExtension.html": {
    "href": "api/FS.Hosting.Shared.Reporting.ReportConstants.DevExpressWithDataFileExtension.html",
    "title": "Field DevExpressWithDataFileExtension",
    "keywords": "Field DevExpressWithDataFileExtension Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll Liefert die von DevExpress genutzte Dateiendung für Report-Dateien, die bereits mit Daten bestückt wurden und jetzt Layout und Datenquelle in kombinierter Form enthalten. public const string DevExpressWithDataFileExtension = \".prnx\" Returns string Liefert die von genutzte Dateiendung für Report-Dateien, die bereits mit Daten bestückt wurden und jetzt Layout und Datenquelle in kombinierter Form enthalten."
  },
  "api/FS.Hosting.Shared.Reporting.ReportConstants.html": {
    "href": "api/FS.Hosting.Shared.Reporting.ReportConstants.html",
    "title": "Class ReportConstants",
    "keywords": "Class ReportConstants Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll public static class ReportConstants Inheritance object ReportConstants Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields CrystalReportFileExtension Liefert die von FS.Hosting.Shared.Reporting.ReportingSoftware.CrystalReports genutzte Dateiendung für Report-Dateien. DevExpressLayoutFileExtension Liefert die von DevExpress genutzte Dateiendung für Report-Layout-Dateien (ohne Daten). DevExpressWithDataFileExtension Liefert die von DevExpress genutzte Dateiendung für Report-Dateien, die bereits mit Daten bestückt wurden und jetzt Layout und Datenquelle in kombinierter Form enthalten."
  },
  "api/FS.Hosting.Shared.Reporting.ReportingSoftware.html": {
    "href": "api/FS.Hosting.Shared.Reporting.ReportingSoftware.html",
    "title": "Enum ReportingSoftware",
    "keywords": "Enum ReportingSoftware Namespace FS.Hosting.Shared.Reporting Assembly FS.Hosting.Shared.dll [Flags] public enum ReportingSoftware Fields DevExpress = 2 DevExpress' XtraReports ist nutzbar"
  },
  "api/FS.Hosting.Shared.Reporting.html": {
    "href": "api/FS.Hosting.Shared.Reporting.html",
    "title": "Namespace FS.Hosting.Shared.Reporting",
    "keywords": "Namespace FS.Hosting.Shared.Reporting Classes PrintQueue Diese Klasse bietet Methoden an, mit denen die Print-Queue ausgewertet und bearbeitet werden kann. PrintServer Diese Klasse dient dazu die bestehenden Print-Server zu ermitteln und Transaktionen an einem Print-Server zu steuern. Printer Represents a Printer from a PrintServer. All Properties are filled with the Constructor. ReportConstants Enums ExportFormat Format für den Export eines ReportDocument. Orientation ReportingSoftware"
  },
  "api/FS.Hosting.Shared.SaveEntryPoints.html": {
    "href": "api/FS.Hosting.Shared.SaveEntryPoints.html",
    "title": "Enum SaveEntryPoints",
    "keywords": "Enum SaveEntryPoints Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum SaveEntryPoints Fields CallAllways = 1 CallOnlyIfChanged = 0"
  },
  "api/FS.Hosting.Shared.SelectedRowsCollection.html": {
    "href": "api/FS.Hosting.Shared.SelectedRowsCollection.html",
    "title": "Class SelectedRowsCollection",
    "keywords": "Class SelectedRowsCollection Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public class SelectedRowsCollection : IList<guid>, ICollection<guid>, IEnumerable<guid>, IEnumerable, ICloneable Inheritance object SelectedRowsCollection Implements IList<guid> ICollection<guid> IEnumerable<guid> IEnumerable ICloneable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Hosting.Shared.SessionDataModel.ISessionData.GetData.html": {
    "href": "api/FS.Hosting.Shared.SessionDataModel.ISessionData.GetData.html",
    "title": "Method GetData",
    "keywords": "Method GetData Namespace FS.Hosting.Shared.SessionDataModel Assembly FS.Hosting.Shared.dll GetData(string) Gibt den Wert zurück, der für einen Schlüssel gespeichert wurde. string GetData(string key) Parameters key string Der Schlüssel. Returns string Der gespeicherte Wert. null, wenn der Schlüssel nicht gefunden wurde."
  },
  "api/FS.Hosting.Shared.SessionDataModel.ISessionData.HasData.html": {
    "href": "api/FS.Hosting.Shared.SessionDataModel.ISessionData.HasData.html",
    "title": "Method HasData",
    "keywords": "Method HasData Namespace FS.Hosting.Shared.SessionDataModel Assembly FS.Hosting.Shared.dll HasData(string) Prüft, ob für den übergebenen Schlüssel einen Wert existiert. bool HasData(string key) Parameters key string Der Schlüssel. Returns bool"
  },
  "api/FS.Hosting.Shared.SessionDataModel.ISessionData.SetData.html": {
    "href": "api/FS.Hosting.Shared.SessionDataModel.ISessionData.SetData.html",
    "title": "Method SetData",
    "keywords": "Method SetData Namespace FS.Hosting.Shared.SessionDataModel Assembly FS.Hosting.Shared.dll SetData(string, string) Setzt den Wert für einen Schlüssel. void SetData(string key, string value) Parameters key string Der Schlüssel. value string Der Wert. Wird null übergeben, dann wird der Wert gelöscht."
  },
  "api/FS.Hosting.Shared.SessionDataModel.ISessionData.html": {
    "href": "api/FS.Hosting.Shared.SessionDataModel.ISessionData.html",
    "title": "Interface ISessionData",
    "keywords": "Interface ISessionData Namespace FS.Hosting.Shared.SessionDataModel Assembly FS.Hosting.Shared.dll Mithilfe dieser Schnittstelle können über IGlobalObjects am Broker verschlüsselte Daten gespeichert werden. Die Speicherung der Daten erfolgt im Runtime-Repository in der Tabelle tblRep_SessionData. Der Kontext dieser Daten ist der Client, unabhängig vom Benutzer. So können z.B. Login-Informationen gespeichert werden, sodass sich der Benutzer bei einem wiederholten Start der Anwendung nicht erneut anmelden muss. Der Schlüssel für die Verschlüsselung wird mit einer ID versehen und an den Client geschickt. Der Broker/Server ist damit nicht in der Lage, die gespeicherten Daten ohne Hilfe eines Clients zu entschlüsseln. Der Zugriff auf diese Schnittstelle erfolgt über das GlobalObject Property SessionData. public interface ISessionData Remarks Ablauf beim erstmaligen Speichern von Session-Daten Nachfolgend wird der Prozess beschrieben, welcher durchlaufen wird, wenn der Broker zum ersten Mal für einen Client Session-Daten im Runtime Repository speichern soll und damit noch kein Verschlüsselungs-Key existiert. Der Client wurde gestartet und es wird ein Event ausgelöst, welches am Broker die SetData(string, string)-Methode aufruft. Nun soll für einen Schlüsselwert \"Test\" der Wert \"1234\" verschlüsselt gespeichert werden. Die SetData(string, string)-Methode könnte während eines Requests natürlich auch mehrmals für unterschiedliche Schlüsselwerte aufgerufen werden. Während ein Request vom Broker bearbeitet wird, werden alle Key/Value-Paare, die mit SetData(string, string) verschlüsselt werden sollen am Broker zwischengespeichert. Am Ende des Requests, kurz bevor die Antwort an den Client gesendet wird, werden die Daten nun verarbeitet. Der Broker hat vom Client bisher keinerlei Informationen über einen Verschlüsselungs-Key bekommen. Dies veranlasst den Broker, einen neuen AES256 Verschlüsselungs-Key zu generieren. Zusätzlich wird eine ID generiert, welche den Datensatz im Runtime Repository 1:1 dem Client zuordnet. Mit dem AES256-Key wird das Key/Value-Paar (\"Test\"/\"1234\") nun verschlüsselt und mit der ID im Runtime Repository abgespeichert. Mit der nun folgenden Antwort an den Client werden die ID und der AES256-Key mitgeschickt. Der Client speichert sich diese Kombination persistent, sodass sie auch bei einem Neustart noch verfügbar ist. Ablauf bei erneutem Start des Clients Nachfolgend wird der Prozess beschrieben, welcher durchlaufen wird, wenn der Client auf Session Daten zugreifen will, die in einer vorherigen Session gespeichert wurden. Wir gehen davon aus, dass der Client, wie im letzten Beispiel beschrieben, das Key/Value-Paar \"Test\"/ \"1234\" am Broker gespeichert hat und dafür die ID und den AES256-Key bekommen hat. Zwischenzeitlich wurde der Client und damit auch die Broker-Session beendet. D.h., der Broker hat nun keinerlei Informationen mehr darüber, wie er den gespeicherten Datensatz entschlüsseln kann. Wird der Client erneut gestartet, stellt dieser fest, dass für ihn eine ID/AES256-Key Kombination gespeichert wurde. Diese Kombination schickt der Client im allerersten Request an den Broker. Wird nun über SetData(string, string) ein Datensatz verlangt, kann der Broker mittels der vom Client gesendeten ID den Datensatz im Runtime Repository ausfindig machen und mit Hilfe des übermittelten AES256-Keys die Daten entschlüsseln. Ablauf von Session Daten Alle Daten, die mit SetData(string, string) gespeichert werden, erhalten ein Ablaufdatum. Die Validität der Daten ist auf 14 Tage festgesetzt. Meldet sich also ein Client 14 Tage lang nicht am Broker an, so werden alle gespeicherten Session Daten verworfen. Bei einem erneuten Speichern von Daten wird dann eine neue ID/AES256-Key Kombination generiert. Meldet sich ein Client innerhalb der 14 Tage am Broker an, so wird das Ablaufdatum verlängert (Anmeldedatum + 14 Tage). Bei kontinuierlicher Anmeldung am Broker verfallen die Session-Daten also nicht. Methods GetData(string) Gibt den Wert zurück, der für einen Schlüssel gespeichert wurde. HasData(string) Prüft, ob für den übergebenen Schlüssel einen Wert existiert. SetData(string, string) Setzt den Wert für einen Schlüssel."
  },
  "api/FS.Hosting.Shared.SessionDataModel.html": {
    "href": "api/FS.Hosting.Shared.SessionDataModel.html",
    "title": "Namespace FS.Hosting.Shared.SessionDataModel",
    "keywords": "Namespace FS.Hosting.Shared.SessionDataModel Interfaces ISessionData Mithilfe dieser Schnittstelle können über IGlobalObjects am Broker verschlüsselte Daten gespeichert werden. Die Speicherung der Daten erfolgt im Runtime-Repository in der Tabelle tblRep_SessionData. Der Kontext dieser Daten ist der Client, unabhängig vom Benutzer. So können z.B. Login-Informationen gespeichert werden, sodass sich der Benutzer bei einem wiederholten Start der Anwendung nicht erneut anmelden muss. Der Schlüssel für die Verschlüsselung wird mit einer ID versehen und an den Client geschickt. Der Broker/Server ist damit nicht in der Lage, die gespeicherten Daten ohne Hilfe eines Clients zu entschlüsseln. Der Zugriff auf diese Schnittstelle erfolgt über das GlobalObject Property SessionData."
  },
  "api/FS.Hosting.Shared.StackPanelHAlignment.html": {
    "href": "api/FS.Hosting.Shared.StackPanelHAlignment.html",
    "title": "Enum StackPanelHAlignment",
    "keywords": "Enum StackPanelHAlignment Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum StackPanelHAlignment Fields Center = 1 Left = 0 Right = 2"
  },
  "api/FS.Hosting.Shared.StackPanelOrientation.html": {
    "href": "api/FS.Hosting.Shared.StackPanelOrientation.html",
    "title": "Enum StackPanelOrientation",
    "keywords": "Enum StackPanelOrientation Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum StackPanelOrientation Fields Horizontal = 0 Vertical = 1"
  },
  "api/FS.Hosting.Shared.StackPanelVAlignment.html": {
    "href": "api/FS.Hosting.Shared.StackPanelVAlignment.html",
    "title": "Enum StackPanelVAlignment",
    "keywords": "Enum StackPanelVAlignment Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum StackPanelVAlignment Fields Bottom = 2 Center = 1 Top = 0"
  },
  "api/FS.Hosting.Shared.StaticCache.Get.html": {
    "href": "api/FS.Hosting.Shared.StaticCache.Get.html",
    "title": "Method Get",
    "keywords": "Method Get Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Get(string) Gibt den untypisierten statischen Cache zu dem angegebenen FullName zurück, falls dieser existiert, ansonsten null. public static IStaticCache Get(string cacheFullName) Parameters cacheFullName string Returns IStaticCache Examples IStaticCache oCurrencyCache = StaticCache.Get(\"cdCurrencyCache\"); Get(IDevFrameworkDataObject) Gibt den untypisierten statischen Cache zu dem angegebenen IDevFrameworkDataObject zurück, falls dieser existiert, ansonsten null. public static IStaticCache Get(IDevFrameworkDataObject devFrameworkDataObject) Parameters devFrameworkDataObject IDevFrameworkDataObject Returns IStaticCache Examples IStaticCache oCurrencyCache = StaticCache.Get(this.oCurrency);"
  },
  "api/FS.Hosting.Shared.StaticCache.html": {
    "href": "api/FS.Hosting.Shared.StaticCache.html",
    "title": "Class StaticCache",
    "keywords": "Class StaticCache Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Diese statische Klasse bietet Methoden zur Ermittlung eines untypisierten Caches über den Namen oder ein übergebenes IDevFrameworkDataObject, soweit dieser existiert. public static class StaticCache Inheritance object StaticCache Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Get(IDevFrameworkDataObject) Gibt den untypisierten statischen Cache zu dem angegebenen IDevFrameworkDataObject zurück, falls dieser existiert, ansonsten null. Get(string) Gibt den untypisierten statischen Cache zu dem angegebenen FullName zurück, falls dieser existiert, ansonsten null."
  },
  "api/FS.Hosting.Shared.StaticCacheMode.html": {
    "href": "api/FS.Hosting.Shared.StaticCacheMode.html",
    "title": "Enum StaticCacheMode",
    "keywords": "Enum StaticCacheMode Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Arbeitsmodus eines statischen Caches. Dieser kann im Einsprungpunkt GlobalGetStaticCacheMode(IDevFrameworkDataObject) pro Component-Typ festgelegt werden. public enum StaticCacheMode Fields Broker = 1 Daten werden für alle Sessions zentral im Broker verwaltet. Der Einsprungpunkt GlobalWhereStaticCache(IStaticCacheObject) wird durchlaufen. Nicht durchlaufen werden die Einsprungpunkte GlobalOnBeforeLoad(DevFrameworkObject, ref string, ref string, ref string), OnBeforeLoad(ref string, ref string, ref string, bool) und OnBeforeLoad(ref string, ref string, ref string). Session = 2 Daten werden pro Session verwaltet. Die Einsprungpunkte GlobalOnBeforeLoad(DevFrameworkObject, ref string, ref string, ref string), OnBeforeLoad(ref string, ref string, ref string, bool) und OnBeforeLoad(ref string, ref string, ref string) werden durchlaufen. Nicht durchlaufen wird GlobalWhereStaticCache(IStaticCacheObject)."
  },
  "api/FS.Hosting.Shared.TextEditorType.html": {
    "href": "api/FS.Hosting.Shared.TextEditorType.html",
    "title": "Enum TextEditorType",
    "keywords": "Enum TextEditorType Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll Used for example by the Editbox control to specify the kind of text to be handled by the control. public enum TextEditorType Fields HTML = 1 Der über den Datasource bereit gestellte Inhalt wird als Html interpretiert. Note Diese Einstellung ist nur bei mehrzeiligen Editfields möglich (Multiline=true). PlainText = 0 Es soll unformatierter Text dargestellt werden."
  },
  "api/FS.Hosting.Shared.TreeViewDragDropMode.html": {
    "href": "api/FS.Hosting.Shared.TreeViewDragDropMode.html",
    "title": "Enum TreeViewDragDropMode",
    "keywords": "Enum TreeViewDragDropMode Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll [HideForIntellisense] public enum TreeViewDragDropMode Fields AllTreeViews = 3 Drop ist von allen TreeViews aus möglich. None = 0 Drop in diesen TreeView ist nicht erlaubt. OtherTreeViews = 2 Drop ist nur mit Knoten von anderen TreeViews möglich. ThisTreeView = 1 Drop ist nur mit Knoten desselben TreeViews möglich."
  },
  "api/FS.Hosting.Shared.VerticalAlignment.html": {
    "href": "api/FS.Hosting.Shared.VerticalAlignment.html",
    "title": "Enum VerticalAlignment",
    "keywords": "Enum VerticalAlignment Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum VerticalAlignment Fields Bottom = 2 Middle = 1 Stretch = 3 Top = 0"
  },
  "api/FS.Hosting.Shared.WrapPanelHorizontalContentAlignment.html": {
    "href": "api/FS.Hosting.Shared.WrapPanelHorizontalContentAlignment.html",
    "title": "Enum WrapPanelHorizontalContentAlignment",
    "keywords": "Enum WrapPanelHorizontalContentAlignment Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum WrapPanelHorizontalContentAlignment Fields Center = 1 Fill = 3 Left = 0 Right = 2"
  },
  "api/FS.Hosting.Shared.WrapPanelVerticalContentAlignment.html": {
    "href": "api/FS.Hosting.Shared.WrapPanelVerticalContentAlignment.html",
    "title": "Enum WrapPanelVerticalContentAlignment",
    "keywords": "Enum WrapPanelVerticalContentAlignment Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum WrapPanelVerticalContentAlignment Fields Bottom = 2 Fill = 3 Middle = 1 Top = 0"
  },
  "api/FS.Hosting.Shared.WrapPanelWrapArrangement.html": {
    "href": "api/FS.Hosting.Shared.WrapPanelWrapArrangement.html",
    "title": "Enum WrapPanelWrapArrangement",
    "keywords": "Enum WrapPanelWrapArrangement Namespace FS.Hosting.Shared Assembly FS.Hosting.Shared.dll public enum WrapPanelWrapArrangement Fields Horizontal = 0 Vertical = 1"
  },
  "api/FS.Hosting.Shared.html": {
    "href": "api/FS.Hosting.Shared.html",
    "title": "Namespace FS.Hosting.Shared",
    "keywords": "Namespace FS.Hosting.Shared Classes BrowserCommand Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. DelegateChangeToken Ein IChangeToken, der mithilfe eines Delegate die Change-Information zurückgeben kann. DevFrameworkBaseObject Basisklasse für DevFrameworkObject und DevFrameworkObjectColl DevFrameworkObject Basisklasse für alle Components, die über FrameworkStudio erzeugt werden. FSCache FrameworkProgress Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. FrameworkQueryOptions PropertyNotFoundException Diese Exception wir geworfen, wenn bei einem Property-Zugriff über die Methode IDevFrameworkBaseObject.GetProperty() der Property-Name nicht gefunden wurde. SelectedRowsCollection StaticCache Diese statische Klasse bietet Methoden zur Ermittlung eines untypisierten Caches über den Namen oder ein übergebenes IDevFrameworkDataObject, soweit dieser existiert. Interfaces IDevFrameworkBaseObject IDevFrameworkDataObject IDevFrameworkObject IDevFrameworkObjectColl IDevFrameworkObjectMLString Repräsentiert den Eintrag einer TextCollection. IDevFrameworkObjectTextColl IFSCache Infrastruktur zum mehrstufige Cachen von Informationen. Siehe auch FSCache. IFrameworkBarcodeScanInfo Eine Instanz dieses Typs wird nach einem mit der Action FrameworkSystems.FrameworkControls.GeneratedForm.ScanBarcode(System.Action{FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo},FrameworkSystems.FrameworkBase.BarcodeFormat) ausgelösten Scan-Vorgang der Callback-Methode übergeben. Sie beinhaltet die Ergebisse des Scan-Vorgangs. IFrameworkControlActionBase IFrameworkGeoLocationInfo Eine Instanz dieses Typs wird nach einem mit der Action FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation(System.Action{FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo}) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet alle Informationen zum derzeitigen Standort des Endgeräts. IFrameworkPhotoInfo Eine Instanz dieses Typs wird nach einem mit der Action FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto(System.Action{FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo},FrameworkSystems.FrameworkBase.CameraSource) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet die Bilddaten des neuen oder ausgewählten Bildes und Zusatzinformationen. IGridView Ein Grid zeigt immer Daten einer Collection an. Um mit den Daten zu arbeiten, muss auf die Collection zugegriffen werden, die an das entsprechende Grid gebunden ist. IProgressOwner Sammelt die Informationen zu laufenden FrameworkProgress im IGlobalObjects. IStaticCache Schnittstelle eines statischen, untypisierten Caches für Elemente vom Typ IDevFrameworkObject, die über einen untypisierten Primärschlüssel eindeutig identifiziert werden können. Der Cache implementiert IEnumerable (untypisiert). IStaticCacheObject Stellt eine Schnittstelle zu einem Objekt im Cache dar. Über die Methode TryGetPropertyValue(string, out object) kann der Wert von Datenbank-Properties abgefragt werden. IStaticCache<TObj, TPK> Schnittstelle eines statischen Caches für Elemente vom Typ TObj, die über den Primärschlüssel vom Typ TPK eindeutig identifiziert werden können. Der Cache implementiert IEnumerable<TObj>. Der Cache ist NICHT Thread-Save. Methoden dürfen nur aus dem Thread des übergebenen GlobalObjects heraus aufgerufen werden. Enums AdoptMode Gibt an, wie sich die Methoden Clone(AdoptMode) und AdoptValues(IDevFrameworkBaseObject, AdoptMode) verhalten. BarcodeFormat CameraSource ComboEditStyle DevTextAlign Gibt die Ausrichtung des Textes an. DockPanelOrientation DockPanelScrolling EditorStyle ExtendedShortcut ExtendedShortcut contains the same properties as the System.Windows.Forms.Shortcut enumeration. Furthermore it is extended by: Esc = 27 FSDialogResult FSVisibility FieldRowLabelMode FrameworkCloseMode Definiert den Modus mit dem die Application beendet werden soll. FrameworkComponentState Status des Objektes. FrameworkFormatMask FromControlWrapperProcessedState Verarbeitungsstatus der in einem Grid verwendeten Objekte GridRowHeader HorizontalAlignment ListSortOrder Sortierar ListViewHorizontalContentAlignment ListViewItemArrangement ListViewSelectionMode ListViewSelectorPosition ListViewTemplateVariableDataSourceOrigin ListViewVerticalContentAlignment PictureScaleMode used for Picture.ScaleMode SaveEntryPoints StackPanelHAlignment StackPanelOrientation StackPanelVAlignment StaticCacheMode Arbeitsmodus eines statischen Caches. Dieser kann im Einsprungpunkt GlobalGetStaticCacheMode(IDevFrameworkDataObject) pro Component-Typ festgelegt werden. TextEditorType Used for example by the Editbox control to specify the kind of text to be handled by the control. TreeViewDragDropMode VerticalAlignment WrapPanelHorizontalContentAlignment WrapPanelVerticalContentAlignment WrapPanelWrapArrangement"
  },
  "api/FS.Shared.BaseObjects.guid.html": {
    "href": "api/FS.Shared.BaseObjects.guid.html",
    "title": "Class guid",
    "keywords": "Class guid Namespace FS.Shared.BaseObjects Assembly FS.Shared.dll GUID als ID für ein BaseObject. Entspricht der .NET-Guid-Klasse, mit dem Unterschied, daß die GUID nicht auf 16 Byte beschränkt ist. [Serializable] [TypeConverter(typeof(guidConverter))] [DataContract(Namespace = \"http://schemas.datacontract.org/2004/07/FrameworkSystems.FrameworkDataProvider.BaseObjects\")] public sealed class guid : IComparable Inheritance object guid Implements IComparable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/FS.Shared.BaseObjects.html": {
    "href": "api/FS.Shared.BaseObjects.html",
    "title": "Namespace FS.Shared.BaseObjects",
    "keywords": "Namespace FS.Shared.BaseObjects Classes guid GUID als ID für ein BaseObject. Entspricht der .NET-Guid-Klasse, mit dem Unterschied, daß die GUID nicht auf 16 Byte beschränkt ist."
  },
  "api/FS.Shared.FSUtils.EscapeCommandLineArgs.html": {
    "href": "api/FS.Shared.FSUtils.EscapeCommandLineArgs.html",
    "title": "Method EscapeCommandLineArgs",
    "keywords": "Method EscapeCommandLineArgs Namespace FS.Shared Assembly FS.Shared.dll EscapeCommandLineArgs(string) Wandelt den übergebenen String so um dass er als Command-Line-Argument verwendet werden kann. Dabei werden Leerzeichen, \\ und \" escaped. public static string EscapeCommandLineArgs(string arg) Parameters arg string Returns string EscapeCommandLineArgs(IEnumerable<string>) Wandelt die ünergebenen String-Argumente in einen string mit Command-Line-Arguments um. Dabei werden Leerzeichen, \\ und \" escaped. public static string EscapeCommandLineArgs(IEnumerable<string> args) Parameters args IEnumerable<string> Returns string EscapeCommandLineArgs(params string[]) Wandelt die ünergebenen String-Argumente in einen string mit Command-Line-Arguments um. Dabei werden Leerzeichen, \\ und \" escaped. public static string EscapeCommandLineArgs(params string[] args) Parameters args string[] Returns string"
  },
  "api/FS.Shared.FSUtils.TryGetExecutablePath.html": {
    "href": "api/FS.Shared.FSUtils.TryGetExecutablePath.html",
    "title": "Method TryGetExecutablePath",
    "keywords": "Method TryGetExecutablePath Namespace FS.Shared Assembly FS.Shared.dll TryGetExecutablePath(string, out string) Sucht eine Programmdatei im aktuellen Verzeichnis und mithilfe der PATH-Umgebungsvariable. public static bool TryGetExecutablePath(string executableFileName, out string foundPath) Parameters executableFileName string der Name der zu suchenden Programm-Datei. z.B. \"cmd\" oder \"explorer.exe\" foundPath string Gibt den gefundenen Pfad zurück. Returns bool true, wenn die Programmdatei gefunden wurde. Exceptions ArgumentNullException Es wurde ein leerer Pfad übergeben."
  },
  "api/FS.Shared.FSUtils.html": {
    "href": "api/FS.Shared.FSUtils.html",
    "title": "Class FSUtils",
    "keywords": "Class FSUtils Namespace FS.Shared Assembly FS.Shared.dll public static class FSUtils Inheritance object FSUtils Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods EscapeCommandLineArgs(IEnumerable<string>) Wandelt die ünergebenen String-Argumente in einen string mit Command-Line-Arguments um. Dabei werden Leerzeichen, \\ und \" escaped. EscapeCommandLineArgs(string) Wandelt den übergebenen String so um dass er als Command-Line-Argument verwendet werden kann. Dabei werden Leerzeichen, \\ und \" escaped. EscapeCommandLineArgs(params string[]) Wandelt die ünergebenen String-Argumente in einen string mit Command-Line-Arguments um. Dabei werden Leerzeichen, \\ und \" escaped. TryGetExecutablePath(string, out string) Sucht eine Programmdatei im aktuellen Verzeichnis und mithilfe der PATH-Umgebungsvariable."
  },
  "api/FS.Shared.FrameworkApplicationException.-ctor.html": {
    "href": "api/FS.Shared.FrameworkApplicationException.-ctor.html",
    "title": "Constructor FrameworkApplicationException",
    "keywords": "Constructor FrameworkApplicationException Namespace FS.Shared Assembly FS.Shared.dll FrameworkApplicationException(string) public FrameworkApplicationException(string msg) Parameters msg string FrameworkApplicationException(string, int) public FrameworkApplicationException(string msg, int severity) Parameters msg string severity int FrameworkApplicationException(string, Exception) public FrameworkApplicationException(string msg, Exception innerEx) Parameters msg string innerEx Exception FrameworkApplicationException(string, int, Exception) public FrameworkApplicationException(string msg, int severity, Exception innerEx) Parameters msg string severity int innerEx Exception FrameworkApplicationException(MLKeyText) public FrameworkApplicationException(MLKeyText mlkeyText) Parameters mlkeyText MLKeyText FrameworkApplicationException(MLKeyText, int) public FrameworkApplicationException(MLKeyText mlkeyText, int severity) Parameters mlkeyText MLKeyText severity int FrameworkApplicationException(MLKeyText, Exception) public FrameworkApplicationException(MLKeyText mlkeyText, Exception innerEx) Parameters mlkeyText MLKeyText innerEx Exception FrameworkApplicationException(MLKeyText, int, Exception) public FrameworkApplicationException(MLKeyText mlkeyText, int severity, Exception innerEx) Parameters mlkeyText MLKeyText severity int innerEx Exception"
  },
  "api/FS.Shared.FrameworkApplicationException.MLKey.html": {
    "href": "api/FS.Shared.FrameworkApplicationException.MLKey.html",
    "title": "Property MLKey",
    "keywords": "Property MLKey Namespace FS.Shared Assembly FS.Shared.dll MLKey Der mit dem MLKeyText übergebene MLKey. public MLKey MLKey { get; } Property Value MLKey"
  },
  "api/FS.Shared.FrameworkApplicationException.Severity.html": {
    "href": "api/FS.Shared.FrameworkApplicationException.Severity.html",
    "title": "Property Severity",
    "keywords": "Property Severity Namespace FS.Shared Assembly FS.Shared.dll Severity Definiert den Schweregrad der Exception. public int Severity { get; } Property Value int Remarks Diese Information wird momentan nicht ausgewertet."
  },
  "api/FS.Shared.FrameworkApplicationException.html": {
    "href": "api/FS.Shared.FrameworkApplicationException.html",
    "title": "Class FrameworkApplicationException",
    "keywords": "Class FrameworkApplicationException Namespace FS.Shared Assembly FS.Shared.dll Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. [Serializable] public class FrameworkApplicationException : ApplicationException, ISerializable Inheritance object Exception ApplicationException FrameworkApplicationException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors FrameworkApplicationException(MLKeyText) FrameworkApplicationException(MLKeyText, Exception) FrameworkApplicationException(MLKeyText, int) FrameworkApplicationException(MLKeyText, int, Exception) FrameworkApplicationException(string) FrameworkApplicationException(string, Exception) FrameworkApplicationException(string, int) FrameworkApplicationException(string, int, Exception) Properties MLKey Der mit dem MLKeyText übergebene MLKey. Severity Definiert den Schweregrad der Exception."
  },
  "api/FS.Shared.MultiLanguage.MLKey.-ctor.html": {
    "href": "api/FS.Shared.MultiLanguage.MLKey.-ctor.html",
    "title": "Constructor MLKey",
    "keywords": "Constructor MLKey Namespace FS.Shared.MultiLanguage Assembly FS.Shared.dll MLKey(string) public MLKey(string value) Parameters value string"
  },
  "api/FS.Shared.MultiLanguage.MLKey.ToString.html": {
    "href": "api/FS.Shared.MultiLanguage.MLKey.ToString.html",
    "title": "Method ToString",
    "keywords": "Method ToString Namespace FS.Shared.MultiLanguage Assembly FS.Shared.dll ToString() Liefert den String-Wert des MLKeys. public override string ToString() Returns string"
  },
  "api/FS.Shared.MultiLanguage.MLKey.html": {
    "href": "api/FS.Shared.MultiLanguage.MLKey.html",
    "title": "Class MLKey",
    "keywords": "Class MLKey Namespace FS.Shared.MultiLanguage Assembly FS.Shared.dll Diese Klasse verpackt einen MLKey. Der MLKey besteht aus einem String-Wert. public class MLKey Inheritance object MLKey Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Remarks Warning Bitte einen existierenden MLKey immer über MLKeys... verwenden. Diese Klasse sollte im eigenen Code nicht instanziiert werden. Alle im Wörterbuch enthaltenen MLKeys werden mit den Ressources in eine Klasse MLKeys genriert. über diese kann man im eigenen Code unterstützt durch Intellisense auf jedem MLKey zugreifen. FSstring sArticle = MLUtil.GetMLText(MLKeys.LBL_Article); Constructors MLKey(string) Methods ToString() Liefert den String-Wert des MLKeys."
  },
  "api/FS.Shared.MultiLanguage.MLKeyText.-ctor.html": {
    "href": "api/FS.Shared.MultiLanguage.MLKeyText.-ctor.html",
    "title": "Constructor MLKeyText",
    "keywords": "Constructor MLKeyText Namespace FS.Shared.MultiLanguage Assembly FS.Shared.dll MLKeyText(MLKey, string) public MLKeyText(MLKey mLKey, string text) Parameters mLKey MLKey text string"
  },
  "api/FS.Shared.MultiLanguage.MLKeyText.Key.html": {
    "href": "api/FS.Shared.MultiLanguage.MLKeyText.Key.html",
    "title": "Property Key",
    "keywords": "Property Key Namespace FS.Shared.MultiLanguage Assembly FS.Shared.dll Key public MLKey Key { get; } Property Value MLKey"
  },
  "api/FS.Shared.MultiLanguage.MLKeyText.Text.html": {
    "href": "api/FS.Shared.MultiLanguage.MLKeyText.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Namespace FS.Shared.MultiLanguage Assembly FS.Shared.dll Text public string Text { get; } Property Value string"
  },
  "api/FS.Shared.MultiLanguage.MLKeyText.html": {
    "href": "api/FS.Shared.MultiLanguage.MLKeyText.html",
    "title": "Class MLKeyText",
    "keywords": "Class MLKeyText Namespace FS.Shared.MultiLanguage Assembly FS.Shared.dll Diese Klasse verpackt einen MLKey und den lokalisierten Text. So ist es möglich mit dem Text auch den MLKey zu transportieren. In der FrameworkApplicationException kann so der MLKey als \"Fehlercode\" verwendet werden. public class MLKeyText Inheritance object MLKeyText Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Die MLUtil Klasse bietet Methoden, um Texte in Form dieser Klasse zu erhalten: GetMLKeyText(MLKey) FormatMLKeyText(MLKey, params object[]) Constructors MLKeyText(MLKey, string) Properties Key Text"
  },
  "api/FS.Shared.MultiLanguage.html": {
    "href": "api/FS.Shared.MultiLanguage.html",
    "title": "Namespace FS.Shared.MultiLanguage",
    "keywords": "Namespace FS.Shared.MultiLanguage Classes MLKey Diese Klasse verpackt einen MLKey. Der MLKey besteht aus einem String-Wert. MLKeyText Diese Klasse verpackt einen MLKey und den lokalisierten Text. So ist es möglich mit dem Text auch den MLKey zu transportieren. In der FrameworkApplicationException kann so der MLKey als \"Fehlercode\" verwendet werden."
  },
  "api/FS.Shared.RowVersionInvalidException.-ctor.html": {
    "href": "api/FS.Shared.RowVersionInvalidException.-ctor.html",
    "title": "Constructor RowVersionInvalidException",
    "keywords": "Constructor RowVersionInvalidException Namespace FS.Shared Assembly FS.Shared.dll RowVersionInvalidException(string) public RowVersionInvalidException(string caption) Parameters caption string RowVersionInvalidException(string, Exception) public RowVersionInvalidException(string caption, Exception ex) Parameters caption string ex Exception"
  },
  "api/FS.Shared.RowVersionInvalidException.html": {
    "href": "api/FS.Shared.RowVersionInvalidException.html",
    "title": "Class RowVersionInvalidException",
    "keywords": "Class RowVersionInvalidException Namespace FS.Shared Assembly FS.Shared.dll Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen. [Serializable] public class RowVersionInvalidException : FrameworkException, ISerializable Inheritance object Exception FrameworkException RowVersionInvalidException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RowVersionInvalidException(string) RowVersionInvalidException(string, Exception)"
  },
  "api/FS.Shared.html": {
    "href": "api/FS.Shared.html",
    "title": "Namespace FS.Shared",
    "keywords": "Namespace FS.Shared Classes FSUtils FrameworkApplicationException Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. RowVersionInvalidException Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen."
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.AddAddInToDialog.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.AddAddInToDialog.html",
    "title": "Enum AddAddInToDialog",
    "keywords": "Enum AddAddInToDialog Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll public enum AddAddInToDialog Fields CodeFile = 5 Component = 4 DBEditor = 1 Datasource = 3 Form = 6 FrameworkDesigner = 2 Metadatatype = 0 ModComp = 11 NoneForm = 9 PackageManager = 8 Resource = 10 Workflow = 7"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.Dialog.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.Dialog.html",
    "title": "Property Dialog",
    "keywords": "Property Dialog Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll Dialog public AddAddInToDialog Dialog { get; } Property Value AddAddInToDialog"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.Icon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.Icon.html",
    "title": "Property Icon",
    "keywords": "Property Icon Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll Icon Full-Name eines statischen Properties, welches ein Image zurückgibt. z.B. \"NV.ReferenceCheck.UnitTesting.UnitTestStart.UnitTestIcon\" public string Icon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MaintenanceModeOnly.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MaintenanceModeOnly.html",
    "title": "Property MaintenanceModeOnly",
    "keywords": "Property MaintenanceModeOnly Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll MaintenanceModeOnly Wenn gesetzt, dann wird dieses Menü-Item nur im Maintenance-Mode angezeigt. public bool MaintenanceModeOnly { get; set; } Property Value bool"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MenuCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MenuCaption.html",
    "title": "Property MenuCaption",
    "keywords": "Property MenuCaption Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll MenuCaption Der Titel des Menü-Items. public string MenuCaption { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MenuIsEnabledMethod.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MenuIsEnabledMethod.html",
    "title": "Property MenuIsEnabledMethod",
    "keywords": "Property MenuIsEnabledMethod Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll MenuIsEnabledMethod Name einer Methode, die aufgerufen wird, um das Menü-Item zu aktivieren bzw. zu deaktivieren. public string MenuIsEnabledMethod { get; set; } Property Value string Remarks Beispiel: [FSAddInMethod(AddAddInToDialog.DBEditor, MenuCaption = \"Import\", MenuParentPath = \"Database\", MenuIsEnabledMethod = nameof(IsMenuDBImportEnabled))] public static void ImportMethod(object sender, FSAddInEventArgs<FSFormDBEditor> e) { // ... } public static bool IsMenuDBImportEnabled(FSAddInEventArgs<FSFormDBEditor> e) { return e.Form.SelectedTable.IsPartOfActivePackage && !e.Environment.IsFrameworkCompiler && !e.Environment.IsActiveLabelServiceRelease; }"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MenuIsVisibleMethod.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MenuIsVisibleMethod.html",
    "title": "Property MenuIsVisibleMethod",
    "keywords": "Property MenuIsVisibleMethod Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll MenuIsVisibleMethod Name einer Methode, die aufgerufen wird, um das Menü-Item zu aktivieren bzw. zu deaktivieren. public string MenuIsVisibleMethod { get; set; } Property Value string Remarks Beispiel: [FSAddInMethod(AddAddInToDialog.DBEditor, MenuCaption = \"Import\", MenuParentPath = \"Database\", MenuIsVisibleMethod = nameof(IsMenuDBImportVisible))] public static void ImportMethod(object sender, FSAddInEventArgs<FSFormDBEditor> e) { // ... } public static bool IsMenuDBImportVisible(FSAddInEventArgs<FSFormDBEditor> e) { return e.Form.SelectedTable.IsPartOfActivePackage; }"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MenuParentPath.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.MenuParentPath.html",
    "title": "Property MenuParentPath",
    "keywords": "Property MenuParentPath Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll MenuParentPath Definiert, in welcher Menü-Struktur dieses Menü-Item eingehängt werden soll. public string MenuParentPath { get; set; } Property Value string Remarks Untermenüs werden durch einen Punkt speariert - z.B. \"Tools.Checks\" Soll in einem Menü ein \".\" angezeigt werden, dann muss dieser mit @\"\\.\" escaped werden - z.B. @\"Update.FS 4\\.7\""
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll Shortcut public Keys Shortcut { get; set; } Property Value Keys"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.StartNewMenuGroup.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.StartNewMenuGroup.html",
    "title": "Property StartNewMenuGroup",
    "keywords": "Property StartNewMenuGroup Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll StartNewMenuGroup public bool StartNewMenuGroup { get; set; } Property Value bool"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.FSAddInMethodAttribute.html",
    "title": "Class FSAddInMethodAttribute",
    "keywords": "Class FSAddInMethodAttribute Namespace FrameworkSystems.FrameworkStudio.API.AddIn Assembly FSDeveloperAPI.dll [AttributeUsage(AttributeTargets.Method)] public class FSAddInMethodAttribute : Attribute, _Attribute Inheritance object Attribute FSAddInMethodAttribute Implements _Attribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) object.GetType() object.MemberwiseClone() Properties Dialog Icon Full-Name eines statischen Properties, welches ein Image zurückgibt. z.B. \"NV.ReferenceCheck.UnitTesting.UnitTestStart.UnitTestIcon\" MaintenanceModeOnly Wenn gesetzt, dann wird dieses Menü-Item nur im Maintenance-Mode angezeigt. MenuCaption Der Titel des Menü-Items. MenuIsEnabledMethod Name einer Methode, die aufgerufen wird, um das Menü-Item zu aktivieren bzw. zu deaktivieren. MenuIsVisibleMethod Name einer Methode, die aufgerufen wird, um das Menü-Item zu aktivieren bzw. zu deaktivieren. MenuParentPath Definiert, in welcher Menü-Struktur dieses Menü-Item eingehängt werden soll. Shortcut StartNewMenuGroup"
  },
  "api/FrameworkSystems.FrameworkStudio.API.AddIn.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.API.AddIn.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.API.AddIn",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.API.AddIn Classes FSAddInMethodAttribute Enums AddAddInToDialog"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.SearchCompareOperator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.SearchCompareOperator.html",
    "title": "Enum SearchCompareOperator",
    "keywords": "Enum SearchCompareOperator Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data Assembly FrameworkSystems.FrameworkStudio.General.dll public enum SearchCompareOperator Fields [FSDisplayName(\"= - Equal\", 0)] Equal = 0 A comparison for equality [FSDisplayName(\"> - Greater than\", 0)] GreaterThan = 1 A comparison for greater than. [FSDisplayName(\">= - Greater than or equal\", 0)] GreaterThanEqual = 2 A comparison for greater than or equal to. [FSDisplayName(\"< - Less than\", 0)] LessThan = 3 A comparison for less than. [FSDisplayName(\"<= - Less than or equal\", 0)] LessThanEqual = 4 A comparison for less than or equal to. [FSDisplayName(\"Like\", 0)] Like = 6 [FSDisplayName(\"Like non case sensitive\", 0)] LikeNonCaseSensitive = 8 [FSDisplayName(\"!= - Not equal\", 0)] NotEqual = 5"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data Enums SearchCompareOperator"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ContainsNullEntry.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ContainsNullEntry.html",
    "title": "Property ContainsNullEntry",
    "keywords": "Property ContainsNullEntry Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings Assembly FrameworkSystems.FrameworkStudio.General.dll ContainsNullEntry Gibt an, ob die Liste einen leeren Eintrag beinhalten soll.Bei True wird die Liste um einen leeren Eintrag ergänzt.Dieser Eintrag wird ausgewählt, wenn der Wert der Combobox auf kein Value aus der Liste zutrifft. Wird dieser Eintrag vom Benutzer ausgewählt, wird dem dahinterliegenden Property Null zugewiesen. [Browsable(true)] public bool? ContainsNullEntry { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.DisplayMember.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.DisplayMember.html",
    "title": "Property DisplayMember",
    "keywords": "Property DisplayMember Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings Assembly FrameworkSystems.FrameworkStudio.General.dll DisplayMember Gibt an, welches Property des Datasources in der Liste angezeigt werden soll. Bei einer Textcollection ist das in der Regel Text. [Browsable(true)] [TypeConverter(typeof(ListDataSource.CollectionConverter))] public virtual IPropertyRecord DisplayMember { get; set; } Property Value IPropertyRecord"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ValueMember.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ValueMember.html",
    "title": "Property ValueMember",
    "keywords": "Property ValueMember Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings Assembly FrameworkSystems.FrameworkStudio.General.dll ValueMember Gibt an, welches Property des Datasources den Wert eines Eintrags darstellt. Es ist immer der Eintrag ausgewählt, dessen Value gleich dem Wert der Combobox ist. Bei einer Textcollection ist das in der Regel ID. [Browsable(true)] [TypeConverter(typeof(ListDataSource.CollectionConverter))] public IPropertyRecord ValueMember { get; set; } Property Value IPropertyRecord"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.html",
    "title": "Class ListDataSource",
    "keywords": "Class ListDataSource Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings Assembly FrameworkSystems.FrameworkStudio.General.dll Summary description for DataBinding. [Serializable] [TypeConverter(typeof(ExpandableObjectConverter))] public class ListDataSource : ICloneable, ICustomTypeDescriptor Inheritance object ListDataSource Implements ICloneable ICustomTypeDescriptor Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ContainsNullEntry Gibt an, ob die Liste einen leeren Eintrag beinhalten soll.Bei True wird die Liste um einen leeren Eintrag ergänzt.Dieser Eintrag wird ausgewählt, wenn der Wert der Combobox auf kein Value aus der Liste zutrifft. Wird dieser Eintrag vom Benutzer ausgewählt, wird dem dahinterliegenden Property Null zugewiesen. DisplayMember Gibt an, welches Property des Datasources in der Liste angezeigt werden soll. Bei einer Textcollection ist das in der Regel Text. ValueMember Gibt an, welches Property des Datasources den Wert eines Eintrags darstellt. Es ist immer der Eintrag ausgewählt, dessen Value gleich dem Wert der Combobox ist. Bei einer Textcollection ist das in der Regel ID."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings Classes ListDataSource Summary description for DataBinding."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Equals.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Equals.html",
    "title": "Method Equals",
    "keywords": "Method Equals Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Equals(object) Determines whether the specified object is equal to the current object. public override bool Equals(object obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.FromString.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.FromString.html",
    "title": "Method FromString",
    "keywords": "Method FromString Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll FromString(string) public static Alignment<H, V> FromString(string value) Parameters value string Returns Alignment<H, V>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.GetHashCode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.GetHashCode.html",
    "title": "Method GetHashCode",
    "keywords": "Method GetHashCode Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Horizontal.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Horizontal.html",
    "title": "Property Horizontal",
    "keywords": "Property Horizontal Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Horizontal public H? Horizontal { get; set; } Property Value H?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.SetFrom.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.SetFrom.html",
    "title": "Method SetFrom",
    "keywords": "Method SetFrom Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll SetFrom(Alignment<H, V>) public void SetFrom(Alignment<H, V> value) Parameters value Alignment<H, V>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShoudldSerialize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShoudldSerialize.html",
    "title": "Method ShoudldSerialize",
    "keywords": "Method ShoudldSerialize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll ShoudldSerialize() public bool ShoudldSerialize() Returns bool"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeHorizontal.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeHorizontal.html",
    "title": "Method ShouldSerializeHorizontal",
    "keywords": "Method ShouldSerializeHorizontal Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll ShouldSerializeHorizontal() public bool ShouldSerializeHorizontal() Returns bool"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeVertical.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeVertical.html",
    "title": "Method ShouldSerializeVertical",
    "keywords": "Method ShouldSerializeVertical Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll ShouldSerializeVertical() public bool ShouldSerializeVertical() Returns bool"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ToString.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ToString.html",
    "title": "Method ToString",
    "keywords": "Method ToString Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Vertical.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Vertical.html",
    "title": "Property Vertical",
    "keywords": "Property Vertical Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Vertical public V? Vertical { get; set; } Property Value V?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.html",
    "title": "Class Alignment<H, V>",
    "keywords": "Class Alignment<H, V> Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll public class Alignment<H, V> where H : struct where V : struct Type Parameters H V Inheritance object Alignment<H, V> Inherited Members object.Equals(object, object) object.ReferenceEquals(object, object) object.GetType() object.MemberwiseClone() Properties Horizontal Vertical Methods Equals(object) Determines whether the specified object is equal to the current object. FromString(string) GetHashCode() Serves as the default hash function. SetFrom(Alignment<H, V>) ShoudldSerialize() ShouldSerializeHorizontal() ShouldSerializeVertical() ToString() Returns a string that represents the current object."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomLeft.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomLeft.html",
    "title": "Property BottomLeft",
    "keywords": "Property BottomLeft Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll BottomLeft public int? BottomLeft { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomRight.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomRight.html",
    "title": "Property BottomRight",
    "keywords": "Property BottomRight Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll BottomRight public int? BottomRight { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopLeft.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopLeft.html",
    "title": "Property TopLeft",
    "keywords": "Property TopLeft Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll TopLeft public int? TopLeft { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopRight.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopRight.html",
    "title": "Property TopRight",
    "keywords": "Property TopRight Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll TopRight public int? TopRight { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.html",
    "title": "Class BorderRadius",
    "keywords": "Class BorderRadius Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll [TypeConverter(typeof(BorderRadiusTypeConverter))] public class BorderRadius Inheritance object BorderRadius Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties BottomLeft BottomRight TopLeft TopRight"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Bottom.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Bottom.html",
    "title": "Property Bottom",
    "keywords": "Property Bottom Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Bottom public int? Bottom { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Left.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Left.html",
    "title": "Property Left",
    "keywords": "Property Left Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Left public int? Left { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Right.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Right.html",
    "title": "Property Right",
    "keywords": "Property Right Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Right public int? Right { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Top.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Top.html",
    "title": "Property Top",
    "keywords": "Property Top Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Top public int? Top { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.html",
    "title": "Class Bounds",
    "keywords": "Class Bounds Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll [TypeConverter(typeof(ControlBoundsTypeConverter))] public class Bounds Inheritance object Bounds Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Bottom Left Right Top"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Bold.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Bold.html",
    "title": "Property Bold",
    "keywords": "Property Bold Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Bold public bool? Bold { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Family.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Family.html",
    "title": "Property Family",
    "keywords": "Property Family Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Family [TypeConverter(typeof(FontFamilyConverter))] public string Family { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Italic.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Italic.html",
    "title": "Property Italic",
    "keywords": "Property Italic Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Italic public bool? Italic { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Size.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Size.html",
    "title": "Property Size",
    "keywords": "Property Size Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Size public int? Size { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Underline.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Underline.html",
    "title": "Property Underline",
    "keywords": "Property Underline Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Underline public bool? Underline { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.html",
    "title": "Class ControlFont",
    "keywords": "Class ControlFont Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll [TypeConverter(typeof(ControlFontTypeConverter))] public class ControlFont Inheritance object ControlFont Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Bold Family Italic Size Underline"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.IsVisible.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.IsVisible.html",
    "title": "Property IsVisible",
    "keywords": "Property IsVisible Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll IsVisible [Browsable(true)] [ControlStylesBrowsable(false)] public bool? IsVisible { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.html",
    "title": "Class ControlLabelTemplate",
    "keywords": "Class ControlLabelTemplate Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll public class ControlLabelTemplate : ControlLabelTemplateBase, INotifyPropertyChanged Inheritance object DevDataBase DevDataStyleBase ControlLabelTemplateBase ControlLabelTemplate Implements INotifyPropertyChanged Inherited Members ControlLabelTemplateBase.BackColor ControlLabelTemplateBase.ForeColor ControlLabelTemplateBase.Font ControlLabelTemplateBase.TextAlign ControlLabelTemplateBase.Padding ControlLabelTemplateBase.Margin ControlLabelTemplateBase.MinSize ControlLabelTemplateBase.MaxSize object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties IsVisible"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll BackColor [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Font.html",
    "title": "Property Font",
    "keywords": "Property Font Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Font public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll ForeColor [TypeConverter(typeof(ColorTypeConverter))] public Color ForeColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Margin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Margin.html",
    "title": "Property Margin",
    "keywords": "Property Margin Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Margin public Bounds Margin { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll MaxSize public NonableSize MaxSize { get; set; } Property Value NonableSize"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MinSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MinSize.html",
    "title": "Property MinSize",
    "keywords": "Property MinSize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll MinSize public NonableSize MinSize { get; set; } Property Value NonableSize"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Padding public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll TextAlign public DevTextAlign? TextAlign { get; set; } Property Value DevTextAlign?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.html",
    "title": "Class ControlLabelTemplateBase",
    "keywords": "Class ControlLabelTemplateBase Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll [TypeConverter(typeof(ControlLabelTemplateConverter))] public abstract class ControlLabelTemplateBase : DevDataStyleBase, INotifyPropertyChanged Inheritance object DevDataBase DevDataStyleBase ControlLabelTemplateBase Implements INotifyPropertyChanged Derived ControlLabelTemplate RowLabelTemplate Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties BackColor Font ForeColor Margin MaxSize MinSize Padding TextAlign"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Height.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Height.html",
    "title": "Property Height",
    "keywords": "Property Height Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Height [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] [ControlStylesBrowsable(true)] public Nonable<int>? Height { get; set; } Property Value Nonable<int>?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Width.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Width.html",
    "title": "Property Width",
    "keywords": "Property Width Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Width [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] [ControlStylesBrowsable(true)] public Nonable<int>? Width { get; set; } Property Value Nonable<int>?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.html",
    "title": "Class NonableSize",
    "keywords": "Class NonableSize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll [TypeConverter(typeof(NonableSizeObjectConverter))] public class NonableSize Inheritance object NonableSize Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Height Width"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll BackColor [Browsable(true)] public Color BackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Font.html",
    "title": "Property Font",
    "keywords": "Property Font Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Font [Browsable(true)] public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll ForeColor [Browsable(true)] public Color ForeColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Margin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Margin.html",
    "title": "Property Margin",
    "keywords": "Property Margin Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Margin [Browsable(true)] public Bounds Margin { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Padding [Browsable(true)] public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.html",
    "title": "Class RowLabelTemplate",
    "keywords": "Class RowLabelTemplate Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll public class RowLabelTemplate : ControlLabelTemplateBase, INotifyPropertyChanged Inheritance object DevDataBase DevDataStyleBase ControlLabelTemplateBase RowLabelTemplate Implements INotifyPropertyChanged Inherited Members ControlLabelTemplateBase.TextAlign ControlLabelTemplateBase.MinSize ControlLabelTemplateBase.MaxSize object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties BackColor Font ForeColor Margin Padding"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll BackColor [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderColor.html",
    "title": "Property BorderColor",
    "keywords": "Property BorderColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll BorderColor [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color BorderColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderRadius.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderRadius.html",
    "title": "Property BorderRadius",
    "keywords": "Property BorderRadius Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll BorderRadius public BorderRadius BorderRadius { get; set; } Property Value BorderRadius"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderThickness.html",
    "title": "Property BorderThickness",
    "keywords": "Property BorderThickness Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll BorderThickness public Bounds BorderThickness { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Font.html",
    "title": "Property Font",
    "keywords": "Property Font Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Font public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll ForeColor [TypeConverter(typeof(ColorTypeConverter))] public Color ForeColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.IconPadding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.IconPadding.html",
    "title": "Property IconPadding",
    "keywords": "Property IconPadding Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll IconPadding public Bounds IconPadding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll Padding public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.html",
    "title": "Class TabTemplate",
    "keywords": "Class TabTemplate Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly FrameworkSystems.FrameworkStudio.General.dll [TypeConverter(typeof(TabTemplateConverter))] public class TabTemplate : DevDataStyleBase, INotifyPropertyChanged Inheritance object DevDataBase DevDataStyleBase TabTemplate Implements INotifyPropertyChanged Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties BackColor BorderColor BorderRadius BorderThickness Font ForeColor IconPadding Padding"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Classes Alignment<H, V> BorderRadius Bounds ControlFont ControlLabelTemplate ControlLabelTemplateBase NonableSize RowLabelTemplate TabTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.Name.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer Assembly FrameworkSystems.FrameworkStudio.General.dll Name Gibt den Namen des Controls an. Über diesen Namen kann in den Form-Methoden auf das Control zugegriffen werden.Einige Controls bieten die Möglichkeit, dynamisch Properties zu verändern.In einer Form-Methode kann so z.B. this.btnCalculate.SetVisible(false); aufgerufen werden, um ein Control auszublenden. Wird für ein Control ein Name vergeben, sollte dieser gut überlegt sein, damit er nicht mehr nachträglich geändert werden muss.Denn werden dem Control Events zugeordnet, orientiert sich deren Name am Namen des Controls. Beispiel: wird für einen Button btnStart eine Form- Methode hinterlegt, bekommt Sie den Namen FE_btnStart_OnClick( ). [Browsable(true)] public virtual string Name { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.html",
    "title": "Class ControlTreeNode",
    "keywords": "Class ControlTreeNode Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer Assembly FrameworkSystems.FrameworkStudio.General.dll public class ControlTreeNode : INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode Implements INotifyPropertyChanged IDisposable Derived ControlDesignViewModel Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Name Gibt den Namen des Controls an. Über diesen Namen kann in den Form-Methoden auf das Control zugegriffen werden.Einige Controls bieten die Möglichkeit, dynamisch Properties zu verändern.In einer Form-Methode kann so z.B. this.btnCalculate.SetVisible(false); aufgerufen werden, um ein Control auszublenden. Wird für ein Control ein Name vergeben, sollte dieser gut überlegt sein, damit er nicht mehr nachträglich geändert werden muss.Denn werden dem Control Events zugeordnet, orientiert sich deren Name am Namen des Controls. Beispiel: wird für einen Button btnStart eine Form- Methode hinterlegt, bekommt Sie den Namen FE_btnStart_OnClick( )."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonIcon.html",
    "title": "Property BackwardButtonIcon",
    "keywords": "Property BackwardButtonIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BackwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button [Browsable(true)] [ControlStylesBrowsable(true)] public string BackwardButtonIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonShortcut.html",
    "title": "Property BackwardButtonShortcut",
    "keywords": "Property BackwardButtonShortcut Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BackwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? BackwardButtonShortcut { get; set; } Property Value ExtendedShortcut?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BrowserMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BrowserMode.html",
    "title": "Property BrowserMode",
    "keywords": "Property BrowserMode Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BrowserMode Gibt an, ob der Browser-Mode ausgewählt wurde. Der Browser-Mode ist zur Anzeige von Webseiten geeignet und verfügt über eine Adresszeile. Die in die Adresszeile eingegebene URL wird durch den LoadPageButton geladen.Das Laden der Seite kann durch den CancelButton abgebrochen und über den ReloadPageButton neu gestartet werden. Außerdem verfügt der Browser-Mode über Buttons, mit denen eine Vorwärts- und Rückwärtsnavigation möglich ist. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? BrowserMode { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonIcon.html",
    "title": "Property CancelButtonIcon",
    "keywords": "Property CancelButtonIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll CancelButtonIcon Pfad zu einem Icon, das für den jeweiligen Button [Browsable(true)] [ControlStylesBrowsable(true)] public string CancelButtonIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Content.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Content.html",
    "title": "Property Content",
    "keywords": "Property Content Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Content Über den Datasource Content können Inhalte wie z.B. HTML-Content oder der Pfad zu einer Datei, die im Browser angezeigt werden soll, an den Client übertragen werden. Der Datasource ist unidirektional(nur von Broker zu Client) und hat höhere Priorität als Url. Ressourcen können mit fsbroker://RelativerPfad angezeigt oder verwendet werden. Mit der Funktion CreateRessourcesUrl( ) der Klasse BrowserCommand kann eine Broker-Url erstellt werden. Diese Url kann dann, wie in dem nachfolgenden Beispiel, in Verbindung mit HTML als Link zu einer Datei verwendet warden: [Browsable(true)] [ControlStylesBrowsable(false)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource Content { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.EnableJavaScript.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.EnableJavaScript.html",
    "title": "Property EnableJavaScript",
    "keywords": "Property EnableJavaScript Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll EnableJavaScript Gibt an, ob JavaScript im Browser aktiviert ist. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? EnableJavaScript { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonIcon.html",
    "title": "Property ForwardButtonIcon",
    "keywords": "Property ForwardButtonIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ForwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button [Browsable(true)] [ControlStylesBrowsable(true)] public string ForwardButtonIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonShortcut.html",
    "title": "Property ForwardButtonShortcut",
    "keywords": "Property ForwardButtonShortcut Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ForwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ForwardButtonShortcut { get; set; } Property Value ExtendedShortcut?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonIcon.html",
    "title": "Property LoadPageButtonIcon",
    "keywords": "Property LoadPageButtonIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll LoadPageButtonIcon Pfad zu einem Icon, das für den jeweiligen Button [Browsable(true)] [ControlStylesBrowsable(true)] public string LoadPageButtonIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLBackwardButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLBackwardButtonTooltip.html",
    "title": "Property MLBackwardButtonTooltip",
    "keywords": "Property MLBackwardButtonTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLBackwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. [Browsable(true)] [ControlStylesBrowsable] public IMLString MLBackwardButtonTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLCancelButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLCancelButtonTooltip.html",
    "title": "Property MLCancelButtonTooltip",
    "keywords": "Property MLCancelButtonTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCancelButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. [Browsable(true)] [ControlStylesBrowsable] public IMLString MLCancelButtonTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLForwardButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLForwardButtonTooltip.html",
    "title": "Property MLForwardButtonTooltip",
    "keywords": "Property MLForwardButtonTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLForwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. [Browsable(true)] [ControlStylesBrowsable] public IMLString MLForwardButtonTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLLoadPageButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLLoadPageButtonTooltip.html",
    "title": "Property MLLoadPageButtonTooltip",
    "keywords": "Property MLLoadPageButtonTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLLoadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. [Browsable(true)] [ControlStylesBrowsable] public IMLString MLLoadPageButtonTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLReloadPageButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLReloadPageButtonTooltip.html",
    "title": "Property MLReloadPageButtonTooltip",
    "keywords": "Property MLReloadPageButtonTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLReloadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. [Browsable(true)] [ControlStylesBrowsable] public IMLString MLReloadPageButtonTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLZoomInButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLZoomInButtonTooltip.html",
    "title": "Property MLZoomInButtonTooltip",
    "keywords": "Property MLZoomInButtonTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLZoomInButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. [Browsable(true)] [ControlStylesBrowsable] public IMLString MLZoomInButtonTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLZoomOutButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLZoomOutButtonTooltip.html",
    "title": "Property MLZoomOutButtonTooltip",
    "keywords": "Property MLZoomOutButtonTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLZoomOutButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. [Browsable(true)] [ControlStylesBrowsable] public IMLString MLZoomOutButtonTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLZoomResetButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.MLZoomResetButtonTooltip.html",
    "title": "Property MLZoomResetButtonTooltip",
    "keywords": "Property MLZoomResetButtonTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLZoomResetButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. [Browsable(true)] [ControlStylesBrowsable] public IMLString MLZoomResetButtonTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnLinkClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnLinkClick.html",
    "title": "Event OnLinkClick",
    "keywords": "Event OnLinkClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein, wenn ein Html-Link mit der Maus angeklickt wurde. Um eine Client-seitige Navigation zu unterbinden, werden alle Links an den Event-Args konsumiert und müssen, falls gewünscht, wieder manuell über einen der Datasources zum Client geschickt werden. public event EventHandler<FrameworkOnLinkClickEventArgs> OnLinkClick Returns EventHandler<FrameworkOnLinkClickEventArgs> Tritt ein, wenn ein Html-Link mit der Maus angeklickt wurde. Um eine Client-seitige Navigation zu unterbinden, werden alle Links an den Event-Args konsumiert und müssen, falls gewünscht, wieder manuell über einen der Datasources zum Client geschickt werden."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageError.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageError.html",
    "title": "Event OnPageError",
    "keywords": "Event OnPageError Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein falls beim Laden der Seite ein Fehler aufgetreten ist Über das Event Argument können folgende Informationen über die Fehlermeldung ausgelesen werden: • Url: Gibt die Url zurück zu der navigiert werden sollte • Message: Gibt den Fehlergrund zurück public event EventHandler<FrameworkOnLinkClickEventArgs> OnPageError Returns EventHandler<FrameworkOnLinkClickEventArgs> Tritt ein falls beim Laden der Seite ein Fehler aufgetreten ist Über das Event Argument können folgende Informationen über die Fehlermeldung ausgelesen werden: • Url: Gibt die Url zurück zu der navigiert werden sollte • Message: Gibt den Fehlergrund zurück"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageLoaded.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageLoaded.html",
    "title": "Event OnPageLoaded",
    "keywords": "Event OnPageLoaded Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein, wenn die aktuelle Seite vom Browser fertig geladen ist. Das Event-Argument stellt die Adresse (url) und den Titel (title) der geladenen Seite zur Verfügung. public event EventHandler<FrameworkOnLinkClickEventArgs> OnPageLoaded Returns EventHandler<FrameworkOnLinkClickEventArgs> Tritt ein, wenn die aktuelle Seite vom Browser fertig geladen ist. Das Event-Argument stellt die Adresse (url) und den Titel (title) der geladenen Seite zur Verfügung."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnSnapshotGenerated.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnSnapshotGenerated.html",
    "title": "Event OnSnapshotGenerated",
    "keywords": "Event OnSnapshotGenerated Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein, wenn der Snapshot von der Action GenerateSnapshot erstellt wurde. • Snapshot: Gibt den Snapshot als Byte-Array im PNG Format zurück public event EventHandler<FrameworkOnLinkClickEventArgs> OnSnapshotGenerated Returns EventHandler<FrameworkOnLinkClickEventArgs> Tritt ein, wenn der Snapshot von der Action GenerateSnapshot erstellt wurde. • Snapshot: Gibt den Snapshot als Byte-Array im PNG Format zurück"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonIcon.html",
    "title": "Property ReloadButtonIcon",
    "keywords": "Property ReloadButtonIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ReloadButtonIcon Pfad zu einem Icon, das für den jeweiligen Button [Browsable(true)] [ControlStylesBrowsable(true)] public string ReloadButtonIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonShortcut.html",
    "title": "Property ReloadButtonShortcut",
    "keywords": "Property ReloadButtonShortcut Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ReloadButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ReloadButtonShortcut { get; set; } Property Value ExtendedShortcut?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowStatusBar.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowStatusBar.html",
    "title": "Property ShowStatusBar",
    "keywords": "Property ShowStatusBar Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ShowStatusBar Gibt an, ob die Statusleiste (Ladestatus der aktuellen Seite + MouseOver Link) angezeigt wird. Die Statusleiste wird nur in Verbindung mit dem BrowserMode angezeigt. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowStatusBar { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowZoomBar.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowZoomBar.html",
    "title": "Property ShowZoomBar",
    "keywords": "Property ShowZoomBar Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ShowZoomBar Gibt an, ob die Leiste zur Änderung der Größe des Inhalts im Browser angezeigt wird. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowZoomBar { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Url.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Url.html",
    "title": "Property Url",
    "keywords": "Property Url Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Url Mit dem Datasource Url können Webseiten, die im Browser angezeigt werden sollen, an den Client übertragen werden. Der Datasource ist unidirektional (nur von Broker zu Client). [Browsable(true)] [ControlStylesBrowsable(false)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource Url { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonIcon.html",
    "title": "Property ZoomInButtonIcon",
    "keywords": "Property ZoomInButtonIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ZoomInButtonIcon Pfad zu einem Icon, das für den jeweiligen Button [Browsable(true)] [ControlStylesBrowsable(true)] public string ZoomInButtonIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonShortcut.html",
    "title": "Property ZoomInButtonShortcut",
    "keywords": "Property ZoomInButtonShortcut Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ZoomInButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ZoomInButtonShortcut { get; set; } Property Value ExtendedShortcut?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonShortcut.html",
    "title": "Property ZoomOutButtonShortcut",
    "keywords": "Property ZoomOutButtonShortcut Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ZoomOutButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ZoomOutButtonShortcut { get; set; } Property Value ExtendedShortcut?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonIcon.html",
    "title": "Property ZoomResetButtonIcon",
    "keywords": "Property ZoomResetButtonIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ZoomResetButtonIcon Pfad zu einem Icon, das für den jeweiligen Button [Browsable(true)] [ControlStylesBrowsable(true)] public string ZoomResetButtonIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonShortcut.html",
    "title": "Property ZoomResetButtonShortcut",
    "keywords": "Property ZoomResetButtonShortcut Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ZoomResetButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ZoomResetButtonShortcut { get; set; } Property Value ExtendedShortcut?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.html",
    "title": "Class BrowserDesignViewModel",
    "keywords": "Class BrowserDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class BrowserDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel BrowserDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties BackwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button BackwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. BrowserMode Gibt an, ob der Browser-Mode ausgewählt wurde. Der Browser-Mode ist zur Anzeige von Webseiten geeignet und verfügt über eine Adresszeile. Die in die Adresszeile eingegebene URL wird durch den LoadPageButton geladen.Das Laden der Seite kann durch den CancelButton abgebrochen und über den ReloadPageButton neu gestartet werden. Außerdem verfügt der Browser-Mode über Buttons, mit denen eine Vorwärts- und Rückwärtsnavigation möglich ist. CancelButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Content Über den Datasource Content können Inhalte wie z.B. HTML-Content oder der Pfad zu einer Datei, die im Browser angezeigt werden soll, an den Client übertragen werden. Der Datasource ist unidirektional(nur von Broker zu Client) und hat höhere Priorität als Url. Ressourcen können mit fsbroker://RelativerPfad angezeigt oder verwendet werden. Mit der Funktion CreateRessourcesUrl( ) der Klasse BrowserCommand kann eine Broker-Url erstellt werden. Diese Url kann dann, wie in dem nachfolgenden Beispiel, in Verbindung mit HTML als Link zu einer Datei verwendet warden: EnableJavaScript Gibt an, ob JavaScript im Browser aktiviert ist. ForwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ForwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. LoadPageButtonIcon Pfad zu einem Icon, das für den jeweiligen Button MLBackwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. MLCancelButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. MLForwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. MLLoadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. MLReloadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. MLZoomInButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. MLZoomOutButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. MLZoomResetButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. ReloadButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ReloadButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ShowStatusBar Gibt an, ob die Statusleiste (Ladestatus der aktuellen Seite + MouseOver Link) angezeigt wird. Die Statusleiste wird nur in Verbindung mit dem BrowserMode angezeigt. ShowZoomBar Gibt an, ob die Leiste zur Änderung der Größe des Inhalts im Browser angezeigt wird. Url Mit dem Datasource Url können Webseiten, die im Browser angezeigt werden sollen, an den Client übertragen werden. Der Datasource ist unidirektional (nur von Broker zu Client). ZoomInButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ZoomInButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ZoomOutButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ZoomResetButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ZoomResetButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Events OnLinkClick Tritt ein, wenn ein Html-Link mit der Maus angeklickt wurde. Um eine Client-seitige Navigation zu unterbinden, werden alle Links an den Event-Args konsumiert und müssen, falls gewünscht, wieder manuell über einen der Datasources zum Client geschickt werden. OnPageError Tritt ein falls beim Laden der Seite ein Fehler aufgetreten ist Über das Event Argument können folgende Informationen über die Fehlermeldung ausgelesen werden: • Url: Gibt die Url zurück zu der navigiert werden sollte • Message: Gibt den Fehlergrund zurück OnPageLoaded Tritt ein, wenn die aktuelle Seite vom Browser fertig geladen ist. Das Event-Argument stellt die Adresse (url) und den Titel (title) der geladenen Seite zur Verfügung. OnSnapshotGenerated Tritt ein, wenn der Snapshot von der Action GenerateSnapshot erstellt wurde. • Snapshot: Gibt den Snapshot als Byte-Array im PNG Format zurück"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ContextMenu.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ContextMenu.html",
    "title": "Property ContextMenu",
    "keywords": "Property ContextMenu Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ContextMenu Gibt an, welches Kontextmenü geöffnet werden soll, wenn der Button betätigt wird. Ist ein Kontextmenü zugeordnet, so wird das Event OnClick nicht ausgelöst [Browsable(true)] [TypeConverter(typeof(RecordsConverter))] public DevControlMainMenuRecord ContextMenu { get; set; } Property Value DevControlMainMenuRecord See Also ContextMenuDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.IsSearchButton.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.IsSearchButton.html",
    "title": "Property IsSearchButton",
    "keywords": "Property IsSearchButton Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll IsSearchButton Gibt an, ob es sich bei dem Button um einen Such-Button handelt. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) [Browsable(true)] public bool? IsSearchButton { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.LoadAtComponent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.LoadAtComponent.html",
    "title": "Property LoadAtComponent",
    "keywords": "Property LoadAtComponent Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll LoadAtComponent Gibt die Component an, an welcher der Load ausgeführt werden soll (dies kann auch eine Collection sein). (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) [DevBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource LoadAtComponent { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCaption Gibt die Beschriftung des Buttons in den definierten Sprachen an. Siehe auch MLCaption in ControlDesignViewModel public override IMLString MLCaption { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.MapEnterToTabAction.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.MapEnterToTabAction.html",
    "title": "Property MapEnterToTabAction",
    "keywords": "Property MapEnterToTabAction Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MapEnterToTabAction [Browsable(true)] [ControlStylesBrowsable(true)] public bool? MapEnterToTabAction { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Wird bei einem Klick auf das Control ausgelöst. public event EventHandler<FrameworkButtonClickEventArgs> OnClick Returns EventHandler<FrameworkButtonClickEventArgs> Wird bei einem Klick auf das Control ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.SearchValuesComponent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.SearchValuesComponent.html",
    "title": "Property SearchValuesComponent",
    "keywords": "Property SearchValuesComponent Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SearchValuesComponent Gibt die Component an, aus der die Load-Condition erzeugt werden soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) [DevBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SearchValuesComponent { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Shortcut Legt ein Tastenkürzel(Tastenkombination) für den schnellen Zugriff auf den Button fest.Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, so wird das OnClick-Event des Buttons ausgelöst. Inherited(Bei der Auswahl dieses Wertes wird die Einstellung gelöscht und der Wert aus der Basis-Klasse oder den Default Control Styles gezogen) None(keine zugeordnet) [Browsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? Shortcut { get; set; } Property Value ExtendedShortcut?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ShowCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ShowCaption.html",
    "title": "Property ShowCaption",
    "keywords": "Property ShowCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ShowCaption [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowCaption { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.html",
    "title": "Class ButtonBaseDesignViewModel",
    "keywords": "Class ButtonBaseDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public abstract class ButtonBaseDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ButtonBaseDesignViewModel Implements INotifyPropertyChanged IDisposable Derived ButtonDesignViewModel ImageButtonDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ContextMenu Gibt an, welches Kontextmenü geöffnet werden soll, wenn der Button betätigt wird. Ist ein Kontextmenü zugeordnet, so wird das Event OnClick nicht ausgelöst IsSearchButton Gibt an, ob es sich bei dem Button um einen Such-Button handelt. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) LoadAtComponent Gibt die Component an, an welcher der Load ausgeführt werden soll (dies kann auch eine Collection sein). (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) MLCaption Gibt die Beschriftung des Buttons in den definierten Sprachen an. Siehe auch MLCaption in ControlDesignViewModel MapEnterToTabAction SearchValuesComponent Gibt die Component an, aus der die Load-Condition erzeugt werden soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) Shortcut Legt ein Tastenkürzel(Tastenkombination) für den schnellen Zugriff auf den Button fest.Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, so wird das OnClick-Event des Buttons ausgelöst. Inherited(Bei der Auswahl dieses Wertes wird die Einstellung gelöscht und der Wert aus der Basis-Klasse oder den Default Control Styles gezogen) None(keine zugeordnet) ShowCaption Events OnClick Wird bei einem Klick auf das Control ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.TypeName.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.TypeName.html",
    "title": "Property TypeName",
    "keywords": "Property TypeName Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TypeName public override string TypeName { get; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.html",
    "title": "Class ButtonDesignViewModel",
    "keywords": "Class ButtonDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control Button. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class ButtonDesignViewModel : ButtonBaseDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ButtonBaseDesignViewModel ButtonDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ButtonBaseDesignViewModel.MLCaption ButtonBaseDesignViewModel.MapEnterToTabAction ButtonBaseDesignViewModel.Shortcut ButtonBaseDesignViewModel.ShowCaption ButtonBaseDesignViewModel.IsSearchButton ButtonBaseDesignViewModel.LoadAtComponent ButtonBaseDesignViewModel.SearchValuesComponent ButtonBaseDesignViewModel.ContextMenu ButtonBaseDesignViewModel.OnClick ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties TypeName See Also ButtonControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Wird bei einem Klick auf das Control ausgelöst. public event EventHandler<FrameworkCheckBoxClickEventArgs> OnClick Returns EventHandler<FrameworkCheckBoxClickEventArgs> Wird bei einem Klick auf das Control ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.ShowCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.ShowCaption.html",
    "title": "Property ShowCaption",
    "keywords": "Property ShowCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ShowCaption [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowCaption { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.html",
    "title": "Class CheckBoxDesignViewModel",
    "keywords": "Class CheckBoxDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control CheckBox. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class CheckBoxDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel CheckBoxDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ShowCaption Events OnClick Wird bei einem Klick auf das Control ausgelöst. See Also CheckboxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll EditStyle [Browsable(true)] public ComboEditStyle? EditStyle { get; set; } Property Value ComboEditStyle?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.MaxDropDownSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.MaxDropDownSize.html",
    "title": "Property MaxDropDownSize",
    "keywords": "Property MaxDropDownSize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MaxDropDownSize [Browsable(true)] [ControlStylesBrowsable(true)] public virtual Size MaxDropDownSize { get; set; } Property Value Size"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.OnSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.OnSelectionChanged.html",
    "title": "Event OnSelectionChanged",
    "keywords": "Event OnSelectionChanged Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. public event EventHandler<FrameworkSelectionChangedEventArgs> OnSelectionChanged Returns EventHandler<FrameworkSelectionChangedEventArgs> Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.html",
    "title": "Class ComboboxDesignViewModel",
    "keywords": "Class ComboboxDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control Combobox. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class ComboboxDesignViewModel : ListBaseDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ListBaseDesignViewModel ComboboxDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ListBaseDesignViewModel.List ListBaseDesignViewModel.ListSortOrder ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties EditStyle MaxDropDownSize Events OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. See Also ComboBoxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.GenerateDocSection.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.GenerateDocSection.html",
    "title": "Property GenerateDocSection",
    "keywords": "Property GenerateDocSection Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll GenerateDocSection Gibt an, ob in der Dokumentation für den Container ein separates Kapitel generiert werden soll. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? GenerateDocSection { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.html",
    "title": "Class ContainerDesignViewModel",
    "keywords": "Class ContainerDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public abstract class ContainerDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel Implements INotifyPropertyChanged IDisposable Derived FieldRowDesignViewModel GridDesignViewModel MainMenuDesignViewModel TabPageDesignViewModel TabbedWindowDesignViewModel TreeNodeDesignViewModel TreeViewDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties GenerateDocSection Gibt an, ob in der Dokumentation für den Container ein separates Kapitel generiert werden soll."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DataSource Ohne Funktion. public override IDatasource DataSource { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCaption Dient lediglich der Bezeichnung in der generierten Dokumentation. public override IMLString MLCaption { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.html",
    "title": "Class ContextMenuDesignViewModel",
    "keywords": "Class ContextMenuDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control ContextMenu. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class ContextMenuDesignViewModel : MainMenuDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel MainMenuDesignViewModel ContextMenuDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members MainMenuDesignViewModel.Checked MainMenuDesignViewModel.MLTooltip MainMenuDesignViewModel.Shortcut MainMenuDesignViewModel.Image MainMenuDesignViewModel.OnClick MainMenuDesignViewModel.OnEnter MainMenuDesignViewModel.OnLeave MainMenuDesignViewModel.OnCanDrop MainMenuDesignViewModel.OnDrag ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties DataSource Ohne Funktion. MLCaption Dient lediglich der Bezeichnung in der generierten Dokumentation. See Also MainMenuControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Alignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Alignment.html",
    "title": "Property Alignment",
    "keywords": "Property Alignment Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Alignment Gibt an, wie sich das Control in seinem Container ausrichten soll. Standardwerte sind Stretch und Stretch [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(AlignmentObjectConverter<HorizontalAlignment, VerticalAlignment>))] public Alignment<HorizontalAlignment, VerticalAlignment> Alignment { get; set; } Property Value Alignment<HorizontalAlignment, VerticalAlignment>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BackColor Gibt die Hintergrund-Farbe des Controls an. Über den Alpha-Kanal (Transparenz-Wert) der Farbe kann die Transparenz des Controls gesteuert werden. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? BackColor { get; set; } Property Value Color?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderColor.html",
    "title": "Property BorderColor",
    "keywords": "Property BorderColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BorderColor Gibt die Farbe des Rands um das Control herum an. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? BorderColor { get; set; } Property Value Color?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderRadius.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderRadius.html",
    "title": "Property BorderRadius",
    "keywords": "Property BorderRadius Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BorderRadius Gibt den Radius für die Rundung des Randes an. Die Unter-Eigenschaften TopLeft, TopRight, BottomRight und BottomLeft können getrennt voneinander angegeben oder überschrieben werden. [Browsable(true)] [ControlStylesBrowsable(true)] public BorderRadius BorderRadius { get; set; } Property Value BorderRadius"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderThickness.html",
    "title": "Property BorderThickness",
    "keywords": "Property BorderThickness Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BorderThickness Gibt die Dicke des Rands um das Control herum an.Der Rand wird in die Größe des Controls hineingerechnet.Die Unter-Eigenschaften Left, Top, Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. [Browsable(true)] [ControlStylesBrowsable(true)] public virtual Bounds BorderThickness { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CaptionAsPlaceholder.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CaptionAsPlaceholder.html",
    "title": "Property CaptionAsPlaceholder",
    "keywords": "Property CaptionAsPlaceholder Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll CaptionAsPlaceholder Gibt an, ob die Caption des Controls als Placeholder angezeigt werden soll. [Browsable(true)] [ControlStylesBrowsable] public virtual bool? CaptionAsPlaceholder { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ControlEvents.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ControlEvents.html",
    "title": "Property ControlEvents",
    "keywords": "Property ControlEvents Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ControlEvents Dieses Property dient dazu, den Editor für die Events anzuzeigen. Es selber selber keinen relevanten Wert. (siehe Events) [Browsable(true)] public object ControlEvents { get; set; } Property Value object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CtrlStyleName.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CtrlStyleName.html",
    "title": "Property CtrlStyleName",
    "keywords": "Property CtrlStyleName Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll CtrlStyleName [Browsable(true)] public string CtrlStyleName { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DataSource [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public virtual IDatasource DataSource { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DisabledBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DisabledBackColor.html",
    "title": "Property DisabledBackColor",
    "keywords": "Property DisabledBackColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DisabledBackColor Definiert die Hintergrundfarbe, wenn das Control deaktiviert ist. Diese Einstellung kann für ComboboxDesignViewModel und EditboxDesignViewModel gesetzt werden. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? DisabledBackColor { get; set; } Property Value Color?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Documentation.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Documentation.html",
    "title": "Property Documentation",
    "keywords": "Property Documentation Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Documentation Öffnet den Dokumentations-Editor (siehe Editor) [Browsable(true)] public object Documentation { get; set; } Property Value object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Font.html",
    "title": "Property Font",
    "keywords": "Property Font Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Font Hier kann die Schrift des Controls eingestellt werden. Die Unter-Properties Family, Size, Bold, Italic und Underline können jeweils getrennt voneinander überschrieben werden. Die Size definiert, wieviel Pixel Platz die Schrift insgesamt bei einer Skalierung von 100% verbraucht.Somit ergibt sich aus Summe der Size und den Properties Padding, BorderThickness und Margin die tatsächliche Höhe des Controls. [Browsable(true)] [ControlStylesBrowsable(true)] public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ForeColor Schriftfarbe. Über die Action SetForeColor(Color?) kann die Farbe zur Laufzeit geändert werden. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? ForeColor { get; set; } Property Value Color?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.FullTextSearch.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.FullTextSearch.html",
    "title": "Property FullTextSearch",
    "keywords": "Property FullTextSearch Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll FullTextSearch Unter den folgenden Bedingungen: FullTextSearch und IsSearchField aktiviert und SearchOperator ist 'Like' wird für das Control in die automatisch generierte Load-Condition ein zusätzlicher %-Wildcard vor das Control hinzugefügt und somit eine FullText Suche aktiviert. Generierter Code Beispiel: ((\"like\", \"%\" + form.Control + \"%\") [Browsable(true)] public bool? FullTextSearch { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.HideInDocumentation.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.HideInDocumentation.html",
    "title": "Property HideInDocumentation",
    "keywords": "Property HideInDocumentation Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? HideInDocumentation { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll IsEditable Wenn hier true gesetzt ist, ist das Control editierbar. Ansonsten ist das Control für Eingaben gesperrt. Über die Action SetEnabled(bool?) kann das Control zur Laufzeit gesperrt werden. [Browsable(true)] public virtual bool? IsEditable { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditableAU.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditableAU.html",
    "title": "Property IsEditableAU",
    "keywords": "Property IsEditableAU Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll IsEditableAU Das IsEditable Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU) [Browsable(true)] public virtual AccessUnitList IsEditableAU { get; set; } Property Value AccessUnitList"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsSearchField.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsSearchField.html",
    "title": "Property IsSearchField",
    "keywords": "Property IsSearchField Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll IsSearchField Soll sich das Control in die automatisch generierte Load-Condition eintragen, muss dieses Property auf True gesetzt werden. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) [Browsable(true)] public bool? IsSearchField { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsVisibleAU.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsVisibleAU.html",
    "title": "Property IsVisibleAU",
    "keywords": "Property IsVisibleAU Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll IsVisibleAU Das IsVisible Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU) [Browsable(true)] public virtual AccessUnitList IsVisibleAU { get; set; } Property Value AccessUnitList"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.LabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.LabelTemplate.html",
    "title": "Property LabelTemplate",
    "keywords": "Property LabelTemplate Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll LabelTemplate [Browsable(true)] [ControlStylesBrowsable(true)] public ControlLabelTemplate LabelTemplate { get; set; } Property Value ControlLabelTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCaption Gibt eine mehrsprachige Beschriftung des Controls an. Je nach Control wird diese entweder selber vom Control angezeigt (z.B. Button, ImageButton, Label) oder es wird durch das FieldPanel ein Label mit dieser Beschriftung generiert (z.B. Editfield, Combobox). [Browsable(true)] [ControlStylesBrowsable] public virtual IMLString MLCaption { get; set; } Property Value IMLString Remarks Auch wenn die Beschriftung nicht direkt in der Oberfläche angezeigt wird, kann es dennoch sinnvoll sein, sie anzugeben. Sie wird dann z.B. in der Dokumentation benutzt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MLTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MLTooltip.html",
    "title": "Property MLTooltip",
    "keywords": "Property MLTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Control, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. [ControlStylesBrowsable(true)] public virtual IMLString MLTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Margin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Margin.html",
    "title": "Property Margin",
    "keywords": "Property Margin Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Margin Gibt den äußeren Rand um das Control herum an. Der Margin wird nicht in die Größe des Controls hineingerechnet. Die Unter-Eigenschaften Left, Top, Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. [Browsable(true)] [ControlStylesBrowsable(true)] public Bounds Margin { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MaxSize Gibt die maximale Größe des Controls an. Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin. Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. [Browsable(true)] [ControlStylesBrowsable(true)] public NonableSize MaxSize { get; set; } Property Value NonableSize Remarks Der spezielle Wert None definiert keine Angabe der Größe. Er muss vom Wert 0 unterschieden werden – damit wird das Control nicht angezeigt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MinSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MinSize.html",
    "title": "Property MinSize",
    "keywords": "Property MinSize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MinSize Gibt die minimale Größe des Controls an.Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin.Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. [Browsable(true)] [ControlStylesBrowsable(true)] public NonableSize MinSize { get; set; } Property Value NonableSize Remarks Der spezielle Wert None definiert keine Angabe der Größe.Er muss vom Wert 0 unterschieden werden."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnCanDrop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnCanDrop.html",
    "title": "Event OnCanDrop",
    "keywords": "Event OnCanDrop Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public event EventHandler<FrameworkOnCanDropEventArgs> OnCanDrop Returns EventHandler<FrameworkOnCanDropEventArgs>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnDrag.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnDrag.html",
    "title": "Event OnDrag",
    "keywords": "Event OnDrag Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public event EventHandler<FrameworkOnDragEventArgs> OnDrag Returns EventHandler<FrameworkOnDragEventArgs>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnEnter.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnEnter.html",
    "title": "Event OnEnter",
    "keywords": "Event OnEnter Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Wird beim setzen des Fokus auf ein Control ausgelöst. public event EventHandler<FrameworkEventArgs> OnEnter Returns EventHandler<FrameworkEventArgs> Wird beim setzen des Fokus auf ein Control ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnLeave.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnLeave.html",
    "title": "Event OnLeave",
    "keywords": "Event OnLeave Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Wird beim Entfernen des Fokus von einem Control ausgelöst. Wenn sich der Wert des Controls geändert hat, wird vor diesem Event das Event OnValidated ausgelöst. public event EventHandler<FrameworkOnLeaveEventArgs> OnLeave Returns EventHandler<FrameworkOnLeaveEventArgs> Wird beim Entfernen des Fokus von einem Control ausgelöst. Wenn sich der Wert des Controls geändert hat, wird vor diesem Event das Event ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Padding Gibt den inneren Rand des Controls – also den Abstand des Control-Inhalts zur Border an.Die Unter-Eigenschaften Left, Top, Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. [Browsable(true)] [ControlStylesBrowsable(true)] public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.SearchOperator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.SearchOperator.html",
    "title": "Property SearchOperator",
    "keywords": "Property SearchOperator Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SearchOperator Gibt an, mit welchem Operator sich das Control in die Load-Condition eintragen soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) [Browsable(true)] public SearchCompareOperator? SearchOperator { get; set; } Property Value SearchCompareOperator?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TabStop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TabStop.html",
    "title": "Property TabStop",
    "keywords": "Property TabStop Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TabStop Wenn dieses Property den Wert true besitzt, wird das Steuerelement bei der Fokustraversierung mittels Tastatur erfasst. Ist es auf false, so wird das Steuerelement bei der Tab-Reihenfolge überspringen. Der Standardwert für die Eigenschaft ist true. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? TabStop { get; set; } Property Value bool? Remarks Sie ist nicht Theme-fähig und kann an allen Steuerelementen mit Ausnahme der folgenden gesetzt werden: Alle Container-Steuerelemente Grid Columns Labels Pictures Tree View Columns Tree View Nodes Menus Custom Controls"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Visibility.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Visibility.html",
    "title": "Property Visibility",
    "keywords": "Property Visibility Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Visibility Steuert die Sichtbarkeit des Controls. Über die Control-Action SetVisible(FSVisibility?) kann die Eigenschaft zur Laufzeit geändert werden. [Browsable(true)] [ControlStylesBrowsable(true)] public FSVisibility? Visibility { get; set; } Property Value FSVisibility?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.html",
    "title": "Class ControlDesignViewModel",
    "keywords": "Class ControlDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public abstract class ControlDesignViewModel : ControlTreeNode, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel Implements INotifyPropertyChanged IDisposable Derived BrowserDesignViewModel ButtonBaseDesignViewModel CheckBoxDesignViewModel ContainerDesignViewModel DashBoardContainerViewModel EditboxDesignViewModel FormContainerDesignViewModel GridColDesignViewModel LabelDesignViewModel ListBaseDesignViewModel ListViewDesignViewModel PictureDesignViewModel RadioButtonDesignViewModel TemplateControlDesignViewModel Inherited Members ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Alignment Gibt an, wie sich das Control in seinem Container ausrichten soll. Standardwerte sind Stretch und Stretch BackColor Gibt die Hintergrund-Farbe des Controls an. Über den Alpha-Kanal (Transparenz-Wert) der Farbe kann die Transparenz des Controls gesteuert werden. BorderColor Gibt die Farbe des Rands um das Control herum an. BorderRadius Gibt den Radius für die Rundung des Randes an. Die Unter-Eigenschaften TopLeft, TopRight, BottomRight und BottomLeft können getrennt voneinander angegeben oder überschrieben werden. BorderThickness Gibt die Dicke des Rands um das Control herum an.Der Rand wird in die Größe des Controls hineingerechnet.Die Unter-Eigenschaften Left, Top, Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. CaptionAsPlaceholder Gibt an, ob die Caption des Controls als Placeholder angezeigt werden soll. ControlEvents Dieses Property dient dazu, den Editor für die Events anzuzeigen. Es selber selber keinen relevanten Wert. (siehe Events) CtrlStyleName DataSource DisabledBackColor Definiert die Hintergrundfarbe, wenn das Control deaktiviert ist. Diese Einstellung kann für ComboboxDesignViewModel und EditboxDesignViewModel gesetzt werden. Documentation Öffnet den Dokumentations-Editor (siehe Editor) Font Hier kann die Schrift des Controls eingestellt werden. Die Unter-Properties Family, Size, Bold, Italic und Underline können jeweils getrennt voneinander überschrieben werden. Die Size definiert, wieviel Pixel Platz die Schrift insgesamt bei einer Skalierung von 100% verbraucht.Somit ergibt sich aus Summe der Size und den Properties Padding, BorderThickness und Margin die tatsächliche Höhe des Controls. ForeColor Schriftfarbe. Über die Action SetForeColor(Color?) kann die Farbe zur Laufzeit geändert werden. FullTextSearch Unter den folgenden Bedingungen: FullTextSearch und IsSearchField aktiviert und SearchOperator ist 'Like' wird für das Control in die automatisch generierte Load-Condition ein zusätzlicher %-Wildcard vor das Control hinzugefügt und somit eine FullText Suche aktiviert. Generierter Code Beispiel: ((\"like\", \"%\" + form.Control + \"%\") HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. IsEditable Wenn hier true gesetzt ist, ist das Control editierbar. Ansonsten ist das Control für Eingaben gesperrt. Über die Action SetEnabled(bool?) kann das Control zur Laufzeit gesperrt werden. IsEditableAU Das IsEditable Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU) IsSearchField Soll sich das Control in die automatisch generierte Load-Condition eintragen, muss dieses Property auf True gesetzt werden. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) IsVisibleAU Das IsVisible Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU) LabelTemplate MLCaption Gibt eine mehrsprachige Beschriftung des Controls an. Je nach Control wird diese entweder selber vom Control angezeigt (z.B. Button, ImageButton, Label) oder es wird durch das FieldPanel ein Label mit dieser Beschriftung generiert (z.B. Editfield, Combobox). MLTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Control, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Margin Gibt den äußeren Rand um das Control herum an. Der Margin wird nicht in die Größe des Controls hineingerechnet. Die Unter-Eigenschaften Left, Top, Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. MaxSize Gibt die maximale Größe des Controls an. Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin. Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. MinSize Gibt die minimale Größe des Controls an.Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin.Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. Padding Gibt den inneren Rand des Controls – also den Abstand des Control-Inhalts zur Border an.Die Unter-Eigenschaften Left, Top, Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. SearchOperator Gibt an, mit welchem Operator sich das Control in die Load-Condition eintragen soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität.) TabStop Wenn dieses Property den Wert true besitzt, wird das Steuerelement bei der Fokustraversierung mittels Tastatur erfasst. Ist es auf false, so wird das Steuerelement bei der Tab-Reihenfolge überspringen. Der Standardwert für die Eigenschaft ist true. Visibility Steuert die Sichtbarkeit des Controls. Über die Control-Action SetVisible(FSVisibility?) kann die Eigenschaft zur Laufzeit geändert werden. Events OnCanDrop OnDrag OnEnter Wird beim setzen des Fokus auf ein Control ausgelöst. OnLeave Wird beim Entfernen des Fokus von einem Control ausgelöst. Wenn sich der Wert des Controls geändert hat, wird vor diesem Event das Event OnValidated ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.BorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.BorderThickness.html",
    "title": "Property BorderThickness",
    "keywords": "Property BorderThickness Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BorderThickness Dieses Property weicht zu den allgemeinen Properties ab. Die Border wird, wie beim TabbedWindow, um die Tab-Pages des Dash-Boards gezeichnet. (Siehe BorderThickness) public override Bounds BorderThickness { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.Columns.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.Columns.html",
    "title": "Property Columns",
    "keywords": "Property Columns Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Columns [Browsable(true)] [ControlStylesBrowsable(true)] public int? Columns { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentBackColor.html",
    "title": "Property ContentBackColor",
    "keywords": "Property ContentBackColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ContentBackColor Die Hintergrund-Farbe in den Tab-Pages des Dash-Boards. Das Property BackColor hingegen zieht außerhalb der Tab-Pages - u.a. in dem Bereich um die Registerkarte-Karten. [Browsable(true)] [ControlStylesBrowsable(true)] public Color ContentBackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentPadding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentPadding.html",
    "title": "Property ContentPadding",
    "keywords": "Property ContentPadding Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ContentPadding Der Abstand der Dash-Items zum Rand der Tab-Page. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin. [Browsable(true)] [ControlStylesBrowsable(true)] public Bounds ContentPadding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderColor.html",
    "title": "Property ItemBorderColor",
    "keywords": "Property ItemBorderColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ItemBorderColor Gibt die Farbe des Rahmens um die Dash-Items an. Diese Eigenschaft kann im Default-Control-Style theme-spezifisch angegeben werden. [Browsable(true)] [ControlStylesBrowsable(true)] public Color ItemBorderColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderMargin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderMargin.html",
    "title": "Property ItemBorderMargin",
    "keywords": "Property ItemBorderMargin Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ItemBorderMargin Gibt die Dicke des (transparenten) Randes für jedes Dash-Item an. Dieser wird außerhalb des colorierten Rahmen angezeigt. Der Standard-Wert ist 2. [Browsable(true)] [ControlStylesBrowsable(true)] public int? ItemBorderMargin { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderThickness.html",
    "title": "Property ItemBorderThickness",
    "keywords": "Property ItemBorderThickness Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ItemBorderThickness Gibt die Dicke des farbigen Rahmens um jedes Dash-Item an. Zum Ausblenden des Rahmens kann der Wert 0 angegeben werden. Der Standard-Wert ist 3. [Browsable(true)] [ControlStylesBrowsable(true)] public int? ItemBorderThickness { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemGap.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemGap.html",
    "title": "Property ItemGap",
    "keywords": "Property ItemGap Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ItemGap Gibt den horizontalen und vertikalen Abstand zwischen den Dash-Items an. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin. Standard-Wert und bisheriges Verhalten ist 0 [Browsable(true)] [ControlStylesBrowsable(true)] public int? ItemGap { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLAddColumnTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLAddColumnTooltip.html",
    "title": "Property MLAddColumnTooltip",
    "keywords": "Property MLAddColumnTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLAddColumnTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLAddColumnTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLAddPageTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLAddPageTooltip.html",
    "title": "Property MLAddPageTooltip",
    "keywords": "Property MLAddPageTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLAddPageTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLAddPageTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLCloseDashItemTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLCloseDashItemTooltip.html",
    "title": "Property MLCloseDashItemTooltip",
    "keywords": "Property MLCloseDashItemTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCloseDashItemTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLCloseDashItemTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLClosePageTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLClosePageTooltip.html",
    "title": "Property MLClosePageTooltip",
    "keywords": "Property MLClosePageTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLClosePageTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLClosePageTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLCollapseDashItemTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLCollapseDashItemTooltip.html",
    "title": "Property MLCollapseDashItemTooltip",
    "keywords": "Property MLCollapseDashItemTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCollapseDashItemTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLCollapseDashItemTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLExpandDashItemTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLExpandDashItemTooltip.html",
    "title": "Property MLExpandDashItemTooltip",
    "keywords": "Property MLExpandDashItemTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLExpandDashItemTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLExpandDashItemTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLMaximzeDashItemTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLMaximzeDashItemTooltip.html",
    "title": "Property MLMaximzeDashItemTooltip",
    "keywords": "Property MLMaximzeDashItemTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLMaximzeDashItemTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLMaximzeDashItemTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLMoveDashItemTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLMoveDashItemTooltip.html",
    "title": "Property MLMoveDashItemTooltip",
    "keywords": "Property MLMoveDashItemTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLMoveDashItemTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLMoveDashItemTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLRemoveColumnTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLRemoveColumnTooltip.html",
    "title": "Property MLRemoveColumnTooltip",
    "keywords": "Property MLRemoveColumnTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLRemoveColumnTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLRemoveColumnTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLRestoreDashItemTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.MLRestoreDashItemTooltip.html",
    "title": "Property MLRestoreDashItemTooltip",
    "keywords": "Property MLRestoreDashItemTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLRestoreDashItemTooltip [Browsable(true)] [ControlStylesBrowsable] public IMLString MLRestoreDashItemTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.OnLayoutChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.OnLayoutChanged.html",
    "title": "Event OnLayoutChanged",
    "keywords": "Event OnLayoutChanged Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public event EventHandler<FrameworkEventArgs> OnLayoutChanged Returns EventHandler<FrameworkEventArgs>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateActive.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateActive.html",
    "title": "Property TabTemplateActive",
    "keywords": "Property TabTemplateActive Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TabTemplateActive Hier werden die Layout-Einstellungen der aktiven Registerkarte vorgenommen. [Browsable(true)] [ControlStylesBrowsable(true)] public TabTemplate TabTemplateActive { get; } Property Value TabTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateInactive.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateInactive.html",
    "title": "Property TabTemplateInactive",
    "keywords": "Property TabTemplateInactive Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TabTemplateInactive Hier werden die Layout-Einstellungen der inaktiven Registerkarte vorgenommen. [Browsable(true)] [ControlStylesBrowsable(true)] public TabTemplate TabTemplateInactive { get; } Property Value TabTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.html",
    "title": "Class DashBoardContainerViewModel",
    "keywords": "Class DashBoardContainerViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control DashboardContainer. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class DashBoardContainerViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel DashBoardContainerViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties BorderThickness Dieses Property weicht zu den allgemeinen Properties ab. Die Border wird, wie beim TabbedWindow, um die Tab-Pages des Dash-Boards gezeichnet. (Siehe BorderThickness) Columns ContentBackColor Die Hintergrund-Farbe in den Tab-Pages des Dash-Boards. Das Property BackColor hingegen zieht außerhalb der Tab-Pages - u.a. in dem Bereich um die Registerkarte-Karten. ContentPadding Der Abstand der Dash-Items zum Rand der Tab-Page. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin. ItemBorderColor Gibt die Farbe des Rahmens um die Dash-Items an. Diese Eigenschaft kann im Default-Control-Style theme-spezifisch angegeben werden. ItemBorderMargin Gibt die Dicke des (transparenten) Randes für jedes Dash-Item an. Dieser wird außerhalb des colorierten Rahmen angezeigt. Der Standard-Wert ist 2. ItemBorderThickness Gibt die Dicke des farbigen Rahmens um jedes Dash-Item an. Zum Ausblenden des Rahmens kann der Wert 0 angegeben werden. Der Standard-Wert ist 3. ItemGap Gibt den horizontalen und vertikalen Abstand zwischen den Dash-Items an. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin. Standard-Wert und bisheriges Verhalten ist 0 MLAddColumnTooltip MLAddPageTooltip MLCloseDashItemTooltip MLClosePageTooltip MLCollapseDashItemTooltip MLExpandDashItemTooltip MLMaximzeDashItemTooltip MLMoveDashItemTooltip MLRemoveColumnTooltip MLRestoreDashItemTooltip TabTemplateActive Hier werden die Layout-Einstellungen der aktiven Registerkarte vorgenommen. TabTemplateInactive Hier werden die Layout-Einstellungen der inaktiven Registerkarte vorgenommen. Events OnLayoutChanged See Also DashboardContainerControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.DockPanelOrientation.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.DockPanelOrientation.html",
    "title": "Property DockPanelOrientation",
    "keywords": "Property DockPanelOrientation Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DockPanelOrientation Horizontal: Die Controls werden nebeneinander platziert. Vertical: Die Controls werden übereinander platziert. HorizontalOrVertical: Die Controls werden nebeneinander platziert. Reicht der Platz nicht aus, „klappt“ das DockPanel auf die Seite und die Controls werden übereinander platziert. [Browsable(true)] [ControlStylesBrowsable(true)] public DockPanelOrientation? DockPanelOrientation { get; set; } Property Value DockPanelOrientation?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.html",
    "title": "Class DockPanelDesignViewModel",
    "keywords": "Class DockPanelDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class DockPanelDesignViewModel : SpaceableContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel LayoutContainerDesignViewModel SpaceableContainerDesignViewModel DockPanelDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties DockPanelOrientation Horizontal: Die Controls werden nebeneinander platziert. Vertical: Die Controls werden übereinander platziert. HorizontalOrVertical: Die Controls werden nebeneinander platziert. Reicht der Platz nicht aus, „klappt“ das DockPanel auf die Seite und die Controls werden übereinander platziert."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DataSource Gibt an, mit welcher Membervariable oder welchem Property das Editfield verbunden werden soll. Handelt es sich beim Datasource um ein schreibgeschütztes Property, wird das Property IsEditable auf False gesetzt und lässt sich nicht mehr ändern. Es sind Membervariablen oder Properties vom Typ String, Number (int, short, long...), Date, Boolean möglich. public override IDatasource DataSource { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Editor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Editor.html",
    "title": "Property Editor",
    "keywords": "Property Editor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Editor [Browsable(true)] [ControlStylesBrowsable(true)] public TextEditorType? Editor { get; set; } Property Value TextEditorType?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Format.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Format [Browsable(true)] [ControlStylesBrowsable(true)] public FrameworkFormatMask? Format { get; set; } Property Value FrameworkFormatMask?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll FormatPattern [Browsable(true)] [ControlStylesBrowsable(true)] public string FormatPattern { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Multiline.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Multiline.html",
    "title": "Property Multiline",
    "keywords": "Property Multiline Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Multiline Gibt an, ob es sich bei dem Editfield um ein Multiline-Field handelt. Wenn ja, sind mehrzeilige Texteingaben und -anzeigen möglich. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? Multiline { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.OnValidated.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.OnValidated.html",
    "title": "Event OnValidated",
    "keywords": "Event OnValidated Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein, wenn der Fokus von dem Editfeld genommen wird und der Wert geändert wurde. Nach diesem Event wird das OnLeave Event mit Parameter HasValueChanged = true ausgelöst. public event EventHandler<FrameworkEventArgs> OnValidated Returns EventHandler<FrameworkEventArgs> Tritt ein, wenn der Fokus von dem Editfeld genommen wird und der Wert geändert wurde. Nach diesem Event wird das OnLeave Event mit Parameter = true ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.PasswordChar.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.PasswordChar.html",
    "title": "Property PasswordChar",
    "keywords": "Property PasswordChar Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll PasswordChar Hier kann ein Zeichen angegeben werden, das bei einer Passworteingabe als Platzhalter angezeigt werden soll, z.B. *. [Browsable(true)] [ControlStylesBrowsable(true)] public char PasswordChar { get; set; } Property Value char"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.ScrollBars.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.ScrollBars.html",
    "title": "Property ScrollBars",
    "keywords": "Property ScrollBars Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ScrollBars Gibt an, ob in dem Editfield Scrollbars angezeigt werden sollen. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. [Browsable(true)] [ControlStylesBrowsable(true)] [DevBrowsable(true)] public ScrollBars? ScrollBars { get; set; } Property Value ScrollBars?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionEnd.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionEnd.html",
    "title": "Property SelectionEnd",
    "keywords": "Property SelectionEnd Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SelectionEnd Die Endposition der Textauswahl [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectionEnd { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionStart.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionStart.html",
    "title": "Property SelectionStart",
    "keywords": "Property SelectionStart Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SelectionStart Die Startposition der Textauswahl [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectionStart { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TextAlign Gibt an, wie der Text im Editfield ausgerichtet sein soll. Bei Inherit wird die Angabe aus dem Default-Style gezogen. Bei DatatypeDefault werden Strings links und Datum und Nummern rechts ausgerichtet. [Browsable(true)] [ControlStylesBrowsable(true)] public DevTextAlign? TextAlign { get; set; } Property Value DevTextAlign?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.WordWrap.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.WordWrap.html",
    "title": "Property WordWrap",
    "keywords": "Property WordWrap Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll WordWrap Gibt an, ob der automatische Zeilenumbruch aktiviert werden soll. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? WordWrap { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.html",
    "title": "Class EditboxDesignViewModel",
    "keywords": "Class EditboxDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control EditField. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class EditboxDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel EditboxDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties DataSource Gibt an, mit welcher Membervariable oder welchem Property das Editfield verbunden werden soll. Handelt es sich beim Datasource um ein schreibgeschütztes Property, wird das Property IsEditable auf False gesetzt und lässt sich nicht mehr ändern. Es sind Membervariablen oder Properties vom Typ String, Number (int, short, long...), Date, Boolean möglich. Editor Format FormatPattern Multiline Gibt an, ob es sich bei dem Editfield um ein Multiline-Field handelt. Wenn ja, sind mehrzeilige Texteingaben und -anzeigen möglich. PasswordChar Hier kann ein Zeichen angegeben werden, das bei einer Passworteingabe als Platzhalter angezeigt werden soll, z.B. *. ScrollBars Gibt an, ob in dem Editfield Scrollbars angezeigt werden sollen. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. SelectionEnd Die Endposition der Textauswahl SelectionStart Die Startposition der Textauswahl TextAlign Gibt an, wie der Text im Editfield ausgerichtet sein soll. Bei Inherit wird die Angabe aus dem Default-Style gezogen. Bei DatatypeDefault werden Strings links und Datum und Nummern rechts ausgerichtet. WordWrap Gibt an, ob der automatische Zeilenumbruch aktiviert werden soll. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. Events OnValidated Tritt ein, wenn der Fokus von dem Editfeld genommen wird und der Wert geändert wurde. Nach diesem Event wird das OnLeave Event mit Parameter HasValueChanged = true ausgelöst. See Also EditboxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.RowLabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.RowLabelTemplate.html",
    "title": "Property RowLabelTemplate",
    "keywords": "Property RowLabelTemplate Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll RowLabelTemplate Jede FieldRow besitzt als erstes Control einen “RowLabel-Container”. In ihm wird das erste Control-Label(bzw.beim LabelMode NoneAligned das erste Control der FieldRow) platziert. Hier werden die Einstellungen für diesen RowLabel-Container vorgenommen.Die Einstellungen für die Control-Labels werden an den LabelTemplates der jeweiligen Controls vorgenommen. Mit MinSize und MaxSize kann die Größe des RowLabel-Containers definiert werden.So können die Labels ausgerichtet werden. Beim LabelMode GeneratedMerged werden alle Control-Labels nebeneinander in dem Container platziert.Zwischen den Labels wird ein Separator in Form eines Slash “/” angezeigt.Dessen Layout kann über die Separator-Eigenschaften des RowLabelTemplates gesteuert werden. [Browsable(true)] [ControlStylesBrowsable(true)] public RowLabelTemplate RowLabelTemplate { get; set; } Property Value RowLabelTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.SynchronizeColumns.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.SynchronizeColumns.html",
    "title": "Property SynchronizeColumns",
    "keywords": "Property SynchronizeColumns Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SynchronizeColumns Ist dieser Schalter gesetzt, dann werden die Controls in den FieldRows in Form einer Tabelle angeordnet. Dabei belegen jedes Control und jedes Control-Label genau eine Zelle dieser Tabelle. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? SynchronizeColumns { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.html",
    "title": "Class FieldPanelDesignViewModel",
    "keywords": "Class FieldPanelDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class FieldPanelDesignViewModel : LayoutContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel LayoutContainerDesignViewModel FieldPanelDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties RowLabelTemplate Jede FieldRow besitzt als erstes Control einen “RowLabel-Container”. In ihm wird das erste Control-Label(bzw.beim LabelMode NoneAligned das erste Control der FieldRow) platziert. Hier werden die Einstellungen für diesen RowLabel-Container vorgenommen.Die Einstellungen für die Control-Labels werden an den LabelTemplates der jeweiligen Controls vorgenommen. Mit MinSize und MaxSize kann die Größe des RowLabel-Containers definiert werden.So können die Labels ausgerichtet werden. Beim LabelMode GeneratedMerged werden alle Control-Labels nebeneinander in dem Container platziert.Zwischen den Labels wird ein Separator in Form eines Slash “/” angezeigt.Dessen Layout kann über die Separator-Eigenschaften des RowLabelTemplates gesteuert werden. SynchronizeColumns Ist dieser Schalter gesetzt, dann werden die Controls in den FieldRows in Form einer Tabelle angeordnet. Dabei belegen jedes Control und jedes Control-Label genau eine Zelle dieser Tabelle."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.FieldRowSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.FieldRowSize.html",
    "title": "Property FieldRowSize",
    "keywords": "Property FieldRowSize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll FieldRowSize Wird das FieldPanel vertikal gestretched, dann kann über die FieldRowSize das Verhältnis angegeben warden, mit dem sich die einzelnen FieldRows vergrößern sollen. Bei der Angabe von None wird die FieldRow mit ihrer minimalen Höhe dargestellt. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] public Nonable<int>? FieldRowSize { get; set; } Property Value Nonable<int>?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.LabelMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.LabelMode.html",
    "title": "Property LabelMode",
    "keywords": "Property LabelMode Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll LabelMode Über die Eigenschaft LabelMode können Sie einstellen, wie für die Controls die Labels generiert werden sollen. [Browsable(true)] [ControlStylesBrowsable(true)] public FieldRowLabelMode? LabelMode { get; set; } Property Value FieldRowLabelMode?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.OptimizeGeneratedLabels.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.OptimizeGeneratedLabels.html",
    "title": "Property OptimizeGeneratedLabels",
    "keywords": "Property OptimizeGeneratedLabels Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll OptimizeGeneratedLabels Über diese Eigenschaft können von mehreren Labels redundante Worte zusammengefasst werden. Diese Einstelllung funktioniert sowohl im LabelMode Generated als auch GeneratedMerged. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? OptimizeGeneratedLabels { get; set; } Property Value bool? Examples • Artikelnr von; Artikelnr bis -> Artikelnr von / bis • von Datum; bis Datum -> von / bis Datum"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.html",
    "title": "Class FieldRowDesignViewModel",
    "keywords": "Class FieldRowDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class FieldRowDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FieldRowDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties FieldRowSize Wird das FieldPanel vertikal gestretched, dann kann über die FieldRowSize das Verhältnis angegeben warden, mit dem sich die einzelnen FieldRows vergrößern sollen. Bei der Angabe von None wird die FieldRow mit ihrer minimalen Höhe dargestellt. LabelMode Über die Eigenschaft LabelMode können Sie einstellen, wie für die Controls die Labels generiert werden sollen. OptimizeGeneratedLabels Über diese Eigenschaft können von mehreren Labels redundante Worte zusammengefasst werden. Diese Einstelllung funktioniert sowohl im LabelMode Generated als auch GeneratedMerged."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FormContainerDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FormContainerDesignViewModel.html",
    "title": "Class FormContainerDesignViewModel",
    "keywords": "Class FormContainerDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control FormContainer. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class FormContainerDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel FormContainerDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() See Also FormContainerControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.DependsDataSourceOnRowData.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.DependsDataSourceOnRowData.html",
    "title": "Property DependsDataSourceOnRowData",
    "keywords": "Property DependsDataSourceOnRowData Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DependsDataSourceOnRowData Ist als EditorStyle Combobox ausgewählt, können Sie im Property List einen DataSource für die Liste angeben. Dieses Property gibt an, ob sich die Liste auf ein Property des Collection-Objekts beziehen soll (True) oder nicht (False). Wenn True angegeben wird, werden unter List die Properties des Collection-Objekts angeboten. In diesem Fall wird für jede Zeile des Grids eine eigene Liste erstellt. Wenn False angegeben wurde, werden in List die Membervariablen des Forms angeboten. Es wird eine Liste für alle Zeilen des Grids erstellt. public bool? DependsDataSourceOnRowData { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll EditStyle [Browsable(true)] public ComboEditStyle? EditStyle { get; set; } Property Value ComboEditStyle?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditorStyle.html",
    "title": "Property EditorStyle",
    "keywords": "Property EditorStyle Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll EditorStyle Bei Editfield wird die Spalte als ganz normales Eingabefeld dargestellt. Bei Checkbox wird in der Spalte eine Checkbox dargestellt. Ist der Wert der Spalte true oder 1, wird die Checkbox gesetzt. Ist der Wert false oder 0, wird die Checkbox nicht gesetzt. Bei Combobox wird die Spalte als Combobox dargestellt. Es müssen dazu noch weitere Einstellungen bei den Properties DependsDataSourceOnRowData und List vorgenommen werden. [ControlStylesBrowsable(true)] public EditorStyle? EditorStyle { get; set; } Property Value EditorStyle?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Format.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Format Eingabedatentyp. Wird hier ein Format angegeben, lassen die Felder nur die Eingabe von Zeichen zu, die diesem Format entsprechen. [ControlStylesBrowsable(true)] public FrameworkFormatMask? Format { get; set; } Property Value FrameworkFormatMask?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll FormatPattern [Browsable(true)] [ControlStylesBrowsable(true)] public string FormatPattern { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.List.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.List.html",
    "title": "Property List",
    "keywords": "Property List Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll List Macht nur Sinn, wenn als EditorStyle Combobox ausgewählt ist. Gibt den Datasource an, aus welchem die Daten für die Liste gezogen werden sollen (analog zur Combobox). [DevBrowsable(true)] [TypeConverter(typeof(DataBindingConverter))] public ListDataSource List { get; set; } Property Value ListDataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCaption Gibt das Label der Spalte in den definierten Sprachen an. Die Caption wird über das Property ermittelt und kann überschrieben werden. public override IMLString MLCaption { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxDropDownSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxDropDownSize.html",
    "title": "Property MaxDropDownSize",
    "keywords": "Property MaxDropDownSize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MaxDropDownSize Gibt die maximale Höre der DropDown-Listes an. [Browsable(true)] [ControlStylesBrowsable(true)] public Size? MaxDropDownSize { get; set; } Property Value Size?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxWidth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxWidth.html",
    "title": "Property MaxWidth",
    "keywords": "Property MaxWidth Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MaxWidth Maximale Breite der Column in Pixel. [ControlStylesBrowsable(true)] [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] public Nonable<int>? MaxWidth { get; set; } Property Value Nonable<int>?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MinWidth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MinWidth.html",
    "title": "Property MinWidth",
    "keywords": "Property MinWidth Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MinWidth Minimale Breite der Column in Pixel. [ControlStylesBrowsable(true)] [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] public Nonable<int>? MinWidth { get; set; } Property Value Nonable<int>?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Name.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Name Zeigt den Namen der Column an. Der Name wird generiert und kann nicht geändert werden. Er setzt sich zusammen aus der Bezeichnung des Grids und des Property-Namen, der die Spalte repräsentiert, verbunden durch einen Unterstrich _. Heißt das Grid grdCustomer würde die Column lngCustomerID z.B. grdCustomer_lngCustomerID heißen. (schreibgeschützt) public override string Name { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnCellValidate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnCellValidate.html",
    "title": "Event OnCellValidate",
    "keywords": "Event OnCellValidate Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public event EventHandler<FrameworkOnCellValidateEventArgs> OnCellValidate Returns EventHandler<FrameworkOnCellValidateEventArgs>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStarting.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStarting.html",
    "title": "Event OnEditingStarting",
    "keywords": "Event OnEditingStarting Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Ereignis wird ausgelöst, sobald eine Zelle vom Nutzer bearbeitet wird. Bei der Verarbeitung dieses Events dürfen keine Dialoge geöffnet werden. public event EventHandler<FrameworkCellCancelEventArgs> OnEditingStarting Returns EventHandler<FrameworkCellCancelEventArgs> Dieses Ereignis wird ausgelöst, sobald eine Zelle vom Nutzer bearbeitet wird. Bei der Verarbeitung dieses Events dürfen keine Dialoge geöffnet werden."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStopped.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStopped.html",
    "title": "Event OnEditingStopped",
    "keywords": "Event OnEditingStopped Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Ereignis ist das Gegenstück zu OnEditingStarting. Es tritt auf, wenn der Benutzer die Bearbeitung einer Zelle beendet. Auch hier sollten keine Dialoge geöffnet werden. public event EventHandler<FrameworkCellEventArgs> OnEditingStopped Returns EventHandler<FrameworkCellEventArgs> Dieses Ereignis ist das Gegenstück zu OnEditingStarting. Es tritt auf, wenn der Benutzer die Bearbeitung einer Zelle beendet. Auch hier sollten keine Dialoge geöffnet werden."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Property.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Property.html",
    "title": "Property Property",
    "keywords": "Property Property Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Property [Browsable(true)] [TypeConverter(typeof(GridColRecordsConverter))] public PropertiesRecord Property { get; set; } Property Value PropertiesRecord"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TextAlign Gibt an, wie der Text in der Column ausgerichtet werden soll (links, rechts oder zentriert). Ist DatatypeDefault angegeben, werden Zahlen und Daten rechts und Text links ausgerichtet. [Browsable(true)] [ControlStylesBrowsable(true)] public DevTextAlign? TextAlign { get; set; } Property Value DevTextAlign?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.html",
    "title": "Class GridColDesignViewModel",
    "keywords": "Class GridColDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control Grid-Column. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class GridColDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel GridColDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties DependsDataSourceOnRowData Ist als EditorStyle Combobox ausgewählt, können Sie im Property List einen DataSource für die Liste angeben. Dieses Property gibt an, ob sich die Liste auf ein Property des Collection-Objekts beziehen soll (True) oder nicht (False). Wenn True angegeben wird, werden unter List die Properties des Collection-Objekts angeboten. In diesem Fall wird für jede Zeile des Grids eine eigene Liste erstellt. Wenn False angegeben wurde, werden in List die Membervariablen des Forms angeboten. Es wird eine Liste für alle Zeilen des Grids erstellt. EditStyle EditorStyle Bei Editfield wird die Spalte als ganz normales Eingabefeld dargestellt. Bei Checkbox wird in der Spalte eine Checkbox dargestellt. Ist der Wert der Spalte true oder 1, wird die Checkbox gesetzt. Ist der Wert false oder 0, wird die Checkbox nicht gesetzt. Bei Combobox wird die Spalte als Combobox dargestellt. Es müssen dazu noch weitere Einstellungen bei den Properties DependsDataSourceOnRowData und List vorgenommen werden. Format Eingabedatentyp. Wird hier ein Format angegeben, lassen die Felder nur die Eingabe von Zeichen zu, die diesem Format entsprechen. FormatPattern List Macht nur Sinn, wenn als EditorStyle Combobox ausgewählt ist. Gibt den Datasource an, aus welchem die Daten für die Liste gezogen werden sollen (analog zur Combobox). MLCaption Gibt das Label der Spalte in den definierten Sprachen an. Die Caption wird über das Property ermittelt und kann überschrieben werden. MaxDropDownSize Gibt die maximale Höre der DropDown-Listes an. MaxWidth Maximale Breite der Column in Pixel. MinWidth Minimale Breite der Column in Pixel. Name Zeigt den Namen der Column an. Der Name wird generiert und kann nicht geändert werden. Er setzt sich zusammen aus der Bezeichnung des Grids und des Property-Namen, der die Spalte repräsentiert, verbunden durch einen Unterstrich _. Heißt das Grid grdCustomer würde die Column lngCustomerID z.B. grdCustomer_lngCustomerID heißen. (schreibgeschützt) Property TextAlign Gibt an, wie der Text in der Column ausgerichtet werden soll (links, rechts oder zentriert). Ist DatatypeDefault angegeben, werden Zahlen und Daten rechts und Text links ausgerichtet. Events OnCellValidate OnEditingStarting Dieses Ereignis wird ausgelöst, sobald eine Zelle vom Nutzer bearbeitet wird. Bei der Verarbeitung dieses Events dürfen keine Dialoge geöffnet werden. OnEditingStopped Dieses Ereignis ist das Gegenstück zu OnEditingStarting. Es tritt auf, wenn der Benutzer die Bearbeitung einer Zelle beendet. Auch hier sollten keine Dialoge geöffnet werden. See Also GridColumnControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.BackColor2.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.BackColor2.html",
    "title": "Property BackColor2",
    "keywords": "Property BackColor2 Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BackColor2 Bestimmt die zeilenweise alternierende Hintergrundfarbe einer Tabelle. Für den Hintergrund der Grid-Zeilen wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Grid-Zeilen die BackColor verwendet [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor2 { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DataSource Gibt den Datasource an, dessen Daten im Grid angezeigt werden sollen. Es ist wichtig, dass Sie hier eine Collection angeben. public override IDatasource DataSource { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridColor.html",
    "title": "Property GridColor",
    "keywords": "Property GridColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll GridColor [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color GridColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridRowHeight.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridRowHeight.html",
    "title": "Property GridRowHeight",
    "keywords": "Property GridRowHeight Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll GridRowHeight Definiert die Höhe einer Zeile. Die Angabe erfolgt in Pixeln. Wenn kein Wert angegeben ist, dann berechnet der Client die Höhe der Zeile anhand der Schriftart. [Browsable(true)] [ControlStylesBrowsable(true)] public int? GridRowHeight { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.HeaderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.HeaderColor.html",
    "title": "Property HeaderColor",
    "keywords": "Property HeaderColor Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll HeaderColor Gibt die Hintergrundfarbe der Tabellenüberschrift an. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color HeaderColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll IsEditable Gibt an, ob am Grid Daten geändert werden dürfen. Ist IsEditable auf False gesetzt, wirkt sichdas auf alle Columns aus – egal, was dort angegeben ist. public override bool? IsEditable { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.MainMemorySortingThreshold.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.MainMemorySortingThreshold.html",
    "title": "Property MainMemorySortingThreshold",
    "keywords": "Property MainMemorySortingThreshold Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MainMemorySortingThreshold Grids bieten grundsätzlich die Möglichkeit, die dargestellten Daten nach einer Spalte zu sortieren oder zu filtern. Dazu stehen zwei Mechanismen (Datenbanksortierung und Hauptspeichersortierung) zur Verfügung. [Browsable(true)] [ControlStylesBrowsable(true)] public int? MainMemorySortingThreshold { get; set; } Property Value int? Remarks Hauptspeichersortierung: * **Vorteil:** Schnell Es kann nach allen Eigenschaften sortiert werden Jederzeit möglich. * **Nachteil:** Hoher Arbeitsspeicherverbrauch. Sortierung auf der Datenbank (Datenbanksortierung): * **Vorteil:** Geringer Arbeitsspeicherverbrauch auch bei großen Datenmengen. * **Nachteil:** Es kann nur nach Datenbankeigenschaften sortiert werden Etwas Langsamer Daten müssen in die Datenbank gespeichert worden sein Um die Vorteile beider Mechanismen nutzen zu können, verwendet Framework Studio beide Mechanismen, abhängig von der Menge der dargestellten Daten. Die Eigenschaft MainMemorySortingThreshold gibt den Grenzwert an, wieviele Datensätze die an das Grid gebundene Collection maximal enthalten darf, damit Hauptspeichersortierung verwendet wird. Werden Datensätze mit der Methode Add der Collection hinzugefügt, so wird der Grenzwert automatisch um die Anzahl hinzugefügter Datensätze erhöht. Wird die Eigenschaft nicht an einem Form Control geändert sondern direkt an einem Control Style, so müssen anschließend die Global Objects kompiliert werden, damit die Änderung wirksam wird."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.Multiselect.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.Multiselect.html",
    "title": "Property Multiselect",
    "keywords": "Property Multiselect Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Multiselect Gibt an, ob mehrere Zeilen ausgewählt werden können. Bei False kann nur maximal eine Zeile ausgewählt werden. Bei True ist die Auswahl mehrerer Zeilen möglich. Welche Zeilen ausgewählt sind, lässt sich in der SelectRowsCollection auswerten und setzen (siehe Property SelectedRows). [Browsable(true)] [ControlStylesBrowsable(true)] public bool? Multiselect { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.NewRowIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.NewRowIcon.html",
    "title": "Property NewRowIcon",
    "keywords": "Property NewRowIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll NewRowIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile neu hinzugefügt wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert New hat. [Browsable(true)] [ControlStylesBrowsable(true)] public string NewRowIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnAppendNewRow.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnAppendNewRow.html",
    "title": "Event OnAppendNewRow",
    "keywords": "Event OnAppendNewRow Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieser Vorgang wird ausgelöst, wenn in der letzten Zeile im letzten editierbaren Feld die Tab-Taste gedrückt wird. public event EventHandler<FrameworkEventArgs> OnAppendNewRow Returns EventHandler<FrameworkEventArgs> Dieser Vorgang wird ausgelöst, wenn in der letzten Zeile im letzten editierbaren Feld die Tab-Taste gedrückt wird."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnCellDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnCellDoubleClick.html",
    "title": "Event OnCellDoubleClick",
    "keywords": "Event OnCellDoubleClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt auf, wenn doppelt in eine Gridzelle (nicht RowHeader und nicht ColumnHeader) geklickt wurde. Das Event Argument stellt Spaltennummer (ColNum) und Datensatznummer (RowID) zur Verfügung. public event EventHandler<FrameworkCellDoubleClickEventArgs> OnCellDoubleClick Returns EventHandler<FrameworkCellDoubleClickEventArgs> Tritt auf, wenn doppelt in eine Gridzelle (nicht RowHeader und nicht ColumnHeader) geklickt wurde. Das Event Argument stellt Spaltennummer () und Datensatznummer () zur Verfügung."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnColumnChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnColumnChanged.html",
    "title": "Event OnColumnChanged",
    "keywords": "Event OnColumnChanged Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Wird ausgelöst, wenn sich der Inhalt einer Spalte geändert hat. Sie können über das EventArg e.RowID das Objekt ermitteln, bei dem das Event aufgetreten ist. public event EventHandler<FrameworkColumnChangedEventArgs> OnColumnChanged Returns EventHandler<FrameworkColumnChangedEventArgs> Wird ausgelöst, wenn sich der Inhalt einer Spalte geändert hat. Sie können über das EventArg e.RowID das Objekt ermitteln, bei dem das Event aufgetreten ist."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerClick.html",
    "title": "Event OnGridCornerClick",
    "keywords": "Event OnGridCornerClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt auf, wenn bei sichtbarer RowHeader-Spalte in die linke, obere Ecke geklickt wurde. public event EventHandler<FrameworkEventArgs> OnGridCornerClick Returns EventHandler<FrameworkEventArgs> Tritt auf, wenn bei sichtbarer RowHeader-Spalte in die linke, obere Ecke geklickt wurde. Examples"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerDoubleClick.html",
    "title": "Event OnGridCornerDoubleClick",
    "keywords": "Event OnGridCornerDoubleClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt auf, wenn bei sichtbarer RowHeader-Spalte doppelt in die linke, obere Ecke geklickt wurde. public event EventHandler<FrameworkEventArgs> OnGridCornerDoubleClick Returns EventHandler<FrameworkEventArgs> Tritt auf, wenn bei sichtbarer RowHeader-Spalte doppelt in die linke, obere Ecke geklickt wurde. Examples"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowClick.html",
    "title": "Event OnRowClick",
    "keywords": "Event OnRowClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt auf, wenn auf die Zeile geklickt wurde. public event EventHandler<FrameworkDoubleClickEventArgs> OnRowClick Returns EventHandler<FrameworkDoubleClickEventArgs> Tritt auf, wenn auf die Zeile geklickt wurde. Remarks Wenn eine Zeile einmal geklickt und dadurch selektiert wurde, wird bei einem erneuten Klick auf dieselbe Zeile kein weiteres OnRowClick-Event ausgelöst. So wird verhindert, dass das OnRowClick-Event für ein und dieselbe Zeile mehrfach hintereinander ausgelöst wird. Wenn dem Grid eine SelectedRowsCollection zugeordnet ist und auf Server-Seite die Selektion auf die zuletzt geklickte Zeile entfernt wird, dann wird bei einem erneuten Klick das Event wieder ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowDoubleClick.html",
    "title": "Event OnRowDoubleClick",
    "keywords": "Event OnRowDoubleClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt auf, wenn auf die Zeile doppelt geklickt wurde. public event EventHandler<FrameworkDoubleClickEventArgs> OnRowDoubleClick Returns EventHandler<FrameworkDoubleClickEventArgs> Tritt auf, wenn auf die Zeile doppelt geklickt wurde."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowSelectionChanged.html",
    "title": "Event OnRowSelectionChanged",
    "keywords": "Event OnRowSelectionChanged Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt auf, wenn sich die Selektion im Grid ändert - auch bei Deselektion von Datensätzen. Wenn dem Grid eine SelectedRowsCollection zugeordnet ist, wird diese durch das Event aktualisiert. public event EventHandler<FrameworkSelectionChangedEventArgs> OnRowSelectionChanged Returns EventHandler<FrameworkSelectionChangedEventArgs> Tritt auf, wenn sich die Selektion im Grid ändert - auch bei Deselektion von Datensätzen. Wenn dem Grid eine zugeordnet ist, wird diese durch das Event aktualisiert."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowsReloadEntry.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowsReloadEntry.html",
    "title": "Event OnRowsReloadEntry",
    "keywords": "Event OnRowsReloadEntry Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt auf, wenn Grid-Zeilen erstmalig an den Client übertragen werden, sowohl bei der initialien Übertragung als auch beim Nachladen von Zeilen. public event EventHandler<FrameworkOnReloadEventArgs> OnRowsReloadEntry Returns EventHandler<FrameworkOnReloadEventArgs> Tritt auf, wenn Grid-Zeilen erstmalig an den Client übertragen werden, sowohl bei der initialien Übertragung als auch beim Nachladen von Zeilen. Remarks Das Event Argument stellt zwei Listen zur Verfügung: RowList: Diese Liste enthält die Zeilennummern der betroffenen Datensätze. RowIDList: Diese Liste enthält die ObjectRowIDs der betroffenen Datensätze. Mit diesen kann der Datensatz direkt aus der Collection ermittelt werden (oMyColl[rowID]). Warning In diesem Event dürfen keine Daten manipuliert werden! Es eignet sich insbesondere für die Färbung oder das Deaktivieren von Gridzellen, abhängig von den dargestellten Daten."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnTableValidate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnTableValidate.html",
    "title": "Event OnTableValidate",
    "keywords": "Event OnTableValidate Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public event EventHandler<FrameworkOnTableValidateEventArgs> OnTableValidate Returns EventHandler<FrameworkOnTableValidateEventArgs>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowChangedIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowChangedIcon.html",
    "title": "Property RowChangedIcon",
    "keywords": "Property RowChangedIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll RowChangedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile geändert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert Changed hat. [Browsable(true)] [ControlStylesBrowsable(true)] public string RowChangedIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowDeletedIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowDeletedIcon.html",
    "title": "Property RowDeletedIcon",
    "keywords": "Property RowDeletedIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll RowDeletedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile zum Löschen markiert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property StateBeforeUpdate den Wert true hat. [Browsable(true)] [ControlStylesBrowsable(true)] public string RowDeletedIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeader.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeader.html",
    "title": "Property RowHeader",
    "keywords": "Property RowHeader Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll RowHeader Bestimmt, ob im Row-Header die Zeilennummer oder der Status des Rows angezeigt wird. [DevBrowsable(true)] [Browsable(true)] [ControlStylesBrowsable(true)] public GridRowHeader? RowHeader { get; set; } Property Value GridRowHeader?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeaderWidth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeaderWidth.html",
    "title": "Property RowHeaderWidth",
    "keywords": "Property RowHeaderWidth Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll RowHeaderWidth Höhe der Spalten. [Browsable(true)] [ControlStylesBrowsable(true)] public int? RowHeaderWidth { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.SelectedRows.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.SelectedRows.html",
    "title": "Property SelectedRows",
    "keywords": "Property SelectedRows Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SelectedRows Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Zeilen im Grid markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectedRows { get; set; } Property Value IDatasource Remarks Eine Collection ist eine Sammlung von mehreren Objekten. Um Objekte in dieser Collection anzusprechen, gibt es verschiedene Möglichkeiten. Sie können einerseits über die ID an ein Objekt herankommen (Collection[ID]), andererseits können Sie auch über die guid Objekte ansprechen (Collection[guid]). So können Sie direkt mit den guids aus der SelectedRowsCollection die entsprechenden Objekte aus dem Datasource ansprechen: // SelectedRowsCollection im Form-Event auswerten (oMyColl ist Datasource des Grids) foreach ( guid guidrow in oSelectedRowsColl ) { oMyColl[guidrow].MyFunction( ); }</code></pre></example> Es ist auch ganz einfach selbst dafür zu sorgen, welche Zeilen ausgewählt werden: // Manuell Zeilen in einem Grid markieren (oMyColl ist Datasource des Grids) // SelectedRowsCollection leeren (keine Zeile ausgewählt) oSelectedRowsColl.Clear( ); // Wenn eine bestimmte Bedingung erfüllt ist, entsprechende Zeilen selektieren foreach (cMyComponent oMyObjectTemp in oMyColl) { if MyObjectTemp.MyProperty > 10 oSelectedRowsColl.Add( MyObjectTemp ); }</code></pre></example>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowHorizontalLines.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowHorizontalLines.html",
    "title": "Property ShowHorizontalLines",
    "keywords": "Property ShowHorizontalLines Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ShowHorizontalLines Gibt an, ob die horizontalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowHorizontalLines { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowVerticalLines.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowVerticalLines.html",
    "title": "Property ShowVerticalLines",
    "keywords": "Property ShowVerticalLines Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ShowVerticalLines Gibt an, ob die vertikalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowVerticalLines { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferReloadRowCount.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferReloadRowCount.html",
    "title": "Property TransferReloadRowCount",
    "keywords": "Property TransferReloadRowCount Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TransferReloadRowCount Definiert, wie viele Zeilen nachgelesen werden, wenn in der Tabelle in den entsprechenden Bereich gescrollt wurde. Bei 0 werden alle Zeilen zurückgegeben. [Browsable(true)] [ControlStylesBrowsable(true)] public int? TransferReloadRowCount { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferStartupRowCount.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferStartupRowCount.html",
    "title": "Property TransferStartupRowCount",
    "keywords": "Property TransferStartupRowCount Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TransferStartupRowCount Definiert, wie viele Zeilen bei einem Load zunächst an den Client zurückgegeben werden. Bei 0 werden alle Zeilen zurückgegeben. Es wird nicht empfohlen, sich standardmäßig alle Zeilen zurückgeben zu lassen, da dies bei großen Datenmengen zu starker Belastung des Clients und des Webservers kommt. Es ist deshalb besser, sich zunächst einen Block zurückgeben zu lassen und bei Bedarf die Daten dynamisch nachlesen zu lassen. [Browsable(true)] [ControlStylesBrowsable(true)] public int? TransferStartupRowCount { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.html",
    "title": "Class GridDesignViewModel",
    "keywords": "Class GridDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control Grid. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class GridDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel GridDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties BackColor2 Bestimmt die zeilenweise alternierende Hintergrundfarbe einer Tabelle. Für den Hintergrund der Grid-Zeilen wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Grid-Zeilen die BackColor verwendet DataSource Gibt den Datasource an, dessen Daten im Grid angezeigt werden sollen. Es ist wichtig, dass Sie hier eine Collection angeben. GridColor GridRowHeight Definiert die Höhe einer Zeile. Die Angabe erfolgt in Pixeln. Wenn kein Wert angegeben ist, dann berechnet der Client die Höhe der Zeile anhand der Schriftart. HeaderColor Gibt die Hintergrundfarbe der Tabellenüberschrift an. IsEditable Gibt an, ob am Grid Daten geändert werden dürfen. Ist IsEditable auf False gesetzt, wirkt sichdas auf alle Columns aus – egal, was dort angegeben ist. MainMemorySortingThreshold Grids bieten grundsätzlich die Möglichkeit, die dargestellten Daten nach einer Spalte zu sortieren oder zu filtern. Dazu stehen zwei Mechanismen (Datenbanksortierung und Hauptspeichersortierung) zur Verfügung. Multiselect Gibt an, ob mehrere Zeilen ausgewählt werden können. Bei False kann nur maximal eine Zeile ausgewählt werden. Bei True ist die Auswahl mehrerer Zeilen möglich. Welche Zeilen ausgewählt sind, lässt sich in der SelectRowsCollection auswerten und setzen (siehe Property SelectedRows). NewRowIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile neu hinzugefügt wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert New hat. RowChangedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile geändert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert Changed hat. RowDeletedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile zum Löschen markiert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property StateBeforeUpdate den Wert true hat. RowHeader Bestimmt, ob im Row-Header die Zeilennummer oder der Status des Rows angezeigt wird. RowHeaderWidth Höhe der Spalten. SelectedRows Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Zeilen im Grid markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. ShowHorizontalLines Gibt an, ob die horizontalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. ShowVerticalLines Gibt an, ob die vertikalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. TransferReloadRowCount Definiert, wie viele Zeilen nachgelesen werden, wenn in der Tabelle in den entsprechenden Bereich gescrollt wurde. Bei 0 werden alle Zeilen zurückgegeben. TransferStartupRowCount Definiert, wie viele Zeilen bei einem Load zunächst an den Client zurückgegeben werden. Bei 0 werden alle Zeilen zurückgegeben. Es wird nicht empfohlen, sich standardmäßig alle Zeilen zurückgeben zu lassen, da dies bei großen Datenmengen zu starker Belastung des Clients und des Webservers kommt. Es ist deshalb besser, sich zunächst einen Block zurückgeben zu lassen und bei Bedarf die Daten dynamisch nachlesen zu lassen. Events OnAppendNewRow Dieser Vorgang wird ausgelöst, wenn in der letzten Zeile im letzten editierbaren Feld die Tab-Taste gedrückt wird. OnCellDoubleClick Tritt auf, wenn doppelt in eine Gridzelle (nicht RowHeader und nicht ColumnHeader) geklickt wurde. Das Event Argument stellt Spaltennummer (ColNum) und Datensatznummer (RowID) zur Verfügung. OnColumnChanged Wird ausgelöst, wenn sich der Inhalt einer Spalte geändert hat. Sie können über das EventArg e.RowID das Objekt ermitteln, bei dem das Event aufgetreten ist. OnGridCornerClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte in die linke, obere Ecke geklickt wurde. OnGridCornerDoubleClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte doppelt in die linke, obere Ecke geklickt wurde. OnRowClick Tritt auf, wenn auf die Zeile geklickt wurde. OnRowDoubleClick Tritt auf, wenn auf die Zeile doppelt geklickt wurde. OnRowSelectionChanged Tritt auf, wenn sich die Selektion im Grid ändert - auch bei Deselektion von Datensätzen. Wenn dem Grid eine SelectedRowsCollection zugeordnet ist, wird diese durch das Event aktualisiert. OnRowsReloadEntry Tritt auf, wenn Grid-Zeilen erstmalig an den Client übertragen werden, sowohl bei der initialien Übertragung als auch beim Nachladen von Zeilen. OnTableValidate See Also GridControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.CaptionAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.CaptionAlign.html",
    "title": "Property CaptionAlign",
    "keywords": "Property CaptionAlign Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll CaptionAlign Ausrichtung des Textes auf dem Image-Button. [Browsable(true)] [ControlStylesBrowsable(true)] public ContentAlignment? CaptionAlign { get; set; } Property Value ContentAlignment? Remarks"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.DisabledImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.DisabledImage.html",
    "title": "Property DisabledImage",
    "keywords": "Property DisabledImage Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DisabledImage Gibt das Bild an, das angezeigt werden soll, wenn der Button disabled ist. Die URL kann einen relativen (zum Applikations-Verzeichnis) oder einen absoluten Pfad darstellen. Über die Drop- Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. [Browsable(true)] [ControlStylesBrowsable(true)] public string DisabledImage { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Image.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Image.html",
    "title": "Property Image",
    "keywords": "Property Image Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Image Gibt das Bild an, das im Normalzustand angezeigt werden soll. [Browsable(true)] [ControlStylesBrowsable(true)] public string Image { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCaption Die Caption wird auf das Bild geblendet, und zwar an der Position, die Sie unter CaptionAlign angegeben haben. Ist ihre Grafik selbsterklärend, können Sie die Caption frei lassen. Soll ein Und-Zeichen (&) dargestellt werden, müssen zwei Und-Zeichen (&&) angegeben werden. public override IMLString MLCaption { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.MouseOverImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.MouseOverImage.html",
    "title": "Property MouseOverImage",
    "keywords": "Property MouseOverImage Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MouseOverImage Gibt das Bild an, das angezeigt werden soll, wenn der Mauszeiger sich über dem Image-Button befindet. [Browsable(true)] [ControlStylesBrowsable(true)] public string MouseOverImage { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.PressedImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.PressedImage.html",
    "title": "Property PressedImage",
    "keywords": "Property PressedImage Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll PressedImage Gibt das Bild an, das angezeigt werden soll, wenn der Image-Button gedrückt wird. [Browsable(true)] [ControlStylesBrowsable(true)] public string PressedImage { get; set; } Property Value string Remarks Warning In der Regel ist es sinnvoll, Image-Buttons im Default Control Style-Editor zu definieren und nur inSonderfällen von dieser Definition abzuweichen(Default Control Styles)."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.html",
    "title": "Class ImageButtonDesignViewModel",
    "keywords": "Class ImageButtonDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control ImageButton. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class ImageButtonDesignViewModel : ButtonBaseDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ButtonBaseDesignViewModel ImageButtonDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ButtonBaseDesignViewModel.MapEnterToTabAction ButtonBaseDesignViewModel.Shortcut ButtonBaseDesignViewModel.ShowCaption ButtonBaseDesignViewModel.IsSearchButton ButtonBaseDesignViewModel.LoadAtComponent ButtonBaseDesignViewModel.SearchValuesComponent ButtonBaseDesignViewModel.ContextMenu ButtonBaseDesignViewModel.OnClick ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties CaptionAlign Ausrichtung des Textes auf dem Image-Button. DisabledImage Gibt das Bild an, das angezeigt werden soll, wenn der Button disabled ist. Die URL kann einen relativen (zum Applikations-Verzeichnis) oder einen absoluten Pfad darstellen. Über die Drop- Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Image Gibt das Bild an, das im Normalzustand angezeigt werden soll. MLCaption Die Caption wird auf das Bild geblendet, und zwar an der Position, die Sie unter CaptionAlign angegeben haben. Ist ihre Grafik selbsterklärend, können Sie die Caption frei lassen. Soll ein Und-Zeichen (&) dargestellt werden, müssen zwei Und-Zeichen (&&) angegeben werden. MouseOverImage Gibt das Bild an, das angezeigt werden soll, wenn der Mauszeiger sich über dem Image-Button befindet. PressedImage Gibt das Bild an, das angezeigt werden soll, wenn der Image-Button gedrückt wird. See Also ImageButtonControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DataSource Gibt das Property an, dessen Inhalt in dem Label angezeigt werden soll. Ist ein Datasource angegeben, wird der Text aus Caption nicht angezeigt. public override IDatasource DataSource { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCaption Hier geben Sie mehrsprachig den Text ein, den das Label anzeigen soll. Wenn der Text des Default-Labels wiederhergestellt werden soll, muss der Inhalt aus Caption nur gelöscht werden. public override IMLString MLCaption { get; set; } Property Value IMLString Remarks Es ist die Eingabe von Plaintext und HTML-Text möglich. HTML-Text muss mit beginnen und mit enden. Soll ein Und-Zeichen (&) dargestellt werden, müssen zwei Und-Zeichen (&&) angegeben werden. Ist auf dem Label ein DataSource hinterlegt, wird der Text, der hier unter Caption eingetragen wurde, nicht mehr angezeigt. Der Datasource hat dann höhere Priorität."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TextAlign Ausrichtung des Textes innerhalb des Labels. [Browsable(true)] [ControlStylesBrowsable(true)] public DevTextAlign? TextAlign { get; set; } Property Value DevTextAlign?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.html",
    "title": "Class LabelDesignViewModel",
    "keywords": "Class LabelDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control Label. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class LabelDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel LabelDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties DataSource Gibt das Property an, dessen Inhalt in dem Label angezeigt werden soll. Ist ein Datasource angegeben, wird der Text aus Caption nicht angezeigt. MLCaption Hier geben Sie mehrsprachig den Text ein, den das Label anzeigen soll. Wenn der Text des Default-Labels wiederhergestellt werden soll, muss der Inhalt aus Caption nur gelöscht werden. TextAlign Ausrichtung des Textes innerhalb des Labels. See Also LabelControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.List.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.List.html",
    "title": "Property List",
    "keywords": "Property List Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll List Gibt den Datasource für die Liste der Einträge der Combobox an. Es können Collections und TextCollections ausgewählt werden. [Browsable(true)] [TypeConverter(typeof(DataBindingConverter))] public ListDataSource List { get; set; } Property Value ListDataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.ListSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.ListSortOrder.html",
    "title": "Property ListSortOrder",
    "keywords": "Property ListSortOrder Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ListSortOrder Gibt an, ob und wie die Einträge der Liste sortiert werden sollen.Für die Sortierung ist das DisplayMember ausschlaggebend.Ist Unsorted eingestellt, werden die Einträge in der Reihenfolge angezeigt, wie sie in der Collection stehen.Den Collections kann beim Load() eine SortOrder mitgegeben werden und TextCollections sind immer aufsteigend nach ID sortiert. [Browsable(true)] [ControlStylesBrowsable(true)] public ListSortOrder? ListSortOrder { get; set; } Property Value ListSortOrder?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.html",
    "title": "Class ListBaseDesignViewModel",
    "keywords": "Class ListBaseDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public abstract class ListBaseDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ListBaseDesignViewModel Implements INotifyPropertyChanged IDisposable Derived ComboboxDesignViewModel ListboxDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties List Gibt den Datasource für die Liste der Einträge der Combobox an. Es können Collections und TextCollections ausgewählt werden. ListSortOrder Gibt an, ob und wie die Einträge der Liste sortiert werden sollen.Für die Sortierung ist das DisplayMember ausschlaggebend.Ist Unsorted eingestellt, werden die Einträge in der Reihenfolge angezeigt, wie sie in der Collection stehen.Den Collections kann beim Load() eine SortOrder mitgegeben werden und TextCollections sind immer aufsteigend nach ID sortiert."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DataSource Membervariable oder Property, welches an die ListView gebunden werden soll. Muss vom Typ IDevFrameworkObjectColl sein. Bildet auch die Datengrundlage für das ListItem Template. public override IDatasource DataSource { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemArrangement.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemArrangement.html",
    "title": "Property ItemArrangement",
    "keywords": "Property ItemArrangement Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ItemArrangement Definiert die Anordnung der ListItems abhängig von der Größe der ListView. [Browsable(true)] [ControlStylesBrowsable(true)] public ListViewItemArrangement? ItemArrangement { get; set; } Property Value ListViewItemArrangement? Remarks Es stehen zwei Optionen zur Verfügung: List Die ListItems werden untereinander angeordnet. Dabei werden diese horizontal auf die gesamte Breite der ListView gestreckt. Die unter ItemSize.Width eingegebene Breite gilt als Mindestbreite. Die Höhe (ItemSize.Height) ist fix. Wrap Die ListItems werden abhängig von der ItemSize.Width und der Breite der ListView umgebrochen. Es werden pro Zeile so viele ListItems wie möglich angezeigt. Die ItemSize.Width gibt dabei die Mindestbreite eines ListItems an. Die Höhe (ItemSize.Height) ist fix. Die ListItems werden gleichmäßig gestreckt, um die gesamte Breite der ListView auszunutzen."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemSize.html",
    "title": "Property ItemSize",
    "keywords": "Property ItemSize Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ItemSize Gibt die Größe eines ListItems an. Hierbei gilt die Width als Mindestbreite. Abhängig vom ItemArrangement werden ListItems gestreckt, um den vorhandenen Platz optimal auszunutzen. Die angegebene Height wird im Gegensatz zur Width nicht an die Größe der ListView angepasst und bleibt stabil. [Browsable(true)] [ControlStylesBrowsable(true)] public NonableSize ItemSize { get; set; } Property Value NonableSize"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemActivated.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemActivated.html",
    "title": "Event OnItemActivated",
    "keywords": "Event OnItemActivated Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Event wird gefeuert, wenn ein ListItem angeklickt oder auf einem mobilen Gerät mit dem Finger angetippt wird. public event EventHandler<FrameworkOnItemActivatedEventArgs> OnItemActivated Returns EventHandler<FrameworkOnItemActivatedEventArgs> Dieses Event wird gefeuert, wenn ein ListItem angeklickt oder auf einem mobilen Gerät mit dem Finger angetippt wird."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemSelectionChanged.html",
    "title": "Event OnItemSelectionChanged",
    "keywords": "Event OnItemSelectionChanged Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Event wird gefeuert, wenn sich die Anzahl der selektierten ListItems ändert. Die derzeit selektierten ListItems können über das an der ListView gebundene Property SelectedItems ausgelesen werden. public event EventHandler<FrameworkSelectionChangedEventArgs> OnItemSelectionChanged Returns EventHandler<FrameworkSelectionChangedEventArgs> Dieses Event wird gefeuert, wenn sich die Anzahl der selektierten ListItems ändert. Die derzeit selektierten ListItems können über das an der ListView gebundene Property ausgelesen werden."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectedItems.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectedItems.html",
    "title": "Property SelectedItems",
    "keywords": "Property SelectedItems Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SelectedItems Membervariable oder Property, welches die selektierten ListItems beinhaltet. Muss von Typ SelectedRowsCollection sein. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectedItems { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectionMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectionMode.html",
    "title": "Property SelectionMode",
    "keywords": "Property SelectionMode Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SelectionMode Gibt an, ob und wie ListItems in einer ListView selektiert werden können. [Browsable(true)] [ControlStylesBrowsable(true)] public ListViewSelectionMode? SelectionMode { get; set; } Property Value ListViewSelectionMode?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectorPosition.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectorPosition.html",
    "title": "Property SelectorPosition",
    "keywords": "Property SelectorPosition Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SelectorPosition Der Selector ist ein kleines Häkchen, welches am ListItem anzeigt, ob es selektiert ist oder nicht. Abhängig vom individuellen Design des ListItems kann definiert werden, an welcher Stelle der Selector über dem ListItem angezeigt wird. [Browsable(true)] [ControlStylesBrowsable(true)] public ListViewSelectorPosition? SelectorPosition { get; set; } Property Value ListViewSelectorPosition? Remarks Das folgende Bild zeigt die möglichen Positionen:"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Spacing.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Spacing.html",
    "title": "Property Spacing",
    "keywords": "Property Spacing Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Spacing Gibt den horizontalen und vertikalen Abstang zwischen den ListItems an. [Browsable(true)] [ControlStylesBrowsable(true)] public ControlSpacing Spacing { get; set; } Property Value ControlSpacing"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Template.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Template.html",
    "title": "Property Template",
    "keywords": "Property Template Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Template Öffnet den ListView Template Editor. [Browsable(true)] public object Template { get; set; } Property Value object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.html",
    "title": "Class ListViewDesignViewModel",
    "keywords": "Class ListViewDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control ListView. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class ListViewDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ListViewDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties DataSource Membervariable oder Property, welches an die ListView gebunden werden soll. Muss vom Typ IDevFrameworkObjectColl sein. Bildet auch die Datengrundlage für das ListItem Template. ItemArrangement Definiert die Anordnung der ListItems abhängig von der Größe der ListView. ItemSize Gibt die Größe eines ListItems an. Hierbei gilt die Width als Mindestbreite. Abhängig vom ItemArrangement werden ListItems gestreckt, um den vorhandenen Platz optimal auszunutzen. Die angegebene Height wird im Gegensatz zur Width nicht an die Größe der ListView angepasst und bleibt stabil. SelectedItems Membervariable oder Property, welches die selektierten ListItems beinhaltet. Muss von Typ SelectedRowsCollection sein. SelectionMode Gibt an, ob und wie ListItems in einer ListView selektiert werden können. SelectorPosition Der Selector ist ein kleines Häkchen, welches am ListItem anzeigt, ob es selektiert ist oder nicht. Abhängig vom individuellen Design des ListItems kann definiert werden, an welcher Stelle der Selector über dem ListItem angezeigt wird. Spacing Gibt den horizontalen und vertikalen Abstang zwischen den ListItems an. Template Öffnet den ListView Template Editor. Events OnItemActivated Dieses Event wird gefeuert, wenn ein ListItem angeklickt oder auf einem mobilen Gerät mit dem Finger angetippt wird. OnItemSelectionChanged Dieses Event wird gefeuert, wenn sich die Anzahl der selektierten ListItems ändert. Die derzeit selektierten ListItems können über das an der ListView gebundene Property SelectedItems ausgelesen werden. See Also ListViewControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.Multiselect.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.Multiselect.html",
    "title": "Property Multiselect",
    "keywords": "Property Multiselect Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Multiselect Wenn grundsätzlich mehrere Einträge ausgewählt werden können sollen, muss dieses Property auf True gesetzt werden. Ist es auf False gesetzt, kann nur genau ein Eintrag ausgewählt werden. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? Multiselect { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.OnSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.OnSelectionChanged.html",
    "title": "Event OnSelectionChanged",
    "keywords": "Event OnSelectionChanged Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. public event EventHandler<FrameworkEventArgs> OnSelectionChanged Returns EventHandler<FrameworkEventArgs> Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.SelectedEntries.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.SelectedEntries.html",
    "title": "Property SelectedEntries",
    "keywords": "Property SelectedEntries Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll SelectedEntries Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Einträge in der Listbox selektiert sind. Dieses Property muss vom Typ FS.Hosting.Shared.FSArrayList sein. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectedEntries { get; set; } Property Value IDatasource Remarks Um die selektierten Objekte auszuwerten, kann ganz einfach über die FSArrayList iteriert werden. Beispiel: // SelectedEntries im Form-Event auswerten foreach(var oMyObj in oSelectedEntries) { oMyObj.MyFunction(); } Es ist auch ganz einfach selbst dafür zu sorgen, welche Einträge ausgewählt werden: Beispiel: // Manuell Einträge in einer Listbox markieren (oMyColl ist Datasource der Listbox) // SelectedEntries leeren (keine Einträge ausgewählt) oSelecteEntries.Clear( ); // Wenn eine bestimmte Bedingung erfüllt ist, entsprechende Einträge selektieren foreach (cMyComponent oMyObjectTemp in oMyColl) { if MyObjectTemp.MyProperty > 10 oSelecteEntries.Add(MyObjectTemp); }"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.html",
    "title": "Class ListboxDesignViewModel",
    "keywords": "Class ListboxDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control Listbox. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class ListboxDesignViewModel : ListBaseDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ListBaseDesignViewModel ListboxDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ListBaseDesignViewModel.List ListBaseDesignViewModel.ListSortOrder ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Multiselect Wenn grundsätzlich mehrere Einträge ausgewählt werden können sollen, muss dieses Property auf True gesetzt werden. Ist es auf False gesetzt, kann nur genau ein Eintrag ausgewählt werden. SelectedEntries Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Einträge in der Listbox selektiert sind. Dieses Property muss vom Typ FS.Hosting.Shared.FSArrayList sein. Events OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. See Also ListBoxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Checked.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Checked.html",
    "title": "Property Checked",
    "keywords": "Property Checked Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Checked Ist ein Property hinterlegt, welches als boolescher Wert ausgewertet werden kann (bool, FSbool, FSshort,…), so wird vor der Bezeichnung des Menüeintrags ein Haken dargestellt, wenn das hinterlegte Property den Wert true repräsentiert. [Browsable(true)] [ControlStylesBrowsable(false)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource Checked { get; set; } Property Value IDatasource Remarks Warning Wenn die Eigenschaft Image gesetzt ist, übersteuert diese die Checked Darstellung."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DataSource Ist ein Datasource hinterlegt, wird die MLCaption wie bei einem Label durch den Inhalt überschrieben. public override IDatasource DataSource { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Image.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Image.html",
    "title": "Property Image",
    "keywords": "Property Image Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Image Gibt das Bild an, das vor der Bezeichnung des Menüeintrags angezeigt werden soll. Die URL kann einen zum Applikations-Verzeichnis relativen Pfad oder einen absoluten Pfad darstellen. Über die Drop-Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Ist die Eigenschaft Checked ebenfalls zugewiesen, so wird die Darstellung des Checked-Status durch das Image übersteuert. [Browsable(true)] [ControlStylesBrowsable(true)] public string Image { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCaption Hinterlegen Sie hier mehrsprachig die Bezeichnung, die für den Menüeintrag angezeigt werden soll. Soll ein Und-Zeichen(&) dargestellt werden, müssen zwei Und-Zeichen(&&) angegeben werden. Ist auf dem Label ein Datasource hinterlegt, wird der Text, der hier unter Caption eingetragen wurde, nicht mehr angezeigt. Der DataSource hat dann höhere Priorität. public override IMLString MLCaption { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.MLTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.MLTooltip.html",
    "title": "Property MLTooltip",
    "keywords": "Property MLTooltip Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLTooltip Ist ein Tooltip hinterlegt, wird dieser in der Dokumentation angezeigt. Die UI zeigt für Menu Items keinen Tooltip an. public override IMLString MLTooltip { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnCanDrop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnCanDrop.html",
    "title": "Event OnCanDrop",
    "keywords": "Event OnCanDrop Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Event wird nicht unterstützt. public event EventHandler<FrameworkEventArgs> OnCanDrop Returns EventHandler<FrameworkEventArgs> Dieses Event wird nicht unterstützt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Wird bei einem Klick auf das Control ausgelöst. public event EventHandler<FrameworkButtonClickEventArgs> OnClick Returns EventHandler<FrameworkButtonClickEventArgs> Wird bei einem Klick auf das Control ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnDrag.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnDrag.html",
    "title": "Event OnDrag",
    "keywords": "Event OnDrag Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Event wird nicht unterstützt. public event EventHandler<FrameworkEventArgs> OnDrag Returns EventHandler<FrameworkEventArgs> Dieses Event wird nicht unterstützt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnEnter.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnEnter.html",
    "title": "Event OnEnter",
    "keywords": "Event OnEnter Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Event wird nicht unterstützt. public event EventHandler<FrameworkEventArgs> OnEnter Returns EventHandler<FrameworkEventArgs> Dieses Event wird nicht unterstützt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnLeave.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnLeave.html",
    "title": "Event OnLeave",
    "keywords": "Event OnLeave Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Event wird nicht unterstützt. public event EventHandler<FrameworkEventArgs> OnLeave Returns EventHandler<FrameworkEventArgs> Dieses Event wird nicht unterstützt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Shortcut Zur Anwahl des Menüeintrags über einen ShortCut, wird einfach die entsprechende Tastenkombination aus der Combobox ausgewählt. [Browsable(true)] [DevBrowsable(true)] public ExtendedShortcut? Shortcut { get; set; } Property Value ExtendedShortcut?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.html",
    "title": "Class MainMenuDesignViewModel",
    "keywords": "Class MainMenuDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control Menu-Item. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class MainMenuDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel MainMenuDesignViewModel Implements INotifyPropertyChanged IDisposable Derived ContextMenuDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Checked Ist ein Property hinterlegt, welches als boolescher Wert ausgewertet werden kann (bool, FSbool, FSshort,…), so wird vor der Bezeichnung des Menüeintrags ein Haken dargestellt, wenn das hinterlegte Property den Wert true repräsentiert. DataSource Ist ein Datasource hinterlegt, wird die MLCaption wie bei einem Label durch den Inhalt überschrieben. Image Gibt das Bild an, das vor der Bezeichnung des Menüeintrags angezeigt werden soll. Die URL kann einen zum Applikations-Verzeichnis relativen Pfad oder einen absoluten Pfad darstellen. Über die Drop-Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Ist die Eigenschaft Checked ebenfalls zugewiesen, so wird die Darstellung des Checked-Status durch das Image übersteuert. MLCaption Hinterlegen Sie hier mehrsprachig die Bezeichnung, die für den Menüeintrag angezeigt werden soll. Soll ein Und-Zeichen(&) dargestellt werden, müssen zwei Und-Zeichen(&&) angegeben werden. Ist auf dem Label ein Datasource hinterlegt, wird der Text, der hier unter Caption eingetragen wurde, nicht mehr angezeigt. Der DataSource hat dann höhere Priorität. MLTooltip Ist ein Tooltip hinterlegt, wird dieser in der Dokumentation angezeigt. Die UI zeigt für Menu Items keinen Tooltip an. Shortcut Zur Anwahl des Menüeintrags über einen ShortCut, wird einfach die entsprechende Tastenkombination aus der Combobox ausgewählt. Events OnCanDrop Dieses Event wird nicht unterstützt. OnClick Wird bei einem Klick auf das Control ausgelöst. OnDrag Dieses Event wird nicht unterstützt. OnEnter Dieses Event wird nicht unterstützt. OnLeave Dieses Event wird nicht unterstützt. See Also MainMenuControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.CaptionAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.CaptionAlign.html",
    "title": "Property CaptionAlign",
    "keywords": "Property CaptionAlign Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll CaptionAlign Wenn das Bild eine Caption anzeigen soll, können Sie hier bestimmen, wo dies arrangiert ist. [Browsable(true)] [ControlStylesBrowsable(true)] public ContentAlignment? CaptionAlign { get; set; } Property Value ContentAlignment?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DataSource Hier kann eine Datenquelle angegeben werden, aus der das Bild zur Laufzeit ermittelt wird. Zur Auswahl stehen alle Properties des Forms (und deren Unter-Properties). Gültige Typen für den Datasource sind string und FSstring sowie byte[] und FSbyteArray. Dabei gilt für die String Datentypen, dass der Inhalt eine URL zu dem Bild enthält, das dargestellt werden soll. Ist der Typ des Datasources ein Byte Array, so muss dieses Byte Array das Bild in einem der folgenden Formate darstellen: GIF, JPG oder PNG. public override IDatasource DataSource { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Image.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Image.html",
    "title": "Property Image",
    "keywords": "Property Image Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Image URL zu dem Bild, das angezeigt werden soll. Zum Anwendungsverzeichnis relative und absolute Pfade sind zulässig. [Browsable(true)] [ControlStylesBrowsable(true)] public string Image { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCaption Hinterlegen Sie hier mehrsprachig die Caption des Bildes. public override IMLString MLCaption { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Wird ausgelöst, wenn der Benutzer auf das Bild klickt. public event EventHandler<FrameworkButtonClickEventArgs> OnClick Returns EventHandler<FrameworkButtonClickEventArgs> Wird ausgelöst, wenn der Benutzer auf das Bild klickt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ScaleMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ScaleMode.html",
    "title": "Property ScaleMode",
    "keywords": "Property ScaleMode Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ScaleMode Diese Eigenschaft gibt an, wie ein Bild skaliert werden soll. [Browsable(true)] [ControlStylesBrowsable(true)] public PictureScaleMode? ScaleMode { get; set; } Property Value PictureScaleMode? Remarks Wenn ein PictureControl durch Angabe von Anchors dynamisch vergrößert wird, dann ziehen die oben beschriebenen Einstellungen auch. Note Einschränkung: Die Modi funktionieren bei Bildern, die per Datasource als FSbyteArray an das Control übergeben werden. Bei Bildern, die über eine URL gelesen werden, funktionieren nur die Modi Normal und Stretch. Wenn ein anderer Mode angegeben ist, dann zieht Stretch."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ShowCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ShowCaption.html",
    "title": "Property ShowCaption",
    "keywords": "Property ShowCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ShowCaption Gibt an, ob das Caption angezeigt wird oder nicht. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowCaption { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.html",
    "title": "Class PictureDesignViewModel",
    "keywords": "Class PictureDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control Picture. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class PictureDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel PictureDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties CaptionAlign Wenn das Bild eine Caption anzeigen soll, können Sie hier bestimmen, wo dies arrangiert ist. DataSource Hier kann eine Datenquelle angegeben werden, aus der das Bild zur Laufzeit ermittelt wird. Zur Auswahl stehen alle Properties des Forms (und deren Unter-Properties). Gültige Typen für den Datasource sind string und FSstring sowie byte[] und FSbyteArray. Dabei gilt für die String Datentypen, dass der Inhalt eine URL zu dem Bild enthält, das dargestellt werden soll. Ist der Typ des Datasources ein Byte Array, so muss dieses Byte Array das Bild in einem der folgenden Formate darstellen: GIF, JPG oder PNG. Image URL zu dem Bild, das angezeigt werden soll. Zum Anwendungsverzeichnis relative und absolute Pfade sind zulässig. MLCaption Hinterlegen Sie hier mehrsprachig die Caption des Bildes. ScaleMode Diese Eigenschaft gibt an, wie ein Bild skaliert werden soll. ShowCaption Gibt an, ob das Caption angezeigt wird oder nicht. Events OnClick Wird ausgelöst, wenn der Benutzer auf das Bild klickt. See Also PictureControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.DatasourceOnValue.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.DatasourceOnValue.html",
    "title": "Property DatasourceOnValue",
    "keywords": "Property DatasourceOnValue Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DatasourceOnValue Wert, bei dem der Radio-Button aktiv ist. [Browsable(true)] public int? DatasourceOnValue { get; set; } Property Value int?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll MLCaption Beschriftung des Radio-Buttons. Wird rechts neben dem Radio-Button angezeigt. public override IMLString MLCaption { get; set; } Property Value IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Wird bei einem Click auf den Radio-Button ausgelöst. Der Button GroupDataSource des übergeordneten Panels wird auf den DataSourceOnValue-Wert gestellt. public event EventHandler<FrameworkRadioButtonClickEventArgs> OnClick Returns EventHandler<FrameworkRadioButtonClickEventArgs> Wird bei einem Click auf den Radio-Button ausgelöst. Der Button GroupDataSource des übergeordneten Panels wird auf den DataSourceOnValue-Wert gestellt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.html",
    "title": "Class RadioButtonDesignViewModel",
    "keywords": "Class RadioButtonDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class RadioButtonDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel RadioButtonDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties DatasourceOnValue Wert, bei dem der Radio-Button aktiv ist. MLCaption Beschriftung des Radio-Buttons. Wird rechts neben dem Radio-Button angezeigt. Events OnClick Wird bei einem Click auf den Radio-Button ausgelöst. Der Button GroupDataSource des übergeordneten Panels wird auf den DataSourceOnValue-Wert gestellt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.ActiveImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.ActiveImage.html",
    "title": "Property ActiveImage",
    "keywords": "Property ActiveImage Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ActiveImage Für die TabPage kann ein Header-Image hinterlegt, bzw. das auf Tabbed Window Ebene hinterlegte überschrieben werden. Das Image wird angezeigt, wenn das Tabbed Window aktiviert wird. [Browsable(true)] [ControlStylesBrowsable(true)] public string ActiveImage { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Shortcut Definiert die Tastenkombination, mit der die TabPage ausgewählt werden kann. Der Shortcut wird in der Anwendung als Tooltip angezeigt, wenn sich die Maus über der TabPage befindet. [Browsable(true)] [ControlStylesBrowsable(true)] [DevBrowsable(true)] public ExtendedShortcut? Shortcut { get; set; } Property Value ExtendedShortcut?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.html",
    "title": "Class TabPageDesignViewModel",
    "keywords": "Class TabPageDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class TabPageDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TabPageDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ActiveImage Für die TabPage kann ein Header-Image hinterlegt, bzw. das auf Tabbed Window Ebene hinterlegte überschrieben werden. Das Image wird angezeigt, wenn das Tabbed Window aktiviert wird. Shortcut Definiert die Tastenkombination, mit der die TabPage ausgewählt werden kann. Der Shortcut wird in der Anwendung als Tooltip angezeigt, wenn sich die Maus über der TabPage befindet."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.ActiveImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.ActiveImage.html",
    "title": "Property ActiveImage",
    "keywords": "Property ActiveImage Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ActiveImage Sie können für die Registerkarten-Bezeichnung Grafiken hinterlegen, welche im Viewer statt des normalen Graus angezeigt werden. Die aktuell ausgewählte Registerkarte zeigt die hier hinterlegte Grafik an. [Browsable(true)] [ControlStylesBrowsable(true)] public string ActiveImage { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DataSource Der hinterlegte Datasource erhält einen Wert vom Typ Int, in dem zurückgegeben wird, welches Tab aktiv ist (mit 0 beginnend). public override IDatasource DataSource { get; set; } Property Value IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.InactiveImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.InactiveImage.html",
    "title": "Property InactiveImage",
    "keywords": "Property InactiveImage Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll InactiveImage Die Grafik wird auf allen Tabs angezeigt, die nicht aktiv sind. [Browsable(true)] [ControlStylesBrowsable(true)] public string InactiveImage { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChange.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChange.html",
    "title": "Event OnSelectedTabPageChange",
    "keywords": "Event OnSelectedTabPageChange Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar bevor das Programm auf das neue Tab gewechselt ist. Soll z.B. der Wechsel auf ein anderes Tab unterbunden werden, kann hier entsprechend eine Anweisung an den Datasource hinterlegt werden. public event EventHandler<FrameworkOnSelectedTabChangeEventArgs> OnSelectedTabPageChange Returns EventHandler<FrameworkOnSelectedTabChangeEventArgs> Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar bevor das Programm auf das neue Tab gewechselt ist. Soll z.B. der Wechsel auf ein anderes Tab unterbunden werden, kann hier entsprechend eine Anweisung an den Datasource hinterlegt werden."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChanged.html",
    "title": "Event OnSelectedTabPageChanged",
    "keywords": "Event OnSelectedTabPageChanged Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar nachdem das Programm auf das neue Tab gewechselt ist. public event EventHandler<FrameworkOnSelectedTabChangedEventArgs> OnSelectedTabPageChanged Returns EventHandler<FrameworkOnSelectedTabChangedEventArgs> Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar nachdem das Programm auf das neue Tab gewechselt ist."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.TabAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.TabAlignment.html",
    "title": "Property TabAlignment",
    "keywords": "Property TabAlignment Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll TabAlignment Bestimmt, an welcher Stelle der Registerkarte die Bezeichnung/der Name der Registerkarte (der \"Reiter\", hier als Beispiel „Seite“) dargestellt wird. [Browsable(true)] [ControlStylesBrowsable(true)] public TabAlignment? TabAlignment { get; set; } Property Value TabAlignment?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.html",
    "title": "Class TabbedWindowDesignViewModel",
    "keywords": "Class TabbedWindowDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class TabbedWindowDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TabbedWindowDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ActiveImage Sie können für die Registerkarten-Bezeichnung Grafiken hinterlegen, welche im Viewer statt des normalen Graus angezeigt werden. Die aktuell ausgewählte Registerkarte zeigt die hier hinterlegte Grafik an. DataSource Der hinterlegte Datasource erhält einen Wert vom Typ Int, in dem zurückgegeben wird, welches Tab aktiv ist (mit 0 beginnend). InactiveImage Die Grafik wird auf allen Tabs angezeigt, die nicht aktiv sind. TabAlignment Bestimmt, an welcher Stelle der Registerkarte die Bezeichnung/der Name der Registerkarte (der \"Reiter\", hier als Beispiel „Seite“) dargestellt wird. Events OnSelectedTabPageChange Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar bevor das Programm auf das neue Tab gewechselt ist. Soll z.B. der Wechsel auf ein anderes Tab unterbunden werden, kann hier entsprechend eine Anweisung an den Datasource hinterlegt werden. OnSelectedTabPageChanged Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar nachdem das Programm auf das neue Tab gewechselt ist."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.Template.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.Template.html",
    "title": "Property Template",
    "keywords": "Property Template Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Template Öffnet den ListView Template Editor. [Browsable(true)] public object Template { get; set; } Property Value object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.html",
    "title": "Class TemplateControlDesignViewModel",
    "keywords": "Class TemplateControlDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Diese Klasse repräsentiert das Control TemplateControl. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. public class TemplateControlDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel TemplateControlDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Template Öffnet den ListView Template Editor. See Also TemplateControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ClosedIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ClosedIcon.html",
    "title": "Property ClosedIcon",
    "keywords": "Property ClosedIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ClosedIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist und benötigt das Property des NodeDataSource-Objekts. [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public string ClosedIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ContinueEquivalent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ContinueEquivalent.html",
    "title": "Property ContinueEquivalent",
    "keywords": "Property ContinueEquivalent Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ContinueEquivalent Um eine Rekursion aufzubauen, wählen Sie hier den eigenen TreeNode als ContinueEquivalent aus. Für Elemente der ersten Ebene ist null default, für Elemente der zweiten Ebene der TreeNode der ersten Ebene. [Browsable(true)] [DevBrowsable(true)] [TypeConverter(typeof(DevControlTreeNodeConverter))] public guid ContinueEquivalent { get; set; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.NodeDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.NodeDataSource.html",
    "title": "Property NodeDataSource",
    "keywords": "Property NodeDataSource Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll NodeDataSource DataSource des TreeNodes. Collections oder Textcollections sind möglich. [Browsable(true)] [DevBrowsable(true)] [TypeConverter(typeof(DataBindingConverter))] public NodeListDataSource NodeDataSource { get; set; } Property Value NodeListDataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnAfterSelect.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnAfterSelect.html",
    "title": "Event OnAfterSelect",
    "keywords": "Event OnAfterSelect Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein, wenn ein Knoten ausgewählt wurde. public event EventHandler<DevEventHandlerOnTreeNodeSelectedEventArgs> OnAfterSelect Returns EventHandler<DevEventHandlerOnTreeNodeSelectedEventArgs> Tritt ein, wenn ein Knoten ausgewählt wurde."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDoubleClick.html",
    "title": "Event OnDoubleClick",
    "keywords": "Event OnDoubleClick Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein, wenn auf einen Knoten doppelt geklickt wurde. public event EventHandler<DevEventHandlerOnTreeNodeSelectedEventArgs> OnDoubleClick Returns EventHandler<DevEventHandlerOnTreeNodeSelectedEventArgs> Tritt ein, wenn auf einen Knoten doppelt geklickt wurde."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDragDrop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDragDrop.html",
    "title": "Event OnDragDrop",
    "keywords": "Event OnDragDrop Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll Tritt ein, wenn ein Tree-Node per Drag and Drop innerhalb eines TreeViews oder (aus einem anderen TreeView) in einen TreeView verschoben wird. public event EventHandler<DevEventHandlerOnTreeNodeDragDropEventArgs> OnDragDrop Returns EventHandler<DevEventHandlerOnTreeNodeDragDropEventArgs> Tritt ein, wenn ein Tree-Node per Drag and Drop innerhalb eines TreeViews oder (aus einem anderen TreeView) in einen TreeView verschoben wird."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OpenIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OpenIcon.html",
    "title": "Property OpenIcon",
    "keywords": "Property OpenIcon Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll OpenIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist. Benötigt das Property des NodeDataSource-Objekts. [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public string OpenIcon { get; set; } Property Value string"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.html",
    "title": "Class TreeNodeDesignViewModel",
    "keywords": "Class TreeNodeDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class TreeNodeDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TreeNodeDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ClosedIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist und benötigt das Property des NodeDataSource-Objekts. ContinueEquivalent Um eine Rekursion aufzubauen, wählen Sie hier den eigenen TreeNode als ContinueEquivalent aus. Für Elemente der ersten Ebene ist null default, für Elemente der zweiten Ebene der TreeNode der ersten Ebene. NodeDataSource DataSource des TreeNodes. Collections oder Textcollections sind möglich. OpenIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist. Benötigt das Property des NodeDataSource-Objekts. Events OnAfterSelect Tritt ein, wenn ein Knoten ausgewählt wurde. OnDoubleClick Tritt ein, wenn auf einen Knoten doppelt geklickt wurde. OnDragDrop Tritt ein, wenn ein Tree-Node per Drag and Drop innerhalb eines TreeViews oder (aus einem anderen TreeView) in einen TreeView verschoben wird."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.BackColor2.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.BackColor2.html",
    "title": "Property BackColor2",
    "keywords": "Property BackColor2 Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll BackColor2 Gibt die alternierende Hintergrundfarbe für die TreeView an. Für den Hintergrund der Tree-Nodes wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Nodes die BackColor verwendet. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor2 { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.DragDropMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.DragDropMode.html",
    "title": "Property DragDropMode",
    "keywords": "Property DragDropMode Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll DragDropMode Gibt an, von welchen Controls aus in den aktuellen Tree-View Drag and Drop ausgeführt werden [Browsable(true)] [ControlStylesBrowsable(true)] public TreeViewDragDropMode? DragDropMode { get; set; } Property Value TreeViewDragDropMode?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.InitialDepth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.InitialDepth.html",
    "title": "Property InitialDepth",
    "keywords": "Property InitialDepth Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll InitialDepth Gibt an, bis zu welcher Ebene Daten vom TreeView an den Anzeige-Client übertragen werden. Hat ein Tree z.B. 5 Ebenen und InitialDepth ist mit 2 definiert, werden erst beim Aufklappen der 3. Ebene im Client die neuen Daten übertragen. [Browsable(true)] [ControlStylesBrowsable(true)] public byte? InitialDepth { get; set; } Property Value byte?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsFirstLevelExpandIconVisible.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsFirstLevelExpandIconVisible.html",
    "title": "Property IsFirstLevelExpandIconVisible",
    "keywords": "Property IsFirstLevelExpandIconVisible Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll IsFirstLevelExpandIconVisible Mit diesem Property kann gesteuert werden, ob in der ersten Ebene des TreeViews das ExpandIcon („+“ Symbol zum Aufklappen) angezeigt werden soll oder nicht. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? IsFirstLevelExpandIconVisible { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.ShowLines.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.ShowLines.html",
    "title": "Property ShowLines",
    "keywords": "Property ShowLines Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ShowLines Gibt an, ob die Linien der Baum-Struktur vor den Tree-Nodes angezeigt werden sollen. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowLines { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.html",
    "title": "Class TreeViewDesignViewModel",
    "keywords": "Class TreeViewDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class TreeViewDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TreeViewDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties BackColor2 Gibt die alternierende Hintergrundfarbe für die TreeView an. Für den Hintergrund der Tree-Nodes wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Nodes die BackColor verwendet. DragDropMode Gibt an, von welchen Controls aus in den aktuellen Tree-View Drag and Drop ausgeführt werden InitialDepth Gibt an, bis zu welcher Ebene Daten vom TreeView an den Anzeige-Client übertragen werden. Hat ein Tree z.B. 5 Ebenen und InitialDepth ist mit 2 definiert, werden erst beim Aufklappen der 3. Ebene im Client die neuen Daten übertragen. IsFirstLevelExpandIconVisible Mit diesem Property kann gesteuert werden, ob in der ersten Ebene des TreeViews das ExpandIcon („+“ Symbol zum Aufklappen) angezeigt werden soll oder nicht. ShowLines Gibt an, ob die Linien der Baum-Struktur vor den Tree-Nodes angezeigt werden sollen."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.ContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.ContentAlignment.html",
    "title": "Property ContentAlignment",
    "keywords": "Property ContentAlignment Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll ContentAlignment Definiert, wie der Inhalt ausgerichtet werden soll. [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(AlignmentObjectConverter<WrapPanelHorizontalContentAlignment, WrapPanelVerticalContentAlignment>))] public Alignment<WrapPanelHorizontalContentAlignment, WrapPanelVerticalContentAlignment> ContentAlignment { get; set; } Property Value Alignment<WrapPanelHorizontalContentAlignment, WrapPanelVerticalContentAlignment>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.HorizontalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.HorizontalContentAlignment.html",
    "title": "Property HorizontalContentAlignment",
    "keywords": "Property HorizontalContentAlignment Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll HorizontalContentAlignment Die Controls werden zeilenweise angeordnet und brechen um, wenn der Platz in der Breite nicht ausreicht. [Browsable(false)] [ControlStylesBrowsable(true)] public WrapPanelHorizontalContentAlignment? HorizontalContentAlignment { get; set; } Property Value WrapPanelHorizontalContentAlignment?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.InvertFlowDirection.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.InvertFlowDirection.html",
    "title": "Property InvertFlowDirection",
    "keywords": "Property InvertFlowDirection Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll InvertFlowDirection Die Controls werden in umgekehrter Reihenfolge im WrapPanel platziert. Die Tab-Order wird dabei auch verdreht, sodass in der Anwendung die Tab-Order wieder von „vorne“ nach „hinten“ läuft. Diese Einstellung kann nützlich sein, wenn neu hinzugefügte Controls standardmäßig am Anfang platziert werden sollen – z.B. bei rechts ausgerichteten Button-Leisten. [Browsable(true)] [ControlStylesBrowsable(true)] public bool? InvertFlowDirection { get; set; } Property Value bool?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.VerticalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.VerticalContentAlignment.html",
    "title": "Property VerticalContentAlignment",
    "keywords": "Property VerticalContentAlignment Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll VerticalContentAlignment Die Controls werden spaltenweise angeordnet, wobei das WrapPanel die Anonrdnung mit der geringsten Höhe sucht. Bei einer gegebenen Breite werden so viele Spalten wie möglich angezeigt. [Browsable(false)] [ControlStylesBrowsable(true)] public WrapPanelVerticalContentAlignment? VerticalContentAlignment { get; set; } Property Value WrapPanelVerticalContentAlignment?"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.html",
    "title": "Class WrapPanelDesignViewModel",
    "keywords": "Class WrapPanelDesignViewModel Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly FrameworkSystems.FrameworkStudio.General.dll public class WrapPanelDesignViewModel : SpaceableContainerDesignViewModel, INotifyPropertyChanged, IDisposable Inheritance object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel LayoutContainerDesignViewModel SpaceableContainerDesignViewModel WrapPanelDesignViewModel Implements INotifyPropertyChanged IDisposable Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.MLCaption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.MLTooltip ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties ContentAlignment Definiert, wie der Inhalt ausgerichtet werden soll. HorizontalContentAlignment Die Controls werden zeilenweise angeordnet und brechen um, wenn der Platz in der Breite nicht ausreicht. InvertFlowDirection Die Controls werden in umgekehrter Reihenfolge im WrapPanel platziert. Die Tab-Order wird dabei auch verdreht, sodass in der Anwendung die Tab-Order wieder von „vorne“ nach „hinten“ läuft. Diese Einstellung kann nützlich sein, wenn neu hinzugefügte Controls standardmäßig am Anfang platziert werden sollen – z.B. bei rechts ausgerichteten Button-Leisten. VerticalContentAlignment Die Controls werden spaltenweise angeordnet, wobei das WrapPanel die Anonrdnung mit der geringsten Höhe sucht. Bei einer gegebenen Breite werden so viele Spalten wie möglich angezeigt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Classes BrowserDesignViewModel ButtonBaseDesignViewModel ButtonDesignViewModel Diese Klasse repräsentiert das Control Button. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. CheckBoxDesignViewModel Diese Klasse repräsentiert das Control CheckBox. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ComboboxDesignViewModel Diese Klasse repräsentiert das Control Combobox. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ContainerDesignViewModel ContextMenuDesignViewModel Diese Klasse repräsentiert das Control ContextMenu. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ControlDesignViewModel DashBoardContainerViewModel Diese Klasse repräsentiert das Control DashboardContainer. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. DockPanelDesignViewModel EditboxDesignViewModel Diese Klasse repräsentiert das Control EditField. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. FieldPanelDesignViewModel FieldRowDesignViewModel FormContainerDesignViewModel Diese Klasse repräsentiert das Control FormContainer. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. GridColDesignViewModel Diese Klasse repräsentiert das Control Grid-Column. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. GridDesignViewModel Diese Klasse repräsentiert das Control Grid. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ImageButtonDesignViewModel Diese Klasse repräsentiert das Control ImageButton. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. LabelDesignViewModel Diese Klasse repräsentiert das Control Label. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ListBaseDesignViewModel ListViewDesignViewModel Diese Klasse repräsentiert das Control ListView. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ListboxDesignViewModel Diese Klasse repräsentiert das Control Listbox. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. MainMenuDesignViewModel Diese Klasse repräsentiert das Control Menu-Item. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. PictureDesignViewModel Diese Klasse repräsentiert das Control Picture. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. RadioButtonDesignViewModel TabPageDesignViewModel TabbedWindowDesignViewModel TemplateControlDesignViewModel Diese Klasse repräsentiert das Control TemplateControl. Die Properties und Events dieser Klasse werden im Form-Designer angeboten. TreeNodeDesignViewModel TreeViewDesignViewModel WrapPanelDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer Classes ControlTreeNode"
  },
  "articles/aktuelle-pakete.html": {
    "href": "articles/aktuelle-pakete.html",
    "title": "Aktuelle Installations-Pakete",
    "keywords": "Aktuelle Installations-Pakete In dieser Liste sind alle aktuellen verfügbaren Installations-Pakete aufgeführt. Paket Version Name der Zip-Datei Framework Studio IDE 4.8.0 Alpha 4 FS_4.8.0_Alpha_4_Setup_x64 Requirements-Paket 64 Bit 4.5.15 FS_4.5.15_Requirements_x64 Runtime Administration 4.2.0 FS_4.2.0_RuntimeAdministration Authentication-Service 4.5.13 FS4.5.13_AuthService Print-Service 4.5.20 FS4.5.20_PrintService FSClient Launcher 64 Bit 4.8.0 Alpha 3 FSCL_4.8.0_Alpha_3_Setup_x64 Runtime Supervisor 4.4.11 RS_4.4.11_Setup_x64"
  },
  "articles/frequently-asked-questions.html": {
    "href": "articles/frequently-asked-questions.html",
    "title": "Frequently asked questions",
    "keywords": "Frequently asked questions In diesem Kapitel dreht sich alles um Fragen und Probleme, welche uns in regelmäßigen Abständen erreichen. Unteranderem werden wir hier auch bekannte Fehler-Stacktraces auflisten und deren Fehlerbehebung. Anleitungen Für eine Performance-Analyse und eine Stackoverflow Analyse gibt es unter Knowledge bereits eine Dokumentation. FrameworkStudio Repository Backup bereitstellen Öffnen Sie Microsoft SQL Management Studio, um auf die FrameworkStudio Repository-Datenbanken zugreifen zu können. Wählen Sie die Datenbank aus, an welcher Sie sich auch im Framework Studio anmelden. ContextMenü der Datenbank im SQL Management Studio öffnen - Tasks - Back up ... Backup type: Full auswählen! Ggf. Speicherort auswählen und OK drücken Die erstellte Backup-Datei auf dem FTP hochladen und uns benachrichten, dass das Backup hochgeladen wurde. Java-Applikation Java-Exception: null Beim Start der Java-Applikation wird folgender oder ähnlicher Fehler ausgegeben: Java-Exception: null at FrameworkSystems.FSJavaClient.DevControl.LayoutComponentDefault.<init>(LayoutComponentDefault.java:54) at FrameworkSystems.FSJavaClient.DevControl.LayoutComponentDefault.<init>(LayoutComponentDefault.java:43) at FrameworkSystems.FSJavaClient.DevControl.LayoutComponentDefault.<init>(LayoutComponentDefault.java:39) at FrameworkSystems.FSJavaClient.UIWrapper.UIItem.createLayoutComponent(UIItem.java:449) at FrameworkSystems.FSJavaClient.UIWrapper.UIItem.getLayoutComponent(UIItem.java:443) at FrameworkSystems.FSJavaClient.UIWrapper.support.UIContainerSupport.setChildrenAtDevControl(UIContainerSupport.java:30) at FrameworkSystems.FSJavaClient.UIWrapper.UIDockPanel.resumeVch(UIDockPanel.java:57) at FrameworkSystems.FSJavaClient.UIWrapper.visualControlHierarchy.VchSuspendManager.resume(VchSuspendManager.java:67) at FrameworkSystems.FSJavaClient.DevForm.<init>(DevForm.java:407) at FrameworkSystems.FSJavaClient.DevRequest.Response(DevRequest.java:1065) at FrameworkSystems.FSJavaClient.DevRequest.Start(DevRequest.java:603) at FrameworkSystems.FSJavaClient.FSViewer.init(FSViewer.java:267) at FrameworkSystems.FSJavaClient.FSViewerSession.run(FSViewerSession.java:87) at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:301) at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:758) at java.awt.EventQueue.access$500(EventQueue.java:97) at java.awt.EventQueue$3.run(EventQueue.java:709) at java.awt.EventQueue$3.run(EventQueue.java:703) at java.security.AccessController.doPrivileged(Native Method) at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:74) at java.awt.EventQueue.dispatchEvent(EventQueue.java:728) at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:205) at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116) at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105) at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101) at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93) at java.awt.EventDispatchThread.run(EventDispatchThread.java:82) Ursache Systemvoraussetzung Seit Version FS 4.5 verwendet FrameworkStudio den JxBrowser. Hierzu gibt es folgenden Hinweis in unserer Neuheiten-Dokumentation: https://frameworksystemsgmbh.github.io/fsdocs/v4.5/articles/neuheiten-4-5.html#neues-browser-control---austausch-des-javafx-browsers Deshalb haben wir die unterstützten Windows Versionen nach oben setzen müssen. Bitte sehen Sie sich hierfür unsere Systemvoraussetzungen. in der Dokumentation an. Lösung: Systeme auf die Systemvoraussetzungen updaten. Sollte ein Update kurzfristig nicht möglich sein, kann der jxBrowser mit folgendem Ausdruck im FS Client Launcher durch den alten Browser ersetzt werden. -Dfs.browser.legacy=1 Caution Langfristig müssen Sie jedoch Ihr System auf die entsprechenden Systemvoraussetzungen updaten, da der alte Browser in Zukunft deaktiviert wird. Der alte Browser deckt nicht alle Funktionen ab, welche eNVenta benötigt. Hier ist deshalb mit Einschränkungen zu rechnen. Ursache Citrix Environment Es gibt ein bekanntes Problem bei unserem neuen JxBrowser Control in Zusammenhang mit Citrix. Die Dokumentation, um dieses Problem lösen können, finden Sie hier oder hier bei Citrix direkt. Es ist notwendig die Citrix API Hooks auszuschalten. Betriebssystem MacOS Applikation Unterstützung MacOS unterstützen wir seit einiger Zeit nicht mehr. Wir gewährleisten auch keinen Support hierfür . Auf eigenes Risiko kann natürlich mit Java 8 ein Betrieb von eNVenta ERP versucht werden. Änderungen sind hier in der Zukunft nicht geplant. Exception Code Analysis has been disabled in this code editor because generating code took too long (17,1 s) Code Analysis has been disabled in this code editor because generating code took too long (17,5s)! Exception in diagnostics task: System.Exception: Error creating code for NV.ERP.MM.Sales.cfrmSalesOrder Bei dieser Meldung im Output-Fenster handelt es sich um einen Schutz-Mechanismus und nicht um einen \"Fehler\". Der Code-Editor führt recht aufwändige Analysen durch, damit die (potentiellen) Compile-Error unmittelbar beim Bearbeiten im Code kenntlich gemacht werden. Dauert diese Analyse zu lange kann das dazu führen, dass Framework Studio praktisch lahmgelegt wird, sobald im Code-Editor getippt wird. Arbeiten ist dann nicht mehr möglich. Um genau diese Blockade zu verhindern, schalten wir diese Analyse ab, wenn die Ermittlung beim ersten Aufruf länger als 10 Sekunden oder bei einem erneuten Aufruf länger als 5 Sekunden dauert. Im genannten Beispiel waren es 17,1 Sekunden. Drucker wird im Namen mit ## ERR ## angezeigt Der Print-Service prüft beim Hochfahren alle konfigurierten Drucker. Wenn dabei ein Fehler auftritt (z.B. weil der Drucker nicht mehr existiert), wird der Name des betroffenen Druckers mit der Kennung ## ERR ## versehen. Um sicher zu gehen, können Sie auch die Log-Datei des Print-Service prüfen. Mit der PrintServiceConfigEditor.exe können Sie diese Drucker aus der Konfiguration entfernen. Nach einem Neustart des Print-Service werden die gelöschten / nicht mehr existenten Drucker im Runtime-Repository auf gelöscht gesetzt. Anschließend sollten Sie auch in eNVenta nicht mehr angeboten werden."
  },
  "articles/knowledge/dottrace-performance.html": {
    "href": "articles/knowledge/dottrace-performance.html",
    "title": "Performance-Analyse mit dotTrace",
    "keywords": "Performance-Analyse mit dotTrace dotTrace von der Firma JetBrains ist ein kostenpflichtiges Werkzeug zur Analyse der Performance von .NET-Anwendungen. Aufzeichnen mit Console-Werkzeug Für die Aufzeichnung von Sitzungen bietet JetBrains eine kostenlose Konsole-Anwendung (zur Download-Seite). Diese Aufzeichnung können mit der dotTrace-Anwendung analysiert werden. Development-Broker aufzeichnen Als erstes bauen Sie den Command-Line Befehl für die Aufzeichnung mit der dottrace.exe zusammen. Dazu verwenden sie am besten einen Text-Editor. Wichtig ist, dass alle Argumente ohne Zeilen-Umbruch zusammengefügt werden müssen. Folgende Argumente werden benötigt: start Es soll eine Anwendung gestartet werden --service-input=stdin Die Aufzeichnung wird über die Console gesteuert. Weitere Erklärungen folgen unten. --profiling-type=Tracing Dieser Aufzeichnungs-Modus protokolliert einzelne Methoden-Aufrufe und ermöglicht eine sehr detaillierte Auswertung sowohl über die Dauer als auch die Anzahl von Methoden-Aufrufen. --save-to=C:\\temp\\Profile\\MyProfiling.dtp Dort werden die Snapshots gespeichert. Werden mehrere Snapshots erzeugt erhalten diese den Dateinamen MyProfiling-2.dtp usw. Bei einer neuen Session muss ein abweichender Dateiname angegeben werden. \"--work-dir=C:\\Program Files\\enventa Group\\Framework Studio\\4.7\" Das Programm-Verzeichnis von Framework Studio. Bitte auf die \"Gänsefüßchen\" achten. Die sind notwendig wegen der Leerzeichen im Pfad. \"C:\\Program Files\\enventa Group\\Framework Studio\\4.7\\FS.Hosting.Broker.Dev.exe\" - Exe-Datei für den Development-Broker -- Dieser Trenner muss zwingend vor die jetzt folgenden Argumente gepackt werden, weil diese ebenfalls -- enthalten. --devbroker -RepositoryName \"FSDemoCustomize 4.3\" -ApplicationPath ... Das sind die Argumente des Development-Brokers. Diese erhalten sie folgendermaßen: Aus der Framework Studio heraus die Application starten. Im System Tray wird das Icon für den Development-Broker angezeigt. Klicken Sie auf dieses Icon und rufen Sie den Menü-Punkt Copy Command Line Arguments auf. Fügen Sie alle Argumente aus der Zwischen-Ablage ein - bis auf das erste Argument - das ist der Name der Exe-Datei. Beenden sie die Application wieder, ansonsten funktioniert der anschließende Start nicht. Ein kompletter Aufruf sieht dann z.B. so aus: dottrace.exe start --service-input=stdin --profiling-type=Tracing --save-to=C:\\temp\\ProfileTest\\MySnapshot.dtp \"--work-dir=C:\\FS\\Framework Studio 4.3.0.0\" \"C:\\FS\\Framework Studio 4.3.0.0\\FrameworkBrokerHostDev.exe\" -- --devbroker -RepositoryName \"FSDemoCustomize 4.3\" -ApplicationPath \"C:\\FS\\Compile43\\NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1\" -ApplicationBinPath \"C:\\FS\\Compile43\\NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1\\bin\" -ApplicationName \"FSDemoApplication\" -ApplicationConfig \"C:\\FS\\Compile43\\NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1\\FSDemoApplication.config\" -Endpoint \"http://localhost:8080/Dev/NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1/FSDemoApplication/\" -StartPageAddress \"http://localhost:8080/Dev/NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1/FSDemoApplication/start\" -LoggingMode \"3\" -LoggingDir \"C:\\FS\\Logging\\*\" -LoggingRequestFileName \"% ? Request.xml\" -LoggingResponseFileName \"% ? Response.xml\" Starten Sie die Console im dotTrace Ordner. Führen Sie den gerade zusammengestellten Befehl aus. Dabei wird der Application-Broker gestartet. Klicken Sie auf das System-Tray-Icon der Application und rufen Sie den Menüpunkt Open Client Start Page auf. Es wird die Start-Page angezeigt über die sie Application starten können. DotTrace läuft jetzt in der Console und zeichnet den aktuellen Application-Broker auf. Sie können die Aufzeichnung durch Eingabe der folgenden Befehle steuern. Ein Befehl muss mit Enter bestätigt werden. ##dotTrace[\"drop\"] Stoppt die aktuelle Aufzeichnung ohne diese zu speichern. Vor allem direkt nach dem Start ist das sinnvoll, bis man sich an der gewünschten Stelle im Programm befindet. ##dotTrace[\"start\"] Startet die Aufzeichnung ##dotTrace[\"get-snapshot\"] Stoppt die Aufzeichnung und speichert diese ab. Während einer Session können mehrere Snapshots erzeugt werden. Diese werden mit fortlaufenden Nummern gespeichert. Sind alle Aufzeichnungen fertig, dann kann die Anwendung beendet werden. Beenden sie den Application-Broker über das System-Tray-Icon. Läuft gerade eine Aufzeichnung, dann speichert dotTrace diese automatisch ab. Der Java-Client muss manuell beendet werden. Die erzeugten Snapshots können jetzt inkl. der erzeugten .dtp.000, .dtp.001 ... Dateien für die Analyse verpackt werden."
  },
  "articles/knowledge/merhfacher-package-owner.html": {
    "href": "articles/knowledge/merhfacher-package-owner.html",
    "title": "Package-Owner in mehreren Repositories",
    "keywords": "Package-Owner in mehreren Repositories Framework Studio ist dafür konzipiert, dass ein Package über seine komplette Lebensdauer in genau einem Repository entwickelt wird - man darf also grundsätzlich nur in einem einzigen Repository der Owner sein. Insbesondere gilt das für Funktions-Packages, die exportiert werden und in einem Ziel-Repository zum Einsatz kommen. Caution Wird ein Funktions-Package in mehreren Repositories gleichzeitig entwickelt - ist man also Owner in mehreren Repositories, dann erzeugt das Kollisionen im Ziel-Repository. Werden Versionen desselben Packages aus mehreren Quell-Repositories in ein Ziel-Repository importiert, vermischen sich dabei die Änderungen aus beiden Repositories und verursachen Kollisionen. Besonders problematisch ist, solche Kollisionen erst nach dem Package-Import im Ziel-Repository auftreten. Im besten Fall führen sie dort unmittelbar beim Compile zu Fehlermeldungen und können so relativ schnell erkannt werden. Je nach Situation kann es auch passieren, dass solche Probleme erst zur Laufzeit in der Anwendung zutage treten und dort z.B. durch einen fehlerhaften Methoden-Inhalt zu Fehlverhalten führen. Solche Kollisionen können unmittelbar auftreten - sie treten eventuell aber auch erst zu einem viel späteren Zeitpunkt auf. Diese Kollisionen können sich z.B. folgendermaßen auswirken: Es existieren Unter-Elemente (z.B. Component-Properties) die dort nicht hingehören. Eine Methode hat den falschen Inhalt (aus der anderen Package-Version) Es fehlen Unter-Elemente (weil sie in der anderen Package-Version gelöscht wurden) ... Technischer Hintergrund In Framework Studio werden die Elemente mit einem fortlaufenden Zähler versioniert. Bei einem Check-Out wird die neue Versions-Nummer des Elementes mit Max+1 ermittelt. Dabei teilen sich alle Versionen eines Packages denselben Nummernkreis der Versions-Nummern. Beispiel: Wird in der Package-Version \"2.0\" ein Element ausgecheckt erhält es die Versions-Nummer 7, wird im Anschluss in der Package-Version \"3.0\" dasselbe Element ausgecheckt erhält es die Versions-Nummer 8. Wird diese Aktion in 2 jedoch verschiedenen Repositories durchgeführt, dann erhalten die Elemente in beiden Package-Versionen \"2.0\" und \"3.0\" dieselbe Versions-Nummer 7. Alle z.B. neu angelegten Component-Properties erhalten ebenfalls die Versions-Nummer 7. Importiert man diese beiden Package-Versionen \"2.0\" und \"3.0\" in dasselbe Ziel-Repository, dann ist dort die Versions-Nummer 7 ein Mix aus den Änderungen in beiden Package-Versionen. Spielregeln bei mehreren Repositories Grundsätzlich darf es nur ein Repository geben, indem man Owner ist. Wird von dieser Regel abgewichen, dann bedeutet das einen erhöhten organisatorischen Aufwand und es müssen einige Spielregeln beachtet werden. Wird von diesen Regeln abgewichen hat das Kollisionen zur Folge, die nur mit enormen Aufwand zu bereinigen sind. Versions-Nummern separieren Die Kreise der Versions-Nummern müssen voneinander separiert werden. Das erfolgt, indem in einem der beiden Repositories - idealerweise dem \"neueren\" - alle Versions-Nummern um den Wert 5000 erhöht werden. Es gibt dafür eine Funktion im Package-Manager: In der Datei FrameworkStudio.exe.config im Programm-Verzeichnis den folgenden Config-Schalter ergänzen: <?xml version=\"1.0\"?> <configuration> <appSettings> <!-- Aktivate PackageManager - Menu Tools / Lift Element Versions --> <add key=\"VersionLiftActive\" value=\"true\" /> ... Den Package-Manager starten und am \"neuen\" Repository anmelden Das gewünschte Package auswählen Menü Tools / Lift Element Versions (increase all Versions with 5000) ausführen. Im alten Repository keine Package-Version löschen Im alten Repository dürfen keine Package-Versionen mehr gelöscht werden, weil dies erneut Kollisionen im Ziel-Repository verursacht. Package-Versionen sollten statt dessen mit einem entsprechenden Kommentar durch Lock für eine weitere Bearbeitung gesperrt werden. Beim Löschen einer Package-Version werden die Versions-Nummern ebenfalls angehoben. Das ist notwendig, weil bei der Lösch-Aktion ggf. Versions-Nummern gelöscht werden, die bei einem späteren Check-Out in einer anderen Version des Packages erneut verwendet werden und so Kollisionen erzeugen. Wird also im \"alten\" Repository eine Package-Version gelöscht, dann werden die Versions-Nummern auf denselben Wert angehoben wie im neuen Repository. Das produziert in der Folge Kollisionen. Kollision bereinigen Ist in einem Ziel-Repository ein Kollision aufgetreten, muss diese behoben werden. Wird die Kollision sehr schnell erkannt, sollte man darüber nachdenken, ggf. eine Sicherung des Repositories zurückzuspielen. Anschließend muss dann eine korrigierte Variante der Package-Version importiert werden. Ist das zurückspielen der Sicherung keine Option, weil z.b. im eigenen Package Änderungen vorgenommen wurden, dann kann dies auf die Folgende Weise behoben werden: In den Quell-Repositories die Versions-Nummern separieren und die Package-Versionen neu exportieren Im Ziel-Repository alle Versionen des betroffenden Packages löschen. Saubere Stände der Package-Versionen neu importieren."
  },
  "articles/knowledge/snapshot-isolation.html": {
    "href": "articles/knowledge/snapshot-isolation.html",
    "title": "Zeilenversionierung im SQL-Server",
    "keywords": "Zeilenversionierung im SQL-Server Alle Microsoft SQL-Server Datenbanken, welche von Framework Studio genutzt werden, müssen mit aktivierter Zeilenversionierung arbeiten. Andernfalls können insbesondere längere Transaktionen unnötige Blockierungen auf Select-Statements zur Folge haben. Mit folgendem Statement kann die Einstellung überprüft werden. Dabei muss AdventureWorks durch den Namen der Datenbank ersetzt werden: SELECT snapshot_isolation_state_desc AS [READ_COMMITTED_SNAPSHOT], is_read_committed_snapshot_on AS [ALLOW_SNAPSHOT_ISOLATION] FROM sys.databases WHERE NAME = 'AdventureWorks' GO Das Ergebnis sollte ON, 1 sein. Mit folgenden Statements können die Einstellungen korrekt gesetzt werden. Dabei muss AdventureWorks durch den Namen der Datenbank ersetzt werden: ALTER DATABASE [AdventureWorks] SET READ_COMMITTED_SNAPSHOT ON GO ALTER DATABASE [AdventureWorks] SET ALLOW_SNAPSHOT_ISOLATION ON GO Beim Ausführen dieser Statements darf niemand angemeldet sein (auch keine Services) da exklusiver Zugriff auf die Datenbank benötigt wird. Framework Studio aktiviert die Zeilenversionierung beim Anlegen von Datenbanken automatisch."
  },
  "articles/knowledge/stackoverflow-analysieren.html": {
    "href": "articles/knowledge/stackoverflow-analysieren.html",
    "title": "StackOverflow Analysieren",
    "keywords": "StackOverflow Analysieren Wenn in einem .NET-Programm eine StackOverflowException ausgelöst wird, dann crashed der komplette Prozess. Für den Programmierer gibt es leider absolut keine Möglichkeit, dies abzufangen. Es gibt die Möglichkeit, sich mit dem Visual Studio Debugger vorher an den Prozess zu hängen. Wenn die Exception aufschlägt, zeigt der Debugger den Call-Stack an. Man benötigt dafür aber Visual Studio und es kann hin und wieder passieren, dass dies auch mal nicht funktioniert. Im folgenden wird eine alternative Vorgehensweise beschrieben, die deutlich zuverlässiger zum Ergebnis führt. Es wird mithilfe des Werkzeug ProcDump beim Auftreten dieser Exception ein Dump-File erstellt. Dieses wird anschließend mit windbg analysiert und der Call-Stack ermittelt. Ist es ein StackOverflow? zuerst stellt sich die Frage ob der Absturz eines Brokers tatsächlich durch einen StackOverflow ausgelöst wird. Das kann an den folgenden Symptomen festgestellt werden: 1.) Alle Benutzer die auf dem Broker arbeiten erhalten die Meldung: Session has been terminated! SessionID is unknown. 2.) Im Event-Log des Broker-Servers ist folgender Eintrag zu finden: Quelle: Application Error Ereignis-ID: 1000 Detail-Text: Name der fehlerhaften Anwendung: w3wp.exe Ausnahmecode: 0xc00000fd Fehler reproduzieren Wenn nicht bekannt ist, wie genau der Fehler entsteht, dann ist es empfehlenswert dies herauszufinden. Denn so kann man gezielt einen Broker starten, den Fehler auslösen und ein Dump-File erzeugen. Um das einzugrenzen kann das SessionTrace verwendet werden. Dazu gibt man in der web.config die folgenden Informationen an: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <appSettings> <add key=\"SessionTraceFolder\" value=\"C:\\temp\\sessiontrace\" /> <add key=\"SessionTraceCaching\" value=\"false\"/> ... Warning Das Ändern der Datei startet den Broker neu Den SessionTraceFolder kann man auch im Publish-Wizard angeben. Das SessionTraceCaching muss aber manuell auf \"false\" gesetzt werden, damit Anfang und Ende eines Requests getrennt protokolliert werden. Das ist entscheidend für die Analyse des Fehlers. Wurden die Dateien erzeugt und es ist mind. ein Absturz aufgetreten, dann kann man den SessionTrace-Ordner in das Werkzeug FSSessionTraceAnalyzer.exe einlesen (dieses befindet sich im Framework Studio Programmverzeichnis). Auf der Registerkarte \"Session Map\" gibt es unten einen Link \"Show open Requests\". Dieser zeigt eine Liste aller Requests an, zu denen keine Ende protokolliert wurde. Das können potentielle Kandidaten sein, aber ggf. auch Requests die unverschuldet mit abgebrochen wurden. Gut ist es daher, wenn mehrere Abstürze aufgetreten sind, so lässt sich der entscheidende Kandidat besser finden. Gibt die gewonnene Info noch keine Aufschluss über die Ursache, dann ist der nächste Schritt das Erstellen eines Dump-Files. Dump-File erstellen Vorbereitungen Das freie Werkzeug ProcDump herunterladen https://docs.microsoft.com/en-us/sysinternals/downloads/procdump Die Zip-Datei entpacken z.B. in den Ordner C:\\ProcDump Dump erzeugen Der betroffene Prozess muss bereits laufen. ProcDump beobachtet den laufenden Prozess und erzeugt im Falle eines StackOverflow den gewünschten Dump. Eingabeaufforderung starten. Ggf. als Administrator erforderlich um sich an einen Windows Dienst hängen zu können. In den Ordner des ProcDump-Programms navigieren C:\\> cd C:\\ProcDump Das Programm starten C:\\ProcDump> procdump64.exe -accepteula -e 1 -f C00000FD.STACK_OVERFLOW -g -ma <PID> %temp% <PID> ist die ID des Processes. Diese kann über den Task-Manager in Erfahrung gebracht werden. Es kann auch der Name des Prozesses - z.B. w3wp.exe oder NV.ERP.Base.JobServer.Host.JobServerHost.WindowsService.exe angegeben werden. Dies funktioniert aber nicht, wenn der Prozess mehrfach mit dem selben Namen ausgeführt wird (bsp. w3wp.exe mehrfach gestartet wird). Die Eingabeaufforderung offen und am Server den Windows-Benutzer angemeldet lassen. Wenn jetzt eine StackOverflowException auftritt, erzeugt dieses Programm einen Dump, bevor das Programm im Anschluss endgültig crashed. Die Dump-Datei wird in den Temp-Ordner gepackt. Sie heißt NameDesProcesses_Datum_Uhrzeit.dmp. Diese Datei kann im nächsten Schritt mit WinDbg analysiert werden. Die Datei kann ggf. mehrere GB groß sein, denn sie enthält ein komplettes Hauptspeicher-Abbild des Prozesses. Erfolgt eine Analyse bei N&V, dann sollte die Datei als 7-Zip gepackt und per ftp bereitgestellt werden. Analyse mit windbg.exe Vorbereitungen Note Ist auf dem Rechner Visual Studio installiert, dann ist WinDbg evtl. bereits verfügbar. Die Installation ist in diesem Fall nicht nötig. Das Tool WinDbg bietet Microsoft als Store-App an: https://apps.microsoft.com/detail/9pgjgd53tn86. Alternativ kann die Installation dieses Tools auch über das Windows SDK erfolgen. Dazu das Windows SDK von der folgenden Seite herunterladen: https://developer.microsoft.com/windows/downloads/windows-sdk/ Button \"Laden Sie das Installationsprogramm herunter>\" Die Installations-Routine winsdksetup.exe starten. Alles Haken außer \"Debugging Tools for Windows\" entfernen.< Installieren. Analyse Die windbg.exe (x64-Variante) starten. Einfach im Startmenü \"windbg\" eintippen. Die Dump-Datei einlesen Menü File -> Open Crash Dump Unten in die Text-Zeile die folgenden Befehle eingeben: 0:000> .loadby sos clr 0:000> !analyze Jetzt den Callstack anzeigen mit folgendem Befehl: 0:000> !clrstack Dies kann eine ganze Weile gehen - einfach abwarten :-) Links https://msdn.microsoft.com/de-de/library/system.stackoverflowexception(v=vs.110).aspx https://www.thebestcsharpprogrammerintheworld.com/2017/12/12/capture-a-stackoverflowexception-and-make-a-dump-0xc00000fd/ https://stackify.com/using-windbg-to-analyze-net-crash-dumps-async-crash/"
  },
  "articles/neuheiten-4-2.html": {
    "href": "articles/neuheiten-4-2.html",
    "title": "Neuheiten Framework Studio 4.2",
    "keywords": "Neuheiten Framework Studio 4.2 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen. Neue Systemvoraussetzungen In dieser Version gibt es einige Anpassungen bei den Systemvoraussetzungen. Im folgenden sind die wichtigsten Änderungen aufgeführt. Datenbank-Server Es wird der Oracle Server 12.2 oder höher (18c, 19c, ...) unterstützt. Ältere Versionen werden nicht mehr unterstützt. Es wird der SQL-Server 2012 oder höher unterstützt. Ältere Version (z.B. SQL-Server 2008) werden nicht mehr unterstützt. Important Ein Betrieb mit einer älteren Datenbank-Version ist nicht möglich. Ein Connect auf so einen Datenbank-Server führt unmittelbar zu einer entsprechenden Fehlermeldung. Oracle Client Es wird nur noch der Oracle Managed Provider unterstützt. Der Oracle ODP Provider wird nicht mehr unterstützt. Framework Studio benötigt damit keinen separaten Oracle-Client mehr. 64 Bit Die folgenden Programme können nur noch auf 64-Bit Systemen installiert werden. Eine 32-Bit Installations-Routine wird nicht mehr angeboten: Framework Studio IDE / Package Manager Publish / Publish2Go Anwendungs-Broker Framework Studio Services 32-Bit wird weiterhin unterstützt für: Client-Rechner Print-Server .NET Framework 4.8 Framework Studio setzt auf das .NET Framework 4.8 auf. Der Installer ist im Requirements-Paket enthalten und muss ggf. vor der Installation von Framework Studio ausgeführt werden. Alternativ kann der Installer auch direkt bei Microsoft heruntergeladen werden: https://dotnet.microsoft.com/download/dotnet-framework/net48 Betriebssysteme Mit dem Umstieg auf das .NET Framework 4.8 können einige ältere Windows Betriebssysteme nicht mehr unterstütz werden. Es werden aktuell folgende Betriebssysteme unterstützt: Server Windows Server 2012 R2 - oder höher Client / Entwicklungs-Rechner Windows 10 (Version 18.03 - oder höher) Windows 8.1 Für die Endanwender-Rechner bzw. Terminal-Server gelten weiter die bisherigen Anforderungen. C# 7 Mit dem Update auf das .net Framework 4.8 unterstützt Framework Studio auch die C# Sprach-Features bis zur Version 7.3. Eine Übersicht der Features bietet die Web-Seite: https://docs.microsoft.com/dotnet/csharp/whats-new/csharp-7 In der folgenden Liste werden einige Features genannt, die seit C# 6 hinzugekommen sind. Der Einsatz dieses Features ist in Framework-Studio empfehlenswert: out variables - inline-Deklaration (C# 7.0) Folgende Features können ggf. sinnvoll sein: Tuples (C# 7.0) - nur innerhalb von Methoden-Code (z.B. bei Linq-Queries), nicht als Parameter oder Rückgabe-Typ von Methoden Inferred tuple element names (C# 7.1) Tuples support == and != (C# 7.3) Pattern matching (C# 7.0) Local functions (C# 7.0) - aber nur sehr gut überlegt!! MLKey Wörterbuch Eine zentrale Neuerung in der Version 4.2 betrifft das Handling der fremdsprachigen Texte. Diese werden jetzt in einem zentralen Wörterbuch verwaltet. Bisher wurden alle Texte am jeweiligen Element (z.B. Metadatentyp, ComponentProperty, FormControl) gepflegt. Jetzt werden an allen diesen Stellen Schlüssel (MLKeys) angegeben, die auf das zentrale Wörterbuch verweisen. Dadurch hat man erst einmal etwas mehr organisatorischen Aufwand, aber auf längerer Sicht betrachtet bringt diese Vorgensweise viele Vorteile: Redundanzen werden vermieden, weil existierende Texte wiederverwendet werden können und sollen. Dadurch erhält man zudem in der kompletten Anwendung durchgängige und einheitliche Bezeichnungen. Die fremdsprachigen Übersetzungen können sehr einfach und zentral gepflegt werden. Besonders im Customizing-Package ist das von großem Vorteil, weil jetzt nicht mehr die einzelnen Elemente ausgecheckt werden müssen. Das Wörterbuch kann auch im Service-Release bearbeitet werden. Der Export und Import von Texten ist sehr einfach. Es wird das standardisierte TMX-Format verwendet. Texte können so zwischen verschiedenen Packages und Versionen ausgetauscht werden. Auch eine Übersetzung durch Werkzeuge oder externe Dienstleister ist dadurch deutlich einfacher als bisher. Eine detailliert Beschreibung der Funktionalität finden sie im Kapitel MLKey. Es ist sinnvoll, die Texte des eigenen Packages in das Wörterbuch zu überführen. Bitte beachten sie dazu die Hinweise und Anleitungen für die Migration. Fremdsprachen im Customizing-Package Sprachen werden jetzt an der Package-Version organisiert und können somit in Customizing-Packages ergänzt werden. Code-Messages überarbeitet Die vom Exception- und MessageBox-Wizard generierten Code-Messages wurden überarbeitet. Das bisherige Konstrukt mit #region wurde durch eine Variante mit einem einfachen eingefärbten Kommentar // FSCodeMessage: ersetzt. Das macht den Quellcode kompakter und leserlicher – ohne extra aufklappen zu müssen. Der XML-Teil, welcher bisher die Informationen für die Wizard-Dialoge beinhaltet hat, entfällt. In der Vergangenheit konnte es sein, dass die XML-Informationen vom Code abwichen. Der Wizard hat dann den Code ignoriert und einfach ersetzt. Dadurch konnten wichtige Infos – wie z.B. ein MessageBox EventHandler – verloren gehen. Die Informationen werden jetzt aus dem Code geparsed. Kann (z.B. aufgrund von manuellen Anpassungen) der Code nicht geparsed werden, kann er nicht mehr durch den Wizard bearbeitet werden. Die Code-Messages können einen MLKey aus dem Wörterbuch verwenden. Die bisherige Variante mit TextCollection-Einträgen soll nach und nach durch die MLKeys ersetzt werden und so die ctMessage-TextCollections auslaufen. Bei MsgBox.Show() sind die Enum-Werte für Button und Icon leserlich ausgeschrieben. Bisher wurden dort nur die int-Werte verwendet. Die Konvertierung des bestehenden Codes in das neue Format erfolgt auf folgende Weise: Durch die MLKey-Konvertierungs-Routine – diese setzt alle Code-Messages automatisch auf einen MLKey und/oder das neue Format um. Durch manuellen Aufruf des Exception- oder MsgBox-Wizards. Beim Speichern wird der Code durch die neue Variante ersetzt. Bei beiden Konvertierungen wird nur der Code betrachtet - der alte XML-Teil wird ignoriert. Neue Messages werden immer im neuen Format generiert. Dabei ist es egal, ob ein Textcollection-Eintrag oder ein MLKey verwendet wird. Neue Text-Funktionen In Framework Studio 4.2 wurden im Zuge der Umstellung auf die MLKeys auch die Text-Zugriffe auf Text-Collections und DevMLStrings überarbeitet. Note Es muss eine Migration durchgeführt werden. Actions SetEnabled und SetVisible nullable Die Control-Actions SetEnabled und SetVisible haben neue Überladungen bekommen, welche das Zurücksetzen auf den im Property-Grid des Form-Designers eingestellten Wert ermöglichen. Dazu wurden folgende Überladungen ergänzt, bei denen der null-Wert zum Zurücksetzten verwendet werden kann: SetEnabled(bool? value) SetEnabled(FSbool value) SetVisible(FSVisibility? value) Caution Achtung, falls Reflection verwendet wurde! Sollte eine der ursprünglichen Methoden aus irgend einem Grund per Reflection angesprochen worden sein, so kann es nun zu dem Problem kommen, dass nicht mehr eine eindeutige, sondern mehrere Überladungen der Methode gefunden werden. Die Überladungen SetEnabled(bool value) und SetVisible(FSVisibility value) wurden entfernt, da Aufrufe vom Compiler direkt auf die entsprechenden Nullable-Überladungen umgelenkt werden. Forms und Workflows Obsolete setzen Soll ein Form oder ein Workflow nicht mehr verwendet werden, so können die für diese Elemente generierten Klassen mit dem Obsolete Attribut versehen werden. Dazu muss der Name des Elements mit _Obsolete enden. Beispiel: wlfArticleDetail_Obsolete Der Compiler erzeugt dann bei Verwendung der Elemente Warnings in der Form 'wflArticleDetail_Obsolete' is obsolete: 'Workflow 'wflArticleDetail_Obsolete' will be deleted in future version.'. Weitere Neuerungen Die MLColumn-Sprache kann zur Laufzeit beeinflusst werden. An den DBColumns können die Größen-Angaben überschrieben werden, auch wenn ein Metadatentyp zugeordnet ist. Compare with previous in Method- und Element-History Browsern Such-Funktionalität für die ML-Columns Im Register AccessUnits wird bei einer ungültigen Parent Beziehung ein Button 'Fix the parent Access Unit' angezeigt. Dieser löscht die ungültige Parent Beziehung und legt, falls kein anderer gültiger Parent vorhanden ist, die Access Unit unter Root."
  },
  "articles/neuheiten-4-3.html": {
    "href": "articles/neuheiten-4-3.html",
    "title": "Neuheiten Framework Studio 4.3",
    "keywords": "Neuheiten Framework Studio 4.3 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen. Statisches Caching an Components (Static Cache) Framework Studio wurde um einen statischen Caching-Mechanismus erweitert. Wird dieser für eine geeignete Component aktiviert, so können Daten statt von der Datenbank aus diesem Cache geladen werden. Dadurch sind erhebliche Performance-Vorteile möglich. Details sind im Kapitel Statisches Caching beschrieben. Umstellung auf PropertyChanged Die Framework Studio Components implementieren jetzt das Standard-Interface INotifyPropertyChanged. Details sind im Kapitel PropertyChanged beschrieben. Ggf. sind Anpassungen im eigenen Code notwendig. Bitte beachten sie dazu die Hinweise für die Umstellung. In diesem Zuge sind einige weitere Änderungen vorgenommen worden: Die Methoden GetProperty, SetProperty, GetPropertyMdt und die Eigenschaft ComponentProperties wurde an (I)DevFrameworkBaseObject verschoben. Damit können jetzt auch direkt an der Collection definierte Properties verarbeitet werden. Mit der neuen Methode IsComponentProperty kann man prüfen, ob es sich um ein vom Entwickler angelegtes Property handelt. Das Databinding in den Forms wurde komplett neu entwickelt. Das bringt unter anderem die folgenden Vorteile: Deutlich weniger Code und deutlich kleinere Assemblies (ca. -30%) Bei der Änderung von Werten wird für die Aktualisierung der Control-Inhalte am Ende des Requests jeder Wert nur einmal neu gelesen. Das gilt auch, wenn ein Property im Laufe des Requests mehrfach geändert wurde. Im Einzelfall kann das eine signifikante Steigerung der Performance bedeuten. Verhaltens-Änderung bei der SelectedRowsCollection Die an einem Grid gebundene Objekt-Collection und SelectedRowsCollection haben in der Vergangenheit eng zusammengearbeitet. Werden Records aus der Collection gelöscht oder eine neue Collection zugewiesen, dann werden aus der SelectedRowsCollection unmittelbar die entsprechenden Einträge entfernt. Das war möglich weil jede Änderung sofort vom Data-Binding übernommen wurde. Der neue asynchrone Ansatz im Data-Binding verhindert dies erst einmal. Damit bestehende Logik, die heute diesen Mechanismus voraussetzt, weiterhin funktioniert, wurde er im neuen Data-Binding nachgebaut - allerdings mit einer kleinen Einschränkung: Warning Weist man im Form eine neue Objekt-Hierarchie zu, die ihrerseits die Objekt-Collection für das Grid beinhaltet, dann wird die SelectedRowsCollection nicht automatisch geleert. Das muss in diesem Fall manuell durchgeführt werden. Deprecated Eigenschaft LabelOfControl Die Unterstützung für die Control-Eigenschaft LabelOfControl, die teilweise noch im Hintergrund gezogen hat, wurde entfernt. Siehe LabelOfControl Cleanup. Intellisense mit Roslyn Das Intellisense im Code-Editor wurde komplett überarbeitet. Es setzt jetzt mit \"Roslyn\" auf dieselbe Technologie auf wie das Intellisene von Visual Studio. Folgende Features werden jetzt unterstützt (Auszug): Lambda-Expressions (Linq) Generische Typen var schlüsselwort Überladene Methoden werden korrekt aufgelöst GoTo Definition für Form-Controls uvm ... Im Code-Editor werden Compile-Error und Warnings während dem Tippen direkt im Code markiert. Die Details des Errors werden in einem Tooltip angezeigt. Export von Tabellen Beschreibungen Im HTML-Export der Dokumentation gibt es eine neue Option Export DB-Tables. Diese integriert die Beschreibungen aller Datenbank-Tabellen. Beim Export über die FSConsole kann das über den Parameter \\ExportDBTables gesteuert werden. Im PBE kann dieser Export automatisiert werden. Menü Änderung beim Anlegen von Properties und Methods Beim Anlegen neuer Methoden in Forms oder Components wird nun in den Menüs abgefragt, ob diese als Public Method oder Protected Method angelegt werden sollen. Ferner gilt diese Regelung auch für Properties in Forms. Bei den Properties in den Components kann zwischen einer, wie bisher standermäßgen Public Property und einer Membervariable unterschieden werden. Eine Membervariable wird automatisch als Protected angelegt. Weitere Neuerungen Beim Export des Wörterbuches kann man die direkten Verwendungen der einzelnen MLKeys als Kommentar exportieren. Dazu gibt es im Export-Dialog eine neue Checkbox Include usings. Copy&Paste ist kompatibel bis einschließlich Framework Studio 3.11. Mit älteren Versionen von Framework Studio können per Copy&Paste keine Element-Informationen mehr ausgetauscht werden. In der Registerkarte Set Method kann bei Component Properties vom Typ Individual die generierte Prüfung auf den Getter der Checkbox Check before set unterbunden werden. Eine Prüfung findet standardmäßig statt, weshalb die Checkbox per default gesetzt ist. Die Registerkarte Description bei den Components wurde in General umbenannt. Ab der neuen Version befindet sich hier eine zusätzliche Checkbox Autogenerate Membervariable. Diese Checkbox wird ausschließlich bei Individual und Individual (readonly) Properties angezeigt und generiert sowohl eine Membervariable als auch ein Depends On Property, sobald sie gesetzt wird. In die Registerkarte General wurden ferner die Textfelder Display MinLength, Display MaxLength, Display MinLines und Display MaxLines und die Comboboxen Mapping und Drag Source verschoben. Des Weiteren können Sie wie gewohnt im Textfeld Description eine Beschreibung hinzufügen. Mit der Taste F1 kann im PropertyGrid für ein selektiertes Property, für welches eine Definition vorliegt, die Dokumentation geöffnet werden."
  },
  "articles/neuheiten-4-4.html": {
    "href": "articles/neuheiten-4-4.html",
    "title": "Neuheiten Framework Studio 4.4",
    "keywords": "Neuheiten Framework Studio 4.4 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen. Neue Requirements Kein Internet Explorer 11 mehr Der Internet Explorer 11 wird nicht mehr unterstützt. Folgende Features können nur noch mit aktuellen Browsern wie z.B. Edge, Chrome oder Firefox genutzt werden: Client Start Page Mit Framework Studio generierte Online-Hilfe Mobile Client Windows Client-Betriebssysteme Am Client- und Entwicklungs-Rechner wird nur noch Windows 10 unterstützt. Ältere Windows-Versionen werden nicht mehr unterstützt. Client Launcher Mit der Version 4.4 gibt es einen neuen Client-Launcher. Dieser bietet eine experimentelle Unterstützung für Java 11 (64 Bit). Darüber hinaus gibt es ein paar kleinere Neuerungen. Ein Update auf diese Version ist aber nicht zwingend nötig. Bei Bedarf kann weiterhin der Client-Launcher mit der Version 4.2.16 verwendet werden. Umbau der Code Generierung und des Compiles Die Code-Generierung und der FS Compile wurden grundlegend überarbeitet. Hieraus ergeben sich folgende Neuheiten: Für jeden Namespace und Typen gibt es nur noch eine DLL, welche generiert und kompiliert wird. Die Link-Schichten sind obsolet und werden zukünftig nicht mehr generiert. Auch die Context-Versionen sind nicht mehr notwendig. Die Anzahl der Assemblies hat sich stark reduziert, womit das debuggen komfortabler und der Compile schneller ist. Der Code aller Schichten muss und kann vor Ort komplett erstellt werden. Die Debug DLLs, welche mit dem FrameworkCompiler kompiliert wurden, werden nicht mehr in das Repository geschrieben. Note Zum Debuggen kann und muss zwingend der betroffene Code lokal debuggable kompiliert werden. Das bietet den entscheidenden Vorteil, dass Visual Studio beim Debuggen zuverlässig die richtigen cs-Dateien findet. Debug-Informationen, die vom FrameworkCompiler erzeugt wurden, zeigten immer auf einen absoluten Dateipfad, der auf dem eigenen Rechner nicht mehr stimmt. Es gibt bei den Options die Möglichkeit einen automatischen Debug Compile zu aktivieren. Des Weiteren wurde der Login-Dialog, sowie der GetDLLs Dialog um die gleiche Option \"AutoDebug DLLs\" erweitert. Wird beispielsweise beim Login die AutoDebug-Option auf \"All\" gesetzt, werden alle Compile Object Types beim Login automatisch debuggable kompiliert. Nähere Informationen finden Sie in den entsprechenden Dialog-Dokumentationen. Bei importierten oder versiegelten Package-Version kann man sich jetzt mit einem normalen Benutzer anmelden und debuggable kompilieren. Die Optionen Debug und DebugAll sind überarbeitet worden. Debug bedeutet, dass die Services, Components, CustomControls und Forms-Elemente des aktuellen Packages und der Base-Packages debuggable kompiliert werden. Im Gegensatz hierzu kompiliert DebugAll alle Element-Typen debuggable. Beachten Sie, dass vor allem Interfaces und DBTables aufwendig und somit mehr Zeit benötigen, um debuggable kompiliert zu werden. Important Im Zuge der Änderungen an der Code-Generierung und der Zusammenlegung der Code-Dateien in eine DLL, können zirkulären Referenzen auftreten. Des Weiteren kann es sein, dass nun fehlende Referenzen ergänzt werden müssen. Etwaige Fehler müssen in der IDE behoben werden. Nachfolgende Maintenance Routine kann gegebenenfalls beim Lösen der Fehlern unterstützen. Maintenance Routine für Referenzen und Konstruktoren Im Maintenance-Mode stehen speziell für den Update auf die Version 4.4 neue Cleanup-Routinen zur Verfügung. Constructor Cleanup: Ungültige Konstruktor Deklarationen in Components werden in eine gültige Form überführt. Dies ist notwendig, da der Compile in der FS Version 4.4 ungültige Deklarationen als Error ausgibt. References Cleanup: Entfernt nicht existente externe User-Referenzen und stellt externe $GAC-Referenzen auf $DotNetDirectory um. DevExpress® XtraReports™ Mit der Version 4.4 bietet Framework Studio experimentelle Unterstützung für DevExpress® XtraReports™ 21.1 an. Hierbei handelt es sich um eine alternative Reporting-Lösung, die zunächst parallel mit Crystal Reports eingesetzt werden kann, diese langfristig allerdings ersetzen soll. Einige Vorteile der neuen Lösung sind z.B.: Erhöhte Performance, sowohl im Druck als auch beim Design Keine Installation einer separaten Runtime notwendig Kein Erwerb von Nutzer-Lizenzen notwendig Datenquellen müssen nicht über xsd-Dateien abgewickelt werden, sondern werden direkt auf Basis der Objekte selbst gebildet Langfristig Support für von Windows losgelöste Entwicklung (.NET Core) Technisch zugänglichere Plattform (Custom Controls, Custom Designer u.Ä.) Dadurch die Möglichkeit, Reports direkt im Browser anzupassen Warning Dieses Release beinhaltet noch keine vollwertige Funktionalität. Sie können sich bereits mit der neuen Lösung auseinandersetzen und Nutzungserfahrungen sammeln, ein produktiver Einsatz ist allerdings ausdrücklich noch nicht vorgesehen. Eine Beibehaltung der aktuellen Dateiformate und API in Versionen vor dem vollständigen Release wird angestrebt, aber nicht garantiert. Im Report Document Type wurden Anpassungen vorgenommen, die gleichzeitiges Führen von Crystal- und DevExpress®-Dateien für den selben logischen Report erlauben. Jeder Report kann jetzt gleichzeitig einen Crystal Report und einen DevExpress® Report besitzen. Die beiden Dateien sind unabhängig voneinander editier-, lösch- und ersetzbar. Falls ein Report Document Type gedruckt werden soll, der gleichzeitig einen Crystal- und einen DevExpress® Report beinhaltet, wird auf Basis des Flags Global.ReportingSoftware entschieden, welcher der beiden genutzt werden soll. Das Flag lässt sich im Use-Code überschreiben. Falzmarken und in den Report eingebettete Subreports wurden mit eigenen Custom Controls gelöst. Um bei der Konvertierung mit dem originalen Crystal Report vergleichen zu können, wurde ein Button im Designer geschaffen, welcher diesen schreibgeschützt öffnet. Report Migration Summary Für die Migration der Crystal Reports zu DevExpress® muss der zu erwartende Aufwand bewertet und die noch ausstehenden Reports gelistet werden können. Diese Übersicht kann über das Kontextmenü eines Namespaces oder für einen Report Document Type angezeigt werden. Namespace-Referenzen überarbeitet Die Namespace-Referenzen arbeiten mit Compile Object Types. Diese entsprechen den Compile-Schritten. So sind z.B. die Object Types Service, Service Proxy, Service Host und FSTransformation zum Compile Object Type Service zusammengefasst. Der Dialog für die Namespace-Referenzen wurde überarbeitet: Es werden jetzt alle Referenzen für alle Typen in einer Liste angezeigt. Die Liste bietet eine Übersicht der wichtigsten Detail-Informationen. Die Usings werden als Freitext-Feld bearbeitet. Bei der Auswahl von $GAC-Referenzen werden diese, wenn möglich auf $DotNetDirectory korrigiert. Individueller Code - Code files Für die Definition von individuellem Code steht ein neues Element Code File zur Verfügung. Der Code einer Code file muss eine Klasse beinhalten, in welcher Methoden, Konstruktoren, Properties etc. definiert werden können. Es können mehrere Klassen, jedoch keine Namespaces, in eine Code file definiert werden. Aufgrund gängiger Konventionen sollte ein Code File jedoch nur eine Klasse beinhalten und der Name des Code Files identisch mit dem Namen der Klasse sein. Ferner ist der identische Namen für die Intellisense notwendig. Für ein Code file muss ein Compile Step festgelegt werden. Dieser bestimmt mit welchem Object Typ der Code kompiliert wird und somit in welchem Namespace sich das Code file befindet. Soll der individuelle Code auch in einem anderen Namespace zur Verfügung stehen, muss hierfür eine Referenz angelegt werden. Diese muss auf den Namespace des Code files und auf dessen Compile step verweisen. Ein Beispiel hierzu findet sich hier. Note Der Compile step sollte zu einem späteren Zeitpunkt nicht geändert werden, da ansonsten bestehende Referenzen auf das Code file ungültig werden und der Compile Fehler generieren wird. Die Compile Fehler können verhindert werden, indem der ObjectType der Referenzen ebenfalls angepasst wird. REST Endpoint für Service Hosts Standardmäßig bietet ein Service Host den ausgewählten Service bzw. dessen Service Contract nach außen hin über WCF und damit das SOAP-Protokoll an. Moderne Applikationen und allen voran Webapplikationen in Borwsern oder auf mobilen Endgeräten unterstützen mittlerweile jedoch oft kein SOAP mehr und bevorzugen deshalb die Kommunikation über JSON. Framework Studio bietet die Möglichkeit, den Service Host so zu konfigurieren, dass vollständig automatisch ein zusätzlicher Endpoint generiert wird, mit dem die im Service Contract propagierten Methoden auch über JSON und damit über einen normalen HTTP-Request angesprochen werden können. Eine detaillierte Beschreibung dieser neuen Funktionalität befindet sich HIER. Placeholder für Editfields und Comboboxen Für Editfields und Comboboxen steht ein neues Property CaptionAsPlaceholder zur Verfügung. Wenn dieses Property auf true gesetzt wird, zeigt das Editfield oder die Combobox die Caption als Placeholder an, solange das Control leer ist bzw. keinen Datensatz anzeigt. Auf diese Weise können zusammenhängende Daten ggf. übersichtlicher dargestellt werden: Hinweise Placeholder funktionieren sowohl im Java Client als auch im HTML Client. Die Farbe des Placeholders ist fest auf RGB(180, 180, 180) bzw. #b4b4b4 gesetzt. Befindet sich das Control in einem FieldPanel, so wird kein extra Label generiert, wenn CaptionAsPlaceholder auf true gesetzt ist. Bilder Unterstützung für HTML Editfields Editfields mit dem Editor Type HTML können nun Inline-Bilder anzeigen. Diese Bilder können aus der Zwischenablage im Java-Client oder mithilfe eines <img/> Tags eingefügt werden. Reports, die mit DevExpress® erstellt werden, unterstützen diese Bilder. Crystal Reports unterstützt diese Bilder leider nicht. Genaueres unter Editfield. FS Client Launcher Im Client-Launcher gibt es folgende Neuerungen: Die Online-Hilfe kann aus dem Konfigurations-Dialog mit F1 aufgerufen werden. Anzeige des Splash Screen der Application Für Version 4.4 Anwendungen gibt es eine Experimentelle Unterstützung für Java 11 (64 Bit) Der Pfad des .jarcache Ordners hat sich von %userprofile%\\FSClientLauncher\\.jarcache\\ zu %localappdata%\\FSClientLauncher\\.jarcache\\ geändert. Durch die Verwendung von %localappdata% wird bei serverbasierten Benuzter-Profilen der Jar-Cache nicht mehr zum Server synchronisiert. Beim ersten Start nach dem Update wird der alte .jarcache Ordner einmalig an die neue Stelle verschoben. Weitere Neuerungen Für Comboboxen und Listboxen kann die DisabledBackColor definiert werden. In Methoden-Parametern und Rückgabetypen können die C# 7 Tuple-Types verwendet werden. Bei den Access Units wurde die Ansicht der verbundenen AccessUnits verbessert. Es werden nun neben den Parents auch die AccessUnit-Children angezeigt. Zudem können die AccessUnit-Parents bearbeitet werden. Die RowID und RowVersion sind nun zwei unabhängige Mechanismen. Dies bedeutet, dass die FSROWID als eindeutiger und alleiniger Primary Key für Update- und Delete-Bedingung gilt. Die RowVersion wird weiterhin für die Concurrency-Violation Überprüfung verwendet. Dabei ist es nebensächlich, ob der Primary Key eine ROWID oder ein individueller PK ist. Analog zur GlobalOnBeforeSaveAction() gibt es auch eine GlobalOnAfterSaveAction(), welche jedoch nach der SaveAction aufgerufen wird. Im StaticCache steht eine neue Methode ContainsKey(pk) zur Verfügung. Für Checkboxen wurde der Tabellenfilter auf Checked/Unchecked (bzw. Aktiviert/Deaktiviert) geändert. Gibt es Datensätze mit Null-Werten, werden diese bei der Checkbox-Filterung als Unchecked gewertet. Im Package Manager ist es möglich Warnings, welcher der Compiler ignorieren soll, anzugeben. Des Weiteren kann auch das Level der Warnings angegeben werden. Die Einstellung wird an die Customizing-Packages vererbt. Sie kann ausschließlich durch Nissen & Velten am eNVenta Package (bzw. einem anderen Default-Package) geändert werden. Im Publish, Run und Publish2go Wizard kann nun auch das Icon für die Anwendung gesetzt werden. Es ist nun möglich, im Wörterbuch nach Dependencies für MLKeys zu suchen. Es ist nun möglich, auf der Client Start Page die Client-Option Java Web Start während des Publish Vorganges ein oder aus zu blenden. Standardmäßig ist der Java Web Start nun deaktiviert. Es ist nun möglich an dem Application-Element die Form-Navigation im HTML Client zu deaktivieren. Bei den Relation-Properties (Components) steht in der Registerkarte Load Command nun ein CodeEditor mit entsprechender Intellisense zur Verfügung. Es ist nun möglich, den Code im C# Editor, mit dem Shortcut SHIFT + ALT + F den Code zu formattieren. Es ist nun möglich, Grid-Columns per Action zu verschieben. Dafür gibt es zwei neue Methoden(MoveBefore / MoveAfter) an der GridColumnControlAction und zwei neue Methoden(InsertBefore / InsertAfter) an der GridControlAction. Der Text in einem Dokumentations-Editor wird jetzt auf Rechtschreibfehler überprüft. Gefundene Rechtschreibfehler werden rot unterstrichen. Es werden die Sprachen Deutsch (de), Englisch (en), Französisch (fr) und Italienisch (it) unterstützt. Es ist nun möglich, Dokumentationen abhängig von den Lizenzeinstellungen zu exportieren. Dafür wurden neue Checkboxen im Export Wizard hinzugefügt und die Parameter der FSConsole erweitert. Das Einfügen von Links im Dokumentations-Editor wurde überarbeitet. Es kann nun mithilfe von Autocomplete nach existierenden Dokumentationen gesucht werden. Es ist nun möglich, Url-Links aus der Zwischenablage mit STRG+V, Rechte-Maustaste->Edit->Paste oder dem Link einbinden Dialog im Dokumentations-Editor einzufügen. Es ist nun möglich, Bilder aus der Zwischenablage mit STRG+V, Rechte-Maustaste->Edit->Paste oder dem Bild einbinden Dialog im Dokumentations-Editor einzufügen. Es ist nun möglich, Tooltips im Dokumentationsfenster zu bearbeiten. Es ist nun möglich, Headlines im Dokumentationsfenster zu nutzen. Am cGlobal wurde der neuer EntryPoint OnLicenseGranted geschaffen, mit dem man Lizenz-Freigabe programmatisch einschränken kann, obwohl die Lizenz-Datei dies erlaubt. Parallel dazu wurde die neue Methode LicenseGrantedInFile am AUHelper geschaffen. Noch nicht abgespeicherte Tabs werden nun mit einem Stern * gekennzeichnet."
  },
  "articles/neuheiten-4-5.html": {
    "href": "articles/neuheiten-4-5.html",
    "title": "Neuheiten Framework Studio 4.5",
    "keywords": "Neuheiten Framework Studio 4.5 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen. Neue Systemvoraussetzungen In dieser Version gibt es Anpassungen bei den Systemvoraussetzungen. Datenbank-Server Es wird der SQL-Server 2014 oder höher unterstützt. Ältere Version (z.B. SQL-Server 2012) werden nicht mehr unterstützt. Der SQL-Server 2012 läuft laut Microsoft zum 12.07.2022 aus. Important Ein Betrieb mit einer älteren Datenbank-Version ist nicht möglich. Ein Connect auf so einen Datenbank-Server führt unmittelbar zu einer entsprechenden Fehlermeldung. Entwicklungs-Rechner Aufgrund der Systemvorraussetzungen von Chromium ist für die Framework Studio IDE mind Windows 10 bzw. Windows Server 2016 erforderlich. Aus diesem Grund müssen wir den IDE-Support für Windows Server 2012 einstellen. Die Chromium Runtime wird von den neuen Code-Editoren, verwendet. Als Application-Server kann weiterhin der Windows Server 2012 verwendet werden. Der Publish muss aber mit einem Publish2Go-Paket erfolgen, welches auf einem anderen Rechner mit der IDE bzw. den Package-Manager erstellt wurde. Neues Browser-Control - Austausch des JavaFX Browsers Für die Anzeige von HTML-Inhalten im Java-Client kam bisher für das Browser-Control die JavaFX WebView Component zum Einsatz. Dieses Control hat mehrere Probleme: auf einigen Webseiten gibt es Abstürze des Java-Clients die Browser-Controls laufen im Java-Prozess und benötigen teilweise zu viel Speicher Aus diesem Grund wurde die JavaFX WebView Component durch den JxBrowser ersetzt, welcher auf Chromium basiert. Dies bringt einige Verbesserungen mit sich: Performance / Stabilität / Sicherheit (eigene Prozesse im Hintergrund) Java Speicher wird nicht so stark belastet -> weniger OutOfMemory Exceptions Hi-DPI Unterstützung Regelmäßige (Sicherheits)-Updates Developer tools für Entwickler können aktiviert werden (siehe hier) Weitere Neuerungen Für Ressourcen kann eine Beschreibung angegeben werden. Es gibt nun die beiden Optionen alle Tabs links bzw. rechts vom aktuellen Tab zu schließen. Diese Funktionen sind über das Kontextmenü erreichbar. In der ClassView können mit der Enter-Taste die Properties und Methods des aktuell angezeigten Records geöffnet werden. In der Search gibt es die neue Funktion \"Copy List as Text\". Diese erscheint, sobald neben den Suchergebnissen das Kontextmenü geöffnet wird. Wird in die Listen-Ansicht gewechselt, können nun auch hier alle Ergebnisse kopiert werden."
  },
  "articles/neuheiten-4-6.html": {
    "href": "articles/neuheiten-4-6.html",
    "title": "Neuheiten Framework Studio 4.6",
    "keywords": "Neuheiten Framework Studio 4.6 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen. Update von Version 3.11 oder älter Important Für ein Update auf Framework Studio 4.6 muss das Repository bzw. die jeweilige Package-Version mindestens in der Version 4.0 verfügbar sein. Repositories bzw. Package-Versionen mit dem Stand von FS 3.11 oder älter müssen zunächst auf FS 4.0 - FS 4.5 upgedatet werden. Empfohlen ist die Long-Term-Version FS 4.5. Deprecated Layout entfernt Mit Version 4.0 wurden die Forms auf ein modernes Layout mit sich selbst organisierenden Containern umgestellt. Das alte koordinatenbasierte \"Depercated Layout\" wurde in einem \"Notbetrieb\" unterstützt um eine Migration zu ermöglichen. Mit Framework Studio 4.6 wird das \"Deprecated Layout\" nicht mehr unterstützt. Important Vor dem Update einer Package-Version auf Framework Studio 4.6 müssen alle Deprecated Forms vollständig migriert werden. Ein Update ist ansonsten nicht möglich. Modernisierungen in der IDE Um Framework Studio für die Zukunft fitzumachen und den Weg in die neue .NET Welt zu ebnen wird vor allem unter der Haube sehr viel vorbereitet. Zum teil wirken sich die Arbeiten auch spürbar auf die Oberfläche der IDE aus. Im Folgenden sind einige Punkte aufgeführt. Die Menüs, Toolbars und Context-Menüs wurden überarbeitet. Neben internen Optimierungen wurden Anordnung und Reihenfolge der Befehle vereinheitlicht und viele Befehle haben Symbole erhalten. Alte DataGrids wurden durch neue DataGridViews ersetzt. Das verbessert das Layout. TreeViews wurden überarbeitet und in ihrem Verhalten und der Darstellung vereinheitlicht. Weitere Neuerungen Neues Component-Property IsHistorical Für die Component-Methoden Clone() und AdoptValues() gibt es einen neuen AdoptMode NoHistory. Dieser unterbindet das Übertragen der IsHistorical-Information. Es gibt eine neue SQL MOD()-Funktion für den Modulo-Operator."
  },
  "articles/neuheiten-4-7.html": {
    "href": "articles/neuheiten-4-7.html",
    "title": "Neuheiten Framework Studio 4.7",
    "keywords": "Neuheiten Framework Studio 4.7 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen. Important Dieses Dokument zeigt die Neuerungen beim Update von Version 4.6 auf 4.7. Beim Update von einer älteren Version beachten Sie bitte auch die Hinweise und Neuerungen der älteren Version (Neuheiten 4.6). Tip In einem kleinen Leitfaden werden die für den Update auf Version 4.7 notwendigen Schritte erklärt. Neue FS Lizenz Die Lizenz für Framework Studio wurde auf XML-Serialisierung umgestellt. Dies hat zwei notwendige Aktionen zur Folge: Zunächst muss die Lizenzdatenbank upgedated werden. Dies wird bei der Anmeldung am Repository automatisch angeboten. Anschließend muss eine neue FrameworkStudio Lizenz eingespielt werden, welche von uns bereitgestellt wird. Tip Die Verwaltung der Lizenzen befindet sich jetzt in der Repository-Auswahl. Die neue Lizenz mit der Dateiendung .fslx ist ab FS Version 4.7 gültig. Für alle älteren FS Versionen gilt weiterhin die alte Lizenz mit der Dateiendung .fsl. Repositories, welche Packages in unterschiedlichen Versionen beinhalten, benötigen somit zwei gültige Lizenzen. Neue Systemvoraussetzungen In dieser Version gibt es Anpassungen bei den Systemvoraussetzungen. Datenbank-Server Es wird der SQL-Server 2016 oder höher unterstützt. Ältere Version (z.B. SQL-Server 2014) werden nicht mehr unterstützt. Für den SQL-Server 2014 läuft laut Microsoft der erweiterte Support im Jahr 2024 aus. Es wird Oracle 19c oder höher unterstützt. Ältere Versionen (z.B. Oracle 12.2 oder Oracle 18c) werden nicht mehr unterstützt. Für Oracle 12.2 lief der Support laut Oracle im Jahr 2022 aus. Die Version 18c lief bereits 2021 aus. Important Ein Betrieb mit einer älteren Datenbank-Version ist nicht möglich. Ein Connect auf so einen Datenbank-Server führt unmittelbar zu einer entsprechenden Fehlermeldung. Laufzeitlizenzen werden zur Laufzeit aufgelöst Die Laufzeitlizenzen (Runtime Licenses) werden jetzt zur Laufzeit aktualisiert und die Berechtigungen für die aktuelle Access Unit Hierarchie aufgelöst. Runtime-Lizenzen müssen nicht mehr aktualisiert und neu ausgeliefert werden, wenn es Änderungen in der Access Unit Hierarchie gibt. Es ist keine Developer-License mehr nötig. Wird eine neues Form oder eine neue AccessUnit angelegt und in die Access Unit Hierarchie eingehängt, dann wird diese direkt beim nächsten Start des Development-Brokers auf die Lizenz angewendet. So können neue Features schon während der Entwicklung direkt mit einer Kunden-Lizenz verprobt werden. Neuorganisation der Framework Studio Namespaces Die Struktur der FSramework-Studio-Assemblies wurde überarbeitet. Dadurch wurden Klassen und auch Namespaces neu organisiert. Dies ist eine notwendige Vorarbeit für zukünftige Umstellungen auf .Net Core. Für die Korrektur der Namespaces im Methoden-Code und in den Referenzen, gibt es eine Namespace CleanUp Maintenance-Routine. Diese ist unter dem Menüpunkt Update / FS 4.7 / (1) Namespace CleanUp zu finden. Maintenance Routine für obsolete MsgBox.Show() Aufrufe Alle MsgBox.Show(...) Methoden wurden auf [Obsolete] gesetzt. Die Aufrufe können über die Maintenance-Routine durch den Code throw MsgBox.Exception(...) ersetzt werden. Die Funktionalität bleibt identisch. Die Maintenance Routine ist unter dem Menüpunkt Update / FS 4.7 / (2) MsgBox.Show() Cleanup zu finden. this.Global aus Konstruktoren entfernt Zur Bereinigung der Global-Aufrufe Remove Global Cleanup Die Maintenance Routine ist unter dem Menüpunkt Update / FS 4.7 / (3) Remove Global Cleanup zu finden. FSCache siehe FS Memory Cache Neue Programm-Verzeichnisse Aufgrund der Umfirmierung zur \"enventa Group\" wurden die Programm-Verzeichnisse angepasst. In diesem Zuge wurden einige Konsolidierungen vorgenommen und eine einheitliche Verzeichnis-Struktur für die verschiedenen FS-Produkte geschaffen. Folgende Ordner gelten ab der Version 4.7: Programm-Verzeichnisse %ProgramFiles% enventa Group\\ Framework Studio\\4.7\\ FS Client Launcher\\ Runtime Supervisor\\ Sofern bei der Installation kein abweichendes Programm-Verzeichnis angegeben wurde, wird das jeweilige Programm bei einem Update auf das neue Programm-Verzeichnis umgezogen. Application-Daten %AppData% enventa Group\\ Framework Studio\\X.Y\\ FS Client Launcher\\ FS Java Client\\ FS Runtime Administration\\ %LocalAppData% enventa Group\\ FS Client Launcher\\ FS Java Client\\ Beim ersten Programmstart werden die jeweiligen Verzeichnisse automatisch umgezogen. Eine Ausnahme bildet FS Java Client. Dieses Verzeichnis wird nicht umgezogen, da es ggf. von mehreren Versionen gleichzeitig verwendet wird. (Das alte Verzeichnis lautet %UserProfile%\\FSJavaClient\\.) Registry-Einträge HKEY_LOCAL_MACHINE\\Software\\ enventa Group\\ Framework Studio\\X.Y\\ FS Client Launcher\\ FS Data Provider\\ FS Publish\\ Runtime Supervisor\\ Die Registry-Einträge dienen den Installations-Routinen der jeweiligen Programme und aktualisieren sich bei einem Update auf die neuen Keys. Die beim Publish erzeugten Registry-Keys sind von HKLM\\Software\\Framework Systems\\Framework Broker\\Installations nach HKLM\\Software\\enventa Group\\FS Publish umgezogen. Die neusten Versionen von Framework Studio 4.5 und 4.6 sind mit dieser Änderung kompatibel und erkennen auch die neuen Einträge. Weitere Neuerungen Die PKL-Lizenz wurde entfernt. Zum Customizing wird für das Basis-Package keine PKL-Lizenz mehr benötigt. Die Dokumentationen für Runtime Supervisor, Runtime Administration und Authentication Service wurden in die Online-Dokumentation übernommen. Diverse Fremdbibliotheken wurden auf die jeweils neuste Version aktualisiert. Frameork Studio IDE: Eigener Compile step UnitTest für Codefiles ermöglicht es, UnitTests in eigene DLLs zu schreiben. Usability Verbesserung beim Anlegen neuer References: Beim Öffnen der References über einen geöffneten Record (Menü Compile-References...) wird der ObjectType der Reference automatisch auf den Typen des Records gesetzt. Das gleiche Verhalten zeigt sich auch im Namespace-TreeView über das ContextMenü des Records bzw. dem References-Button, wenn ein Record vorselektiert ist. Referenz-Prüfung für Ressourcen Bei der Search kann in mehrere Object Types gleichzeitig gesucht werden. Bei der Search bietet das Context-Menü für die jeweiligen Ergebnis-Einträge jetzt alle Befehle an. Maintenance-Routine Code Replace Cleanup zum globalen Ersetzen von Code. DBColumns können nun einzeln kopiert und in eine DBTable eingefügt werden. Die IntelliSense des C# Code-Editors wurde erweitert, sodass nun auch die Framework Studio API-Dokumentation und die .net Framework Dokumentationen angezeigt werden. Im Customzing Package neu angelegte Namespaces erhalten nun zusätzlich die User-Referenzen aus Parent-Namespaces, welche im Basis-Package mit der Option Use in Sub Namespaces angelegt wurden. Im Kontextmenü unter anderem zu finden im Namespace-TreeView wird innerhalb des Menüs \"Edit\" das Öffnen des Element History Browsers angeboten. Background Image im FrameworkDesigner entfernt Änderungen in der API: Neue MLUtil.GetText()- und FormatText()-Methoden für TextCollections. Die Download-API wurde um ExpirationTimeout, ContentFactory und CleanupAction erweitert Neues Property IDevFrameworkObjectColl.CountLoadedEntries Neue Actions SetMinWidth() und SetMaxWidth() für GridColumns. Das Property DevFrameworkObject.Transaction ist obsolete. Es wurde vor nur mit den schon länger obsoleten Transaction-Methoden bestückt und war daher immer null."
  },
  "articles/neuheiten-4-8.html": {
    "href": "articles/neuheiten-4-8.html",
    "title": "Neuheiten Framework Studio 4.8",
    "keywords": "Neuheiten Framework Studio 4.8 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen. Important Dieses Dokument zeigt die Neuerungen beim Update von Version 4.7 auf 4.8. Beim Update von einer älteren Version beachten Sie bitte auch die Hinweise und Neuerungen der älteren Version (Neuheiten 4.7). Crystal Reports abgekündigt Crystal Reports wird nicht mehr unterstützt. Alle Reports müssen auf DevExpress® umgestellt werden. Für noch nicht umgestellte Reports werden beim Compile der Package-Version entsprechende Warnings generiert und ausgegeben: #warning Crystal Reports are no longer supported. Please convert the Report File to DevExpress. Caution Nicht umgestellte Reports können in der Anwendung nicht mehr ausgedruckt werden. Bei Customizing-Reports wird ggf. auf die DevExpress-Variante des Basis-Packages zurückgefallen, wodurch das Customizing unwirksam wird. In der IDE können die Crystal Reports für die Migration angezeigt werden. Siehe auch Report Document Type. SkiaSharp Library eingebunden Die SkiaSharp Library ist eingebunden und kann zum Erstellen und Bearbeiten von Pixel-Grafiken verwendet werden. Bei SkiaSharp handelt es sich um eine Cross-Plattform Grafik-API, welche auf der Skia-Engine von Google basiert. Eine Referenz auf die SkiaSharp.dll und ein using auf den Namespace SkiaSharp ziehen automatisch in den folgenden Compile-Schritten: Services Components UnitTests Forms Bisher war es üblich, für Pixel-Grafiken die Klasse System.Drawing.Graphics zu verwenden. Diese basiert auf GDI+ und wird deshalb nur auf Windows Betriebssystemen unterstütz. Für einen zukünfitgen Einsatz von .net auf z.B. Lunix-Servern muss dies abgelöst werden. SkiaSharp bietet diese Möglichkeit. Komponentenbaukasten - Modular Components Es wurde ein neues Element hinzugefügt. Die Doku mit allen Besonderheiten und etwaigen Anwendungsfällen findet sich hier: Modular Components Icons In den Modular Components wurden für Properties und Methods die Icons erneuert, sie orientieren sich an den offiziellen Visual Studio Icons. Dies ermöglicht eine schnellere Übersicht, welches AccessLevel das Property oder die Methode hat. public: Property bzw. Method-Zeichen internal: mit Herz protected: mit Stern private: mit Schloss CodeFiles haben spezifische Icons für den ausgewählten Compile Step erhalten."
  },
  "articles/release-4-2.html": {
    "href": "articles/release-4-2.html",
    "title": "Release-Information Framework Studio 4.2",
    "keywords": "Release-Information Framework Studio 4.2 4.2.40 (X.Y.Z) Neuerungen Vor einem Compile werden nun alle ungespeicherten Elemente automatisch gespeichert. 4.2.39 (01.09.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.39_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer HTML Client Der HTML Client wurde auf Angular 16.2 upgedated. Das Scrolling bei vielen offenen Forms wurde im Browser und auf Tablets verbessert. Korrigierte Fehler 2023083651 - Data Provider: Werden in SQL-Bedingungen mithilfe von DB.SqlString() Parameter ergänzt, dann wird für die Größe der Parameter standardmäßig die tatsächliche Länge der Werte verwendet. Dadurch entstehen sehr viele unterschiedliche Statements, die vom SQL-Server nicht wiedererkannt werden. Das beeinträchtigt die Permormance der Datenbank. Note Wenn die Werte das erlauben, werden jetzt großzügige Standardgrößen verwendet. Dadurch erhöht sich in der Praxis die Wiedererkennungsrate signifikant. 4.2.38 (28.07.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.38_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023073469 - Publish2Go: Das Änderungsdatum von Ressourcen-Dateien wird falsch gesetzt. Die Zeitzone wird nicht korrekt berücksichtigt. 2023063291 - IDE: Im Form-Designer wird in der Control-Eigenschaft \"SearchOperator\" der Wert \"LikeNonCaseSensitive\" nicht angeboten. 2023073422 - IDE: Fehlerhafte Daten im Repository können dafür sorgen, dass der Workflow-Branch seine Bedingung in eine falsche Version schreibt. 4.2.37 (26.05.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.37_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023052947 - IDE: Für eine Component werden bei der Dependency-Suche Component-Properties ermittelt, obwohl diese aufgrund eines Datenbank-Mapping einen ganz anderen Datentyp als die Component besitzen. Grund dafür sind ungültige Repository-Daten. Diese haben ansonsten bei der normalen Arbeit keine Auswirkung. 4.2.36 (28.04.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.36_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023032382 - Broker: Wird eine Gridspalte mit \"LIKE\" gefiltert, werden ggf. keine Treffer gefunden, wenn sich der gesuchte Begriff in einem mehrzeiligen Text befindet. 2023032535 - Code-Generierung: Es wird die FSWarn1004-Error-Message ausgegeben, nach welcher Primary-Key Spalten nicht länger als 28 Zeichen sein dürfen. Die DB-Spalte selbst ist jedoch nicht als Primary-Key gekennzeichnet. 4.2.35 (24.02.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.35_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer HTML Client Der HTML Client wurde auf Angular 15.1 upgedated. Neue Features oder Bugfixes gibt es nicht. Korrigierte Fehler 2023012107 - IDE: Im ReportDocumentType können gelöschte DataSources oder Properties dazu führen, dass bei einer Änderung des Reports im Service Release eine Meldung \"Can't delete objects of Service Release 4.x\" angezeigt wird. 4.2.34 (23.12.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.34_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022111577 - Framework: ConvertLoadCondition schlägt fehl, wenn man in die Condition mithilfe von DB.SqlString Texte einfügt, die eckige Klammern und Zeilenumbrüche enthalten. Beispiel: ConvertLoadCondition(\"[sText] = \" + DB.SqlString(\"x \\r\\n [ab]\")) 4.2.33 (25.11.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.33_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021118404 - Java-Client: Im Tooltip-Text einer Drop-Action werden keine Zeilenumbrüche dargestellt, wodurch lange Texte in einer einzelnen langen Zeile über den ganzen Bildschirm dargestellt werden. 4.2.32 (28.10.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.32_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer HTML Client Siehe korrigierte Fehler Die Barcode Scanner Library wurde aktualisiert Das Frontend wurde auf Angular 14 aktualisiert Korrigierte Fehler 2022101271 - Broker: Wird in einem Callback von TakePhoto, ScanBarcode oder GetGeolocation eine MessageBox angezeigt, wird diese vom Broker als Exception interpretiert. 2022091073 - IDE: In speziellen Konstellationen können bei customized Workflows in Switches keine Rows hinzugefügt werden. 2022101272 - HTML Client: Die Actions TakePhoto und GetGeolocation funktionieren nicht im Browser. 4.2.31 (30.09.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.31_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. 4.2.30 (29.07.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.30_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler Wenn man im Login-screen der IDE den Dropdown-button der Combobox verwendet und dann den Namen eines Benutzers eintippt, überlappen sich die beiden Dropdown-Fenster. Wenn man im Package-Manager den AssemblyPrefix bearbeiten möchte, dann kann es vorkommen, dass der Package-Manager einfriert. 4.2.29 (24.06.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.29_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022060088 - Broker: Wird auf einem Grid, das eine GroupBy-Query anzeigt, über den Client ein Filter eingestellt, dann wird ein SQL-Error angezeigt. Der Fehler tritt auf, wenn aufgrund sehr vieler Datensätze der Reload-Mechanismus greift und der Filter deshalb über die Datenbank angewendet wird. 4.2.28 (27.05.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.28_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022059888 - JavaClient: Wird eine Grid-Zelle mit Enter verlassen, dann kann es passieren, dass eine im OnColumnChanged-Event aufgerufene SetCell-Action ignoriert wird. Der Fokus landet dann nicht in der gewünschten Grid-Zelle. Auftreten kann der Fehler, wenn z.B. im OnColumnChanged ein modaler Dialog geöffnet wird. 2022059912 - Java-Client: Sind in einem Menü mehrere Separatoren enthalten, dann kann es beim Öffnen des Forms im Java-Client zu einer StackOverflowException kommen. Der Fehler tritt auf, wenn viele Menu-Items ausgeblendet werden. In der Folge wird das Form nicht angezeigt oder die Anwendung startet nicht korrekt. 2022049758 - IDE: Hat der CSharp-Compiler ein Problem, das den Compile komplett verhindert (weil z.B. das Programm-Verzeichnis beschädigt ist), dann meldet Framework Studio keinen entsprechenden Fehler. Bei der Arbeit als normaler Benutzer werden keine DLLs erzeugt, wodurch der Start des Brokers nicht möglich ist. Beim Ausführen eines FrameworkCompiler treten Fehler auf, weil DLLs nach dem Compile nicht gefunden werden. 2022059769 - IDE: Beim Einfügen eines Links in einen customizten Workflow erscheint in seltenen Fällen eine Fehlermeldung. System.ArgumentException: An item with the same key has already been added. 2022059953 - HTML Client: GetGeoLocation liefert falsche Werte. 4.2.27 (29.04.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.27_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022018960 - IDE: Im Multilanguage Text Editor findet die Suche bei mehrzeiligen Texten nur Wörter, die in der ersten Zeile stehen. Der Text ab der 2. Zeile wird nicht berücksichtigt. 2022039417 - IDE: Beim Einfügen eines Format-Tags (z.b. [b], [i], [h1] usw.) werden ggf. zu viele Tags zusammengefasst. So können versehentlich z.B. Image-Tags in die Headline rutschen, was im Anschluss zu Fehlern führt. 2022049597 - Data-Provider: Oracle - Wird in einem SQL-Command ein Identifier mit Sonderzeichen oder eine Ziffer am Anfang verwendet, dann wird das für Oracle nicht korrekt umgesetzt. Beispiel: DELETE FROM [30_TEST] 2022049553 - Framework: Die Update-Analyse greift bei Oracle ggf. verzögert auf die Data-Connection zu. Das führt bei deaktiviertem FSPooling zu einer ObjectDisposedException. Bei aktivem FSPooling wird die Connection nicht mehr freigegeben. 4.2.26 (25.02.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.26_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022029190 - Java-Client: Alle Jar-Dateien müssen neu signiert werden, weil das Java-Zertifikat widerrufen wurde. 2022029126 - IDE: Nach dem bearbeiten eines Global Events kann es passieren, dass im Workflow-Link auf dieses Global Event keine Init-Methode mehr angeboten wird. 2022029194 - IDE: Wird auf einem ControlType ein Undo Checkout ausgeführt, dann werden Form-Controls mit diesem ControlStyle und der zu verwerfenden Control-Version auf gelöscht gesetzt. Note Dieser Fehler kann eine Erklärung für Fälle sein, in denen aus heiterem Himmel Controls verschwunden sind - ohne dass jemand das Form ausgecheckt hat. Er war seit 05.2020 aktiv. 2022029147 - Doku: Informationen zum Aufräumen von tblRep_SessionLogging. 4.2.25 (28.01.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.25_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022018908 - JavaClient: Wird per Action ein TabbedWindow (oder sein Parent) ausgeblendet, dann feuert das OnSelectedTabPageChange Event. Findet das beim Öffnen eines Forms statt, dann kann das zur Folge haben, dass das Form sich nicht im Vordergrund öffnet. 2022018909 - Java-Client: Beim Öffnen eines Forms wird in der Java-Console ggf. eine Meldung \"FrameworkSystems.FSJavaClient.DevControl.LayoutComponentDefault cannot be cast to FrameworkSystems.FSJavaClient.DevControl.DevControlTabPage\" ausgegeben. 2022018927 - Java-Client: Beim Ausführen der Action LoadGridLayout kann es bei großen Grids vorkommen, dass nicht alle Daten verarbeitet werden. 2021128765 - IDE: Beim Import einer TMX-Datei ins Wörterbuch werden ISO-Sprach-Codes in Großbuchstaben nicht erkannt. 2021128815 - HTML Client: Das Picture Control wird nicht upgedated, wenn die DataSource auf \"null\" gesetzt wird. 2021128823 - HTML Client: Die Frequenz der Beep-Action ist hart auf 1000Hz festgelegt und ignoriert damit den übergebenen Wert. 4.2.24 (23.12.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.24_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021118513 - IDE: Beim Ändern eines Query-JoinTypes in der Customization kommt es zu einer Exception. 2021118541 - IDE: Wird ein zu langer Datenbank-Servername oder Repository-Name verwendet, dann bricht der Start der IDE mit einer Exception ab. 2021128590 - IDE: Die Browser-Variante des HTML Clients funktioniert weder im Development Broker noch in einer gepublishten Umgebung. 2021128584 - Code-Generierung: Wird im Metadatentyp als Format-Pattern ein Regulärer Ausdruck verwendet, dann wird dieser im generierten Code nicht sauber escaped. In der Folge kann es zu Compile-Fehlern kommen. 2021128747 - HTML Client: Die ComboBox (ListValuesInput) reagiert nicht auf Eingaben von Buchstaben zur Auswahl des Eintrags. 2021128773 - HTML Client: Editfields mit einer DataSource vom Typ \"FSDateTime\" werfen beim Senden des Wertes zum Broker in gewissen Fällen eine Exception. 4.2.23 (26.11.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.23_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021108192 - IDE: Wird im ListView als DataSource eine TextCollection verwendet, dann ist nach dem Neustart der IDE in der Template-Variable die Zuordnung auf das Text-Property verloren. In der Folge kommt es auch zu Compile-Fehlern. 2021108258 - IDE: Verkleinert man das Framework Studio Haupt-Fenster, dann kann es passieren, dass im Namespace-Baum die untere Hälfte nicht mehr greifbar ist. Ist dann der Monitor zu klein - z.B. über Remote Desktop - dann kann man das Haupt-Fenster nicht weit genug vergrößern und der Namespace-Baum lässt sich nicht mehr bedienen. 2021118300 - HTML Client: OnAfterRequest() wird am Broker nur für das derzeit aktive Form des Clients aufgerufen. 4.2.22 (29.10.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.22_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021108162 - Java Client: Die Actions LoadGridLayout() und SaveGridLayout() arbeiten intern mit dem Titel der Spalte. Dadurch werden beim LoadGridLayout() Spalten ggf. nicht korrekt erkannt, wenn der Titel sich ändert oder mehrere Spalten denselben Titel haben. Note Die Actions arbeiten jetzt mit dem internen Namen der Spalte. LoadGridLayout() erkennt aber weiterhin die Informationen, die mit dem Titel gespeichert wurden. 2021108103 - IDE: Werden bei der Suche nach CheckOut Treffer gefunden, deren Namespace nicht mehr existiert, dann gibt es eine Exception und das Ergebnis wird nicht angezeigt. Das kann vorkommen, wenn der Namespace von einem anderen Benutzer gelöscht wird, während man selbst darin neue Elemente angelegt hat. Note Diese Treffer werden jetzt direkt unterhalb vom Package angezeigt. 2021108136 - IDE: Wenn im Form-Designer die Font eines Elementes über dem Property-Grid angepasst werden soll, kann es in seltenen Fällen vorkommen, dass Fonts ohne Namen in der Liste zur Auswahl stehen. Wenn eine Font ohne Namen ausgewählt wird, führt dies zu einem Absturz der IDE. 2021108146 - IDE: Wenn nach dem Anlegen einer neuen .WTS-Ressource in den eNVenta Update Script Editor gegangen wird und dort direkt auf \"New Table\" geklickt wird, führt dies zu einem Absturz von FS. 2021108205 - IDE: Wenn beim Erstellen einer neuen Column in einer Datenbanktabelle ein Metadatentype ausgewählt wird, wird der Name des neuen Columns richtigerweise umbenannt. Allerdings verliert der Name dabei den Package prefix (z. B. CCC_). 4.2.21 (24.09.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.21_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021097624 - IDE: Ruft man in einer customized Form die Control Events auf einem Custom Control auf, werden dort die Event-Methoden-Zuweisungen aus der Basis nicht angezeigt. 2021097638 - IDE: Bei einem Undo Checkout auf einem ReportDocumentType wird die vorherige Version des Reports nicht auf die Festplatte geschrieben. Bei einem darauffolgenden Edit wird die bereits bearbeitete Version angezeigt, nicht die zurückgesetzte. 4.2.20 (27.08.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.20_Setup_x64 FS4.2.20_AuthService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer Authentication-Service Es gibt einen neuen Authentication-Service mit der Version 4.2.20. Dieser ersetzt die bisherige Version 4.0.16. Die neue Version behebt einen Fehler in der Windows-Authentication (siehe unten). Note Der neue Authentication-Service ist kompatibel mit älteren Versionen von Applikationen (FS 4.0 und älter). Korrigierte Fehler 2021087506 - Authentication Service: Die Windows-Authentifizierung funktioniert nicht, wenn der Authentication Service als Windows Service installiert ist und mit einem Domain-User betrieben wird. 2021087467 - HTML Client: Beim Öffnen des virtuellen Keyboards in Android 8 oder älter, wird die WebView in seltenen Fällen vertikal um die Höhe der Statusbar nach oben verschoben. Die Folge ist ein grauer Streifen zwischen der WebView und dem Keyboard. 2021087519 - HTML Client: Labels werden als fokussierbar angesehen und stören die Fokusreihenfolge. 2021087523 - HTML Client: Controls ohne Größe (MaxWidth = 0 oder MaxHeight = 0) werden fälschlicherweise in der Fokusreihenfolge berücksichtigt und stören diese dadurch. 4.2.19 (30.07.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.19_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2020104512 - IDE: bei der Anlage eines neuen Crystal Report mit einer neuen Report-Datei gibt es eine Exception: System.System.ArgumentNullException: Der Wert darf nicht NULL sein 2021077185 - IDE: Nach dem Bearbeiten von Namespace-Referenzen kann es vorkommen, dass trotz Speichern der Namespace noch immer als geändert angezeigt wird. FS muss neu gestartet werden . 2021077150 - Framework: Mit Framework Studio 4.2.17 und 4.3.5 wurden an den FS-Typen das Interface IFormattable implementiert (Bug 2021066957). Diese Erweiterung hat negative Auswirkungen auf bestehenden Code - z.B. wenn SQL-Statements mit String.Format() oder String-Interpolation erzeugt werden. Bisher wurden null-Werte über Methode ToString() mit dem String \"null\" abgebildet, die Format-Methoden liefern aber einen leeren String zurück. Note Die IFormattable-Implementierung wurde bis auf Weiteres wieder komplett entfernt. 2021077114 - HTML Client: Wird ein Control mit \"Tab\" verlassen, so kann es ein, dass der Fokus-Indikator (Outline oder gelbe Hintergundfarbe) immer noch sichtbar ist. 2021077151 - HTML Client: Ein TabbedWindow kann per \"Tab\" nicht fokussiert werden. Befindet sich der Fokus im letzten Control der aktiven TabPage, so springt der Fokus nicht mehr heraus zum nächsten Control. 2021077221 - HTML Client: Die Kamera funktioniert nicht auf Android 11 oder höher 2021077223 - HTML Client: Bei der Ausführung der TakePhoto-Action am Client wird nicht nur das Bild zurück an den Broker geschickt, sondern auch lokal eine Kopie in der Gallery gespeichert. 2021077228 - HTML Client: Der Fullscreen-Modus funktioniert auf Android 11 nicht. Note Auf Grund eines zwar bestätigten aber bisher nicht korrigierten Bugs in Android 11 kann der HTML Client auf dieser Version deshalb nur im normalen Modus betrieben werden. 2021077229 - HTML Client: Beim Pausieren der App auf Android wird ggf. die aktive Session nicht korrekt gespeichert. Dadurch kann nach einem Neustart der App ggf. die Session nicht fortgeführt werden. 4.2.18 (25.06.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.18_Setup_x64 FS4.2.18_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neue Crystal Reports Runtime Es wird die Crystal Reports Runtime mit Version 13.0.26 und höher unterstützt. Voraussetzung ist der neue Print-Service 4.2.18. Das Requirements-Paket beinhaltet vorerst weiterhin die Version 13.0.18 Note Bitte beachten sie unbedingt die Hinweise in den aktualisierten Systemvoraussetzungen! Korrigierte Fehler 2021066859 - Print-Service: Treten beim Verarbeiten von Druckaufträgen wiederholt Fehler auf, dann führt der Print-Service einen Restart durch. Wird der Print-Service aber als Console ausgeführt, dann funktioniert dieser Restart nicht. In der Folge läuft der Print-Service weiter und produziert weiter Fehler. 2021066919 - Print-Service: Wenn im Print-Service sehr viele Drucker definiert sind, dann kann das den Start des Dienstes so stark verzögern, dass der Start in einen Timeout läuft. Im PrintServiceConfigEditor wird ein Timeout von 30 Sekunden verwendet. Note Die Analyse der Drucker wird jetzt nach dem Start des Dienstes ausgeführt. Anstehende Druckjobs werden erst im Anschluss verarbeitet. Es kann also sein, dass die ersten Druckjobs erst mehrere Sekunden nach erfolgreichem Start des Dienstes verarbeitet werden. 2021066928 - Print-Service: Läuft der Print-Service in einen Fehler - z.B. bei der Verarbeitung eines Crystal Report Documents - dann erfolgt ein automatischer Restart des Services. Dabei wird die letzte Transaktion auf \"fehlerhaft\" gesetzt. In der Folge wird der Druck-Job nicht verarbeitet, auch wenn nach dem Neustart eine Verarbeitung möglich wäre. Note Tritt so ein Fehler auf, dann wiederholt der Print-Service jetzt nach dem Restart einmalig den Druck-Job. 2021066966 - Print-Service: Wird der Print-Service als Console ausgeführt, dann blockiert eine Markierung von Text die Console und damit den kompletten Print-Service. Note Bei einer Blockade läuft der Print-Service jetzt im Hintergrund weiter. Während der Blockade werden alle Ausgaben gepuffert und nach der Freigabe ausgegeben. Die Blockade der Console-Ausgabe während der Markierung ist eine Windows-Funktion und kann durch den Print-Service nicht unterbunden werden. 2020093875 - IDE: Eine DLL-Referenz in einem Form-Namespace, welche in Sub Namespaces verwendet werden kann, führt zu einem Compile-Fehler im Child bzw. Sub-Namespace. 2021056504 - IDE: Werden an einer GridColumn die Events bearbeitet, werden die Änderungen nicht autom. gespeichert und auch der Speicherbutton wird nicht aktiviert. 2021066783 - IDE: Mit einem Oracle-Repository kommt es beim Aufruf der Method History zu einem Fehler: ORA-00932: Inkonsistente Datentypen: CLOB erwartet, CHAR erhalten. 2021066884 - IDE: Im Paste-Dialog in der Registerkarte \"Summary\" wird bei einem Replace \"No conflicts found!\" angezeigt. Hierdurch ist auf den ersten Blick nicht ersichtlich, dass eine Methode mit gleicher Signatur überschrieben wird. 2021066945 - IDE: Beim Checkin eines Records werden auch von dem Record verwendete, neu angelegte Records erkannt und diese automatisch mit eingecheckt. Handelt es sich bei dem verwendeten Record aber um eine Customization, dann ist dessen Checkin nicht zwingend nötig, weil er ja schon im Basis-Package eingecheckt wurde. 2021066893 - HTML Client: Das sofortige Blockieren der UI bei einem Event wurde entschärft. Das Sperren erfolgt erst nach 500ms. 4.2.17 (30.04.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.17_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021036188 - Oracle: Werden in einem Grid Spalten mit Langtext gefiltert oder sortiert, dann kommt zu einer Sql-Exception, wenn die Texte auf der Datenbank eine Länge von 2000 bzw. 4000 Zeichen überschreiten. Die SQL-Methode LOB_COMPARABLE( ) beinhaltet keine Längenbegrenzung. ORA-22835: Buffer too small for CLOB to CHAR or BLOB to RAW conversion. 2021036077 - IDE: Ist in einem Workflow-Link ein Target FormContainer zugewiesen, dann kann es sein, dass dieser in einem abgeleiteten Workflow nicht mehr zieht. 2021036122 - IDE: Beim Öffnen des Method History Browser für kopierte oder neu erstellte Methoden, bei denen die Deklaration vor dem Speichern nicht bearbeitet wurde, kann es zu einer Fehlermeldung kommen. 2021046301 - IDE: Im Runtime License Manager kann es im AccessUnitTree durch Drücken der Leertaste zu einer Unhandled Exception und in der Folge zum Absturz der IDE kommen. 2021046405 - IDE: Beim Anlegen oder Löschen von Template DataSources im ListView- oder Template Control Designer kommt keine Rückfrage zum Auschecken des Forms. 2021046385 - HTML Client: Bei sehr schnellen Eingaben per Maus oder Touch können versehentlich mehrere Requests aneinandergereiht werden. 2021046388 - HTML Client: Im ListView und Template Control werden NULL-Werte als \"null\" (String) angezeigt, anstatt nichts anzuzeigen. 2021046253 - SqlServer: Wird am Ende einer sehr großen Transaktion ein Rollback ausgeführt, dann kann das zu einem Timeout und einem Abbruch der Sql-Connection führen. In der Folge kann es wegen der geschlossenen Sql-Connection im laufenden Broker-Request zu weiteren Sql-Fehlern kommen. 4.2.16 (26.03.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.16_Setup_x64 FSCL_4.2.16_Setup_x86 FSCL_4.2.16_Setup_x64 FSCL_4.2.16_Setup_Msi_x86 FSCL_4.2.16_Setup_Msi_x64 FS_4.2.16_Requirements_x86 (neuer FSClient Launcher) FS_4.2.16_Requirements_x64 (neuer FSClient Launcher) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen im FS Client-Launcher werden die Protokolle automatisch in Dateien gespeichert. Im FS Client-Launcher kann über eine Umgebungs-Variable eine abweichende Java Runtime definiert werden. Korrigierte Fehler 2021025789 - Java-Client: In den Fenstern des Haupt-Arbeitsbereiches ist es nicht mehr möglich, mit den Pfeil-Tasten durch die Menüs zu navigieren. Das erschwert die Bedienung an Blindenarbeitsplätzen. 2021035831 - Publish: Beim Auto-Publish mit FSConsole wird bei Datenbankverbindungen mit Windows Authentication fälschlicherweise trotzdem ein Username und ein Passwort erwartet. 2021025761 - IDE: Wird beim Export des Wörterbuches die Auswahl der Sprachen eingeschränkt, dann werden trotzdem alle Sprachen exportiert. 2021035928 - IDE: Bei einem \"ReplaceAll\" im Code-Editor wird der Suchtext fälschlicherweise immer als RegEx interpretiert, unabhängig von der Checkbox \"Use regular expression\". 2021036115 - Framework: Arbeitet eine Component mit einer importierten Business-Datenbank, dann kann es beim Aufruf der Methode GenerateLoadCondition() zu einer SQL-Exception kommen, wenn die Datenbank-Tabelle \"dbRun_Config\" nicht existiert. 4.2.15 (26.02.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.15_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Änderung der Logik beim Schließen des letzten Forms im HTML Client Auf Grund von Bug 2021015392 wurde die Logik, die beim Schließen des letzten Forms im HTML Client greift, überarbeitet. Es gibt nun 2 Szenarien, die es zu beachten gilt. Eine detailierte Beschreibung gibt es hier HTML Client Actions Der HTML Client unterstutzt nun die Actions SetTitle und SetCaption. Mehr Informationen zu den unterstützten Action finden Sie hier Korrigierte Fehler 2021025560 - Java-Client: In einem TreeView wird durch den Benutzer ein TreeNode selektiert. Das löst ein OnAfterSelect-Event aus. Dann wird durch eine Aktion am Broker (z.B. durch setzen des TreeView-Datasources) ein anderer TreeNode selektiert. Klickt der Benutzer jetzt erneut auf den zuerst selektierten Eintrag, dann wird kein OnAfterSelect-Event ausgelöst. 2021025568 - Java-Client: Bei der Arbeit mit der Accessibility-Schnitstelle kann es beim Schließen von Forms zu Exceptions kommen: java.lang.ClassCastException: FrameworkSystems.FSJavaClient.DevControl.DevControlFieldRow cannot be cast to javax.accessibility.Accessible 2021015392 - HTML Client: Wird das letzte Form vom Broker aus per Action geschlossen, so muss am Client die Session ohne Rückfrage geschlossen werden, wenn keine weiteren Forms offen sind. 4.2.14 (29.01.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.14_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Vorwärts- und Rückwärtsnavigation mit Maustasten Die bisherige Navigation zwischen Einträgen ist nun auch mit den beiden zusätzlichen Navigationstasten an der Seite der Maus möglich. Korrigierte Fehler 2020125151 - Oracle: An einigen Stellen wird für das Ermitteln von Datenstrukturen der Datenbank auf die ALL_-Views zugegriffen. Besser ist es, die USER_-Views zu verwenden, weil dadurch Fehler vermieden werden können. 2016042153 - IDE: Am DBIndex gibt es eine Eigenschaft \"Active\". Diese wird über eine wenig intuitive Combobox gesteuert, welche keine Beschriftung hat und allermeist nur \"Inherit\" anzeigt. 2020114533 - IDE: Ein leerer customized Namespace kann nicht gelöscht werden. 2020125090 - IDE: Wird eine AccessUnit und deren AccessUnit Parent angelegt und nur ersteres wird eingecheckt, erfolgt keine Dependency Prüfung auf den AccessUnit Parent. 2021015220 - IDE: Werden in einem Customizing-Package Themes definiert, dann werden diese nicht mehr erkannt, sobald für dieses Customizing-Package eine Context-Version gebildet wird. 4.2.13 (18.12.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.13_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2020125024 - JavaClient: Nach dem Aufruf der Grid-Action ResetSortAndFilter() am Broker wird im Client die Markierung im Spalten-Kopf nicht entfernt. Erst wenn man mit der Maus über den Spalten-Kopf fährt, wird dieser aktualisiert. 2020104105 - IDE: Wenn man an einem WorkflowLink die Eigenschaft \"Create Target\" ändert, wird unter Umständen die Eigenschaft \"Auto Fokus\" auf den gleichen Wert gesetzt. Die Benutzeroberfläche ermöglicht dann kein Ändern der Eingenschaft mehr. Gespeichert wird für \"Auto Fokus\" allerdings ggf. der ursprüngliche Wert. 2020114784 - IDE: Im GlobalEvent wird beim Parameter der Datentyp über einen TreeView ausgewählt. Dort kann nicht auf Typen des Basis-Packages zugegriffen werden. Note Der Datentyp wird jetzt über eine Auto-Completion-Textbox bearbeitet - wie auch z.B. bei den Component-Properties oder den Report-Datasources. 2020114826 - IDE: Existiert eine AccessUnit, die bei einer anderen AccessUnit als Parent hinterlegt ist, nicht mehr, kommt es zu Exceptions beim Compilieren und beim Öffnen der AccessUnit Ansicht. Note In der Registerkarte 'Access Units' wird ein Button 'Fix the parent Access Unit' angezeigt, sobald am AccessUnit ein ungültiger Parent hinterlegt ist. Wird dieser Button gedrückt, hat dies zur Folge, dass die ungültige Beziehung gelöscht wird. Sollte kein anderer gültiger Parent verfügbar sein, wird 'Root' als Parent definiert. 2020124958 - Framework: Im Grid-Binding kann es zu einem Stackoverflow / Absturz kommen, wenn das Grid den Inhalt eines Individual Properties anzeigt, welches im Getter einen neuen Value erzeugt. 2020125083 - Package Merge: Components verlieren beim Merge in das Basis-Package in der Query Einstellungen GroupBy und ReadOnly. 2020125050 - Package-Merge: Bei TextCollections kann es passieren, dass im Customizing geänderte Texte nicht korrekt in das Basis-Pacakge gemerged werden. 4.2.12 (27.11.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.12_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. HTML Client Neuerungen SetFocus Action auf Formebene Bisher wurde lediglich die letzte am Broker ausgeführte SetFocus-Action am Client ausgeführt und das unabhängig von den Forms. SetFocus-Actions werden nun per Form abgearbeitet. Deep Links Der Android Mobile Client unterstützt nun das Öffnen von Deep Links. Damit kann z.B. aus einem Browser heraus per Link der Mobile Client geöffnet und automatisch ein Login an einem Broker ausgeführt werden. Zudem kann der Broker-Liste ein Eintrag hinzugefügt werden. Beispiel im HTML: <a href=\"fsbroker://framework-systems.de?name=Demo&url=http%3A%2F%2FAwesomeServer%3A8080%2FAwesomeApplication&login=true&save=true\">Open Deep Link</a> Der Link beginnt immer mit der Custom-Url fsbroker://framework-systems.de. Diese wird vom Mobile Client im Android-System registriert und sorgt für das Öffnen der App. Zusätzlich kann die Url aus bis zu vier der folgenden Parameter bestehen: Parameter Typ Benötigt Funktion name string (url-encoded) Ja Der Name des Brokers url string (url-encoded) Ja Die Broker-Url login boolean (true/false) Nein Steuert, ob sich die App nach dem Öffnen sofort am gegebenen Broker angemelden soll. Bei false wird lediglich die Startseite angezeigt. Der Standardwert ist true. save boolean (true/false) Nein Steuert, ob der angegebene Broker in der Login-Liste des Mobile Client gespeichert werden soll. Existiert ein Eintrag mit demselben namen, so wird dessen Url überschrieben. Der Standardwert ist false. Die Parameter name und url müssen immer url-enkodiert sein. So muss wie im Beispiel statt http://AwesomeServer:8080/AwesomeApplication die url-enkodierte Variante http%3A%2F%2FAwesomeServer%3A8080%2FAwesomeApplication angegeben werden. Einen entsprechenden Url-Encoder finden Sie z.B. unter https://www.urlencoder.org Note Ein Klick auf einen Deep Link wird vom Mobile Client nur dann interpretiert, wenn folgende Bedingungen erfüllt sind: Die App ist nicht bereits an einem Broker angemeldet Die App findet beim Start keine alte Session, die fortgeführt werden kann Korrigierte Fehler 2020114581 - Publish: Im Publish-Setting können keine Unicode-Zeichen gespeichert werden. Je nach Code-Page der Datenbank gehen ggf. auch deutsche Umlaute verloren. Auch beim Einlesen eines Release-Settings im Publish und Publish2Go gehen Unicode-Zeichen verloren. 2020114749 - Package-Manager: Existieren in der Repsitory-Datenbank Tabellen oder Constraints mit Namen, die Whitespaces oder Sonderzeichen enthalten (z.B. BIN$-Tabellen auf Oracle), dann kann es beim Import oder beim Löschen einer Package-Version zu SQL-Fehlermeldungen kommen. In der Folge kann es passieren, dass auf dem Repository die Constraints nicht mehr aktiviert werden. 2020104499 - IDE: Bei der Code-Generierung der Interfaces kann es passieren, dass für die Component-Properties falsche Display-Length Informationen generiert werden. In der Folge werden Änderungen am Metadatentyp nicht korrekt gezogen. 2020114542 - IDE: Für das Anzeigen des generierten Codes zu Debugging-Zwecken wird Visual Studio 2019 nicht erkannt. Note Da es mehrere parallele Installationen von Visual Studio geben kann, ist eine eindeutige Ermittlung des Installationspfades nicht möglich. Der Pfad muss in den Optionen manuell angegeben werden. Framework Studio öffnet bei Bedarf den Optionen-Dialog. 2020114672 - IDE: Bei einem Oracle-Repository kann als Database kein TNS-String angegeben werden. Das führt zur Exceptions bei der Anmeldung am Repository. Note Für die Verwendung einer Container-Datenbank kann bei Database \"SERVICE_NAME=AbcXyz\" angegeben werden. Beim Server-Namen kann der Port jetzt mit \":\" angegeben werden z.B. \"Server:1521\". 2020114783 - IDE: Wird eine Component-Methode von public auf protected gesetzt, dann werden die Interfaces nicht in den Auto-Compile aufgenommen. Die Folge ist ein Compile-Error bei den Components. 2020114578 - HTML Client: Wird beim Start der App eine alte Session wieder hergestellt, so kommt es ggf. vor, dass der dem Form per Action zugewiesene CloseButton nicht funktioniert. 4.2.11 (30.10.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.11_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. HTML Client Neuerungen Neues Framework als Basis Der HTML Client wurde bisher mit Apache Cordova und Adobe PhoneGap Build in die mobile Welt gebracht. Adobe hat im September angekündigt, PhoneGap nicht mehr weiter zu entwickeln. Auf Grund von erweiterter Hardware-Unterstützung und der einfacheren Integration in den Entwicklungsprozess haben wir jedoch schon vor dieser Ankündigung den HTML Client auf das Ionic Capacitor Framework umgezogen. Auch die Browser-Version des HTML Clients profitiert maßgeblich vom neuen Framework. Zusätzlich zu den Bugfixes unter Korrigierte Fehler sind ab sofort folgende Verbesserungen Verfügbar: Die TakePhoto Action funktioniert nun auch im Browser Die GetGeolocation Action funktioniert nun auch im Browser Die PrintReport Action wird nun unterstützt Eine noch aktive Session wird sofort beim Starten der App geladen Wird das letzte Form geschlossen, gibt es eine Rückfrage, ob die Session geschlossen werden soll Die UI wird bei länger laufenden Requests nun vollständig gesperrt, um parallele Eingaben zu verhindern Neue Systemvoraussetzungen Unterstützt werden wie bisher Handys und Tablets mit Android 6.0 oder höher. Caution Auf Geräten mit Android 7.X oder niedriger muss Google Chrome parallel zwingend installiert sein, da die integrierte WebView nicht mehr unterstützt wird Ist auf dem Endgerät Google Chrome nicht installiert, so wird zur Anzeige der HTML-Applikation die integrierte Android WebView verwendet. Diese basiert wie Google Chrome ebenfalls auf der Chromium Engine, ist aber auf vielen - vor allem älteren - Endgeräten nur in einer sehr betagten Version verfügbar. Dies kann ggf. zu Fehlern führen. Es gelten folgende Regeln: Ist Google Chrome installiert, wird dessen Chromium Engine für die Ausführung des Framework Studio Mobile Client verwendet Ist Google Chrome nicht installiert, wird die Android WebView verwendet Note Auch auf neueren Geräten ab Android 8.0 empfehlen wir, die aktuellste Version von Google Chrome zu installieren, um die breiteste Unterstützung von Features und die fehlerfreie Darstellung der App zu garantieren. Globales CSS für ListViewItems und Template Controls Es besteht ab sofort die Möglichkeit, ListViewItems und Template Controls mit globalen CSS Styles zu versehen, welche applikationsweit angewendet werden. So kann sehr einfach ein grundlegendes Theme für die HTML Controls bereitgestellt werden, ohne dasselbe CSS an jedem Control erneut anwenden zu müssen. Mehr Informationen dazu gibt es unter folgenden Links: ListView TemplateControl Korrigierte Fehler 2020104399 - Broker: Bei der Konvertierung von XML nach JSON kann kann es zu einer Exception kommen, welche als Folge ggf. den HTML Client abstürzen lässt. 2020104461 - Package-Manager: Beim Löschen einer Package-Version wird eine Exception angezeigt: Record to update was not found in repository. Type: LabelRecord, Lbl_ID: 12... 2020093967 - IDE: Werden Properties an Template DataSources geändert, so wird keine Rückfrage zum Auschecken des Forms gestellt. Betrifft den ListView Template Editor sowie den Template Control Editor. 2020104124 - IDE: Im Template Editor von Template Control und ListView wird das DataSource Editor Panel nicht geschlossen, wenn die letzte DataSource aus der Liste entfernt wird. 2020104125 - IDE: Wenn am ListView ein Padding oder Margin definiert ist, so stellt die Preview im Template Editor das ListViewItem falsch dar. 2020104354 - IDE: Namespace-Referenzen auf den v4.0 Global Assembly Cache werden nicht unterstätzt. Der Auswahl-Dialog bietet diese Assemblies nicht an. 2020094098 - Framework: Wird mit einer Component, die eine Tabelle einer importierten Datenbank verwendet, ein Datensatz gelöscht, dann kommt es zu Exceptions, wenn die Datenbank keine Tabelle dbRun_mlStrings besitzt. Die Tabelle dbRun_mlStrings wird durch die Update-Logik automatisch angelegt, allerdings dann nicht, wenn die komplette Datenbank als \"imported\" gekennzeichnet ist. 2020031857 - HTML Client: Wird direkt im Form_Load-Event der Fokus mit SetFocus() in ein Control gesetzt, so wird dieses dennoch nicht fokussiert. 2020083526 - HTML Client: Bei langen Requests wird nun die komplette UI gesperrt (nach 300ms), sodass während der Bearbeitung keine Request-Kaskaden vom User ausgelöst werden können, die für Verwirrung sorgen. 2020083528 - HTML Client: Wird SetFocus() auf einem Control ausgeführt, welches im gleichen Request erst auf \"Visible\" geschaltet wird, so wird der Fokus nicht in das Control gesetzt. 2020083532 - HTML Client: Wird eine FieldRow zum ersten Mal auf \"Visible\" gesetzt, kann es sein, dass das Control-Label in der ersten Spalte nicht angezeigt wird. 2020083684 - HTML Client: Wird das letzte Form einer App geschlossen, so bleibt die Session offen, ohne die Möglichkeit, zurück ins Hauptmenü des HTML Client zu wechseln. Beim Schließen des letzten Forms der App wird nun gefragt, ob die Session beendet und zurück ins Hauptmenü gewechselt werden soll. 2020104210 - HTML Client: Wenn ein ListView ein Bottom Padding hat und durch die Anzahl der ListViewItems scrollbar wird, so wird das Bottom Padding nicht angezeigt, wenn man ganz nach unten scrollt. 2020104396 - HTML Client: Wenn in einem ListView oder Template Control der %FILESURL% Platzhalter verwendet wird, aber keine Template-Variablen definiert sind, so wird der Platzhalter zur Laufzeit nicht durch den Broker-Pfad ersetzt. 2020104444 - HTML Client: Auf Android-Geräten werden alle Bilder (z.B. an ImageButtons oder in ListViews) auf unbestimmte Zeit gecached. Selbst wenn eine Resource mit einem neuen Bild versehen und compiliert wird, wird am Client immernoch das alte Bild angezeigt. 2020094030 - Package-Merge: WorkflowEvents an Forms und ihre Links gehen unter Umständen verloren. 2020094032 - Package-Merge: Die Checkbox \"Output\" wird an VirtualColumns beim Merge nicht immer korrekt gesetzt. 4.2.10 (25.09.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.10_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Fehler im Package-Merge Warning Seit 29.05.2020 gibt es mehrere Probleme mit dem Package-Merge. Einige wurden korrigiert, jedoch sind noch offene Punkte bekannt. Daher empfehlen wir, bis zum nächsten Patchday auf den Package-Merge zu verzichten. Korrigierte Fehler 2020093914 - JavaClient: Der Client startet im Hintergrund eine cmd.exe. Das führt ggf. zu Problemen, wenn per Gruppenrichtline der Zugriff auf die Kommandozeile verhindert wird. 2020093778 - IDE: Kopiert man ein Property, an dem explizit ein MLKey zugeordnet ist, von einer Component in eine Andere, so wird der MLKey nicht mit übertragen. Statt dessen werden die Texte aus dem MLKey eingetragen. 2020093830 - IDE: Wird ein Compile-Vorgang gestartet, direkt nachdem der Mauszeiger in den Code-Editor platziert wurde, dann kann es in seltenen Fällen zu Exceptions und ggf. auch zu einem Absturz der IDE kommen. 2020093841 - IDE: Wunsch: Beim Kopieren per Copy&Paste von Elementen in ein anderes Package mit Texten, denen ein MLKey zugeordnet ist, soll der vollständige MLKey bei Bedarf im Zielpackage eingefügt werden. 2020093992 - IDE: In TextCollections ist die Angabe von Texten nicht mehr möglich. 2020083585 - HTML Client: Die Enter-Taste wird auf Android <= 6.0 nicht erkannt. So kann z.B. nicht mit Enter aus einem Editfield heraus gesprungen werden. 2020083660 - HTML Client: Ist einer CheckBox als DataSource ein FS-Datentyp (z.B. FSshort, FSint oder FSlong) zugeordnet und dieser auf \"NULL\" gesetzt, so ist die CheckBox dennoch angehakt. 2020011097 - Package-Merge: Im Schritt \"Checkout\" kommt es zu Fehlermeldungen, wenn im Zielpackage Elemente customized waren und anschließend wieder gelöscht wurden. 2020093954 - Package-Merge: Die Parent-Beziehungen von AccessUnits werden nicht übertragen. 2020093955 - Package-Merge: Es werden nicht alle geänderten Einstellungen in das Zielpackage übertragen. 2020093963 - Package-Merge: DataContracts werden beim Merge-Vorgang ausgelassen. 4.2.9 (28.08.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.9_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2020083454 - JavaClient: Wird eine Anwendung als \"Frameless\" gestartet (z.B. der Pick-Monitor in eNVenta ERP), dann kann es passieren, dass eine Fehlermeldung angezeigt wird: Java-Exception: The frame is displayable. 2020083525 - Oracle: Beim automatischen Datenbank-Update kann es vorkommen, dass das Einlesen der Struktur-Informationen sehr lange dauert. 2019016813 - IDE: Wird eine Text-Collection per Paste in eine bestehende Text-Collection gemerged, werden die ausgewählten Texte in der Summary-Registerkarte nicht angezeigt. 2020011256 - IDE: Im Documentation-Editor wird beim Rückgängig machen der letzten Aktion (STRG+Z) der gesamte Text gelöscht, wenn lediglich eine neue Section hinzugefügt wurde oder seit dem CheckOut nichts verändert wurde. 2020062830 - IDE: Ändert man an einem Property im Getter oder Setter die Checkbox \"Write Individual\", dann wird der Methoden-Code nicht aktualisiert. 2020073327 - IDE: Beim Copy&Paste einer TextCollection werden die MLKeys nicht übertragen. 2020073331 - IDE: Nach Einfügen einer Text-Collection wird den Save-Button nicht aktiviert. 2020073346 - IDE: Im ClassView werden die Member nicht korrekt nach Name sortiert. 2020073361 - IDE: Wird im Basis-Form eine Form-Methode gelösch, die in einem Control-Event zugeordnet ist, dann wird in der Event-Zuordnung im agbeleiteten Form diese Methode weiterhin angezeigt. 2020073369 - IDE: Führt man im Workflow-Editor einen Doppel-Klick auf ein Global-Event aus um dieses zu öffnen, dann wird eine Exception angezeigt. Ein weiterer Doppel-Klick öffnet das Global-Event. 2020073372 - IDE: Wird ein neues Global-Event angelegt, dann wird eine SQL-Exception ausgelöst. Ein Speichern ist nicht mehr möglich. 2020083515 - IDE: Wird ein als Imported gekennzeichneter View customized, dann ist im Customizing die Checkbox \"Imported\" nicht aktiv. In der Folge wird beim Compile der DBTables ein Error ausgegeben: #error: 'FSErr[1064] No view definition has been specified. 2020083531 - IDE: Wird ein DataContract, dessen Contract Type auf \"IList\" oder \"Array\" steht, customized, dann wird in der Customization der Typ \"Single Item\" angezeigt. Note Wenn so ein Fall entstanden ist, dann muss der DataContract im Customizing-Package gelöscht und neu customized werden. 2020083513 - HTML Client: Ist an einem modalen Form \"HideModalHeader = true\" gesetzt, so wird mit dem Back-Button auf Android-Geräten nicht das Form geschlossen, sondern versucht, die Session zu beenden. 4.2.8 (31.07.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.8_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. HTML Client Neuerungen MLKeys und Preview im TemplateControl und ListView Im HTML-Editor des TemplateControls und ListViews können jetzt MLKeys verwendet werden. Außerdem gibt es dort nun eine Preview-Funktion. Weitere Informationen: TemplateControl und ListView. Unterstützung für das TabbedWindow Control Das TabbedWindow Control wird nun in vollem Umfang vom HTML Client unterstützt: Volle Unterstützung der TabTemplates Horizontale und vertikale ausrichtung Verwendung des DataSource-Properties, um TabPages aus dem Code heraus zu selektieren Overflow-Verhalten bei zu vielen Tabs: Sind die Tabs zu breit oder zu hoch für das Display, kann ganz einfach mit dem Mausrad oder per Touch auf mobilen Geräten durch die Liste gescrollt werden OnSelectedTabPageChange und OnSelectedTabPageChanged Events Modale Dialoge ohne Header Über ein neues Property HideModalHeader am Form kann der Header (mit Titel und Close-Button) ausgeblendet werden, wenn es als modaler Dialog aufgerufen wird. So steht etwas mehr Platz zur Verfügung. Da mit dem Header auch der Close-Button verschwindet, muss der Aufruf von this.Close() am Form anderweitig erfolgen, z.B. durch einen eigens implementieren Button oder ein Event. Fullscreen Der HTML Client wird auf mobilen Geräten ab sofort im Fullscreen-Modus ausgeführt. So steht noch etwas mehr platz für Controls zur Verfügung, da die Statusleiste und Softbuttons des Geräts die App nun überlappen. Form BadgeImages Zusätzlich zu den ImageButtons werden BadgeImages nun auch am Form über das Property BadgeImage DataSource unterstützt. Korrigierte Fehler 2020073096 - JavaClient: Wird die Anwendung über den FSClient-Launcher gestartet, dann erfolgt bei mehreren Anwendungen keine Gruppierung in der Windows Taskleiste. Note Jetzt erfolgt die Gruppierung in der Taskleiste nach der Adresse des Brokers. 2020073176 - Java-Client: Beim Entfernen und wieder Einfügen von dynamischen Grid-Spalten wird die Einfügereihenfolge nicht beachtet. 2020073067 - Oracle: Die Update-Logik in der Anwendung erzeugt Exceptions, wenn in der Business-DB Trigger ohne Tabellen-Bezug existieren. 2020073177 - Oracle: Bei paralleler Verarbeitung kann es passieren, dass der Connect zur Oracle-Datenbank eine Exception 'Timeout bei Verbindungsanforderung' erzeugt. Das betrifft z.B. das parallele Einlesen der Daten beim Start der IDE und das parallele Erzeugen von GlobalObjects in Services und im E-Gate. Note Beim Start der IDE wird jetzt die Anzahl der zusätzlichen Repository-Connections auf 8 erhöht. Mit dem Bug 2020062828 wurde für Oracle die Anzahl auf 4 begrenzt. 2020073201 - Package-Manager: Beim Branch einer Package-Version gehen alle MLKeys verloren. 2020072990 - IDE: In Methoden an Services und ServiceProxies generiert der Exception Editor Wizard durch die Verwendung von \"this.Global\" nicht kompilierbaren Code. 2020073068 - IDE: Der Documentation Chapter Tree wird falsch sortiert. Wenn man die Reihenfolge ändert, wird beim nächsten Öffnen des Chapter Tree wieder die falsche Reihenfolge angezeigt. 2020073205 - IDE: Beim Kopieren von Controls kann es zu einer NullReferenceException kommen. 2020073292 - IDE: Wenn man nach dem Laden eines Settings im Run- oder PublishWizard Framework Studio neu startet, gehen die Setting-Einstellungen verloren. 2020073317 - IDE: Wird ein neues Global-Object angelegt, dann wird dieses nach dem Wechsel auf einen anderen Namespace nicht mehr im Namespace-Baum angezeigt. 2020073335 - IDE: Bei der Bearbeitung des Source-Events im Workflow-Link kann es zu einem Absturz der IDE kommen. 2020073350 - IDE: Bei der Arbeit mit Text-Collections kann es passieren, dass in den Code der Text-Collection fälschlicherweise 2 Properties \"ID\" und \"Text\" generiert werden. In der Folge kann das zu Compile-Fehlern führen, wenn dadurch der Component-Code evtl. nicht zum Interface-Code passt. 2020073078 - Framework: Beim Neustart der Endanwendung unter Beibehalt des angemeldeten Benutzers wird der AuthenticationService nicht kontaktiert, um die Benutzerrollen neu auszuwerten. 2020072975 - HTML Client: Das OnValidated-Event wird gefeuert, obwohl sich im Textfeld nichts geändert hat. 2020073049 - HTML Client: Buttons und ImageButtons berechnen ihre Höhe unabhängig vom ShowCaption-Property. 2020073066 - HTML Client: In einem FieldPanel mit \"SynchronizedColumns = true\" wird für ausgeblendete Control Labels ggf. Platz reserviert, wodurch das Layout durcheinander gebracht wird. 2020073075 - HTML Client: FieldRows mit dem LabelMode \"None_Fill\" verursachen zur Laufzeit eine Exception, wenn das zugehörige FieldPanel \"SynchronizedColumns = true\" gesetzt hat. 2020073097 - HTML Client: Ausgeblendete Controls werden in manchen Situationen in der Fokusreihenfolge beachtet. Dies hat zur Folge, dass der Fokus ggf. in einem Control vor einem ausgeblendeten Control festhängt. 4.2.7 (26.06.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.7_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2020031817 - Java-Client: Die Shortcuts Ctrl-H, Ctrl-T, Ctrl-Shift-T und Ctrl-Shift-O funktionieren nicht, wenn sich der Fokus in einem (Html)-Eingabefeld befindet. 2020062855 - Publish2Go: Wird eine Application per Publish2Go gepublished, kann es passieren, dass bei einer Application die Einstellung für den HTML-Client falsch ausgewertet wird. Auf der Broker-Startseite wird dann die Option \"HTML\" nicht angeboten. Oder bei mehren Applications wird die Option \"HTML\" fälschlicherweise bei einer normalen Application angeboten. Note Publish2Go-Pakete müssen mit der neuen Version komplett neu erzeugt werden, damit die Korrektur wirksam wird. 4.2.6 (16.06.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.6_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2020052640 - IDE: Leitet man von einer Basis-Formklasse aus einem Basis-Package ab (Derive), zu der es eine Customization im aktuellen Package gibt, so kommt es zu einer Fehlermeldung und der Ableitung fehlen anschließend Controls. 2020062773 - IDE: Beim Copy&Paste wird der Control-Style nicht übertragen. Wird im Form-Designer ein neues Control mit einem vererbten Control-Style angelegt, dann wird der \"Control-Type\" auf eine alte Art verschlüsselt. 2020062779 - IDE: Wurde ein Control-Type gelöscht, dann führt das beim Öffnen eines Forms in der IDE und beim Compile zu einer Exception. Das passiert auch, wenn die betroffenen Controls bereits auf \"gelöscht\" stehen. 2020062828 - IDE: Das parallele Einlesen der Objekt-Daten beim Start der IDE mit mehreren Datenbank-Verbindungen bereitet unter Oracle Verbindungs-Probleme. Note Neues Verhalten nach der Korrektur. Unter Oracle wird die maximale Anzahl der zusätzlichen Repository-Verbindungen auf 4 begrenzt. Unter SQL-Server werden jetzt maximal 8 zusätzliche Verbindungen geöffnet. Nach 15 Sekunden werden die zusätzlichen Verbindungen wieder geschlossen. 2020062840 - IDE: Unter Oracle kommt es beim Checkout einer Textcollection zu einer Datenbank-Exception: ORA-00932: Inkonsistente Datentypen: CHAR erwartet, NUMBER erhalten. 4.2.5 (29.05.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.5_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Framework Studio Performance verbessert Die Performance der Framework Studio IDE wurde erheblich verbessert. Besonders zu spüren ist das beim Öffnen großer Elemente in Customizing Packages. Auch die Laufzeit des Compile-Wizard hat sich signifikant verringert. Erreicht wurde diese Verbesserung dadurch, dass die IDE beim Start einmal alle relevanten Informationen aus der Repository-Datenbank einliest. Direkt nach dem Start der IDE ist ein höherer Verbrauch an Arbeitsspeicher zu beobachten. Bei längerer Arbeit relativiert sich dieser Effekt, da die IDE bisher auch schon sehr viele Informationen in den Arbeitsspeicher gelesen hat. Um eine bessere Performance zu erzielen, werden die Daten parallel über mehrere Datenbank-Verbindungen eingelesen. Das bedeutet, Framework Studio öffnet in kurzer Zeit bis zu 8 zusätzliche Verbindungen zur Repository-Datenbank. Die zusätzlichen Verbindungen werden nach spätestens 15 Sekunden wieder geschlossen. MDT- und DBColumn-Änderungen im Service Release Im Service-Release-Modus können jetzt am Metadatentyp und an der DB-Column die folgenden Eingenschaften geändert werden: Caption, Tooltip, Description DisplayMinLength, DisplayMaxLength DisplayMinLines, DisplayMaxLines Korrigierte Fehler 2020042334 - Java-Client: Die Windows-Skalierung hat keinen Einfluss auf die Skalierung des Browser Controls. 2020042358 - Java-Client: In einer Grid-Combobox kann der Leer-Eintrag nicht ausgewählt werden, wenn an dem zugrundeliegenden Metadatentypen Values oder Value-Ranges definiert sind. 2019027232 - IDE: Es kommt vor, dass nach der Suche der Ergebnis-TreeView ganz nach rechts gescrollt wird. 2020031851 - IDE: Im \"Generated Code\"-Fenster und in der Method-History führt ein Klick mit der rechten Maustaste zu einer Exception. 2020042348 - IDE: Eine Exception wird geworfen, wenn der Datenbankname beim Anmelden an einem Repository ein Leerzeichen am Ende beinhaltet. 2020052462 - IDE: Der Form-Designer zeigt keine Control-Images an, wenn man ein Theme ungleich \"Default\" auswählt. Lediglich im Theme veränderte Bilder werden angezeigt. 2020052447 - Package Manager: Wird für eine Package-Version, die sich im Service-Release-Modus befindet, der Compile-Wizard ausgeführt, dann werden die Metadatentypen und DBTables nicht compiliert. Dadurch werden z.B. Änderungen an der Caption nicht gezogen. 4.2.4 (24.04.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.4_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2020021741 - Java-Client: Werden in ein Html-Texteingabefeld mindestens 35 Zeilenumbrüche (p-Tags) eingefügt und erst danach Text, so kommt es beim nächsten Brokerrequest zu einer StackOverflowException. Die Anwendung ist dann unter Umständen nicht mehr bedienbar. 2020031863 - IDE: Beim Kopieren eines Browser-Controls kann es zu einer NullReferenceException kommen. 2020032095 - IDE: In einem abgeleiteten Workflow wird an Events einer Form-Instanz die Base-Eigenschaft angezeigt. Sie ist sogar änderbar. 2020042138 - IDE: Beim Kopieren und Einfügen eines ListView oder Template Controls in einem Package mit Package Prefix, wird den Template DataSources das Prefix im Namen mehrfach vorangestellt und weicht somit vom Namen im HTML Template ab. 2020032100 - Code-Generierung: Bei der Prüfung auf doppelte Controls werden bei Forms im neuen Layout weiterhin Controls aus dem Deprecated Layout berücksichtigt und führen unter Umständen zu einer nicht behebbaren Warning. 4.2.3 (27.03.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.3_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Labeln und Branchen im Package Manager Im Package Manager gibt es generell zwei Möglichkeiten, eine neue Package-Version zu eröffnen: Label (): Erzeugt eine neue Version auf gleicher Ebene und versiegelt dabei die Ursprungsversion. Ausgecheckte Elemente werden dabei in die neue Version übertragen. Branch (): Erzeugt eine neue Unterversion (eine Ebene tiefer) und verändert den Zustand der Ursprungsversion dabei nicht. Ausgecheckte Elemente verbleiben in der Ursprungsversion. Folgendes hat sich geändert: Beide Funktionen stehen nun immer zur Verfügung, wenn man Besitzer (Owner) des Packages ist. Auch beim Branchen wird nun geprüft, ob alle in der Ursprungsversion eingecheckten Elemente vom FrameworkCompiler kompiliert wurden. Ausgecheckte Elemente werden beim Branchen generell nicht in die neue Version übernommen. HTML Client Der ImageButton unterstützt nun das BadgeImage. Korrigierte Fehler 2020021640 - IDE: Öffnet man einen bestehenden Exception Editor / Message Box Wizard und öffnet die MLKey-Auswahl, dann ist der erste MLKey ist ausgewählt. Es sollte der aktuelle MLKey selektiert sein. 2020021722 - IDE: Der \"Multilanguage Text Migration\" Wizard weist in Custom Packages mit nur deutschen Texten bestehende passende MLKeys mit Fremdsprachentexten aus Basispackages nicht zu. 2020031861 - IDE: Wird im Message-Editor ein MLKey ausgewählt, der keinen englischen Text besitzt, dann wird im generierten Code kein Text angezeigt. Es sollte in diesem Fall ein Fallback auf den deutschen Text erfolgen. 2020031842 - HTML Client: ListView und Template Controls \"verschucken\" den Focus, wenn sie mittels Tastatur fokussiert werden. 2020031866 - HTML Client: In seltenen Fällen wird im OnLeave-Event in den FrameworkOnLeaveEventArgs der Activator nicht oder falsch befüllt. 2020031889 - HTML Client: Die Selektoren für ListViewItems sind nicht sichtbar, wenn die SelectorPosition am ListView auf \"MiddleLeft\" oder \"MiddleRight\" gesetzt ist. 4.2.2 (28.02.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2020021533 - Broker: Wird ein im Treeview dargestelltes Element aus seiner Collection am Parent entfernt und anschließend eine Eigenschaft geändert, die zuvor zu einer geänderten Darstellung im Treeview geführt hätte (z.B. sDisplayName), so kann es zu einer Fehlermeldung kommen. System.ArgumentOutOfRangeException: index must reference an CollectionEntry. 2020011293 - IDE: Wird im Customizing-Package in einem Workflow ein Fired-Event verknüpft, welches aus dem Basis-Package kommt, dann wird bei der Verwendung dieses Events in einem anderen Workflow das dahinter liegenede Form nicht erkannt. Das verursacht Warnings beim Compile und bei Methoden-Aufrufe im Workflow-Link können keine Werte aus dem Quell-Form als Parameter übergeben werden. 2020021461 - IDE: Ein Verweis auf eine ältere Newtonsoft.Json.dll führt zu einer Exception beim Testen der Runtime Supervisor Url. 2020021519 - IDE: Öffnet man aus einem Customizing-Package heraus die Component aus dem Basis-Package, dann kann es vorkommen, dass in der Combobox DB-Connection ein falscher Wert angezeigt wird. Diese falsche Anzeige hat aber keine Auswirkung auf die tatsächlich verwendete Connection. 2020021539 - IDE: Beim Customizen von Methoden über das Contextmenü im Codeeditor wird eine falsche Deklaration angelegt. 2020021606 - HTML-Client: Ein SetFocus() and einem Control im Form.load() Event wird am Client nicht korrekt verarbeitet. Der Fokus wird nicht in das Control gesetzt. 2020021513 - Package-Merge: Unter Oracle kann es beim Package-Merge zu folgender Exception kommen: FrameworkSystems.FrameworkExceptions.FrameworkDbException (0x80004005): ORA-01461: Ein LONG-Wert kann nur zur Einfügung in eine LONG-Spalte gebunden werden ---> Oracle.ManagedDataAccess.Client.OracleException (0x80004005) 4.2.1 (31.01.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Connection-Pooling überarbeitet Aufgrund verschiedener Probleme wurde das Connection-Pooling der FrameworkDataConnection komplett überarbeitet. Dabei gab es auch Verhaltens-Änderungen. Bisher hat der Pool immer alle existierenden Connections gezählt - sowohl den Vorrat an verfügbaren als auch die momentan verwendeten Connections. Jetzt steuern die FSPooling-Parameter nur noch den Vorrat. Das hat (im Vergleich zu früher) den Vorteil, dass das Pooling auch dann noch wirksam ist, wenn dauerhaft eine größere Anzahl an Connections in Verwendung ist. Der Connection-Pool stellt im Broker eine Menge von wiederverwendbaren Datenbank-Verbindungen zur Verfügung. Dabei kann über die FSPooling-Parameter das Verhalten des Pools gesteuert werden. Die Parameter haben die folgende Bedeutung: FSPoolingMin: Wird eine Connection nicht mehr benötigt, wird sie (z.B. am Ende eines Broker-Requests) wieder zurück in den Vorrat / Pool gepackt. Der Pool darf dauerhaft diese Anzahl an Connections beinhalten. FSPoolingMax: Das ist die maximale Anzahl der Connections, die sich im Pool befinden dürfen. Ist der Pool voll, dann wird die Connection nicht in den Pool zurückgepackt sondern sie wird direkt geschlossen. FSPoolingTimeout: (in Sekunden) Die Connections zwischen Min und Max verbleiben maximal diese Zeit im Pool. Werden sie nicht vorher wieder verwendet, werden sie nach dem Timeout aus dem Pool entfernt und geschlossen. Neuerungen Such-Funktionalität für die ML-Columns Korrigierte Fehler 2020011151 - Oracle: Wird in einer DB-Column eine Spalte mit dem Typ Boolean angelegt, dann bringt der Datenbank-Update-Assistent einen Fehler, wenn die entsprechende Spalte auf der Datenbank bereits korrekt angelegt ist. 2020011286 - Package-Manager: An der Package-Version werden im Register Language nicht alle Sprachen aus den Basis-Packages angezeigt, wenn man an der Using-Hierarchie Änderungen vornimmt. 2020011298 - Package-Manager: Bei Package-Hierarchien mit Context-Versionen werden die Sprachen aus dem Basis-Package nicht korrekt übernommen. 2020011377 - Package-Manager: Beim Import einer Package-Version kann es zu folgendem Fehler kommen: \"There is an open DataReader associated with this Connection which must be closed first.\" 2019120999 - IDE: Wird an einer Tabellen-Spalte, die in einer customizten DBTable hinzugefügt wurde, aus Versehen die CheckBox \"Not Null\" gesetzt, dann lässt sich diese nicht mehr entfernen. 2019121032 - IDE: Wenn Framework Studio abstürzt, dann läuft der Development-Broker im Hintergrund weiter. Dieser blockiert Dateien im Compile-Verzeichnis und muss manuell beendet werden. 2020011086 - IDE: Wird bei einer Sql-Server Repository-Connection ein Server-Name mit einem Port angegeben (z.B. 127.0.0.1,1433), dann wird beim Beenden der IDE eine Exception angezeigt. 2020011136 - IDE: Wird in der ListView-Ansicht des Workflows nach einem Namen gefiltert und anschließend in der angezeigten Liste mit Doppelklick ein Workflow selektiert, dann wird eine InvalidCastException angezeigt. 2020011258 - IDE: FS stürzt mit einer GDI+ Exception ab, wenn animierte Gifs für die Dokumentation ausgewählt werden. 2020011334 - IDE: Nach dem Import eines Service-Releases wird ein darin neu angelegter MLKey im Multilanguage Text Editor zwar angezeigt, jedoch kommt es beim Kompilieren zu einer Exception, weil der MLKey nicht generiert wird. 2019121005 - Framework: Am Typ FSSystemGuid fehlt die statische Methode FromString(string). 2020011254 - FS-Broker: Wird bei einem Metadatentypen ein Format-Pattern mit einem \"&\" Zeichen angegeben, dann verursacht das XML-Exceptions wenn man ein Form öffnet, das ein Control mit diesem Metadatentypen enthält. 4.2 (20.12.2019) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.0_Setup_x64 FS_4.2.0_Requirements_x64 (Requirements-Paket) FS_4.2.0_RuntimeAdministration Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Die Neuerungen finden Sie unter Neuheiten 4.2 Beta-Version Hinweise Die Installation-Routine der Release-Version führt für eine bereits installierte Beta-Version ein Update auf die Release-Version aus. Important Bitte beachten Sie alle Anweisungen und Hinweise in diesem Abschnitt, wenn sie bereits eine Beta-Version von Framework Studio 4.2 verwendet haben. Die Package-Exporte und Service-Release-Exporte der aktuellen Framework Studio 4.2 Version sind inkompatibel mit den vorangegangenen Framework Studio 4.2 Beta Versionen. Dies gilt in beide Richtungen. Führen Sie in jedem Fall einen Update auf die Release-Version durch, bevor sie neue Packages im Repository importieren. Verwenden sie keine Beta-Packages mehr. Im Laufe der Beta-Versionen gab es Änderungen am Repository. Bitte führen Sie auf allen mit der Beta-Version neu erstellten und upgedateten Repositories den Update erneut aus: Im Programm-Verzeichnis die FrameworkStudioUpgradeDatabase.exe starten und am Repository anmelden. Falls noch offene Scripte angeboten werden, diese bitte ausführen. Zeilenversionierung im SQL-Server Beim Anlegen neuer Runtime Repositories im SQL-Server hat Framework Studio versäumt, die Zeilenversionierung zu aktivieren. Dadurch kann es insbesondere bei längeren Transaktionen zu unnötigen Blockierungen von Select-Statements kommen. Dieser Fehler ist nun durch die Korrektur von Bug 2019110775 behoben. Warning Bestehende SQL-Server Runtime Repositories müssen manuell korrigiert werden! Details dazu finden Sie hier: Zeilenversionierung im SQL-Server. Korrigierte Fehler In der Version 4.2 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.0.18 enthalten. Zusätzlich wurden die folgenden Bugs behoben. 2019027233 - Code-Generierung: Im generierten Code von ReportDocumentTypes wird der Package-Name verwendet statt dem Assembly-Prefix. 2019089003 - Doku-System: Ausgeblendete Controls (hidden/Collapsed) werden im Doku-Screenshot nicht gerendert. 2019100072 - Framework: Die MLColumn-Einträge werden nicht mit dem Record gelöscht, wenn nicht zuvor auf die fremdsprachigen Texte zugegriffen wurde. 2019099502 - Repository: Alle Sublabeled Tabellen sollen aus Performance-Gründen mit einem Index auf die PackageID-Spalte versehen werden."
  },
  "articles/release-4-3.html": {
    "href": "articles/release-4-3.html",
    "title": "Release-Information Framework Studio 4.3",
    "keywords": "Release-Information Framework Studio 4.3 4.3.17 (24.06.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.17_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022060088 - Broker: Wird auf einem Grid, das eine GroupBy-Query anzeigt, über den Client ein Filter eingestellt, dann wird ein SQL-Error angezeigt. Der Fehler tritt auf, wenn aufgrund sehr vieler Datensätze der Reload-Mechanismus greift und der Filter deshalb über die Datenbank angewendet wird. 4.3.16 (27.05.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.16_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022059888 - JavaClient: Wird eine Grid-Zelle mit Enter verlassen, dann kann es passieren, dass eine im OnColumnChanged-Event aufgerufene SetCell-Action ignoriert wird. Der Fokus landet dann nicht in der gewünschten Grid-Zelle. Auftreten kann der Fehler, wenn z.B. im OnColumnChanged ein modaler Dialog geöffnet wird. 2022059912 - Java-Client: Sind in einem Menü mehrere Separatoren enthalten, dann kann es beim Öffnen des Forms im Java-Client zu einer StackOverflowException kommen. Der Fehler tritt auf, wenn viele Menu-Items ausgeblendet werden. In der Folge wird das Form nicht angezeigt oder die Anwendung startet nicht korrekt. 2022049758 - IDE: Hat der CSharp-Compiler ein Problem, das den Compile komplett verhindert (weil z.B. das Programm-Verzeichnis beschädigt ist), dann meldet Framework Studio keinen entsprechenden Fehler. Bei der Arbeit als normaler Benutzer werden keine DLLs erzeugt, wodurch der Start des Brokers nicht möglich ist. Beim Ausführen eines FrameworkCompiler treten Fehler auf, weil DLLs nach dem Compile nicht gefunden werden. 2022059769 - IDE: Beim Einfügen eines Links in einen customizten Workflow erscheint in seltenen Fällen eine Fehlermeldung. System.ArgumentException: An item with the same key has already been added. 2022059936 - IDE: Wird bei einer Code-Transformation der Parameter der Methode angepasst, wird in der Folge fehlerhafter Code generiert. Dieser führt zu einem Compile-Error. Note Der Fehler entsteht beim Bearbeiten der Deklaration. Um den Compile-Fehler zu beheben muss die Deklaration erneut bearbeitet werden, damit sich die im Hintergrund gespeicherten Daten aktualisieren. 2022059953 - HTML Client: GetGeoLocation liefert falsche Werte. 4.3.15 (29.04.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.15_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022018960 - IDE: Im Multilanguage Text Editor findet die Suche bei mehrzeiligen Texten nur Wörter, die in der ersten Zeile stehen. Der Text ab der 2. Zeile wird nicht berücksichtigt. 2022039417 - IDE: Beim Einfügen eines Format-Tags (z.b. [b], [i], [h1] usw.) werden ggf. zu viele Tags zusammengefasst. So können versehentlich z.B. Image-Tags in die Headline rutschen, was im Anschluss zu Fehlern führt. 2022049597 - Data-Provider: Oracle - Wird in einem SQL-Command ein Identifier mit Sonderzeichen oder eine Ziffer am Anfang verwendet, dann wird das für Oracle nicht korrekt umgesetzt. Beispiel: DELETE FROM [30_TEST] 2022049553 - Framework: Die Update-Analyse greift bei Oracle ggf. verzögert auf die Data-Connection zu. Das führt bei deaktiviertem FSPooling zu einer ObjectDisposedException. Bei aktivem FSPooling wird die Connection nicht mehr freigegeben. 4.3.14 (25.03.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.14_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022029183 - Broker: Die properties MainMemorySortingThreshold, TransferStartupRowCount, TransferStartupNodeRowCount und ListSortOrder verhalten sich unterschiedlich, je nachdem ob ihr Wert aus der Basis stammt. 4.3.13 (25.02.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.13_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022029190 - Java-Client: Alle Jar-Dateien müssen neu signiert werden, weil das Java-Zertifikat widerrufen wurde. 2022029126 - IDE: Nach dem bearbeiten eines Global Events kann es passieren, dass im Workflow-Link auf dieses Global Event keine Init-Methode mehr angeboten wird. 2022029194 - IDE: Wird auf einem ControlType ein Undo Checkout ausgeführt, dann werden Form-Controls mit diesem ControlStyle und der zu verwerfenden Control-Version auf gelöscht gesetzt. Note Dieser Fehler kann eine Erklärung für Fälle sein, in denen aus heiterem Himmel Controls verschwunden sind - ohne dass jemand das Form ausgecheckt hat. Er war seit 05.2020 aktiv. 2022029147 - Doku: Informationen zum Aufräumen von tblRep_SessionLogging. 4.3.12 (28.01.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.12_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2022018908 - JavaClient: Wird per Action ein TabbedWindow (oder sein Parent) ausgeblendet, dann feuert das OnSelectedTabPageChange Event. Findet das beim Öffnen eines Forms statt, dann kann das zur Folge haben, dass das Form sich nicht im Vordergrund öffnet. 2022018909 - Java-Client: Beim Öffnen eines Forms wird in der Java-Console ggf. eine Meldung \"FrameworkSystems.FSJavaClient.DevControl.LayoutComponentDefault cannot be cast to FrameworkSystems.FSJavaClient.DevControl.DevControlTabPage\" ausgegeben. 2022018927 - Java-Client: Beim Ausführen der Action LoadGridLayout kann es bei großen Grids vorkommen, dass nicht alle Daten verarbeitet werden. 2021128765 - IDE: Beim Import einer TMX-Datei ins Wörterbuch werden ISO-Sprach-Codes in Großbuchstaben nicht erkannt. 2021128775 - IDE: Wird im Code-Editor vor einer geschweiften Klammer in einem SingleLine-Kommentar ein \".\" gesetzt, aktiviert sich die Intellisense. 2022018882 - Doku-System: Die Tabellenbeschreibungen beim HTML-Export werden unsortiert ausgegeben. 2021128815 - HTML Client: Das Picture Control wird nicht upgedated, wenn die DataSource auf \"null\" gesetzt wird. 2021128823 - HTML Client: Die Frequenz der Beep-Action ist hart auf 1000Hz festgelegt und ignoriert damit den übergebenen Wert. 4.3.11 (23.12.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.11_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021118541 - IDE: Wird ein zu langer Datenbank-Servername oder Repository-Name verwendet, dann bricht der Start der IDE mit einer Exception ab. 2021128588 - IDE: Beim Kopieren eines Component Properties wird die Eigenschaft \"Autogenerate Membervariable\" nicht kopiert. 2021128590 - IDE: Die Browser-Variante des HTML Clients funktioniert weder im Development Broker noch in einer gepublishten Umgebung. 2021128584 - Code-Generierung: Wird im Metadatentyp als Format-Pattern ein Regulärer Ausdruck verwendet, dann wird dieser im generierten Code nicht sauber escaped. In der Folge kann es zu Compile-Fehlern kommen. 2021128747 - HTML Client: Die ComboBox (ListValuesInput) reagiert nicht auf Eingaben von Buchstaben zur Auswahl des Eintrags. 2021128773 - HTML Client: Editfields mit einer DataSource vom Typ \"FSDateTime\" werfen beim Senden des Wertes zum Broker in gewissen Fällen eine Exception. 4.3.10 (26.11.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.10_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021108192 - IDE: Wird im ListView als DataSource eine TextCollection verwendet, dann ist nach dem Neustart der IDE in der Template-Variable die Zuordnung auf das Text-Property verloren. In der Folge kommt es auch zu Compile-Fehlern. 2021108258 - IDE: Verkleinert man das Framework Studio Haupt-Fenster, dann kann es passieren, dass im Namespace-Baum die untere Hälfte nicht mehr greifbar ist. Ist dann der Monitor zu klein - z.B. über Remote Desktop - dann kann man das Haupt-Fenster nicht weit genug vergrößern und der Namespace-Baum lässt sich nicht mehr bedienen. 2021118333 - IDE: Im Form-Designer werden beim Wechsel zwischen verschiedenen Form-AccessUnits die 'Parents' nicht korrekt angezeigt bzw. aktualisiert. 2021118513 - IDE: Beim Ändern eines Query-JoinTypes in der Customization kommt es zu einer Exception. 2021118297 - Framework: Werden einem ReportDocument AdditionalReports hinzugefügt, dann liefert die Methode GetReportEnums() Ergebinsse mit mehrdeutigen Report-Namen zurück. Bis zur Version 4.2 war die Ergebnismenge eindeutig. 2021118425 - FS-Framework: Enthält ein TreeView sehr viele Ebenen, dann dauert der Dispose beim Schließen des Forms sehr lange. Die Laufzeit wächst dabei exponentiell mit der Anzahl der Ebenen. 2021118300 - HTML Client: OnAfterRequest() wird am Broker nur für das derzeit aktive Form des Clients aufgerufen. 4.3.9 (29.10.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.9_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021087483 - Java Client: Werden in einem Request die MultiSelect-Eigenschaft eines Grids und zusätzlich Rows selektiert, greift die Selektierung nicht. Auch bereits selektiere Zeilen gehen verloren. 2021108162 - Java Client: Die Actions LoadGridLayout() und SaveGridLayout() arbeiten intern mit dem Titel der Spalte. Dadurch werden beim LoadGridLayout() Spalten ggf. nicht korrekt erkannt, wenn der Titel sich ändert oder mehrere Spalten denselben Titel haben. Note Die Actions arbeiten jetzt mit dem internen Namen der Spalte. LoadGridLayout() erkennt aber weiterhin die Informationen, die mit dem Titel gespeichert wurden. 2021108103 - IDE: Werden bei der Suche nach CheckOut Treffer gefunden, deren Namespace nicht mehr existiert, dann gibt es eine Exception und das Ergebnis wird nicht angezeigt. Das kann vorkommen, wenn der Namespace von einem anderen Benutzer gelöscht wird, während man selbst darin neue Elemente angelegt hat. Note Diese Treffer werden jetzt direkt unterhalb vom Package angezeigt. 2021108136 - IDE: Wenn im Form-Designer die Font eines Elementes über dem Property-Grid angepasst werden soll, kann es in seltenen Fällen vorkommen, dass Fonts ohne Namen in der Liste zur Auswahl stehen. Wenn eine Font ohne Namen ausgewählt wird, führt dies zu einem Absturz der IDE. 2021108146 - IDE: Wenn nach dem Anlegen einer neuen .WTS-Ressource in den eNVenta Update Script Editor gegangen wird und dort direkt auf \"New Table\" geklickt wird, führt dies zu einem Absturz von FS. 2021108205 - IDE: Wenn beim Erstellen einer neuen Column in einer Datenbanktabelle ein Metadatentype ausgewählt wird, wird der Name des neuen Columns richtigerweise umbenannt. Allerdings verliert der Name dabei den Package prefix (z. B. CCC_). 2021097867 - Framework: Wird in einem abgeleiteten oder customizten Form einem Grid als DataSource eine neue Collection zugewiesen, dann kann auf diesem Grid keine Sortierung ausgeführt werden. 4.3.8 (24.09.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.8_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021097624 - IDE: Ruft man in einer customized Form die Control Events auf einem Custom Control auf, werden dort die Event-Methoden-Zuweisungen aus der Basis nicht angezeigt. 2021097638 - IDE: Bei einem Undo Checkout auf einem ReportDocumentType wird die vorherige Version des Reports nicht auf die Festplatte geschrieben. Bei einem darauffolgenden Edit wird die bereits bearbeitete Version angezeigt, nicht die zurückgesetzte. 2021097738 - IDE: Wenn direkt nach dem Start der IDE der Fokus im leeren Property Grid steht und die Taste F1 gedrückt wird, dann beendet sich die IDE mit einer UnhandledException. 4.3.7 (27.08.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.7_Setup_x64 FS4.2.20_AuthService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer Authentication-Service Es gibt einen neuen Authentication-Service mit der Version 4.2.20. Dieser ersetzt die bisherige Version 4.0.16. Die neue Version behebt einen Fehler in der Windows-Authentication (siehe unten). Note Der neue Authentication-Service ist kompatibel mit älteren Versionen von Applikationen (FS 4.0 und älter). Korrigierte Fehler 2021087434 - Broker: Grids und ListViews besitzen in FieldPanels kein generiertes Label, wenn die Caption aus dem DataSource-Property gezogen wird. 2021087506 - Authentication Service: Die Windows-Authentifizierung funktioniert nicht, wenn der Authentication Service als Windows Service installiert ist und mit einem Domain-User betrieben wird. 2021087467 - HTML Client: Beim Öffnen des virtuellen Keyboards in Android 8 oder älter, wird die WebView in seltenen Fällen vertikal um die Höhe der Statusbar nach oben verschoben. Die Folge ist ein grauer Streifen zwischen der WebView und dem Keyboard. 2021087519 - HTML Client: Labels werden als fokussierbar angesehen und stören die Fokusreihenfolge. 2021087523 - HTML Client: Controls ohne Größe (MaxWidth = 0 oder MaxHeight = 0) werden fälschlicherweise in der Fokusreihenfolge berücksichtigt und stören diese dadurch. 4.3.6 (29.07.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.6_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2021077133 - Reporting: Wird am ReportDocument über die Methode SetDatasource() ein Wert gesetzt, dann wird das bei einem vorherigen Druck erzeugte DataSet nicht zurückgesetzt. Das hat zur Folge, dass bei Folge-Drucken in eNVenta die Daten für den Report nicht neu aufbereitet werden. Das betrifft z.B. das Ändern der Checkbox Briefkopf im Druck-Dialog. 2021077068 - Broker: Läuft eine Application mit Authentication, dann wird die Lizenz-Prüfung teilweise nicht durchgeführt. Dadurch sehen Benutzer in der Oberfläche nicht lizensierte Elemente. Der Fehler tritt in der Methode für die Berechtigungs-Prüfung Granted() auf. Die Prüfung auf funktionaler Ebene durch LicenseGranted() ist davon nicht betroffen. 2021077185 - IDE: Nach dem Bearbeiten von Namespace-Referenzen kann es vorkommen, dass trotz Speichern der Namespace noch immer als geändert angezeigt wird. FS muss neu gestartet werden . 2021077150 - Framework: Mit Framework Studio 4.2.17 und 4.3.5 wurden an den FS-Typen das Interface IFormattable implementiert (Bug 2021066957). Diese Erweiterung hat negative Auswirkungen auf bestehenden Code - z.B. wenn SQL-Statements mit String.Format() oder String-Interpolation erzeugt werden. Bisher wurden null-Werte über Methode ToString() mit dem String \"null\" abgebildet, die Format-Methoden liefern aber einen leeren String zurück. Note Die IFormattable-Implementierung wurde bis auf Weiteres wieder komplett entfernt. 2021077114 - HTML Client: Wird ein Control mit \"Tab\" verlassen, so kann es ein, dass der Fokus-Indikator (Outline oder gelbe Hintergundfarbe) immer noch sichtbar ist. 2021077151 - HTML Client: Ein TabbedWindow kann per \"Tab\" nicht fokussiert werden. Befindet sich der Fokus im letzten Control der aktiven TabPage, so springt der Fokus nicht mehr heraus zum nächsten Control. 2021077221 - HTML Client: Die Kamera funktioniert nicht auf Android 11 oder höher 2021077223 - HTML Client: Bei der Ausführung der TakePhoto-Action am Client wird nicht nur das Bild zurück an den Broker geschickt, sondern auch lokal eine Kopie in der Gallery gespeichert. 2021077228 - HTML Client: Der Fullscreen-Modus funktioniert auf Android 11 nicht. Note Auf Grund eines zwar bestätigten aber bisher nicht korrigierten Bugs in Android 11 kann der HTML Client auf dieser Version deshalb nur im normalen Modus betrieben werden. 2021077229 - HTML Client: Beim Pausieren der App auf Android wird ggf. die aktive Session nicht korrekt gespeichert. Dadurch kann nach einem Neustart der App ggf. die Session nicht fortgeführt werden. 4.3.5 (25.06.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.5_Setup_x64 FS_4.2.18_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neue Crystal Reports Runtime Es wird die Crystal Reports Runtime mit Version 13.0.26 und höher unterstützt. Voraussetzung ist der neue Print-Service 4.2.18. Das Requirements-Paket beinhaltet vorerst weiterhin die Version 13.0.18 Note Bitte beachten sie unbedingt die Hinweise in den aktualisierten Systemvoraussetzungen! Korrigierte Fehler 2021066859 - Print-Service: Treten beim Verarbeiten von Druckaufträgen wiederholt Fehler auf, dann führt der Print-Service einen Restart durch. Wird der Print-Service aber als Console ausgeführt, dann funktioniert dieser Restart nicht. In der Folge läuft der Print-Service weiter und produziert weiter Fehler. 2021066919 - Print-Service: Wenn im Print-Service sehr viele Drucker definiert sind, dann kann das den Start des Dienstes so stark verzögern, dass der Start in einen Timeout läuft. Im PrintServiceConfigEditor wird ein Timeout von 30 Sekunden verwendet. Note Die Analyse der Drucker wird jetzt nach dem Start des Dienstes ausgeführt. Anstehende Druckjobs werden erst im Anschluss verarbeitet. Es kann also sein, dass die ersten Druckjobs erst mehrere Sekunden nach erfolgreichem Start des Dienstes verarbeitet werden. 2021066928 - Print-Service: Läuft der Print-Service in einen Fehler - z.B. bei der Verarbeitung eines Crystal Report Documents - dann erfolgt ein automatischer Restart des Services. Dabei wird die letzte Transaktion auf \"fehlerhaft\" gesetzt. In der Folge wird der Druck-Job nicht verarbeitet, auch wenn nach dem Neustart eine Verarbeitung möglich wäre. Note Tritt so ein Fehler auf, dann wiederholt der Print-Service jetzt nach dem Restart einmalig den Druck-Job. 2021066966 - Print-Service: Wird der Print-Service als Console ausgeführt, dann blockiert eine Markierung von Text die Console und damit den kompletten Print-Service. Note Bei einer Blockade läuft der Print-Service jetzt im Hintergrund weiter. Während der Blockade werden alle Ausgaben gepuffert und nach der Freigabe ausgegeben. Die Blockade der Console-Ausgabe während der Markierung ist eine Windows-Funktion und kann durch den Print-Service nicht unterbunden werden. 2020093875 - IDE: Eine DLL-Referenz in einem Form-Namespace, welche in Sub Namespaces verwendet werden kann, führt zu einem Compile-Fehler im Child bzw. Sub-Namespace. 2021056504 - IDE: Werden an einer GridColumn die Events bearbeitet, werden die Änderungen nicht autom. gespeichert und auch der Speicherbutton wird nicht aktiviert. 2021066783 - IDE: Mit einem Oracle-Repository kommt es beim Aufruf der Method History zu einem Fehler: ORA-00932: Inkonsistente Datentypen: CLOB erwartet, CHAR erhalten. 2021066884 - IDE: Im Paste-Dialog in der Registerkarte \"Summary\" wird bei einem Replace \"No conflicts found!\" angezeigt. Hierdurch ist auf den ersten Blick nicht ersichtlich, dass eine Methode mit gleicher Signatur überschrieben wird. 2021066945 - IDE: Beim Checkin eines Records werden auch von dem Record verwendete, neu angelegte Records erkannt und diese automatisch mit eingecheckt. Handelt es sich bei dem verwendeten Record aber um eine Customization, dann ist dessen Checkin nicht zwingend nötig, weil er ja schon im Basis-Package eingecheckt wurde. 2021066893 - HTML Client: Das sofortige Blockieren der UI bei einem Event wurde entschärft. Das Sperren erfolgt erst nach 500ms. 4.3.4 (30.04.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.4_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Bei den Access Units wurde die Ansicht der verbundenen AccessUnits verbessert. Es werden nun neben den Parents auch die AccessUnit-Children angezeigt. Zudem können die AccessUnit-Parents bearbeitet werden. Korrigierte Fehler 2021036188 - Oracle: Werden in einem Grid Spalten mit Langtext gefiltert oder sortiert, dann kommt zu einer Sql-Exception, wenn die Texte auf der Datenbank eine Länge von 2000 bzw. 4000 Zeichen überschreiten. Die SQL-Methode LOB_COMPARABLE( ) beinhaltet keine Längenbegrenzung. ORA-22835: Buffer too small for CLOB to CHAR or BLOB to RAW conversion. 2021036077 - IDE: Ist in einem Workflow-Link ein Target FormContainer zugewiesen, dann kann es sein, dass dieser in einem abgeleiteten Workflow nicht mehr zieht. 2021036122 - IDE: Beim Öffnen des Method History Browser für kopierte oder neu erstellte Methoden, bei denen die Deklaration vor dem Speichern nicht bearbeitet wurde, kann es zu einer Fehlermeldung kommen. 2021046301 - IDE: Im Runtime License Manager kann es im AccessUnitTree durch Drücken der Leertaste zu einer Unhandled Exception und in der Folge zum Absturz der IDE kommen. 2021046405 - IDE: Beim Anlegen oder Löschen von Template DataSources im ListView- oder Template Control Designer kommt keine Rückfrage zum Auschecken des Forms. 2021046240 - Framework: Gibt es in einem Grid mehrere Spalten, die dasselbe Property anzeigen, dann führt das beim Sortieren und Filtern im Client zu einer Exception. 2021046385 - HTML Client: Bei sehr schnellen Eingaben per Maus oder Touch können versehentlich mehrere Requests aneinandergereiht werden. 2021046388 - HTML Client: Im ListView und Template Control werden NULL-Werte als \"null\" (String) angezeigt, anstatt nichts anzuzeigen. 2021046253 - SqlServer: Wird am Ende einer sehr großen Transaktion ein Rollback ausgeführt, dann kann das zu einem Timeout und einem Abbruch der Sql-Connection führen. In der Folge kann es wegen der geschlossenen Sql-Connection im laufenden Broker-Request zu weiteren Sql-Fehlern kommen. 4.3.3 (26.03.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.3_Setup_x64 FS_4.3.3_Requirements_x64 (neuer FSClient Launcher) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen im FS Client-Launcher werden die Protokolle automatisch in Dateien gespeichert. Im FS Client-Launcher kann über eine Umgebungs-Variable eine abweichende Java Runtime definiert werden. Korrigierte Fehler 2021025789 - Java-Client: In den Fenstern des Haupt-Arbeitsbereiches ist es nicht mehr möglich, mit den Pfeil-Tasten durch die Menüs zu navigieren. Das erschwert die Bedienung an Blindenarbeitsplätzen. 2021035831 - Publish: Beim Auto-Publish mit FSConsole wird bei Datenbankverbindungen mit Windows Authentication fälschlicherweise trotzdem ein Username und ein Passwort erwartet. 2021025761 - IDE: Wird beim Export des Wörterbuches die Auswahl der Sprachen eingeschränkt, dann werden trotzdem alle Sprachen exportiert. 2021035810 - IDE: Der Befehl \"New Workflow for Form\" legt einen neuen Workflow an, auch wenn dieser bereits existiert. Note Der Befehl wurde in \"Open or create Workflow for Form\" umbenannt und öffnet einen bereits existierenden Workflow. Sollten mehrere Workflows für eine Form existieren, wird die Dependency-Suche ausgeführt. 2021025793 - Framework: Das ListView-Control löscht bei einem Aufruf von Load() oder Clear() an der gebundenen Collection nicht die bisher angezeigten ListViewItems. 2021036115 - Framework: Arbeitet eine Component mit einer importierten Business-Datenbank, dann kann es beim Aufruf der Methode GenerateLoadCondition() zu einer SQL-Exception kommen, wenn die Datenbank-Tabelle \"dbRun_Config\" nicht existiert. 2021035904 - FS-Framework: In einer Component kann es in sehr seltenen Fällen bei einem Aufruf von PropertyChanged zu einer NullException kommen. Der Fehler tritt nur im Multi-Threading auf (z.B. im eNVenta Job-Server). 2021035808 - FS-Services: Nach dem Publish eines Services startet dieser nicht. Es wird eine Fehlermeldung System.ArgumentNullException ausgegeben. 2021035983 - Package Merge: Beim Analysieren der betroffenen Records kann im Bereich Workflow eine NullReferenceException auftreten. 4.3.2 (26.02.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Änderung der Logik beim Schließen des letzten Forms im HTML Client Auf Grund von Bug 2021015392 wurde die Logik, die beim Schließen des letzten Forms im HTML Client greift, überarbeitet. Es gibt nun 2 Szenarien, die es zu beachten gilt. Eine detailierte Beschreibung gibt es hier HTML Client Actions Der HTML Client unterstutzt nun die Actions SetTitle und SetCaption. Mehr Informationen zu den unterstützten Action finden Sie hier Korrigierte Fehler 2021025560 - Java-Client: In einem TreeView wird durch den Benutzer ein TreeNode selektiert. Das löst ein OnAfterSelect-Event aus. Dann wird durch eine Aktion am Broker (z.B. durch setzen des TreeView-Datasources) ein anderer TreeNode selektiert. Klickt der Benutzer jetzt erneut auf den zuerst selektierten Eintrag, dann wird kein OnAfterSelect-Event ausgelöst. 2021025568 - Java-Client: Bei der Arbeit mit der Accessibility-Schnitstelle kann es beim Schließen von Forms zu Exceptions kommen: java.lang.ClassCastException: FrameworkSystems.FSJavaClient.DevControl.DevControlFieldRow cannot be cast to javax.accessibility.Accessible 2021015413 - Framework: Wird einem Property, welches an ein Grid-Control gebunden ist eine neue Instanz zugewiesen, dann werden die am Grid eingestellten Filter und Sortierungen zurückgesetzt. 2021025449 - Framework: die Eigenschaft \"ComponentProperties\" hat eine schlechte Performance. 2021025498 - Framework: Bei Template- und ListView-Controls werden die Namen der Template-Variablen nicht korrekt im Response verschlüsselt. In der Folge kommt es zu Fehlermeldungen im Mobile-Client: Could not find TemplateDataSource 2021025514 - FS-IDE: Wird in einem Namespace, der im Basis-Package keine Component beinhaltet (z.B. eNVenta NV.ERP.MM), im Customizing-Package eine neue Component angelegt, dann kommt es beim Compile zu einer FileNotFoundException. 2021015392 - HTML Client: Wird das letzte Form vom Broker aus per Action geschlossen, so muss am Client die Session ohne Rückfrage geschlossen werden, wenn keine weiteren Forms offen sind. 4.3.1 (29.01.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Die Vorwärts- und Rückwärtsnavigation zwischen Einträgen ist nun auch mit den beiden zusätzlichen Navigationstasten an der Seite der Maus möglich. Korrigierte Fehler 2020125151 - Oracle: An einigen Stellen wird für das Ermitteln von Datenstrukturen der Datenbank auf die ALL_-Views zugegriffen. Besser ist es, die USER_-Views zu verwenden, weil dadurch Fehler vermieden werden können. 2016042153 - IDE: Am DBIndex gibt es eine Eigenschaft \"Active\". Diese wird über eine wenig intuitive Combobox gesteuert, welche keine Beschriftung hat und allermeist nur \"Inherit\" anzeigt. 2020114533 - IDE: Ein leerer customized Namespace kann nicht gelöscht werden. 2020124914 - IDE: Ruft man in der Set-Method eines Component-Properties den Exception-Wizard auf, dann kann es im Anschluss zu NullReferenceExceptions kommen. In diesem Fall ist ein Restart von Framework Studio nötig um die Situation zu bereinigen. 2020125090 - IDE: Wird eine AccessUnit und deren AccessUnit Parent angelegt und nur ersteres wird eingecheckt, erfolgt keine Dependency Prüfung auf den AccessUnit Parent. 2021015220 - IDE: Werden in einem Customizing-Package Themes definiert, dann werden diese nicht mehr erkannt, sobald für dieses Customizing-Package eine Context-Version gebildet wird. 2020125181 - Code-Generierung: Wird an einem abgeleiteten Grid der DataSource überschrieben, dann führt das zu einem Compile-Fehler. 2020125172 - Framework: Das Listen-DataBiding einer Combobox überträgt zu oft Daten an den Client, wenn der Verwendete Display- oder Value-Member ein Individual Property ist. In der Folge kann es im JavaClient bei der Eingabe von Werten in die Combobox zu Fehlverhalten kommen. 2020125182 - Framework: Wird an einem abgeleiteten Grid der DataSource überschrieben, dann zeigt das Grid in der Anwendung nur leere Zeilen an. 2020125183 - Framework: Wird an einer Component ohne Datenbank-Bezug die Methode RollbackChanges() aufgerufen, dann wird kein PropertyChanged-Event gefeuert. In der Folge wird im in einem Form das Databinding nicht aktualisiert. 4.3 (18.12.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.0_Setup_x64 FS_4.3.0_Requirements_x64 (Requirements-Paket) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Die Neuerungen finden Sie unter Neuheiten 4.3 Bekannte Probleme Warning In der aktuellen Version sind die folgenden Probleme vorhanden. Diese werden mit dem nächsten Service-Release behoben. 2020124914 - IDE: Ruft man in der Set-Method eines Component-Properties den Exception-Wizard auf, dann kann es im Anschluss zu NullReferenceExceptions kommen. In diesem Fall ist ein Restart von Framework Studio nötig um die Situation zu bereinigen. Workaround: Zuerst mit der Maus in die Get-Method des Properties klicken. Dadurch wird eine Initialisierung ausgeführt, die die Exception verhindert. Korrigierte Fehler In der Version 4.3 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.2.13 enthalten. Zusätzlich wurden die folgenden Bugs behoben: 2020052729 - Java-Client: Im Dialog für die Eingabe der Spalten-Filter sollte der Fokus direkt in das Eingabe-Feld gesetzt werden. Nach Eingabe eines Wertes soll der Filter direkt angewendet werden. 2017089506 - IDE: Wenn man in einem Code-Editor die Suche eingeschränkt auf den selektierten Bereich ausführt, wird immer Case-sensitiv gesucht, auch wenn die Checkbox nicht gesetzt ist. Find and Replace ist ebenfalls betroffen. 2020042323 - IDE: Beim Erstellen einer individual Datenbank-Connection wird ein neuer (leerer) Eintrag erstellt. Es sollte der vorhandene Eintrag kopiert und als Individual (editable) angelegt werden. 2020073102 - IDE: Wird in einer DBTable die letzte Column gelöscht, dann wird eine NullReferenceException angezeigt. 2020104512 - IDE: bei der Anlage eines neuen Crystal Report mit einer neuen Report-Datei gibt es eine Exception: System.System.ArgumentNullException: Der Wert darf nicht NULL sein 2020104214 - Code-Generierung: Public ComponentProperties vom Typ Membervariable werden z.T. in das Interface der Component generiert. Databinding im Form ist damit dann trotzdem nicht möglich. Note In vergangenen Versionen wurden diese Properties bereits als Obsolete gekennzeichnet. Mit der aktuellen Version wurden sie komplett entfernt. Damit gilt jetzt die ganz klare Regel: Component-Properties mit dem Typ Membervariable stehen nicht in den Interfaces zur Verfügung. 2020124918 - Code-Generierung: Wird ein Global Object auf ein cGlobal-Property umgelenkt, welches mit einem Obsolete-Attribut versehen ist, dann gilt das Global Object selber nicht als Obsolete. Dadurch treten 1.) Obsolete-Warnings beim Compile der Global Objects auf, und 2.) erzeugen Verwendungen dieses Global Objects keine Warning."
  },
  "articles/release-4-4.html": {
    "href": "articles/release-4-4.html",
    "title": "Release-Information Framework Studio 4.4",
    "keywords": "Release-Information Framework Studio 4.4 4.4.21 (X.Y.Z) Neuerungen Vor einem Compile werden nun alle ungespeicherten Elemente automatisch gespeichert. 4.4.20 (01.09.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.20_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer HTML Client Der HTML Client wurde auf Angular 16.2 upgedated. Das Scrolling bei vielen offenen Forms wurde im Browser und auf Tablets verbessert. Korrigierte Fehler 2023083693 - IDE: Wird ein Individual-Property mit gesetzter Checkbox Autogenerate Membervariable in ein Generated-Property geändert, bleibt die Checkbox im Hintergrund gesetzt. In der Folge kommt es zu Fehlern bei der Code-Generierung, weil fälschlicherweise immer noch Code für die Membervariable generiert wird. 2023083651 - Data Provider: Werden in SQL-Bedingungen mithilfe von DB.SqlString() Parameter ergänzt, dann wird für die Größe der Parameter standardmäßig die tatsächliche Länge der Werte verwendet. Dadurch entstehen sehr viele unterschiedliche Statements, die vom SQL-Server nicht wiedererkannt werden. Das beeinträchtigt die Permormance der Datenbank. Note Wenn die Werte das erlauben, werden jetzt großzügige Standardgrößen verwendet. Dadurch erhöht sich in der Praxis die Wiedererkennungsrate signifikant. 4.4.19 (28.07.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.19_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023073469 - Publish2Go: Das Änderungsdatum von Ressourcen-Dateien wird falsch gesetzt. Die Zeitzone wird nicht korrekt berücksichtigt. 2023063291 - IDE: Im Form-Designer wird in der Control-Eigenschaft \"SearchOperator\" der Wert \"LikeNonCaseSensitive\" nicht angeboten. 2023073422 - IDE: Fehlerhafte Daten im Repository können dafür sorgen, dass der Workflow-Branch seine Bedingung in eine falsche Version schreibt. 2023063205 - Code-Generierung: Component-Methoden mit optionalen Parametern können bei der Generierung des Interface-Codes Exceptions verursachen. Ein Compile ist dann nicht möglich. 2023053077 - DevExpress: Die zum letzten Patchday eingabaute \"Hülle\" um die DataSource-Objekte (Bug 2023052942) verursacht Probleme beim Einsatz von Scripting. Durch diese Hülle haben die Objekte nicht mehr den ursprünglichen Typ. Darüber hinaus liefert in einem Calculated Field OnGetValue-Script die Methode GetColumnValue() keine Werte mehr. Note Die Anpassung wurde zurückgebaut und die Reporting-Schnittstelle verhält sich jetzt wieder wie zuvor. Die im Bug 2023052942 beschriebenen Probleme treten dadurch jetzt wieder auf. Mit Version 4.5.7 ist das Thema gelöst. In der Version 4.4 wird es keine Korrektur mehr geben. Der ursprünglich mit Version 4.4.18 korrigiert Bug: 2023052942 - DevExpress: Calculated Fields und Expressions mit Aggregate-Funktionen greifen nicht über unser Rptx-Interface auf die Instanzen zu sondern über die Klasse. Dadurch arbeitet der Report mit falschen Typen und es kann zu inhaltlichen Fehlern kommen. So werden z.B. Bilder nicht angezeigt, weil DevExpress mit dem FS-Typ FSbyteArray nichts anfangen kann. Ticket bei Dev-Express: https://supportcenter.devexpress.com/ticket/details/t1165586/aggregate-expression-uses-class-properties-instead-of-explicit-interface-implementation 4.4.18 (26.05.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.18_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023042824 - Broker: Eine Listbox oder Combobox verwendet als Listen-Datasource eine Collection. Werden aus dieser Collection Records entfernt, dann werden die entsprechenden Einträge nicht aus dem Controls entfernt. 2023042844 - IDE: In einem customizten Report Document Type kann für einen Basis-Report eine neue Datei importiert werden. Wählt man in der Dateiauswahl eine Datei mit abweichendem Namen aus, dann wird eine Rückfrage angezeigt, ob der Report-Name geändert werden soll. Das Ändern des Namens ist im Customizing jedoch gar nicht möglich. 2023052888 - IDE: Die Rename-Aktion für Namespaces ist aktiv, auch wenn ein Rename nicht ausgeführt werden darf. 2023052947 - IDE: Für eine Component werden bei der Dependency-Suche Component-Properties ermittelt, obwohl diese aufgrund eines Datenbank-Mapping einen ganz anderen Datentyp als die Component besitzen. Grund dafür sind ungültige Repository-Daten. Diese haben ansonsten bei der normalen Arbeit keine Auswirkung. 2023052863 - DevExpress: Bei einem neu angelgeten SQL-Server-Entwicklungs-Repository erhält die Sql-Server-Rolle FrameworkBrokerRole keinen Zugriff auf die Tabelle tblRep_ReportDesign. Dadurch kann es in der Anwendung bei Verwendung des DevExpress Report-Web-Designers zu folgendem SQL-Fehler kommen: The INSERT permission was denied on the object 'tblRep_ReportDesign' Note Neue Repositories werden in Zukunft richtig angelegt. Bestehende Repositories werden nicht automtisch korrigiert. Mit dem folgenden Script können fehlerhafte Repositories bei Bedarf manuell korrigiert werden. GRANT SELECT, UPDATE, INSERT, DELETE ON tblRep_ReportDesign TO FrameworkBrokerRole; 2023052900 - DevExpress: Werden im Report-Designer mehrere Felder auf einmal in den Report gezogen, dann erstellt der Designer automatisch eine Tabelle. Zieht man diese Felder mit der rechten Maustaste in den Report, dann sollte er dieselbe Tabelle allerdings mit Beschriftungen der jeweiligen Felder anlegen. Die Tabelle ist jedoch komplett leer. Vergleiche auch https://docs.devexpress.com/XtraReports/120025/detailed-guide-to-devexpress-reporting/use-report-controls/use-tables/bind-table-cells-to-data 2023052932 - DevExpress: (Verbesserung) Ein Foldmark-Control kann jetzt auch in einem Sub-Report platziert werden. Die Falzmarken werden dabei auf allen Seiten des Haupt-Reports platziert - unabhängig davon, an welcher Position der Sub-Report platziert ist. 4.4.17 (28.04.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.17_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023022324 - JavaClient / Broker: Wird beim Anlegen einer Dynamischen Grid-Spalte - z.B. über das Client Side Customizing - eine Combobox-Liste definiert, dann führt das zu Exceptions und das Form öffnet sich nicht mehr. 2023032535 - Code-Generierung: Es wird die FSWarn1004-Error-Message ausgegeben, nach welcher Primary-Key Spalten nicht länger als 28 Zeichen sein dürfen. Die DB-Spalte selbst ist jedoch nicht als Primary-Key gekennzeichnet. 2023032619 - DevExpress: Der Word Druck eines Reports wirft eine Exception, wenn Felder sich überschneiden. Auch im RichText Format kann es zu Darstellungsfehlern kommen. 2023042680 - DevExpress: Im Designer wird beim Copy&Paste eines bestehenden Labels der Textinhalt nicht übertragen. 4.4.16 (31.03.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.16_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023032382 - Broker: Wird eine Gridspalte mit \"LIKE\" gefiltert, werden ggf. keine Treffer gefunden, wenn sich der gesuchte Begriff in einem mehrzeiligen Text befindet. 2023032595 - Code-Generierung: Wird eine Form und der zugehörige Workflow gecustomized, so wird bei der Code-Generierung in der Customized-Form der Code für das WorkflowEvent zusätzlich generiert. In Folge dessen verdeckt das WorkflowEvent in der Customization das WorkflowEvent aus der Basis. Dies kann beispielsweise zur Folge haben, dass Forms nicht mehr geöffnet werden können. 4.4.15 (24.02.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.15_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Update des Runtime Repository nötig Auf Grund von Bug 2023022188 muss beim Publish2Go das Runtime Repository nochmals upgedated werden. Beim Publishen einer Applikation erscheint dann ggf. die Warnung \"The selected runtime repository is not prepared for this version of Publish2Go. You have to prepare the runtime repository before you can publish.\". Um diese Situation zu lösen, muss im Publish2Go Wizard unter Connection Groups die RuntimeConnection ausgewählt werden und mit dem Button Prepare Runtime Repository die fehlenden Scripte ausgeführt werden. Neuer HTML Client Der HTML Client wurde auf Angular 15.1 upgedated. Neue Features oder Bugfixes gibt es nicht. Korrigierte Fehler 2023022188 - Broker: Clientside Report Customizing (DevExpress) funktioniert nicht mit Applikationen, die mit einem Runtime-Repository arbeiten, auf einem IIS gepublished wurden, oder eine Oracle-Datenbank als Runtime-Connection nutzen. 2023012107 - IDE: Im ReportDocumentType können gelöschte DataSources oder Properties dazu führen, dass bei einer Änderung des Reports im Service Release eine Meldung \"Can't delete objects of Service Release 4.x\" angezeigt wird. 2023012036 - Doku-Export: In bestimmten Konstellationen fehlen bei einem Dokumentationsexport gecustomizte Elemente (Bsp: Checkbox auf Screenshots) und deren Dokumentation in der Gesamtdokumentation. 4.4.14 (27.01.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.14_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023012014 - Publish2Go: Publish2Go kann nicht ausgeführt werden, wenn der IIS nicht installiert ist (z.B. zur Installation von ServiceHosts). 2021118441 - IDE: Bei Workflow-Links, deren Quelle ein Global-Event-Handler ist, kann keine Instance-ID angegeben werden. Die Auswahl-Combobox zeigt keine Einträge an. 2022121811 - IDE: Die in der IDE im Form-Designer eingestellte Sortierung an Grid-Spalten funktioniert nicht. Note Die Einbau dieses Features umfasst auch eine Anpassung in der Code-Generierung. Damit die Einstellungen korrekt ziehen muss der Quellcode des Forms neu aufgebaut werden. Im Service-Release Modus reicht es, das betroffene Form einmal aus- und wieder einzuchecken. 2022121833 - IDE: In einer grafischen Transformation kann bei FSstring-Properties die Checkbox \"Ignore nulls\" nicht gesetzt werden. 2022121864 - IDE: Das Intellisense erkennt Component-Typen nicht und zeigt diese als Fehler an. 4.4.13 (23.12.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.13_Setup_x64 FSCL_4.4.13_Setup_x86 FSCL_4.4.13_Setup_x64 FS_4.4.13_Requirements_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer FS Client Launcher Es gibt einen neuen Client Launcher. Der mit Version 4.4.11 ausgelieferte FS Client Launcher enthielt eine aktuellere Java-Runtime (8 Update 282). Diese hat in einigen Fällen Fehler bei Drag&Drop Vorgängen ausgelöst, welche zu einem vollständigen einfrieren von eNVenta ERP geführt haben. Über den Task Manager musste anschließend eNVenta ERP beendet werden. Im neu ausgelieferten FS Client Launcher ist deshalb wieder die bewährte Java Runtime Version 8 Update 202 enthalten. Abkündigung des MSI-Installers für den FS Client Launcher In letzter Zeit wurden uns vermehrt Probleme bei der Installation des FS Client Launchers gemeldet. In den meisten Fällen war dies auf den Einsatz des MSI-Installers zurückzuführen. Aus diesem Grund wird der MSI-Installer zukünftig nicht mehr bereitgestellt. Zum einen führte die fehlende Kompatibilität der beiden Installer zu Fehlbedienungen. So darf der MSI-Installer nicht für ein Update verwendet werden, wenn die Installation mit dem Standard-Installer (.exe) vorgenommen wurde. Zum anderen enthält der Standard-Installer einige vorgelagerte Prüfungen und Absicherungen, die im MSI-Installer nicht enthalten sind. Der MSI-Installer ist deshalb fehleranfälliger. Note Der MSI-Installer wird nicht mehr angeboten. Verwenden Sie stattdessen den Standard-Installer (exe-Datei). Der Standard-Installer bietet die Möglichkeit über Kommandozeilen-Parameter eine \"Silent\" Installation durchzuführen. Somit kann der Standard-Installer auch in automatisierten Software-Verteilungen eingesetzt werden. Tip Der Standard-Installer kann für das Update einer MSI-Installation verwendet werden. Dadurch ist ein Wechsel sehr einfach möglich. Ist ein Wechsel nicht möglich und Sie benötigen unbedingt weiterhin den MSI-Installer, dann wenden Sie sich bitte mit einer plausiblen Begründung an den Support. Wir stellen Ihnen dann auf Anfrage den MSI-Installer zur Verfügung. Neues Requirements-Paket enthält den neuen FS Client Launcher 4.4.13 Korrigierte Fehler 2022121646 - FSClientLauncher: Ist in der Application kein Start-Image definiert, dann kann die Anwendung nicht über den Client-Launcher gestartet werden. 2022101231 - JavaClient: Wird in einem Grid eine neue Zeile hinzugefügt und soll diese fokussiert werden, dann funktioniert das Fokussieren nicht, wenn das Grid schon sehr viele Zeilen besitzt und sich die neue Zeile außerhalb des sichtbaren Bereichs befindet. 2022111611 - Reporting: Wird der DevExpress-ReportDesigner auf einem Betriebssystem mit der Sprache Deutsch ausgeführt, reagiert die Oberfläche sehr langsam. 2022121700 - Reporting: Werden in der Anwendung in HTML-Feldern Leerzeilen eingegeben, dann werden diese beim Druck in DevExpress-Reports unterdrückt. 2021046290 - Framework: Wird in einem TreeView-Control nach dem Einfügen von neuen Unterknoten der Datasource des TreeViewss auf diesen Knoten gesetzt, dann kann es passieren, dass beim Aufklappen nicht alle Knoten an den Client übertagen werden. Im JavaClient führt das zur Anzeige von Fehlermeldungen und unvollständigen Daten im TreeView. 2022111577 - Framework: ConvertLoadCondition schlägt fehl, wenn man in die Condition mithilfe von DB.SqlString Texte einfügt, die eckige Klammern und Zeilenumbrüche enthalten. Beispiel: ConvertLoadCondition(\"[sText] = \" + DB.SqlString(\"x \\r\\n [ab]\")) 4.4.12 (25.11.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.12_Setup_x64 FS_4.4.12_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer Print-Service Siehe korrigierte Fehler Korrigierte Fehler 2021118404 - Java-Client: Im Tooltip-Text einer Drop-Action werden keine Zeilenumbrüche dargestellt, wodurch lange Texte in einer einzelnen langen Zeile über den ganzen Bildschirm dargestellt werden. 2022111520 - Print-Service: Die Newtonsoft.Json.dll fehlt im Programmverzeichnis. In der Folge wird bei aktiviertem Runtime Supervisor oder beim Testen der Verbindung im Config-Editor eine Exception geworfen. 2022111445 - Publish: Beim Publish eines Service-Hosts gewinnen die Assemblies von Framework Studio über die bin-Ressourcen. Dadurch passen die Assemblies nicht zu den Binding-Redirects in der app.config, was in der Folge zu Fehlermeldungen führt. Werden im bin-Ordner Assemblies als Ressourcen eingebunden, dann sollen diese ggf. bereits existierende Assemblies von Framework Studio überschreiben. In der app.config werden dafür entsprechende Binding-Redirects erzeugt. 2021097889 - FS-IDE: Ungespeicherte ML-Keys werden vom Compiler ohne Fehler verarbeitet. Werden die ML-Keys letztenendes nicht gespeichert, kann dies zu Folgefehlern führen. Vor einem Compile werden jetzt automatisch alle ML-Keys gespeichert. 4.4.11 (28.10.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.11_Setup_x64 FS_4.4.11_PrintService FSCL_4.4.11_Setup_x86 FSCL_4.4.11_Setup_x64 FSCL_4.4.11_Setup_Msi_x86 FSCL_4.4.11_Setup_Msi_x64 RS_4.4.11_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer FS Client Launcher Der Pfad des .jarcache Ordners hat sich von %userprofile%\\FSClientLauncher\\.jarcache\\ zu %localappdata%\\FSClientLauncher\\.jarcache\\ geändert. Durch die Verwendung von %localappdata% wird bei serverbasierten Benuzter-Profilen der Jar-Cache nicht mehr zum Server synchronisiert. Beim ersten Start nach dem Update wird der alte .jarcache Ordner einmalig an die neue Stelle verschoben. Bessere Performance in der Konsole bei der Ausgabe sehr vieler Informationen. In der gespeicherten Log-Datei werden die Client-Launcher-Version und Zeit-Angaben protokolliert. Neuer Print-Service Siehe korrigierte Fehler Neuer Runtime-Supervisor Siehe korrigierte Fehler Neuer HTML Client Siehe korrigierte Fehler Die Barcode Scanner Library wurde aktualisiert Das Frontend wurde auf Angular 14 aktualisiert Korrigierte Fehler 2022101251 - Java-Client: Wenn bei einem Drag&Drop-Vorgang ein modaler Dialog geöffnet wird, dann kann es in seltenen Fällen vorkommen, dass im Hintergrund die Kennzeichnung der Drop-Ziele hängen bleibt. In diesem Fall funktioniert im modalen Dialog kein Drag&Drop mehr. 2022101304 - Java-Client: Wird ein modaler Dialog geöffnet, dann kann es passieren, dass beim ersten OnLeave-Event die SetFocus-Action nicht funktioniert. Der Fehler tritt auf, wenn der Dialog direkt mit dem Schließen eines anderen modalen Dialogs geöffnet wird. 2022091078 - Print-Service: Bei einem ungültigen PaperSourceKind wird eine Exception im Logfile ausgegeben. Die Funktion des PrintService wird dadurch nicht beeinträchtigt. 2022101271 - Broker: Wird in einem Callback von TakePhoto, ScanBarcode oder GetGeolocation eine MessageBox angezeigt, wird diese vom Broker als Exception interpretiert. 2022090844 - IDE: Wird zunächst eine Transformation customized und anschließend der verwendete DataContract, dann werden neu hinzugefügte Properties beim DataContract erst bei einem Neustart von FS in der Transformation angezeigt. 2022091073 - IDE: In speziellen Konstellationen können bei customized Workflows in Switches keine Rows hinzugefügt werden. 2022091140 - IDE: Fehlende Usability im DataContract Wizard beim Vergrößern/Verkleinern des Fensters - die Tabelle wächst nicht mit. 2022101193 - IDE: Im ServiceRelease Modus kann es beim Speichern von Components zu größeren Verzögerungen kommen. 2022101270 - IDE: Beim Compile werden auch Warnings ausgegeben, die im Code des Basis-Package auftreten. 2022101262 - DevExpress Reporting: Bei Sub-Reports findet keine Korrektur der HTML-Texte statt. Dadurch werden P-Tags mit extra Zeilenumbrüchen dargestellt. Im Report-Designer Preview greifen die HTML-Korrekturen nicht. 2022101272 - HTML Client: Die Actions TakePhoto und GetGeolocation funktionieren nicht im Browser. 2022101230 - StartPage: Wird die Startpage auf einem kleinen Display angezeigt, werden die oberen Inhalte abgeschnitten. In Folge reagiert auch der Button \"Start Application\" nicht. 2022101303 - Runtime-Supervisor: Die Web Application zeigt in der Überschrift die falsche Version an. 4.4.10 (30.09.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.10_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Ein CheckIn mit unkompilierten Änderungen ist im Serivce Release Modus nicht mehr möglich. Ausgenommen hiervon sind Resourcen und TextCollections. Im Service Release könnnen nun auch neue Properties in Components, Forms und Data Contracts hinzugefügt werden. Detailliertere Informationen finden sich im Kapitel: strukturelle Erweiterungen im Service Release Sobald sich der Status an einem Record durch einen CheckIn oder CheckOut ändert, wird die SearchView und die Source Control History aktualisiert. Korrigierte Fehler 2022080812 - IDE: Wird im Multilanguage Text Editor die Dependency-Suche ausgeführt, dann kann es zu folgender Exception kommen: System.ArgumentOutOfRangeException: Das angegebene Argument liegt außerhalb des gültigen Wertebereichs. 4.4.9 (26.08.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.9_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Erweiterte Möglichkeiten im Service-Release Die starken Einschränkungen im Service-Release führen derzeit dazu, dass einige notwendige Fehlerkorrekturen gar nicht oder nur mit sehr viel \"Kreativität\" durchgeführt werden können. Durch den Umbau der Code Generierung und des Compiles zur Version 4.4 ist es möglich, diese Einschränkungen etwas aufzuweichen. Ein erstes Paket gibt es mit der aktuellen Version von Framework Studio. Für die nächsten Versionen sind noch weitere Öffnungen geplant. Im Service-Release-Modus können jetzt strukturelle Erweiterungen vorgenommen werden. Important Findet am Ende des Service-Release-Zyklus eine Auslieferung statt, dann muss im Package-Manager an der Package-Version mit Button Start new Service Release cycle das Auslieferungs-Datum (Last Deployment) gesetzt werden. Nur so werden die bis jetzt neu angelegten Strukturen ebenfalls geschützt. In der aktuellen Ausbaustufe sind folgende Erweiterungen möglich: Neue Methoden in Components / Forms / Services / Service Hosts / Service Proxies / Service Contracts Ändern von Beschriftungen (MLKeys) in AccessUnits / Component-Properties / Form-Controls. Somit können die Beschriftungen jetzt durchgängig geändert werden. Ändern aller Form-Control-Eigenschaften. Neue Resourcen Neuerungen An der TextCollection IDevFrameworkObjectTextColl steht eine neue Methode bereit. Die Drop-Methode bool IDevFrameworkObjectTextColl.Drop(FSlong id) ermöglicht einen Eintrag mit einer bestimmten ID zu löschen. Detailliertere Infos siehe API-Dokumentation. DevExpress: Bei EmbeddedSubReport wird der DataMember nicht mehr geändert. Es wird weiterhin der DataMember des Haupt-Reports vorbelegt. Wird der DataMember anschließend vom Benutzer geändert, dann bleibt diese Einstellung jetzt erhalten. Korrigierte Fehler 2022070513 - Java-Client: Bewegt man den Mauszeiger während einer DragDrop-Aktion so schnell, dass er sich beim Loslassen schon wieder außerhalb des dropbaren Bereichs befindet, kommt es zu einer Java-Exception. 2022080704 - Print-Service: Das Auswählen der Printer und Adapter im Configuration Editor funktioniert nicht mit den Pfeiltasten. 2022070446 - Code-Generierung: An Metadatentyp-Klassen wird das Attribut [MDTClass] nicht generiert. In der Folge liefern die Methoden der Klasse MDTClassAttribute falsche Informationen. Note Die Code-Generierung wurde korrigiert. Für bestehenden Code im Service-Release gibt es einen Fallback, der mit dem Namen der Assembly arbeitet, sodass keine neue Generierung erforderlich ist. 2022070458 - Code-Generierung: Ist bei einem Individual Property die Checkbox \"Autogenerate Membervariable\" gesetzt, dann wird im AdoptValues für den Wert der Membervariable kein Clone erzeugt. Note Der Quellcode für die entsprechende Component muss neu erzeugt werden. Im Service-Release reicht es, die Component aus- und wieder einzuchecken. Der anschließende Compile-Lauf erzeugt dann den korrigierten Quellcode. 2022080669 - Code-Generierung: Wird in einer Component eine public static Methode angelegt, dann führt dies im Interface-Code zu einem Compile-Fehler. 4.4.8 (29.07.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.8_Setup_x64 FS4.4.8_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. FSROWID und FSROWVERSION können nachträglich angelegt werden In einer DBTable können die Spalten FSROWID und FSROWVERSION nachträglich angelegt werden. Der Update-Assistent wendet die notwendigen Änderungen inklusive der Anpassung des Primary Key korrekt auf der Datenbank an. Bisher wurde eine neue FSROWID-Spalte als unlösbare Änderung gewertet. Neuerungen für DevExpress® Reporting Änderungen im FS Report Designer: Default-Name für neue Controls Label / TableCell = lbl_ RichText: rtf_ BarCode: bar_ Picture: pic_ CheckBox: cbx_ Wird aus der Field-List per Drag&Drop ein Feld in den Designer gezogen, dann wird der Name des Controls an die Field-Expression angepasst ([oArticle].[decPrice] => lbl_oArticle_decPrice). In Textfeldern wird zur besseren Lesbarkeit im Designer bei segmentierten Expressions ein Comment vorangestellt ([oSalesOrderDetail].[decPrice] => /*decPrice*/ [oSalesOrderDetail].[decPrice]). High DPI Skalierung wird unterstützt. Neuerungen im Umgang mit ReadOnly Package-Versionen Damit auch für importierten Packages Debug-Stände erzeugt werden können, wurde das Verhalten von importierten oder geschlossenen Package-Versionen angepasst: Normale user und FCUser können sich jetzt an importierten und an geschlossenen packages anmelden. Compile: Normale user dürfen importierte oder geschlossene packages kompilieren. Der FrameworkCompiler und jegliche FCUser dürfen importierte oder geschlossene packages ansehen, aber nicht kompilieren. Die Optionen im Login-screen wurden entsprechend angepasst. FCUser werden beim Verlassen der Anwendung nicht mehr über einen ausstehenden Abschluss des workspaces gewarnt, falls es sich um ein importiertes oder geschlossenes package handelt. Korrigierte Fehler 2022070299 - Broker: Fehler im Data-Binding - Wenn in einem Grid eine Combobox-Spalte mit DependsDataSourceOnRowData angelegt ist, dann kann es passieren, dass am Client geänderte Werte nicht zurück in das gebundene Property geschrieben werden. 2022070358 - Package-Manager: Wird ein Service-Release-Stand über ein Full-Package importiert, dann erhält der Workspace der importierten Package-Version nicht das Service-Release-Datum, sondern das Release-Datum. In der Folge zeigen der Package-Manager und die eNVenta Versions-Info veraltete Datumswerte an. 2022070530 - Package-Manager: Bei Customzing-Packages kann es vorkommen, dass im Compile-Lauf zu viele - in diesem Package nicht gecustomizte Namespaces - compiliert werden. In der Folge kann es bei komplizierten Package-Hierarchien in seltenen Fällen vorkommen, dass Logik eines Basis-Packages \"ausgeblendet\" wird. 2022070434 - IDE: Wird im Customizing oder in einer Ableitung an einem TreeNode z.B. ein DisplayMember geändert, dann werden im Repository falsche Informationen gespeichert. Nach einem Neustart der IDE bzw. im Compile-Lauf wird dadurch der komplette NodeDataSource - also die zugewiesene Collection - als geändert betrachtet. In der Folge kann eine falsche Code-Generierung dazu führen, dass der TreeView zur Laufzeit nicht alle Daten anzeigt. Note Die betroffenen Stellen müssen mit der aktuellen Version manuell korrigiert werden. Dafür bitte am TreeNode die Eigenschaft NodeDataSource mit \"Reset\" zurücksetzen (sodass diese nicht mehr fett gedruckt erscheint) und anschließend die DisplayMember erneut setzen. 2022070415 - Framework: Die Methode IsComponentProperty(string) liefert möglichweise false zurück, obwohl das Property existiert. Wenn man im Login-screen der IDE den Dropdown-button der Combobox verwendet und dann den Namen eines Benutzers eintippt, überlappen sich die beiden Dropdown-Fenster. Wenn man im Package-Manager den AssemblyPrefix bearbeiten möchte, dann kann es vorkommen, dass der Package-Manager einfriert. 4.4.7 (24.06.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.7_Setup_x64 RS_4.4.7_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen für DevExpress® Reporting Report Migration Summary inklusive einer XML-Aufbereitung der Crystal-Reports. Änderungen im FS Report Designer: Das Datei-Handling wurde grundlegend überarbeitet Readonly Reports sind nicht mehr eingeschränkt. Änderungen können bei Bedarf mit \"Save As...\" gespeichert werden. Speichern von Embedded SubReports überarbeitet. Wird aus einem Linked Subreport heraus ein Embedded Subreport geöffnet, ist dieser Readonly. Die FS-spezifischen Report Controls haben Icons erhalten Korrigierte Fehler 2022059879 - JavaClient: Beim Öffnen eines Forms werden vom WrapPanel Layout-Exceptions geworfen, wenn der Frame extrem schmal ist. 2022050010 - Java-Client: Wird in einem HTML-Textfeld ein Bild eingefügt, dann wird im HTML-Code das img-Tag nicht mit einem MIME-Type versehen. Der Client zeigt das Bild korrekt an, aber bei der Weiterverarbeitung des HTML (z.B. dem Senden einer Email über Outlook) kann es sein, dass das Bild nicht korrekt verarbeitet wird. 2022060088 - Broker: Wird auf einem Grid, das eine GroupBy-Query anzeigt, über den Client ein Filter eingestellt, dann wird ein SQL-Error angezeigt. Der Fehler tritt auf, wenn aufgrund sehr vieler Datensätze der Reload-Mechanismus greift und der Filter deshalb über die Datenbank angewendet wird. 2022060124 - Code-Generierung: Wird ein Customizing-Package compiliert, dann wird in die Package-Info für die Basis-Packages nicht das richtige Compile-Datum generiert. Alle Packages erhalten dieselben Werte wie das Customzing-Package. In der Folge werden in eNVenta in der Versions-Info falsche Datums-Werte und ein falscher Wert bei Service-Release angezeigt. 2022050005 - Runtime Supervisor: Observables können auf Grund von inkompatiblen API-Versionen nicht mit dem Runtime Supervisor kommunizieren. 4.4.6 (27.05.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.6_Setup_x64 FS4.4.6_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer Print-Service Im PrintService wurde die DevExpress® Reporting Runtime aktualisiert. Korrigierte Fehler 2022059888 - JavaClient: Wird eine Grid-Zelle mit Enter verlassen, dann kann es passieren, dass eine im OnColumnChanged-Event aufgerufene SetCell-Action ignoriert wird. Der Fokus landet dann nicht in der gewünschten Grid-Zelle. Auftreten kann der Fehler, wenn z.B. im OnColumnChanged ein modaler Dialog geöffnet wird. 2022059912 - Java-Client: Sind in einem Menü mehrere Separatoren enthalten, dann kann es beim Öffnen des Forms im Java-Client zu einer StackOverflowException kommen. Der Fehler tritt auf, wenn viele Menu-Items ausgeblendet werden. In der Folge wird das Form nicht angezeigt oder die Anwendung startet nicht korrekt. 2022059952 - Publish2Go: Die Einstellungen für das Load Balancing sind nicht sichtbar. 2022059938 - Package-Manager: Beim Compile eines Service-Release wird für bearbeitete DBTables kein neuer Code generiert. In der Folge wird dieser Code beim Package-Export nicht berücksichtigt. Nach dem Import im Ziel-Repository können dann Compile-Fehler auftreten. Note Damit die Korrektur greift muss die betroffene DBTable einmal aus- und eingecheckt werden. Beim anschließenden Compile-Lauf wird der Code dann korrekt aufgebaut. 2022049752 - IDE: Wird im Basis-Package ein Element in einen neuen Namespace verschoben und der alte Namespace gelöscht, dann findet im Customizing-Package die Routine \"Adjust moved Customizations\" betroffene Elemente nicht. Dadurch hängen die customizten Elemente in der Luft und verursachen ggf. Fehler beim Compile. 2022049758 - IDE: Hat der CSharp-Compiler ein Problem, das den Compile komplett verhindert (weil z.B. das Programm-Verzeichnis beschädigt ist), dann meldet Framework Studio keinen entsprechenden Fehler. Bei der Arbeit als normaler Benutzer werden keine DLLs erzeugt, wodurch der Start des Brokers nicht möglich ist. Beim Ausführen eines FrameworkCompiler treten Fehler auf, weil DLLs nach dem Compile nicht gefunden werden. 2022059769 - IDE: Beim Einfügen eines Links in einen customizten Workflow erscheint in seltenen Fällen eine Fehlermeldung. System.ArgumentException: An item with the same key has already been added. 2022059945 - IDE: Erweiterungen an einem gecustomized Basis-Workflow werden nicht in die Code-Generierung des von der Basis erbenden (nicht gecustomized) Workflows übernommen. 2022059953 - HTML Client: GetGeoLocation liefert falsche Werte. 4.4.5 (29.04.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.5_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Neue Maintenance-Routine Replace TextCollection with MLKeys zum Ersetzen von TextCollection-Aufrufen durch MLKeys im Methoden-Code. Korrigierte Fehler 2022039471 - Package-Manager: Bei einem importierten Package wird die Meldung \"Please import...\" angezeigt, wenn für das Basis-Package ein neues Service-Release importiert wird. Diese Situation kann durch Compile des importierten Packages behoben werden. Die Meldung muss entsprechend angepasst werden. 2022049663 - Package-Manager: Wird ein importiertes Package kompiliert, dann geht das ursprüngliche Compile-Datum verloren. Sowohl im Package-Manager als auch in der Versions-Info von eNVenta ist dadurch der Programm-Stand nicht mehr ersichtlich. Note Die Korrektur greift erst, wenn das Package erneut compiliert wird. 2022018960 - IDE: Im Multilanguage Text Editor findet die Suche bei mehrzeiligen Texten nur Wörter, die in der ersten Zeile stehen. Der Text ab der 2. Zeile wird nicht berücksichtigt. 2022039402 - IDE: Die Intellisense funktioniert im Exception-Editor im Feld \"String.Format\" nicht. 2022039417 - IDE: Beim Einfügen eines Format-Tags (z.b. [b], [i], [h1] usw.) werden ggf. zu viele Tags zusammengefasst. So können versehentlich z.B. Image-Tags in die Headline rutschen, was im Anschluss zu Fehlern führt. 2022039443 - IDE: Headline-Tags ([h1], [h2] , [h3]) können fälschlicherweise in Control-Dokumentationen verwendet werden. 2022049597 - Data-Provider: Oracle - Wird in einem SQL-Command ein Identifier mit Sonderzeichen oder eine Ziffer am Anfang verwendet, dann wird das für Oracle nicht korrekt umgesetzt. Beispiel: DELETE FROM [30_TEST] 2022049553 - Framework: Die Update-Analyse greift bei Oracle ggf. verzögert auf die Data-Connection zu. Das führt bei deaktiviertem FSPooling zu einer ObjectDisposedException. Bei aktivem FSPooling wird die Connection nicht mehr freigegeben. 4.4.4 (25.03.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.4_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Der SpellChecker für das Dokumentationssystem kann nun im Options-Dialog deaktiviert werden. Im Method History Browser und im Element History Browser werden Context-Package Versionen ausgeblendet. Korrigierte Fehler 2022029183 - Broker: Die Properties MainMemorySortingThreshold, TransferStartupRowCount, TransferStartupNodeRowCount und ListSortOrder verhalten sich unterschiedlich, je nachdem ob ihr Wert aus der Basis stammt. 2022029176 - Package-Manager: Wird im Package-Manager mit der Version 4.4 eine Package-Version mit einer älteren Version (z.B. FS 4.2) gelöscht, dann werden Context-Versionen nicht berücksichtigt. Dadurch wird die Package-Hierarchie zerstört. Weil sich das nicht mehr lösen lässt, muss das Repository-Backup zurück gespielt werden. 2022029237 - Package-Manager: Nach dem ersten Import eines Customizing-Packages fehlt die Beziehung zu den Basis-Workspaces. In der Folge treten Exceptions auf. Das Package muss ein weiteres mal importiert werden. 2022039432 - Package-Manager: Wird ein importiertes Package compiliert, weil sich der Service-Release-Stand eines Basis-Packages geändert hat, dann werden in diesem Package die Ressourcen nicht compiliert. Dadurch werden MLKeys, welche im Basis-Package im Service-Release hinzugefügt wurden nicht erkannt. Die Folge sind ggf. Compile-Fehler in diesem Package. 2022039447 - Package-Manager: Wird aus dem Package-Manager heraus der Runtime-License-Manager geöffnet, dann werden bei einer \"Context\"-Package-Hierarchie nicht alle Packages angezeigt. 2022029238 - IDE: Bei einem neuen Customizing-Package, bei dem noch keine eigenen Components existieren, gibt es Compile-Errors, wenn man die Interfaces mit DebugAll compiliert. 2022039298 - IDE: Beim Schreiben im Dokumentations-Editor kann ein Deadlock entstehen. Note Der Fehler ist korrigiert. Dennoch wurde vorsorglich die Rechtschreibprüfung im Dokumentations-Editor per Default deaktiviert. Bei Bedarf kann sie über die Options aktiviert werden. Wenn der Deadlock nach weiteren Tests nicht mehr auftritt, dann wird die Rechtschreibprüfung in der kommenden Version wieder aktiviert. 2022039391 - IDE: Wird in der Dokumentation eines Controls eine Headline hinzugefügt, kommt es beim Rendern des Chapters zu einer Unhandled Exception. 2022039452 - RuntimeAdministration: User Passwort wird bei Änderung der Role-Zuweisung auf einen falschen Wert gesetzt. 4.4.3 (25.02.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.3_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Bekannte Probleme 2022029176 - Package-Manager: Wird im Package-Manager mit der Version 4.4 eine Package-Version mit einer älteren Version (z.B. FS 4.2) gelöscht, dann werden Context-Versionen nicht berücksichtigt. Dadurch wird die Package-Hierarchie zerstört. Weil sich das nicht mehr lösen lässt, muss das Repository-Backup zurück gespielt werden. Note Das Löschen von älteren Package-Versionen wurde vorübergehend deaktiviert, um Beschädigungen an Repositories zu verhindern. Es wird voraussichtlich mit dem nächsten Patchday eine Korrektur geben. Neuerungen Die Anmeldung mit dem FrameworkAdministrator an der IDE zur User-Verwaltung wurde entfernt. Die User-Verwaltung kann nun ausschließlich über den Package Manager im Menü Tools -> Manage Users aufgerufen werden. In der IDE werden noch nicht abgespeicherte Tabs mit einem Stern * gekennzeichnet. Korrigierte Fehler 2022029190 - Java-Client: Alle Jar-Dateien müssen neu signiert werden, weil das Java-Zertifikat widerrufen wurde. 2022029110 - Reporting: Ein ReportEnum-Konstruktor setzt keinen Dateinamen, wodurch z.B. der Druck von per Client Side Customizing erstellten Reports fehlschlägt. 2022019075 - IDE: Beim Anmelden mit dem FrameworkAdministrator an der IDE kommt es zu einer Exception. Note Die Anmeldung mit dem FrameworkAdministrator an der IDE zur User-Verwaltung wurde entfernt. Die User-Verwaltung kann nun ausschließlich über den Package Manager im Menü Tools -> Manage Users aufgerufen werden. 2022029093 - IDE: Customize aus dem Context-Menü einer Basis-Methode funktioniert nicht. 2022029094 - IDE: In der laufenden Session werden Änderungen an Components im Intellisense-Store nicht aktualisiert. Dadurch sind z.B. neu angelegte Properties erst nach einem Neustart zu sehen. 2022029126 - IDE: Nach dem bearbeiten eines Global Events kann es passieren, dass im Workflow-Link auf dieses Global Event keine Init-Methode mehr angeboten wird. 2022029194 - IDE: Wird auf einem ControlType ein Undo Checkout ausgeführt, dann werden Form-Controls mit diesem ControlStyle und der zu verwerfenden Control-Version auf gelöscht gesetzt. Note Dieser Fehler kann eine Erklärung für Fälle sein, in denen aus heiterem Himmel Controls verschwunden sind - ohne dass jemand das Form ausgecheckt hat. Er war seit 05.2020 aktiv. 2022029147 - Doku: Informationen zum Aufräumen von tblRep_SessionLogging. 2022029101 - Framework: AccessUnitHierarchy.CreateHierarchy wirft eine NullReferenceException. 4.4.2 (28.01.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Am cGlobal wurde ein neuer EntryPoint geschaffen, mit dem man Lizenz-Freigabe programmatisch einschränken kann, obwohl die Lizenz-Datei dies erlaubt. Es ist nun möglich, Headlines im Dokumentationsfenster zu nutzen. Korrigierte Fehler 2022018908 - JavaClient: Wird per Action ein TabbedWindow (oder sein Parent) ausgeblendet, dann feuert das OnSelectedTabPageChange Event. Findet das beim Öffnen eines Forms statt, dann kann das zur Folge haben, dass das Form sich nicht im Vordergrund öffnet. 2022018909 - Java-Client: Beim Öffnen eines Forms wird in der Java-Console ggf. eine Meldung \"FrameworkSystems.FSJavaClient.DevControl.LayoutComponentDefault cannot be cast to FrameworkSystems.FSJavaClient.DevControl.DevControlTabPage\" ausgegeben. 2022018927 - Java-Client: Beim Ausführen der Action LoadGridLayout kann es bei großen Grids vorkommen, dass nicht alle Daten verarbeitet werden. 2018043231 - IDE: Beim Paste eines Metadatentyps zeigt die Prüfung keine Konflikte an, wenn der Basis-Metadatentyp nicht existiert. Beim Einfügen wird dann eine Exception ausgelöst. 2021128765 - IDE: Beim Import einer TMX-Datei ins Wörterbuch werden ISO-Sprach-Codes in Großbuchstaben nicht erkannt. 2021128775 - IDE: Wird im Code-Editor vor einer geschweiften Klammer in einem SingleLine-Kommentar ein \".\" gesetzt, aktiviert sich die Intellisense. 2022018943 - IDE: Nach dem Kopieren und Einfügen eines CustomControls kann das Zielform nicht mehr compiliert werden. 2022018947 - IDE: Wenn im Dokumentations-Editor sehr große Dokumentationen bearbeitet werden, kann es zum zeitweisen Einfrieren des Editors kommen. 2022018949 - IDE: GAC-Referenzen werden nicht zu der zu kompilierenden Klasse hinzugefügt, wodurch der Compile mit Errors abbricht. 2022018881 - Doku-System: Die Checkbox \"Include DB-Tables\" beim HTML-Export hat keinen Effekt. Die Tabellenbeschreibungen werden nicht exportiert. 2022018882 - Doku-System: Die Tabellenbeschreibungen beim HTML-Export werden unsortiert ausgegeben. 2022018856 - Framework: AUHelper.GetAccessUnitInfos() verursacht NullReferenceException. 2021128815 - HTML Client: Das Picture Control wird nicht upgedated, wenn die DataSource auf \"null\" gesetzt wird. 2021128823 - HTML Client: Die Frequenz der Beep-Action ist hart auf 1000Hz festgelegt und ignoriert damit den übergebenen Wert. 2022018973 - PackageManager: Muss ein importiertes Package aufgrund eines Service Release kompiliert werden, dann kann es vorkommen, dass die MLKeys dieses Packages nicht berücksichtigt werden. 4.4.1 (23.12.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Kein Internet Explorer 11 mehr Der Internet Explorer 11 wird nicht mehr unterstützt. Folgende Features können nur noch mit aktuellen Browsern wie z.B. Edge, Chrome oder Firefox genutzt werden: Client Start Page Mit Framework Studio generierte Online-Hilfe Mobile Client Neuerungen Erweiterungen im Dokumentations-Editor Rechtschreibprüfung Das Einfügen von Links wurde überarbeitet Einfügen von Url-Links aus der Zwischenablage Einfügen von Bildern aus der Zwischenablage Der Tooltip kann direkt im Editor bearbeitet werden. HTML Client Actions Folgende Actions werden nun vom HTML Client unterstützt: Beep BeepDouble BeepMultiple Korrigierte Fehler 2021128654 - Broker: Wird im Customizing-Package eine Developer-Lizenz verwendet, dann werden die Lizenzen der Basis-Packages nicht ausgewertet. Folglich werden alle Features freigeschaltet. 2021118528 - IDE: Im Login-Dialog kann man mit TAB nicht in die Combobox Auto Debug DLLs springen. 2021118541 - IDE: Wird ein zu langer Datenbank-Servername oder Repository-Name verwendet, dann bricht der Start der IDE mit einer Exception ab. 2021128575 - IDE: Wenn versucht wird, in einer Dokumentation ein Hyperlink einzufügen, muss dieser mit http:// beginnen und verbietet somit https:// Hyperlinks. 2021128588 - IDE: Beim Kopieren eines Component Properties wird die Eigenschaft \"Autogenerate Membervariable\" nicht kopiert. 2021128680 - IDE: Wurden nach dem FrameworkCompiler Elemente eingecheckt, dann werden diese anderen Benutzern bei Get Latest CheckIns ggf. nicht angezeigt. 2021128584 - Code-Generierung: Wird im Metadatentyp als Format-Pattern ein Regulärer Ausdruck verwendet, dann wird dieser im generierten Code nicht sauber escaped. In der Folge kann es zu Compile-Fehlern kommen. 2021128747 - HTML Client: Die ComboBox (ListValuesInput) reagiert nicht auf Eingaben von Buchstaben zur Auswahl des Eintrags. 2021128773 - HTML Client: Editfields mit einer DataSource vom Typ \"FSDateTime\" werfen beim Senden des Wertes zum Broker in gewissen Fällen eine Exception. 4.4.0 (10.12.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.0_Setup_x64 FS_4.4.0_PrintService FS_4.4.0_Requirements_x64 (Requirements-Paket) FSCL_4.4.0_Setup_x86 FSCL_4.4.0_Setup_x64 FSCL_4.4.0_Setup_Msi_x86 FSCL_4.4.0_Setup_Msi_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Die Neuerungen finden Sie unter Neuheiten 4.4 Korrigierte Fehler In der Version 4.4 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.3.10 enthalten. Zusätzlich wurden die folgenden Bugs behoben. 2021118369 - Framework: Wird an einer Grid-Combobox im Customizing an abweichender Display-Member definiert, dann ziehen ggf. weiterhin Eigenschaften des in der Basis angegebenen Display-Members. So wird z.B. weiterhin ein \"Uppercase\" gezogen, wenn im neuen Display-Member kein Format definiert ist."
  },
  "articles/release-4-5.html": {
    "href": "articles/release-4-5.html",
    "title": "Release-Information Framework Studio 4.5",
    "keywords": "Release-Information Framework Studio 4.5 4.5.26 (07.03.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.26_Setup_x64 Weitere Pakete (Dateinamen ohne ZIP-Endung) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.41.5 auf Version 7.42.0 aktualisiert. Das entspricht Chromium 132. Release-Notes des Control-Herstellers: https://teamdev.com/jxbrowser/release-notes/2025/v7-42-0/ Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Neuerungen Der Sql-Parser versteht jetzt WITH-Statements, auch bekannt als Common Table Expression (CTE). Korrigierte Fehler 2025027380 - Java Client: Wenn an einer Registerkarte das Event OnFirstSelect implementiert ist, dann kann es passieren, dass bei der ersten Eingabe in einem TextFeld das OnLeave-Event nicht korrekt gefeuert wird. 2025017265 - Java-Client: Wenn ein Form, das über ein Event geschlossen werden soll, im selben Zug fokussiert wird, kommt es zu einer Fehlermeldung. 2025017231 - IDE: Wird nach dem Kopieren und Einfügen eines Combobox- oder ListBox-Controls das Property, das als ListDataSource definiert ist nicht eingefügt, so kommt es beim Speichern des Forms zu einer Unhandled Exeption und die Anwendung stürzt ab. 2025017263 - IDE: Wenn im Wörterbuch für einen MLKey ein mehrzeiliger Text mit einfachen Zeilenumbrüchen ( \\n / LF ) statt den üblichen ( \\r\\n / CR+LF ) definiert wurde, dann gibt es Probleme bei der Verarbeitung des Textes: In der Tabelle im Multilanguage Text Editor wird der Text mehrzeilig angezeigt - das zieht die Tabelle auseinander. Der Exception-Editor erzeugt einen mehrzeiligen Code, der Compile-Fehler produziert und der Exception-Editor erkennt diesen Code nicht korrekt. 2025027305 - Framework: Die Methode LoadCount() liefert bei GroupBy-Components falsche Werte zurück. Die Anzahl der Sätze wird in einer Gruppierung ermittelt. 4.5.25 (07.02.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.25_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf die Version 24.2.3 aktualisiert. Der HTML Client wurde auf Angular 19.1.1 upgedatet. Neuerungen Bei Klicken auf einen Link im Errors and Warnings Tab wird dieser farblich hervorgehoben, um zu visualisieren, dass der Link bereits besucht wurde. Bei den Aktionen Open, Save (im FS Report Designer), sowie Choose Report wird nun das Verzeichnis der tatsächlichen Report-Datei geöffnet, statt das Haupt-Reportverzeichnis. Korrigierte Fehler 2025017196 - Reporting: Im WebDesigner ist der Expression Editor nicht nutzbar, da weder Formeln angezeigt noch bearbeitet werden können. 2025017210 - Publish2Go: Wird ein Publish2Go-Paket mit mehreren Applications erstellt, dann enthält das Paket nur eine FSJavaClient.jnlp. In der Folge ziehen einige Einstellungen der Application (z.B. Java Heap Size) nicht korrekt. 2024127103 - IDE: Im Formula Converter des DevExpress Report-Designer werden Properties mit einem Package-Prefix nicht korrekt erkannt. Der Unterstrich wird durch einen Punkt erstzt. oObject_oP01_MyColl.shtK07_MyProperty wird zu oObject.oP01.MyColl.shtK07.MyProperty anstatt zu oObject.oP01_MyColl.shtK07_MyProperty 2025017187 - IDE: Der MultiLanguageText-Editor erzeugt Excpetions, wenn es einen überschriebenen Text ohne passenden Text aus dem Basis-Package gibt. 2025017272 - Code-Generierung: Wenn man eine Code-Transformation customized, dann erzeugt falsch generierter Code einen Compile-Error \"Type expected\". 2024096531 - DevExpress: Wird in einem Report mit Gruppen in einigen Positionen eine RunningSum angezigt, dann stimmt der angezeigte Wert nicht. Es handelt sich um einen Fehler in DevExpress: https://supportcenter.devexpress.com/ticket/details/t1255491 4.5.24 (03.01.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.24_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.40.0 auf Version 7.41.5 aktualisiert. Das entspricht Chromium 131. Release-Notes des Control-Herstellers: https://teamdev.com/jxbrowser/release-notes/2024/v7-41-5/ Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Weitere Updates Das CefSharp Browser-Control in der IDE wurde auf Version 131.3.10 upgedatet. Korrigierte Fehler 2024127052 - Java-Client: Der Fokus eines neu geöffneten Forms geht verloren, wenn während des Öffnens ein Event (z.B. SelectedTabPageChanged) gefeuert wird. 2024126994 - Package-Manager: Wird für eine Package-Version ein Hotfix importiert, dann kommt es zu Null-Exceptions beim Compile und beim Export von darauf aufsetzenden Package-Versionen. 2024127022 - IDE: Bei einer Änderung der AccessUnits im FormDesigner wird der Speicherbutton nicht aktiv. 4.5.23 (06.12.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.23_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Im Element History Browser, sowie im Method History Browser wurde der Monaco eigene Diff-Editor eingebaut. Der Vergleich mit einem externen Tool ist dennoch möglich. Im Class-Code und Namespace-Code (Generated-Code) kann man im Editor nun einen Code-Refresh ausführen. Korrigierte Fehler 2024116925 - Package-Manager: Beim Export eines Package-Stacks, bei welchem Packages ohne Owner-Status dabei sind, verliert der Export das korrekte Created Workspace Datum. Beim Import dieses Package-Stacks in ein anderes Repository haben dann alle Packages das Export Datum des zweiten Exports. 2024116779 - IDE: Die maximal Request Größe eines REST Service endpoints ist zu gering. Note Es ist jetzt möglich manuell einen REST-Endoint mit individuellen Binding-Einstellungen anzulegen. Dort kann die Größe der Messages an die Bedürfnisse angepasst werden. 2024116848 - IDE: Wird für einen ServiceProxy, der einen externen Service anbindet, ein anderer Collection Type als System.Array oder System.Collection.ArrayList ausgewählt, kann der Proxy über 'Generate Proxy' nicht mehr generiert werden. 2024116929 - Data Provider: Wird der Funktion DB.SqlString() ein ganzzahliger Decimal-Wert, mit 13, 14 oder 15 Stellen übergeben, dann führt die Ausführung des SQL-Statemens zu einer SQL-Exception. 2024116875 - Framework: Die SortAndFilter()-Methode hat keine Auswirkung auf das Grid, wenn diese im OnLoad oder in der TargetMethod des Workflows aufgerufen wird. 4.5.22 (08.11.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.22_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates Der Monaco Code-Editor wurde auf Version 0.50.0 upgedatet. Das CefSharp Browser-Control in der IDE wurde auf Version 129.0.110 upgedatet. Der HTML Client wurde auf Angular 18.2.2 upgedatet. Bitte beachten Sie die geänderten Systemvoraussetzungen für die App. Es werden nur noch Geräte mit Android 8.0 (API-Level 26) oder höher unterstützt. Korrigierte Fehler 2024106684 - Reporting: Wird ein DevExpress Report als HTML exportiert, dann werden die Bilder (z.B. Barcodes) nicht eingebettet, sondern als Datei referenziert. 2024106579 - IDE: Beim Beenden des Development Service Host läuft dieser 2 mal in die Methode OnServiceHostExit(). 4.5.21 (04.10.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.21_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Das Anlegen eines neuen Repositorys funktioniert jetzt auch mit den strengeren Password-Regeln in SQL-Server 2022. Korrigierte Fehler 2024096453 - Reporting: Bei Update eines Oracle Repositories auf die Versionen 4.4 wurde beim Anlegen der Tabelle tblRep_ReportDesign die Spalte RPTD_Modified vergessen. Dadurch können keine im Client keine DevExpress-Reports bearbeitet werden. Note Beim nächsten Update des Repositories auf Version 4.5, 4.6 oder 4.7 wird die Tabelle automatisch korrigiert. Um ein aktuelles Oracle-Repository nachträglich zu korrigieren gehen Sie wie folgt vor: Bei einem Entwichlungs-Repository bitte im Programm-Verzeichnis die FrameworkStudioUpgradeDatabase.exe ausführen, am Rpository anmelden und den Update durchführen. Bei einem Runtime-Repositoy bitte im Publish-Wizard bzw. Run-Wizard den Button Prepare Runtime Repository drücken und den Update ausführen. 2024096457 - IDE: Die für den Code-Editor verwendete Chromium Runtime arbeitet im Hintergrund mit einem Cache, welcher auch nach dem nächsten Start weiter verwendet wird. Dadurch kann es passieren dass ein Update des Code-Editor erst mit mehreren Tagen Verzögerung zieht. 4.5.20 (06.09.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.20_Setup_x64 FS4.5.20_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf Version 24.1.4 upgedated. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.38.0 auf Version 7.40.0 aktualisiert. Das entspricht Chromium 127. Release-Notes des Control-Herstellers: https://jxbrowser-support.teamdev.com/release-notes/2024/v7-40-0.html Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Neuerungen Die Include Base Packages Funktion im Package-Export über den Package-Manager und die FSConsole bzw. PBE wurde überarbeitet. Korrigierte Fehler 2024086212 - Java-Client: Wird ein Client nicht regulär beendet, dann bleiben temporäre Ordner des JxBrowser-Controls hängen. Passiert das häufiger (z.B. mit F5 aus der IDE heraus), dann sammeln sich sehr viele Ordner an. 2024086290 - Publish2Go: Im Publish2Go Wizard wird bei der ConnectionGroup immer \"Conn1\" angezeigt, statt des korrekten ConnectionGroup Namens. 2024086169 - IDE: FS stürzt mit einer Unhandled NullReferenceException ab, wenn für mehrere Comboboxen gleichzeitig die MaxDropDownSize geändert wird. 2024086225 - IDE: Wird eine Hotfix Package-Version compiliert, dann werden Warnungen ausgegeben, die in der normalen Package-Version nicht angezeigt werden sollen. 4.5.19 (02.08.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.19_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Referenz-Prüfung für Ressourcen Über eine neue API können im Broker Inhalte bereitgestellt werden. Diese können vom Client heruntergeladen werden. Die beiden Actions SetMinWidth und SetMaxWidth für GridColumns wurden umgesetzt Korrigierte Fehler 2024045657 - Java-Client: An einem Grid ist MultiSelect und Drag&Drop aktiv. Wenn man mit Strg+A alle Zeilen selektiert und anschließend mit Strg+Klick eine Zeile deselektiert, dann werden bei dem dadurch ausgelösten RowClick-Event die SelectedRows nicht zum Broker übertragen. In der Folge kann es zu Fehlverhalten in der Anwendung kommen. Im eNVenta Auftrag/Angebot z.B. werden dabei wieder alle Zeilen deselektiert. 2024076053 - IDE: Werden im Code (z.B. einer Transformation) mehrere DataContracts eines generierten ServiceProxies verwendet, dann kann es passieren, dass im Code Ambiguity-Errors angezeigt werden. Bei Compile treten diese aber nicht auf. 2024076086 - IDE: Wird ein Service ausgecheckt und geändert, dann zieht für den generierten Service-Proxy weiter der Saved Code. Es ist ein expliziter Compile ohne Saved Code erforderlich damit die Änderungen ziehen. 2024076089 - IDE: Wird in einem Service eine private oder protected Methode angelegt, dann wird diese im generierten Service-Proxy als Operation erkannt. Sie wird auch in den Proxy-Code generiert und das führt zu Compile-Fehlern. Der Service-Proxy darf nur die public-Methoden anbieten, die auch im Service-Interface landen. 2024076110 - IDE: Wird ein MDT gelöscht und die zugehörige DBTable, welche den MDT in einer Column zuvor nutzte, wird nicht eingecheckt, erfolgen beim Compile mit einem anderen User Compilefehler. Diesen Compilefehler in Form einer NullReferenceException haben wir mit dem Namen der DBTable und der DBColumn als Info ergänzt. 2024076021 - Code-Generierung: Nach der Korrektur des Bugs 2024055731 treten beim Compile im Customizing Warnings auf, wenn Global Objects im Basis-Package als Obsolete markiert sind. 2024076058 - DevExpress Report Designer: Wenn ein Linked SubReport eingebunden und die Report Source Url angegeben wird, dann kann es sein, dass eine Fehlermeldung angezeigt wird: The report ~.....repx contains untrusted data types. Please contact the application vendor or system administrator for assistance. Die URL kann somit nicht angegeben werden. 2024076025 - Package Manager: Beim Compile über den Compile-Wizard / FSConsole.exe kann es bei den Ressources zu Exceptions kommen, wenn Dateien vom Virenscanner blockiert werden. 2024076051 - Package Manager: Tritt beim Compile ein Warning ohne Bezug zum Code auf (z.B. CS1702), dann wird im Compile Log eine NullReference-Exception ausgegeben. Die Liste der Warnings ist ggf. unvollständig. 2024076119 - Package Merge: Beim Customizing einer DBTable wird der Wert der \"View\" auf einen falschen Wert gesetzt. Dieser ist in der IDE unwichtig und wird dort ignoriert. Beim Package Merge wird jedoch der falsche Wert vom Customizing in das Target-Package überschrieben. Dies führt später zu Fehlern. 4.5.18 (05.07.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.18_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Bekannte Probleme Der Client hängt sich beim Drag&Drop (vom Desktop oder Explorer) auf und muss über den Taskmanager beendet werden. Es handelt sich hierbei um einen Fehler in der Java-Runtime. Bug bei OpenJdk Leider ist dieser Fehler seit über einem Jahr nicht gefixt und er betrifft praktisch alle aktuellen Versionen der Java-Runtime. Es gibt auch keine Ansätze, wie wir das in unserer Programmierung lösen könnten. Der Fehler kam mit Java 8 Update 361 rein. Mit dem FS Client Launcher Version 4.5.15 haben wir auf eine aktuelle Java-Runtime Java 8 Update 392 aktualisiert. Wir können nicht auf eine ältere Version zurück gehen, weil wir ansonsten sicherheitstechnisch mit einem sehr veraltetem Stand agieren müssten. Mit der Kenntnis, wie genau dieser Fehler auftritt, ist dieser ziemlich leicht zu reproduzieren: Der Fokus muss in eNVenta in einem Textfeld stehen (gelb hinterlegt) Direkt aus dem Explorer oder dem Desktop (ohne vorher dorthin zu klicken) eine Datei in die Anwendung ziehen. Nach wenigen Versuchen friert die Anwendung ein. Daraus lassen sich mögliche Workarounds ableiten: am einfachsten vor dem Drag&Drop einmal in den Explorer bzw. den Desktop klicken. Alternativ können Sie auf eigenes Risiko auch auf den alten FS Client Launcher 4.4.13 zurückfallen. Dieser arbeitet mit Java 8 Update 202, welche aber einen extrem veralteten Sicherheitsstand hat. Wenn Sie die Installation einer alten Version vorziehen, muss zuerst der aktuelle FS Client Launcher deinstalliert werden - ein \"Rückwärts-Update\" funktioniert nicht. Wir werden diesen Fehler weiter beobachten. Sobald Java das fixt, liefern wir einen aktualisierten FS Client Launcher aus. Neuerungen Neues Kapitel in der Doku: Databinding in Forms Im Publish2Go Wizard gab es bisher die Option nachträglich Service Release Dateien auszutauschen. Da seit FS Version 4.4 die entsprechenden SR-Dateien nicht mehr erstellt werden, haben wir uns dazu entschieden diese Option zu deaktivieren. Ab FS 4.7 werden wir diese Option komplett entfernen! Wenn Sie die Service-Release-Funktion für das Ersetzen von anderen Datei-Typen (z.B. Reports) verwendet haben und dies auch weiterhin benötigen, können Sie die Option über die App.Config im Publish-Ordner wieder aktivieren. Note Bitte melden Sie sich unbedingt bei unserem Support, wenn Sie die Service-Release Option aktivieren und warum Sie dies benötigen. Korrigierte Fehler 2024065939 - Broker: Wird über den HTML-Client eine TakePhoto-Action ausgeführt und diese liefert ein großes Bild mit mehr als 3 MB, dann meldet der Server eine HTTP 500 Fehlermeldung. Die Session der Anwendung muss beendet werden. Fotos können mit aktuellen Handy-Kameras problemlos 5MB oder größer sein. Note Die neue Einstellung, welche jetzt beim Publish angewendet wird, erlaubt Bilder mit einer Größer von ca. 18MB. 2024075973 - Publish: Wenn bei einem abgeleiteten Report Document ein Report-File aus der Basis gezogen wird, dann wird die Report-Datei nicht gefunden. Wird in der Ableitung die Report-Datei nicht geändert, dann wird für die Ableitung die Datei nicht rausgeschrieben - die Datei wird aber im Ordner des abgeleiteten Reports gesucht und nicht im Ordner des Basis-Report. In der Folge kommt es zu Exceptions beim Aufruf der Methode ReportEnum.GetSupportedCultures(). Die Report-Dateien müssen beim Publish auch in den Ordner des abgeleiteten Reports geschrieben werden. 2024065877 - Package-Manager: Für Runtime-Lizenzen kann im Feld \"Addition\" eine Zusatz-Info angegeben werden. Das Auslesen des Addition-Values funktioniert nicht korrekt, weshalb immer ein leerer String zurückgegeben wird. 2024055792 - IDE: UnhandledException beim Speichern einer Form, wenn eine Combobox mit ListDataSource-Properties aus Basis kopiert und in Form eingefügt wurde. 2024065859 - IDE: Beim UndoCheckOut werden neu angelegte Form-Events als Dependency ausgegeben. 2024065862 - IDE: In bestimmten Konstellationen werden falsche Controlgrößen für Fenster in FS gespeichert. So kann es sein, dass die Auswahlliste im SettingManager den Delete Button verdeckt. 2024065894 - IDE: Enthält ein customizter ServiceProxy generierte DataContracts dann werden diese beim UndoCheckout / Delete nicht geprüft und bleiben ausgecheckt hängen. Anschließend kommt es zu Fehlermeldungen bei der CheckedOut-Suche: scope = Null, result position = ResultPosition.Null [line -1] Parameter name: dataTreeRecord 4.5.17 (07.06.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.17_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Zum Customizen muss für das Basis-Package keine PKL-Lizenz mehr eingespielt werden. Die Prüfung wurde entfernt. Ab Version 4.7 wird die PKL-Lizenz komplett entfernt. Fehler, die beim Start der Application auftreten, werden teilweise in einer TargetInvocationException verpackt. Dadurch wurde dem Benutzer nur die Meldung \"Ein Aufrufziel hat einen Ausnahmefehler verursacht\" angezeigt. Die eigentliche Meldung war erst in den Details zu finden. Jetzt wird gleich die richtige Meldung ausgegeben. Korrigierte Fehler 2024035421 - Java-Client: Wenn man im Bearbeitungs-Modus vom Dashboard / Zoom den Titel der Registerkarte bearbeitet und während dessen eine neue Registerkarte einfügt, dann führt das zu Darstellungsfehlern im Layout und Fehlermeldungen in der Java-Console. Die Anwendung muss dann neu gestartet werden. 2024055777 - Publish: FSRowID Update kann nicht geöffnet werden, es wird eine Fehlermeldung.angezeigt. 2024055698 - IDE: Neu angelegte Workflow-Events werden erst nach einem Neustart von FrameworkStudio gefunden. Im Workflow-Designer kann es deshalb beim erstellen eines neuen Links zu folgender Meldung kommen: Can't create link because the selected instance '...' contains no workflow events! 2024055731 - Code-Generierung: Für die Global Objects wird der Init-Code mehrfach generiert. Im Customzing-Umgebungen führt das dazu dass der Code so oft durchlafen wird, wie es Packages in der aktuellen Hierarchie gibt. Note Damit die Korrektur zieht, muss die Package-Version einmal compiliert werden. Das funktioniert auch wenn sich die Package-Version im Service-Release-Modus befindet. 4.5.16 (03.05.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.16_Setup_x64 FS4.5.16_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf Version 23.2.5 upgedated. Es gibt einen neuen FAQ Bereich in unserer Online-Dokumentation. Hier werden wir laufend Themen ergänzen. Neuerungen Für einen Form-Container funktioniert im Java-Client jetzt die Focus-Steuerung. Das umfasst das Navigieren durch die Controls, das Reagieren auf Shortcuts in beiden Richtungen und die SetFocus-Action im inneren Form. Korrigierte Fehler 2024014866 - JavaClient: Wird am Grid in einem EditingStopped-Event mit SetCell-Actions gearbeitet, dann kann es vorkommen, dass die SetCell-Action und damit auch das EditingStarting-Event für eine Zelle mehrfach ausgeführt werden. 2024045513 - IDE: Bei der Generierung der Diffs werden bei \"Compare with Base\" die Basis auf der rechten Seite, statt der linken, angezeigt. Note Verhaltensänderung bei Compare with base. Die Reihenfolge wurde korrigiert. 2024045533 - IDE: \"Export Table Descriptions\" liefert NullReference Exception, wenn die MLDescription der Tabelle oder die MLDescriptions der Columns nicht gesetzt sind. 2024045619 - IDE: Im MethodenCode werden Service-Proxies als Fehler angezeigt und es wird kein Intellisense angeboten. 4.5.15 (05.04.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.15_Setup_x64 FSCL_4.5.15_Setup_x86 FSCL_4.5.15_Setup_x64 FS_4.5.15_Requirements_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer FS Client Launcher Es gibt einen neuen FS Client Laucher. Die enhaltenen Java-Runtimes wurden auf die neusten Sicherheitsupdates aktualisiert: Java 8 Update 392 Java 11.0.21 (für den experimetallen Einsatz) Note Alle im FS Client Launcher verwendeten Java-Versionen sind jetzt frei verwendbare OpenJDK-Builds von Azul.com. Java von Oracle wird nicht mehr verwendet. Neues Zertifikat für Jar-Dateien Important Alle Jar-Dateien für Custom Controls müssen neu signiert werden. Aufgrund von Änderungen bei unserem Zertifikat-Anbieter DigiCert haben wir ein neues Zertifikat erhalten und mussten alle unsere Jar-Dateien neu signieren. Deshalb müssen ggf. auch eigene Custom Controls neu signiert werden, weil es ansonsten beim Start der Anwendung über Java Web Start zu Fehlermendungen kommt. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.36 auf Version 7.38 aktualisiert. Das entspricht Chromium 122. Release-Notes des Control-Herstellers: https://jxbrowser-support.teamdev.com/release-notes/2024/v7-38-0.html Für uns wurde folgender Fehler korrigiert: The SearchContext::findElementsByName() method now returns non-HTML elements such as <svg> too. Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Neues Requirements-Paket beinhaltet den neuen FS Client Launcher Korrigierte Fehler 2024035335 - JavaClient: Wird innerhalb eines SVGs ein <a> href-Link mit spezieller FSCommand-Logik verwendet. Reagiert nicht die Sonderlogik innerhalb FS, sondern der Link wird als \"normaler\" Url-Link verarbeitet. Bug in JxBrowser-Fremdsoftware. 2024025169 - IDE: Nach dem Ausführen der Kommandos \"Close Others, Close Left oder Close Right\" wird der Fokus vom angezeigten Element im Tabfenster nicht korrekt gesetzt. Die Folge ist, dass im Check In Comment-Editor und auch im Toolbox-Editor nichts angezeigt wird. 2024035295 - IDE: Beim UndoCheckOut einer ConnectionGroup fehlt die Abprüfung auf Abhängigkeiten, wie Connection-Records und DBTable-Records. Wird ein UndoCheckout auf eine ConnectionGroup trotz Abhängigkeiten ausgeführt, führt dies zu fehlerhaften Datenbankdaten. 2024035320 - IDE: Beim Wechsel der Methode im Form kann es zu einer Unhandled Exception und folglich zum Absturtz von Framework Studio kommen. 2024035343 - IDE: Bei der Druckvorschau im Documentation Preview werden dem zu druckenden Dokument leere Abschnitte/Seiten hinzugefügt, sobald dieses länger als eine Seite ist. Dieser Fehler tritt nur beim Print einer Preview auf. Der Export einer Dokumentation ist hiervon nicht betroffen. 2024035372 - IDE: Nach dem Löschen einer override FormMethod und anschließendem Neustart von FS, führt ein UndoCheckout der Form zu einer NullReferenceException. Für die Form kann kein UndoCheckout mehr ausgeführt werden. 2024035425 - IDE: Beim Exportieren der Dokumentation für die DBTables kann es zu einer Exception kommen, wenn eine MLDescription einer Spalte die Zeichen \"[\", \"]\" oder \"\\\" enthält. 4.5.14 (01.03.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.14_Setup_x64 FS4.5.14_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf Version 23.2.3 upgedated. Der Monaco Code-Editor wurde auf Version 0.44.0 upgedated. Neuerungen Im Login Dialog gibt es eine neue Checkbox, mit welcher die Packages und Versions gefiltert werden können. Es gibt eine neue Auto Debug DLLs Option: Service, Component, Form, siehe Options. Korrigierte Fehler 2024014914 - IDE: In sehr seltenen Fällen kann es vorkommen, dass \"GoTo Definition\" im Code Editor bei gedrückter STRG-Taste erst bei einem zweiten Click aufgerufen wird. 2024015007 - IDE: Führt man bei CodeFiles den Befehl \"Format Dokument\" aus, dann werden Kommentare, die vor der Klasse stehen, entfernt. 2024015027 - IDE: CodeFiles können im ServiceRelease Modus ausgecheckt, jedoch nicht bearbeitet werden. 2024025056 - IDE: Im Method History Brwoser funktionieren die Compare-Buttons nicht, wenn an der Methoden-Declaration nur die Formatierung oder die Parameter-Namen geändert wurden. 2024025073 - IDE: Das Kommando \"Format Code\" wirft eine \"Can't change the declaration in Service Release.\"-Exception, wenn in der Deklaration einer SR-Methode ein Leerzeichen enthalten ist. 4.5.13 (02.02.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.13_Setup_x64 FS4.5.13_AuthService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates Der HTML Client wurde auf Angular 17.1.1 upgedated Neuerungen Im Package Manager können an der Package Version die Basis-Workspaces fixiert werden. Mit Hilfe von Hotfix-Branches ist es möglich, parallel zum laufenden Service-Release Änderungen vorzunehmen und diese kurzfristig auszuliefern. Maintenance-Routine \"Double Form Doc Cleanup\" zur Bereinigung doppelter Form-Dokumentationen. Korrigierte Fehler 2024014859 - AuthService: Wird ein Benutzer mit \"Angemeldet bleiben\" erneut angemeldet, dann wird im Auth-Service die Login-Info des Benutzers nicht aktualisiert. In der Runtime Administration werden dadurch veraltete Login-Zeiten angezeigt. 2024025113 - AuthService: Wenn eine Anwendung mit Hilfe eines zuvor gespeicherten Tokens einen aktualisierten Token anfragt (RenewToken / Angemeldet bleiben), wird nicht geprüft, ob der Benutzer weiterhin gültig ist. 2024015018 - Package Manager: Bekommt ein Basis-Package einen neuen Service-Release-Stand, dann müssen davon abhängige importierte Packages neu compiliert werden. Hat diese importierte Package-Version den Version State \"Sealed\", dann wird dieser Compile nicht ausgeführt. In der Folge kann das dazu führen, dass Service-Release-Änderungen im Basis-Package nicht greifen. Importierte Package-Versionen werden jetzt nicht mehr als \"Sealed\" angezeigt. 2024014896 - IDE: Die im Options-Dialog angegebene Schriftart und Schriftgröße hat nur Einfluss auf C#-Editoren. Editoren für HTML, CSS, XML und DocML nutzen fälschlicherweise immer die Standardwerte. 4.5.12 (05.01.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.12_Setup_x64 FS4.5.12_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf Version 23.1.6 upgedated. Die Bibliothek Oracle.ManagedDataAccess wurde von Version 21.8.0 auf die neuste Version 21.12.0 aktualisiert. Neuerungen Es wurde eine weitere \"Open compiled code in ...\" Option ergänzt. Nähere Informationen finden Sie hier. Korrigierte Fehler 2023114564 - IDE: Kopieren und das anschließende Einfügen eines Basis-Properties, wenn der Parent (Form, Component) gecustomized ist, funktioniert nicht. Wird das Property jedoch aus der Basis kopiert, ist das Einfügen erfolgreich. 2023124770 - Doku-System: Es wird eine Exception geworfen, wenn beim Export der Dokumentation über FSConsole die Sprache groß geschrieben wird, z.B. \\ISO DE 2023124781 - Doku-System: Bei einer Suche mit mehreren Wörtern in der Online-Hilfe werden ggf. zu wenige Ergebnisse angezeigt. 4.5.11 (01.12.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.11_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.33.2 auf Version 7.36 aktualisiert. Das entspricht Chromium 118. Release-Notes des Control-Herstellers: https://jxbrowser-support.teamdev.com/release-notes/2023/v7-36.html Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Neuerungen Beim Löschen von Form-Methoden gibt es jetzt eine Prüfung, ob diese Methode in einem Control-Event verwendet wird. Korrigierte Fehler 2023114553 - Java-Client: Die temporären Dateien des JxBrowsers im Temp-Verzeichnis werden nach einem Session-Ende nicht gelöscht. 2023114369 - IDE: Wenn nach dem Laden des Methods-Panels (z.B. in einer Component oder einem Form) sehr schnell eine neue Methode ausgewählt wird, bevor der Code Editor vollständig geladen ist, wird fälschlicherweiseder Code der ersten Methode in der Liste angezeigt, obwohl eine andere Methode in der Liste ausgewählt wurde. 2023114408 - IDE: Es wird eine NullReferenceException geworfen, wenn \"GoTo Definition\" auf einen MLKey ausgeführt wird. 2023114450 - IDE: Beim Undo Checkout von Compoents oder Forms kann es zu einer NullReferenceException kommen, die in der Folge die IDE einfrieren lässt. 2023114463 - IDE: Wird an einem customizten Report Document Type ein verändertes Report File gelöscht / auf Standard zurückgesetzt, dann kann es nach einem späteren Checkout und einer erneuten Bearbeitung des Report Files passieren, dass dessen Daten unvollständig gespeichert werden. In Folge sind die Änderungen nach einem Neustart von FS verschwunden und ein erneutes Bearbeiten des Report Files führt beim Save zu einer PRIMARY KEY Verletzung im Repository. 2023114362 - IDE Report Designer: Enthlät ein DevExpress Report einen Linked Subreport, dann wird beim Wechsel in den Preview eine Fehlermeldung angezeigt: The [...] type is not in the list of trusted types and therefore is not deserialized due to security reasons. 4.5.10 (03.11.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.10_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023104277 - Java-Client: Wird durch ein Event im Browser-Control (z.B. PageLoaded) eine Aktion ausgelöst, die einen modalen Dialog öffnet, dann kann es passieren, dass der Client einfriert und über den Task-Manager beendet werden muss. 2023094097 - IDE: Wird eine Methode bearbeitet und schnell auf eine andere Methode gewechselt, kann es vorkommen, dass sich der Methodeninhalt auf die neu geöffnete Methode überträgt. 2023104230 - IDE: Das Intellisense liefert ggf. keinen Vorschlag, wenn direkt nach einem Indexer-Zugriff ein Member eingegeben wird - z.B.: this.oMyColl[0].sPrope... 2023104158 - Hilfe-System: Beim Export der Dokumentation werden die Kapitel-Überschriften nicht für die Suche indiziert. Dadurch werden diese Kapitel zwar über den Index aber nicht über die Suche gefunden. 4.5.9 (06.10.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.9_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Neue Maintenance-Routine DevExpress Rtf Comment Cleanup. Korrigierte Fehler 2023093962 - Reporting: Beim Instantiieren eines DevExpress-Reports kann es zu einer NonTrustedTypeDeserializationException kommen. 2023073498 - Package-Manager: Wenn in einer Package-Hierarchie die Reihenfolge der Basis-Package-Hierarchien verletzt wird, dann kann das aufgrund von Fehlern in der Vererbung zu Laufzeit-Fehlern in der Anwendung führen. Eine falsche Reihenfolge muss als Fehler in der Hierarchie ausgegeben werden. 2023094029 - IDE: Der Name eines CrystalReports wird nicht fett gedruckt, wenn er gecustomized wurde. 4.5.8 (01.09.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.8_Setup_x64 FS4.5.8_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf Version 23.1.4 upgedated. Der HTML Client wurde auf Angular 16.2 upgedated. Das Scrolling bei vielen offenen Forms wurde im Browser und auf Tablets verbessert. Neuerungen In der IDE werden nun vor einem Compile alle ungespeicherten Elemente automatisch gespeichert. Korrigierte Fehler 2023073457 - IDE: Das Output Fenster zeigt Console-Ausgaben aus der Anwendung nicht mehr an. 2023073459 - IDE: Änderungen an Elementen sorgen dafür, dass diese in die Liste der zu compilierenden Namespaces aufgenommen werden. Werden nach dem Compile ohne zu speichern erneut Änderungen vorgenommen, dann landen diese nicht mehr in der Compile-Liste. 2023073537 - IDE: Wird an einer Grid-Column der List-Datasource zurückgesetzt, dann behält die List-Datasource im Hintergund Informationen zum Display- und Value-Member, die bei Compile zu Warnungen führen können. 2023083655 - IDE: Hat eine Methode eine Description mit mehrdeutigen Parameter-Namen, dann führt das im Intellisense beim Verwenden dieser Methode zu einer Exception. Diese wird im Output-Panel ausgegeben und das Intellisense zeigt daraufhin keine Methoden-Parameter an. 2023083693 - IDE: Wird ein Individual-Property mit gesetzter Checkbox Autogenerate Membervariable in ein Generated-Property geändert, bleibt die Checkbox im Hintergrund gesetzt. In der Folge kommt es zu Fehlern bei der Code-Generierung, weil fälschlicherweise immer noch Code für die Membervariable generiert wird. 2023093892 - DevExpress: Calculated Fields können unsere Collections nicht auswerten, weil diese als Enumeration und nicht als Liste übergeben werden. 2023083651 - Data Provider: Werden in SQL-Bedingungen mithilfe von DB.SqlString() Parameter ergänzt, dann wird für die Größe der Parameter standardmäßig die tatsächliche Länge der Werte verwendet. Dadurch entstehen sehr viele unterschiedliche Statements, die vom SQL-Server nicht wiedererkannt werden. Das beeinträchtigt die Permormance der Datenbank. Note Wenn die Werte das erlauben, werden jetzt großzügige Standardgrößen verwendet. Dadurch erhöht sich in der Praxis die Wiedererkennungsrate signifikant. 2023083750 - FS-IDE: In verschiedenen Konstellationen können beim Aufruf der Methoden-IntelliSense Exceptions geworfen werden, wenn Methodenaufrufe verschachtelt werden. 4.5.7 (28.07.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.7_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Breaking Change in der Code-Generierung Die Code-Generierung für Interfaces und Components musste überarbeitet werden, damit die Objektdaten korrekt an DevExpress-Reports übergeben und dort fehlerfrei verarbeitet werden können. Caution Ältere Framework-Studio Versionen und Package-Versionen sind nicht kompatibel. Grundsätzlich gilt das bei jedem Service-Release, aber diesen Monat muss besonders darauf geachtet werden, dass auch wirklich alle Framework-Studio-Installationen (Arbeitsplätze, Compile-Server, ...) auf die neue Version aktualisiert werden. Darüber hinaus müssen alle Package-Versionen auf einen aktuellen Stand gebracht werden. Caution In allen Packages müssen die generierten Codes mit Framwork Studio 4.5.7 neu erzeugt werden. Package-Versionen, welche sich im Service-Release-Modus befinden, müssen wieder geöffnet, compiliert und neu ausgeliefert werden. Anschließend kann die Package-Version wieder in den SR-Modus versetzt werden. Einschränkungen für Report-Scripting Aus Sicherheitsgründen wurde das Scripting für DevExpress-Reports eingeschränkt und abgesichert. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.30.2 auf Version 7.33.2 aktualisiert. Das entspricht Chromium 114. Release-Notes des Control-Herstellers: https://jxbrowser-support.teamdev.com/release-notes/2023/v7-33-2.html Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Caution Aufgrund der Systemvorraussetzungen von Chromium und JxBrowser sind für den Client mind Windows 10 bzw. Windows Server 2016 erforderlich. Aus diesem Grund müssen wir den Client-Support für Windows Server 2012 einstellen. Der Application-Broker ist von dieser Einschränkung NICHT betroffen. Korrigierte Fehler 2023073469 - Publish2Go: Das Änderungsdatum von Ressourcen-Dateien wird falsch gesetzt. Die Zeitzone wird nicht korrekt berücksichtigt. 2023063291 - IDE: Im Form-Designer wird in der Control-Eigenschaft \"SearchOperator\" der Wert \"LikeNonCaseSensitive\" nicht angeboten. 2023073362 - IDE: Das Intellisense zeigt Methoden und Properties an, die nicht für die Benutzung vorgesehen sind (z.B. nicht unterstützte Control-Actions). Das sorgt für Verwirrung. 2023073367 - IDE: neuer Code-Editor - Wenn im MessageBox-Editor ein neuer Event-Handler angelegt wird, dann wird dieser im Hintergrund selektiert. Beim Schließen des Editors landet der geänderte Methoden-Code in der falschen Methode. 2023073422 - IDE: Fehlerhafte Daten im Repository können dafür sorgen, dass der Workflow-Branch seine Bedingung in eine falsche Version schreibt. 2023073478 - FS-IDE: Eine \"Unhandled Exception\" wird beim Start von Framework Studio geworfen, wenn Port 5000 auf dem Localhost durch einen anderen Prozess reserviert wurde. 4.5.6 (30.06.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.6_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neue Systemvoraussetzungen In dieser Version gibt es Anpassungen bei den Systemvoraussetzungen. Caution Aufgrund der Systemvorraussetzungen von Chromium ist für die Framework Studio IDE mind Windows 10 bzw. Windows Server 2016 erforderlich. Aus diesem Grund müssen wir den IDE-Support für Windows Server 2012 einstellen. Die Chromium Runtime wird von den neuen Code-Editoren, verwendet. Als Application-Server kann weiterhin der Windows Server 2012 verwendet werden. Der Publish muss aber mit einem Publish2Go-Paket erfolgen, welches auf einem anderen Rechner mit der IDE bzw. den Package-Manager erstellt wurde. Updates DevExpress wurde auf Version 22.2.6 upgedated Korrigierte Fehler von DevExpress: DevExpress reagiert nicht bei Suche im Group Field Collection Editor bei Datenrekusion Lange Identifier unter Oracle Die Prüfung der Länge von Identifiern wurde von 30 auf 128 Zeichen erweitert. Diese werden von Oracle ab Version 12.2 unterstützt. Die Compile-Warnung FSWarn[2001] schlägt jetzt erst ab 129 Zeichen an. Important Wenn die Oracle-Datenbank mit einem alten Kompatibilität-Modus kleiner als \"12.2\" betrieben wird, dann sind auch weiterhin nur 30 Zeichen zulässig. Das wird von Framework Studio aber nicht geprüft. Nähere Details dazu gibt es direkt bei Oracle. Neue Code-Editoren auf Basis von Monaco Alle Code-Editoren in Framework Studio wurden technologisch auf den neuesten Stand gebracht. Alle C#-, DocML-, HTML-, CSS- und XML-Editoren basieren nun auf dem aus Visual Studio Code bekannten Monaco Editor. Ein Überblick über die neue Technologie befindet sich hier. Die wichtigste Neuerung ist hierbei der Editor-Status, der durch verschiedene Hintergrundfarben unterschieden werden kann. Die vollständige Dokumentation dazu befindet sich hier. Features Es gibt viele neue Features, die sprachunabhängig sind und somit alle Code-Editoren betreffen. Zusätzlich hat jede Programmiersprache ein eigenes Featureset im Editor. Wir empfehlen wärmstens, die neuen Features einmal zu sichten: Sprachunabhängige Features C# Editor HTML Editor CSS Editor DocML Editor Breaking Changes Nachfolgend werden diejenigen Änderungen aufgelistet, die eine Verhaltensänderung zum bisherigen Vorgehen darstellen, oder auf Grund der neuen Technologie der Editoren nicht mehr möglich sind. CheckOut Es ist nicht mehr möglich, durch Tippen im Editor das zugehörige Element (Form, Component, usw.) auszuchecken. Aus diesem Grund wurde der Quick-CheckOut implementiert. Shortcuts Der neue Editor bringt unzählige neue Shortcuts mit sich. Einige davon haben sich mit bestehenden Shortcuts im Framework Studio überschnitten. Dabei wurde die Priorität auf den Editor gelegt, sodass jemand, der sich im Visual Studio auskennt, sich auch sofort im Editor in Framework Studio zurecht findet. Eine Übersicht über alle Shortcuts befindet sich hier. Keine Diagnostic in schreibgeschützten Editoren In schreibgeschützten C#-Editoren mit dem Status Readonly oder CheckedIn werden keine Diagnostics mehr angezeigt. Go To Definition Der Shortcut für Go To Definition im C#-Editor wurde von CTRL + DoubleClick auf CTRL + Click geändert, um den Standard von Visual Studio und Visual Studio Code aufzugreifen. Drag & Drop von Code Snippets Code Snippets sind nicht mehr über die ToolBox verfügbar und können ab jetzt ausschließlich über die IntelliSense mit CTRL + J in den Code eingefügt werden. IntelliSense Icons Die IntelliSense von Monaco bietet leider kein Icon für eine C# Extension Method an. Für Extension Methods wird demnach dasselbe Icon verwendet wie für normale Methoden. Print Die Möglichkeit, in einem Editor zu drucken wurde entfernt. Quick-CheckOut Auf Grund der neuen Technologie für die Code-Editoren ist es nicht mehr möglich, ein Element (Form, Component, usw.) durch Tippen in einem Editor auszuchecken. Aus diesem Grund wurde das CheckOut-System für geöffnete Elemente angepasst. Es ist nun möglich, ein geöffnetes Element rückfragefrei auszuchecken. Dies geschieht wie üblich über das Menü Source Control, die Toolbar des Elements, oder jetzt auch mit den Shortcuts CTRL + F10 und CTRL + F11. Beim CheckIn wird, wie bisher auch, jedesmal eine Rückfrage gestellt, ob das Element eingecheckt werden soll. Auch in modalen Dialogen wie z.B. dem ListView Template Editor oder dem DocML Editor von Controls kann mit CTRL + F10 rückfragefrei ausgecheckt werden. Dadurch wird vermieden, dass der Dialog zum Auschecken geschlossen werden muss. Beim Auschecken von Elementen über den Namespace Tree ist, wie bisher auch, eine Bestätigung des Vorgangs nötig. Korrigierte Fehler 2023063292 - DevExpress: Das Speichern einer geänderten Localization im WebDesigner führt zu einer TypeError-Exception, wenn im Report ein CarryForward-Control vorhanden ist. 2023053007 - Help-System: Durch Browser-Caching kann es vorkommen, dass das angezeigte Kapitel nicht zur Auswahl im Kapitelbaum passt. 2023063205 - Code-Generierung: Component-Methoden mit optionalen Parametern können bei der Generierung des Interface-Codes Exceptions verursachen. Ein Compile ist dann nicht möglich. 2023053077 - DevExpress: Die zum letzten Patchday eingabaute \"Hülle\" um die DataSource-Objekte (Bug 2023052942) verursacht Probleme beim Einsatz von Scripting. Durch diese Hülle haben die Objekte nicht mehr den ursprünglichen Typ. Darüber hinaus liefert in einem Calculated Field OnGetValue-Script die Methode GetColumnValue() keine Werte mehr. Note Die Anpassung wurde zurückgebaut und die Reporting-Schnittstelle verhält sich jetzt wieder wie zuvor. Die im Bug 2023052942 beschriebenen Probleme treten dadurch jetzt wieder auf. Wir arbeiten an einer Lösung für die Version 4.5, die vorraussichtlich zum nächsten Patchday ausgeliefert wird. In der Version 4.4 wird es keine Korrektur mehr geben. Der ursprünglich mit Version 4.4.18 korrigiert Bug: 2023052942 - DevExpress: Calculated Fields und Expressions mit Aggregate-Funktionen greifen nicht über unser Rptx-Interface auf die Instanzen zu sondern über die Klasse. Dadurch arbeitet der Report mit falschen Typen und es kann zu inhaltlichen Fehlern kommen. So werden z.B. Bilder nicht angezeigt, weil DevExpress mit dem FS-Typ FSbyteArray nichts anfangen kann. Ticket bei Dev-Express: https://supportcenter.devexpress.com/ticket/details/t1165586/aggregate-expression-uses-class-properties-instead-of-explicit-interface-implementation 4.5.5 (26.05.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.5_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Für Text-Resourcen steht die Auswahl eines Encoding bereit. Das Encoding wird bei neu hinzugefügten Resourcen und auch bei bereits bestehenden automatisch ermittelt. Bei bestehenden Resourcen wird jedoch erst bei einer Bearbeitung das Encoding abgespeichert. Eine Konvertierung in ein anderes Encoding kann in beiden Fällen vorgenommen werden. Mehr Informationen zum Funktionsumfang findet sich hier. Korrigierte Fehler 2023042824 - Broker: Eine Listbox oder Combobox verwendet als Listen-Datasource eine Collection. Werden aus dieser Collection Records entfernt, dann werden die entsprechenden Einträge nicht aus dem Controls entfernt. 2023042844 - IDE: In einem customizten Report Document Type kann für einen Basis-Report eine neue Datei importiert werden. Wählt man in der Dateiauswahl eine Datei mit abweichendem Namen aus, dann wird eine Rückfrage angezeigt, ob der Report-Name geändert werden soll. Das Ändern des Namens ist im Customizing jedoch gar nicht möglich. 2023052888 - IDE: Die Rename-Aktion für Namespaces ist aktiv, auch wenn ein Rename nicht ausgeführt werden darf. 2023052947 - IDE: Für eine Component werden bei der Dependency-Suche Component-Properties ermittelt, obwohl diese aufgrund eines Datenbank-Mapping einen ganz anderen Datentyp als die Component besitzen. Grund dafür sind ungültige Repository-Daten. Diese haben ansonsten bei der normalen Arbeit keine Auswirkung. 2023052863 - DevExpress: Bei einem neu angelgeten SQL-Server-Entwicklungs-Repository erhält die Sql-Server-Rolle FrameworkBrokerRole keinen Zugriff auf die Tabelle tblRep_ReportDesign. Dadurch kann es in der Anwendung bei Verwendung des DevExpress Report-Web-Designers zu folgendem SQL-Fehler kommen: The INSERT permission was denied on the object 'tblRep_ReportDesign' Note Neue Repositories werden in Zukunft richtig angelegt. Bestehende Repositories werden nicht automtisch korrigiert. Mit dem folgenden Script können fehlerhafte Repositories bei Bedarf manuell korrigiert werden. GRANT SELECT, UPDATE, INSERT, DELETE ON tblRep_ReportDesign TO FrameworkBrokerRole; 2023052900 - DevExpress: Werden im Report-Designer mehrere Felder auf einmal in den Report gezogen, dann erstellt der Designer automatisch eine Tabelle. Zieht man diese Felder mit der rechten Maustaste in den Report, dann sollte er dieselbe Tabelle allerdings mit Beschriftungen der jeweiligen Felder anlegen. Die Tabelle ist jedoch komplett leer. Vergleiche auch https://docs.devexpress.com/XtraReports/120025/detailed-guide-to-devexpress-reporting/use-report-controls/use-tables/bind-table-cells-to-data 2023052932 - DevExpress: (Verbesserung) Ein Foldmark-Control kann jetzt auch in einem Sub-Report platziert werden. Die Falzmarken werden dabei auf allen Seiten des Haupt-Reports platziert - unabhängig davon, an welcher Position der Sub-Report platziert ist. 4.5.4 (28.04.2023) Updates DevExpress wurde auf Version 22.2.4 upgedated Requirements Anpassungen Der DevExpress Report Web-Designer benötigt keine ASP .NET Core Runtime 3.1 mehr. Von der Installations-Routine wird diese Runtime nicht mehr geprüft und sie wurde aus dem Requirements-Paket entfernt. Mit dem Update von DevExpress Web-Designers auf .net 6 haben wir diesen so umgestellt, dass die benötige Runtime bereits enhalten ist (Self Contained). 4.5.3 (31.03.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.3_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Am GridView gibt es ein neues Event EntriesSortedOrFiltered. Korrigierte Fehler 2023032382 - Broker: Wird eine Gridspalte mit \"LIKE\" gefiltert, werden ggf. keine Treffer gefunden, wenn sich der gesuchte Begriff in einem mehrzeiligen Text befindet. 2023022303 - IDE: Beim Compile kann es vorkommen, dass Aufrufe von obsoleten Methoden nicht als Warning ausgegeben werden. Das ist z.B. der Fall, wenn bei einem Message-Box Aufruf ein obsoleter Event-Handler verwendet wird. Note Es handelte sich um einen Fehler im CSharp-Compiler. Mit einem Update auf eine neue Version des Compilers konnte das Problem behoben werden. Die neue Compiler-Version hat zudem eine 15%-20% bessere Performance. 2023032595 - Code-Generierung: Wird eine Form und der zugehörige Workflow gecustomized, so wird bei der Code-Generierung in der Customized-Form der Code für das WorkflowEvent zusätzlich generiert. In Folge dessen verdeckt das WorkflowEvent in der Customization das WorkflowEvent aus der Basis. Dies kann beispielsweise zur Folge haben, dass Forms nicht mehr geöffnet werden können. 4.5.2 (24.02.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Update des Runtime Repository nötig Auf Grund von Bug 2023022188 muss beim Publish2Go das Runtime Repository nochmals upgedated werden. Beim Publishen einer Applikation erscheint dann ggf. die Warnung \"The selected runtime repository is not prepared for this version of Publish2Go. You have to prepare the runtime repository before you can publish.\". Um diese Situation zu lösen, muss im Publish2Go Wizard unter Connection Groups die RuntimeConnection ausgewählt werden und mit dem Button Prepare Runtime Repository die fehlenden Scripte ausgeführt werden. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.27 auf Version 7.30.2 aktualisiert. Das entspricht Chromium 108. Release-Notes des Control-Herstellers: https://jxbrowser-support.teamdev.com/release-notes/2023/v7-30-2.html Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Neuer HTML Client Der HTML Client wurde auf Angular 15.1 upgedated. Neue Features oder Bugfixes gibt es nicht. Korrigierte Fehler 2023022188 - Broker: Clientside Report Customizing (DevExpress) funktioniert nicht mit Applikationen, die mit einem Runtime-Repository arbeiten, auf einem IIS gepublished wurden, oder eine Oracle-Datenbank als Runtime-Connection nutzen. 2023012107 - IDE: Im ReportDocumentType können gelöschte DataSources oder Properties dazu führen, dass bei einer Änderung des Reports im Service Release eine Meldung \"Can't delete objects of Service Release 4.x\" angezeigt wird. 2023012036 - Doku-Export: In bestimmten Konstellationen fehlen bei einem Dokumentationsexport gecustomizte Elemente (Bsp: Checkbox auf Screenshots) und deren Dokumentation in der Gesamtdokumentation. 4.5.1 (26.01.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2023011937 - JavaClient: Die Jar-Dateien für das neue Browser-Control sind nicht signiert. Deshalb ist ein Start der Anwendung über Java-Webstart nicht möglich. 2023012014 - Publish2Go: Publish2Go kann nicht ausgeführt werden, wenn der IIS nicht installiert ist (z.B. zur Installation von ServiceHosts). 2021118441 - IDE: Bei Workflow-Links, deren Quelle ein Global-Event-Handler ist, kann keine Instance-ID angegeben werden. Die Auswahl-Combobox zeigt keine Einträge an. 2022121811 - IDE: Die in der IDE im Form-Designer eingestellte Sortierung an Grid-Spalten funktioniert nicht. Note Die Einbau dieses Features umfasst auch eine Anpassung in der Code-Generierung. Damit die Einstellungen korrekt ziehen muss der Quellcode des Forms neu aufgebaut werden. Im Service-Release Modus reicht es, das betroffene Form einmal aus- und wieder einzuchecken. 2022121833 - IDE: In einer grafischen Transformation kann bei FSstring-Properties die Checkbox \"Ignore nulls\" nicht gesetzt werden. 2022121864 - IDE: Das Intellisense erkennt Component-Typen nicht und zeigt diese als Fehler an. 4.5.0 (23.12.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.5.0_Setup_x64 FSCL_4.4.13_Setup_x86 FSCL_4.4.13_Setup_x64 FS_4.4.13_Requirements_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer FS Client Launcher Es gibt einen neuen FS Client Launcher. Der mit Version 4.4.11 ausgelieferte Client Launcher enthielt eine aktuellere Java-Runtime (8 Update 282). Diese hat teilweise dazu geführt, dass eNVenta ERP bei Drag&Drop Vorgängen eingefroren ist und über den Task-Manager beendet werden musste. Im neu ausgelieferten FS Client Launcher ist deshalb wieder die bewährte Java Runtime Version 8 Update 202 enthalten. Abkündigung des MSI-Installers für den FS Client Launcher Der MSI-Installer wird nicht mehr angeboten. Weitere Informationen finden sie hier. Neues Requirements-Paket enthält den neuen FS Client Launcher 4.4.13 Fremd-Bibliotheken aktualisiert Die folgenden Bibliotheken, die auch im Application-Broker zum Einsatz kommen, wurden auf eine neue Version aktualisiert. Newtonsoft.Json 12.0.2 -> 13.0.1 Oracle.ManagedDataAccess 19.13 -> 21.8 HtmlAgilityPack 1.11.4 -> 1.11.46 Korrigierte Fehler In der Version 4.5 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.4.13 enthalten. Zusätzlich wurden die folgenden Bugs behoben. 2022080621 - Reporting: Bei DevExpress Reports wird ein FSstring.Null als String.Empty an den Report-Datasource übergeben. Analog zu den anderen Datentypen sollte in so einem Fall null übergeben werden. 2022049581 - IDE: Wird ein Dev-Broker gestartet und der Port ist bereits von einem anderen Prozess blockiert, dann wird eine unspezifische System.Net.HttpListenerException ausgegeben."
  },
  "articles/release-4-6.html": {
    "href": "articles/release-4-6.html",
    "title": "Release-Information Framework Studio 4.6",
    "keywords": "Release-Information Framework Studio 4.6 4.6.15 (07.03.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.15_Setup_x64 Weitere Pakete (Dateinamen ohne ZIP-Endung) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.41.5 auf Version 7.42.0 aktualisiert. Das entspricht Chromium 132. Release-Notes des Control-Herstellers: https://teamdev.com/jxbrowser/release-notes/2025/v7-42-0/ Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Neuerungen Der Sql-Parser versteht jetzt WITH-Statements, auch bekannt als Common Table Expression (CTE). Korrigierte Fehler 2025027380 - Java Client: Wenn an einer Registerkarte das Event OnFirstSelect implementiert ist, dann kann es passieren, dass bei der ersten Eingabe in einem TextFeld das OnLeave-Event nicht korrekt gefeuert wird. 2025017265 - Java-Client: Wenn ein Form, das über ein Event geschlossen werden soll, im selben Zug fokussiert wird, kommt es zu einer Fehlermeldung. 2025027375 - Package-Manager: In einem Oracle-Repository kann es passieren, dass das Update einer Package-Version zu einem Fehler führt. Im Script 4.6.0.0 2022.11.18 DeprecatedLayoutCheck.ora wird eine Sql-Exception ausgegeben FS.DataClient.FrameworkDbException: ORA-00932: Inkonsistente Datentypen: CHAR erwartet, NUMBER erhalten. 2025017231 - IDE: Wird nach dem Kopieren und Einfügen eines Combobox- oder ListBox-Controls das Property, das als ListDataSource definiert ist nicht eingefügt, so kommt es beim Speichern des Forms zu einer Unhandled Exeption und die Anwendung stürzt ab. 2025017263 - IDE: Wenn im Wörterbuch für einen MLKey ein mehrzeiliger Text mit einfachen Zeilenumbrüchen ( \\n / LF ) statt den üblichen ( \\r\\n / CR+LF ) definiert wurde, dann gibt es Probleme bei der Verarbeitung des Textes: In der Tabelle im Multilanguage Text Editor wird der Text mehrzeilig angezeigt - das zieht die Tabelle auseinander. Der Exception-Editor erzeugt einen mehrzeiligen Code, der Compile-Fehler produziert und der Exception-Editor erkennt diesen Code nicht korrekt. 2025027305 - Framework: Die Methode LoadCount() liefert bei GroupBy-Components falsche Werte zurück. Die Anzahl der Sätze wird in einer Gruppierung ermittelt. 4.6.14 (07.02.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.14_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf die Version 24.2.3 aktualisiert. Der HTML Client wurde auf Angular 19.1.1 upgedatet. Neuerungen Bei Klicken auf einen Link im Errors and Warnings Tab wird dieser farblich hervorgehoben, um zu visualisieren, dass der Link bereits besucht wurde. Bei den Aktionen Open, Save (im FS Report Designer), sowie Choose Report wird nun das Verzeichnis der tatsächlichen Report-Datei geöffnet, statt das Haupt-Reportverzeichnis. Korrigierte Fehler 2025017196 - Reporting: Im WebDesigner ist der Expression Editor nicht nutzbar, da weder Formeln angezeigt noch bearbeitet werden können. 2025017210 - Publish2Go: Wird ein Publish2Go-Paket mit mehreren Applications erstellt, dann enthält das Paket nur eine FSJavaClient.jnlp. In der Folge ziehen einige Einstellungen der Application (z.B. Java Heap Size) nicht korrekt. 2024127103 - IDE: Im Formula Converter des DevExpress Report-Designer werden Properties mit einem Package-Prefix nicht korrekt erkannt. Der Unterstrich wird durch einen Punkt erstzt. oObject_oP01_MyColl.shtK07_MyProperty wird zu oObject.oP01.MyColl.shtK07.MyProperty anstatt zu oObject.oP01_MyColl.shtK07_MyProperty 2025017187 - IDE: Der MultiLanguageText-Editor erzeugt Excpetions, wenn es einen überschriebenen Text ohne passenden Text aus dem Basis-Package gibt. 2025017272 - Code-Generierung: Wenn man eine Code-Transformation customized, dann erzeugt falsch generierter Code einen Compile-Error \"Type expected\". 2024096531 - DevExpress: Wird in einem Report mit Gruppen in einigen Positionen eine RunningSum angezigt, dann stimmt der angezeigte Wert nicht. Es handelt sich um einen Fehler in DevExpress: https://supportcenter.devexpress.com/ticket/details/t1255491 4.6.13 (03.01.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.13_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.40.0 auf Version 7.41.5 aktualisiert. Das entspricht Chromium 131. Release-Notes des Control-Herstellers: https://teamdev.com/jxbrowser/release-notes/2024/v7-41-5/ Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Weitere Updates Das CefSharp Browser-Control in der IDE wurde auf Version 131.3.10 upgedatet. Korrigierte Fehler 2024127052 - Java-Client: Der Fokus eines neu geöffneten Forms geht verloren, wenn während des Öffnens ein Event (z.B. SelectedTabPageChanged) gefeuert wird. 2024126994 - Package-Manager: Wird für eine Package-Version ein Hotfix importiert, dann kommt es zu Null-Exceptions beim Compile und beim Export von darauf aufsetzenden Package-Versionen. 2024127022 - IDE: Bei einer Änderung der AccessUnits im FormDesigner wird der Speicherbutton nicht aktiv. 2024127026 - Framework: Wird bei einem Aufruf von Clone() oder AdoptValue() ein AdoptMode.NoHistory übergeben, dann wird dieser nicht in den Clone() der Unterobjekte übergeben. In der Folge funktioniert in eNVenta das Kopieren von historisierten Belegen nicht korrekt. 4.6.12 (06.12.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.12_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Im Element History Browser, sowie im Method History Browser wurde der Monaco eigene Diff-Editor eingebaut. Der Vergleich mit einem externen Tool ist dennoch möglich. Im Class-Code und Namespace-Code (Generated-Code) kann man im Editor nun einen Code-Refresh ausführen. Korrigierte Fehler 2024116925 - Package-Manager: Beim Export eines Package-Stacks, bei welchem Packages ohne Owner-Status dabei sind, verliert der Export das korrekte Created Workspace Datum. Beim Import dieses Package-Stacks in ein anderes Repository haben dann alle Packages das Export Datum des zweiten Exports. 2024116779 - IDE: Die maximal Request Größe eines REST Service endpoints ist zu gering. Note Es ist jetzt möglich manuell einen REST-Endoint mit individuellen Binding-Einstellungen anzulegen. Dort kann die Größe der Messages an die Bedürfnisse angepasst werden. 2024116848 - IDE: Wird für einen ServiceProxy, der einen externen Service anbindet, ein anderer Collection Type als System.Array oder System.Collection.ArrayList ausgewählt, kann der Proxy über 'Generate Proxy' nicht mehr generiert werden. 2024116929 - Data Provider: Wird der Funktion DB.SqlString() ein ganzzahliger Decimal-Wert, mit 13, 14 oder 15 Stellen übergeben, dann führt die Ausführung des SQL-Statemens zu einer SQL-Exception. 2024116875 - Framework: Die SortAndFilter()-Methode hat keine Auswirkung auf das Grid, wenn diese im OnLoad oder in der TargetMethod des Workflows aufgerufen wird. 4.6.11 (08.11.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.11_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates Der Monaco Code-Editor wurde auf Version 0.50.0 upgedatet. Das CefSharp Browser-Control in der IDE wurde auf Version 129.0.110 upgedatet. Der HTML Client wurde auf Angular 18.2.2 upgedatet. Bitte beachten Sie die geänderten Systemvoraussetzungen für die App. Es werden nur noch Geräte mit Android 8.0 (API-Level 26) oder höher unterstützt. Korrigierte Fehler 2024106684 - Reporting: Wird ein DevExpress Report als HTML exportiert, dann werden die Bilder (z.B. Barcodes) nicht eingebettet, sondern als Datei referenziert. 2024106579 - IDE: Beim Beenden des Development Service Host läuft dieser 2 mal in die Methode OnServiceHostExit(). 4.6.10 (04.10.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.10_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Das Anlegen eines neuen Repositorys funktioniert jetzt auch mit den strengeren Password-Regeln in SQL-Server 2022. Korrigierte Fehler 2024096453 - Reporting: Bei Update eines Oracle Repositories auf die Versionen 4.4 wurde beim Anlegen der Tabelle tblRep_ReportDesign die Spalte RPTD_Modified vergessen. Dadurch können keine im Client keine DevExpress-Reports bearbeitet werden. Note Beim nächsten Update des Repositories auf Version 4.5, 4.6 oder 4.7 wird die Tabelle automatisch korrigiert. Um ein aktuelles Oracle-Repository nachträglich zu korrigieren gehen Sie wie folgt vor: Bei einem Entwichlungs-Repository bitte im Programm-Verzeichnis die FrameworkStudioUpgradeDatabase.exe ausführen, am Rpository anmelden und den Update durchführen. Bei einem Runtime-Repositoy bitte im Publish-Wizard bzw. Run-Wizard den Button Prepare Runtime Repository drücken und den Update ausführen. 2024096396 - IDE: Bei der Anzeige des Load-Commands eines Relation-Properties kann es zu Fehlermeldungen kommen. 2024096457 - IDE: Die für den Code-Editor verwendete Chromium Runtime arbeitet im Hintergrund mit einem Cache, welcher auch nach dem nächsten Start weiter verwendet wird. Dadurch kann es passieren dass ein Update des Code-Editor erst mit mehreren Tagen Verzögerung zieht. 2024096521 - IDE: Wenn ein Link an einen Workflow hinzugefügt wird, der keine WorkflowEvents definiert hat oder die bestehenden WorkflowEvents keine Verknüpfungen haben, kommt es beim Öffnen des Links, sobald er mit einem anderen Workflow oder Form verbunden wurde, zu einer ArgumentNullException. Der Link kann dann nicht mehr geöffnet werden. 4.6.9 (06.09.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.9_Setup_x64 FS4.5.20_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf Version 24.1.4 upgedated. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.38.0 auf Version 7.40.0 aktualisiert. Das entspricht Chromium 127. Release-Notes des Control-Herstellers: https://jxbrowser-support.teamdev.com/release-notes/2024/v7-40-0.html Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Neuerungen Die Include Base Packages Funktion im Package-Export über den Package-Manager und die FSConsole bzw. PBE wurde überarbeitet. Korrigierte Fehler 2024086212 - Java-Client: Wird ein Client nicht regulär beendet, dann bleiben temporäre Ordner des JxBrowser-Controls hängen. Passiert das häufiger (z.B. mit F5 aus der IDE heraus), dann sammeln sich sehr viele Ordner an. 2024086290 - Publish2Go: Im Publish2Go Wizard wird bei der ConnectionGroup immer \"Conn1\" angezeigt, statt des korrekten ConnectionGroup Namens. 2024086169 - IDE: FS stürzt mit einer Unhandled NullReferenceException ab, wenn für mehrere Comboboxen gleichzeitig die MaxDropDownSize geändert wird. 2024086225 - IDE: Wird eine Hotfix Package-Version compiliert, dann werden Warnungen ausgegeben, die in der normalen Package-Version nicht angezeigt werden sollen. 2024086326 - IDE: Wird an einem TreeControl auf zweiter Ebene eine NodeDataSource angelegt, ist diese nach einem Neustart von FS nicht mehr gesetzt. 4.6.8 (02.08.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.8_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Referenz-Prüfung für Ressourcen Über eine neue API können im Broker Inhalte bereitgestellt werden. Diese können vom Client heruntergeladen werden. Die beiden Actions SetMinWidth und SetMaxWidth für GridColumns wurden umgesetzt Korrigierte Fehler 2024045657 - Java-Client: An einem Grid ist MultiSelect und Drag&Drop aktiv. Wenn man mit Strg+A alle Zeilen selektiert und anschließend mit Strg+Klick eine Zeile deselektiert, dann werden bei dem dadurch ausgelösten RowClick-Event die SelectedRows nicht zum Broker übertragen. In der Folge kann es zu Fehlverhalten in der Anwendung kommen. Im eNVenta Auftrag/Angebot z.B. werden dabei wieder alle Zeilen deselektiert. 2024055750 - IDE: Verschiebt man Elemente mit der Funktion \"Change Namespace\" in einen anderen Nemspace, dann wird das verschobene Element auch weiterhin im alten Namespace angezeigt. Die IDE muss neu gestartet werden, damit die Anzeige wieder stimmt. 2024075974 - IDE: Wird aus der Datasource Hierarchy Search eine DBTable Column geöffnet, wo die zugehörige DBTable bereits im Hintergrund geöffnet und ausgecheckt ist, übernimmt die Column den Metadatatype der zuvor selektieren Column. 2024076053 - IDE: Werden im Code (z.B. einer Transformation) mehrere DataContracts eines generierten ServiceProxies verwendet, dann kann es passieren, dass im Code Ambiguity-Errors angezeigt werden. Bei Compile treten diese aber nicht auf. 2024076086 - IDE: Wird ein Service ausgecheckt und geändert, dann zieht für den generierten Service-Proxy weiter der Saved Code. Es ist ein expliziter Compile ohne Saved Code erforderlich damit die Änderungen ziehen. 2024076089 - IDE: Wird in einem Service eine private oder protected Methode angelegt, dann wird diese im generierten Service-Proxy als Operation erkannt. Sie wird auch in den Proxy-Code generiert und das führt zu Compile-Fehlern. Der Service-Proxy darf nur die public-Methoden anbieten, die auch im Service-Interface landen. 2024076110 - IDE: Wird ein MDT gelöscht und die zugehörige DBTable, welche den MDT in einer Column zuvor nutzte, wird nicht eingecheckt, erfolgen beim Compile mit einem anderen User Compilefehler. Diesen Compilefehler in Form einer NullReferenceException haben wir mit dem Namen der DBTable und der DBColumn als Info ergänzt. 2024076021 - Code-Generierung: Nach der Korrektur des Bugs 2024055731 treten beim Compile im Customizing Warnings auf, wenn Global Objects im Basis-Package als Obsolete markiert sind. 2024076058 - DevExpress Report Designer: Wenn ein Linked SubReport eingebunden und die Report Source Url angegeben wird, dann kann es sein, dass eine Fehlermeldung angezeigt wird: The report ~.....repx contains untrusted data types. Please contact the application vendor or system administrator for assistance. Die URL kann somit nicht angegeben werden. 2024076025 - Package Manager: Beim Compile über den Compile-Wizard / FSConsole.exe kann es bei den Ressources zu Exceptions kommen, wenn Dateien vom Virenscanner blockiert werden. 2024076051 - Package Manager: Tritt beim Compile ein Warning ohne Bezug zum Code auf (z.B. CS1702), dann wird im Compile Log eine NullReference-Exception ausgegeben. Die Liste der Warnings ist ggf. unvollständig. 2024076101 - Package Manager: Der Package-Tree wird beim Löschen oder Hinzufügen von Packages nicht aktualisiert, wenn \"Show only applicable packages\" aktiviert ist. 2024076119 - Package Merge: Beim Customizing einer DBTable wird der Wert der \"View\" auf einen falschen Wert gesetzt. Dieser ist in der IDE unwichtig und wird dort ignoriert. Beim Package Merge wird jedoch der falsche Wert vom Customizing in das Target-Package überschrieben. Dies führt später zu Fehlern. 4.6.7 (05.07.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.7_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Bekannte Probleme Der Client hängt sich beim Drag&Drop (vom Desktop oder Explorer) auf und muss über den Taskmanager beendet werden. Es handelt sich hierbei um einen Fehler in der Java-Runtime. Bug bei OpenJdk Leider ist dieser Fehler seit über einem Jahr nicht gefixt und er betrifft praktisch alle aktuellen Versionen der Java-Runtime. Es gibt auch keine Ansätze, wie wir das in unserer Programmierung lösen könnten. Der Fehler kam mit Java 8 Update 361 rein. Mit dem FS Client Launcher Version 4.5.15 haben wir auf eine aktuelle Java-Runtime Java 8 Update 392 aktualisiert. Wir können nicht auf eine ältere Version zurück gehen, weil wir ansonsten sicherheitstechnisch mit einem sehr veralteten Stand agieren müssten. Mit der Kenntnis, wie genau dieser Fehler auftritt, ist dieser ziemlich leicht zu reproduzieren: Der Fokus muss in eNVenta in einem Textfeld stehen (gelb hinterlegt) Direkt aus dem Explorer oder dem Desktop (ohne vorher dorthin zu klicken) eine Datei in die Anwendung ziehen. Nach wenigen Versuchen friert die Anwendung ein. Daraus lassen sich mögliche Workarounds ableiten: am einfachsten vor dem Drag&Drop einmal in den Explorer bzw. den Desktop klicken. Alternativ können Sie auf eigenes Risiko auch auf den alten FS Client Launcher 4.4.13 zurückfallen. Dieser arbeitet mit Java 8 Update 202, welche aber einen extrem veralteten Sicherheitsstand hat. Wenn Sie die Installation einer alten Version vorziehen, muss zuerst der aktuelle FS Client Launcher deinstalliert werden - ein \"Rückwärts-Update\" funktioniert nicht. Wir werden diesen Fehler weiter beobachten. Sobald Java das fixt, liefern wir einen aktualisierten FS Client Launcher aus. Neuerungen Neues Kapitel in der Doku: Databinding in Forms Im Publish2Go Wizard gab es bisher die Option nachträglich Service Release Dateien auszutauschen. Da seit FS Version 4.4 die entsprechenden SR-Dateien nicht mehr erstellt werden, haben wir uns dazu entschieden diese Option zu deaktivieren. Ab FS 4.7 werden wir diese Option komplett entfernen! Wenn Sie die Service-Release-Funktion für das Ersetzen von anderen Datei-Typen (z.B. Reports) verwendet haben und dies auch weiterhin benötigen, können Sie die Option über die App.Config im Publish-Ordner wieder aktivieren. Note Bitte melden Sie sich unbedingt bei unserem Support, wenn Sie die Service-Release Option aktivieren und warum Sie dies benötigen. Korrigierte Fehler 2024065939 - Broker: Wird über den HTML-Client eine TakePhoto-Action ausgeführt und diese liefert ein großes Bild mit mehr als 3 MB, dann meldet der Server eine HTTP 500 Fehlermeldung. Die Session der Anwendung muss beendet werden. Fotos können mit aktuellen Handy-Kameras problemlos 5MB oder größer sein. Note Die neue Einstellung, welche jetzt beim Publish angewendet wird, erlaubt Bilder mit einer Größer von ca. 18MB. 2024075973 - Publish: Wenn bei einem abgeleiteten Report Document ein Report-File aus der Basis gezogen wird, dann wird die Report-Datei nicht gefunden. Wird in der Ableitung die Report-Datei nicht geändert, dann wird für die Ableitung die Datei nicht rausgeschrieben - die Datei wird aber im Ordner des abgeleiteten Reports gesucht und nicht im Ordner des Basis-Report. In der Folge kommt es zu Exceptions beim Aufruf der Methode ReportEnum.GetSupportedCultures(). Die Report-Dateien müssen beim Publish auch in den Ordner des abgeleiteten Reports geschrieben werden. 2024065877 - Package-Manager: Für Runtime-Lizenzen kann im Feld \"Addition\" eine Zusatz-Info angegeben werden. Das Auslesen des Addition-Values funktioniert nicht korrekt, weshalb immer ein leerer String zurückgegeben wird. 2024055792 - IDE: UnhandledException beim Speichern einer Form, wenn eine Combobox mit ListDataSource-Properties aus Basis kopiert und in Form eingefügt wurde. 2024065859 - IDE: Beim UndoCheckOut werden neu angelegte Form-Events als Dependency ausgegeben. 2024065862 - IDE: In bestimmten Konstellationen werden falsche Controlgrößen für Fenster in FS gespeichert. So kann es sein, dass die Auswahlliste im SettingManager den Delete Button verdeckt. 2024065894 - IDE: Enthält ein customizter ServiceProxy generierte DataContracts dann werden diese beim UndoCheckout / Delete nicht geprüft und bleiben ausgecheckt hängen. Anschließend kommt es zu Fehlermeldungen bei der CheckedOut-Suche: scope = Null, result position = ResultPosition.Null [line -1] Parameter name: dataTreeRecord 4.6.6 (07.06.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.6_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Zum Customizen muss für das Basis-Package keine PKL-Lizenz mehr eingespielt werden. Die Prüfung wurde entfernt. Ab Version 4.7 wird die PKL-Lizenz komplett entfernt. Fehler, die beim Start der Application auftreten, werden teilweise in einer TargetInvocationException verpackt. Dadurch wurde dem Benutzer nur die Meldung \"Ein Aufrufziel hat einen Ausnahmefehler verursacht\" angezeigt. Die eigentliche Meldung war erst in den Details zu finden. Jetzt wird gleich die richtige Meldung ausgegeben. Korrigierte Fehler 2024035421 - Java-Client: Wenn man im Bearbeitungs-Modus vom Dashboard / Zoom den Titel der Registerkarte bearbeitet und während dessen eine neue Registerkarte einfügt, dann führt das zu Darstellungsfehlern im Layout und Fehlermeldungen in der Java-Console. Die Anwendung muss dann neu gestartet werden. 2024055777 - Publish: FSRowID Update kann nicht geöffnet werden, es wird eine Fehlermeldung.angezeigt. 2024055698 - IDE: Neu angelegte Workflow-Events werden erst nach einem Neustart von FrameworkStudio gefunden. Im Workflow-Designer kann es deshalb beim erstellen eines neuen Links zu folgender Meldung kommen: Can't create link because the selected instance '...' contains no workflow events! IDE: ChooseTheme Menü zeigt IDs statt Names. IDE: Select Repository Connection bei Eingabe des Users werden Grid-Events ausgelöst. 2024055731 - Code-Generierung: Für die Global Objects wird der Init-Code mehrfach generiert. Im Customzing-Umgebungen führt das dazu dass der Code so oft durchlafen wird, wie es Packages in der aktuellen Hierarchie gibt. Note Damit die Korrektur zieht, muss die Package-Version einmal compiliert werden. Das funktioniert auch wenn sich die Package-Version im Service-Release-Modus befindet. 4.6.5 (03.05.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.5_Setup_x64 FS4.5.16_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf Version 23.2.5 upgedated. Es gibt einen neuen FAQ Bereich in unserer Online-Dokumentation. Hier werden wir laufend Themen ergänzen. Neuerungen Für einen Form-Container funktioniert im Java-Client jetzt die Focus-Steuerung. Das umfasst das Navigieren durch die Controls, das Reagieren auf Shortcuts in beiden Richtungen und die SetFocus-Action im inneren Form. Korrigierte Fehler 2024014866 - JavaClient: Wird am Grid in einem EditingStopped-Event mit SetCell-Actions gearbeitet, dann kann es vorkommen, dass die SetCell-Action und damit auch das EditingStarting-Event für eine Zelle mehrfach ausgeführt werden. 2024035398 - IDE: Die UI-Performance bei einem ServiceProxy mit vielen Service Operations ist langsam. So kann bspw. ein Save des ServiceProxy sehr lange dauern. 2024045513 - IDE: Bei der Generierung der Diffs werden bei \"Compare with Base\" die Basis auf der rechten Seite, statt der linken, angezeigt. Note Verhaltensänderung bei Compare with base. Die Reihenfolge wurde korrigiert. 2024045533 - IDE: \"Export Table Descriptions\" liefert NullReference Exception, wenn die MLDescription der Tabelle oder die MLDescriptions der Columns nicht gesetzt sind. 2024045611 - IDE: Die Goto-Befehle (Open Customization, Open Customization Base, ...) haben keine Shortcuts mehr. 2024045619 - IDE: Im MethodenCode werden Service-Proxies als Fehler angezeigt und es wird kein Intellisense angeboten. 4.6.4 (05.04.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.4_Setup_x64 FSCL_4.5.15_Setup_x86 FSCL_4.5.15_Setup_x64 FS_4.5.15_Requirements_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuer FS Client Launcher Es gibt einen neuen FS Client Laucher 4.5.15. Die enhaltenen Java-Runtimes wurden auf die neusten Sicherheitsupdates aktualisiert: Java 8 Update 392 Java 11.0.21 (für den experimetallen Einsatz) Note Alle im FS Client Launcher verwendeten Java-Versionen sind jetzt frei verwendbare OpenJDK-Builds von Azul.com. Java von Oracle wird nicht mehr verwendet. Neues Zertifikat für Jar-Dateien Important Alle Jar-Dateien für Custom Controls müssen neu signiert werden. Aufgrund von Änderungen bei unserem Zertifikat-Anbieter DigiCert haben wir ein neues Zertifikat erhalten und mussten alle unsere Jar-Dateien neu signieren. Deshalb müssen ggf. auch eigene Custom Controls neu signiert werden, weil es ansonsten beim Start der Anwendung über Java Web Start zu Fehlermendungen kommt. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.36 auf Version 7.38 aktualisiert. Das entspricht Chromium 122. Release-Notes des Control-Herstellers: https://jxbrowser-support.teamdev.com/release-notes/2024/v7-38-0.html Für uns wurde folgender Fehler korrigiert: The SearchContext::findElementsByName() method now returns non-HTML elements such as <svg> too. Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Neues Requirements-Paket beinhaltet den neuen FS Client Launcher 4.5.15 Korrigierte Fehler 2024035335 - JavaClient: Wird innerhalb eines SVGs ein <a> href-Link mit spezieller FSCommand-Logik verwendet. Reagiert nicht die Sonderlogik innerhalb FS, sondern der Link wird als \"normaler\" Url-Link verarbeitet. Bug in JxBrowser-Fremdsoftware. 2024025169 - IDE: Nach dem Ausführen der Kommandos \"Close Others, Close Left oder Close Right\" wird der Fokus vom angezeigten Element im Tabfenster nicht korrekt gesetzt. Die Folge ist, dass im Check In Comment-Editor und auch im Toolbox-Editor nichts angezeigt wird. 2024035295 - IDE: Beim UndoCheckOut einer ConnectionGroup fehlt die Abprüfung auf Abhängigkeiten, wie Connection-Records und DBTable-Records. Wird ein UndoCheckout auf eine ConnectionGroup trotz Abhängigkeiten ausgeführt, führt dies zu fehlerhaften Datenbankdaten. 2024035320 - IDE: Beim Wechsel der Methode im Form kann es zu einer Unhandled Exception und folglich zum Absturtz von Framework Studio kommen. 2024035343 - IDE: Bei der Druckvorschau im Documentation Preview werden dem zu druckenden Dokument leere Abschnitte/Seiten hinzugefügt, sobald dieses länger als eine Seite ist. Dieser Fehler tritt nur beim Print einer Preview auf. Der Export einer Dokumentation ist hiervon nicht betroffen. 2024035372 - IDE: Nach dem Löschen einer override FormMethod und anschließendem Neustart von FS, führt ein UndoCheckout der Form zu einer NullReferenceException. Für die Form kann kein UndoCheckout mehr ausgeführt werden. 2024035385 - IDE: Scrollen und die Sortierung in der Registerkarte \"Query\" einer Component im SR-Modus ist deaktiviert. 2024035399 - IDE: DataContracts vom Typ \"External Proxy Contract\", welche aus einem ServiceProxy mit externem Service erstellt werden, werden nicht im Namespaces TreeView angezeigt. 2024035425 - IDE: Beim Exportieren der Dokumentation für die DBTables kann es zu einer Exception kommen, wenn eine MLDescription einer Spalte die Zeichen \"[\", \"]\" oder \"\\\" enthält. 2024035435 - IDE: Unter gewissen Konstellationen kann es nach dem Löschen eines Form-Properties und Neuanlegen eines Properties zu einer Unhandled Exception kommen. 4.6.3 (01.03.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.3_Setup_x64 FS4.5.14_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf Version 23.2.3 upgedated. Der Monaco Code-Editor wurde auf Version 0.44.0 upgedated. Neuheiten Im Login Dialog gibt es eine neue Checkbox, mit welcher die Packages und Versions gefiltert werden können. Im Package Manager können die Packages gefiltert werden. So werden nur noch Packages angezeigt, welche bearbeitbare Labels passend zur FS-Version haben. Es gibt eine neue Auto Debug DLLs Option: Service, Component, Form, siehe Options. Korrigierte Fehler 2024014914 - IDE: In sehr seltenen Fällen kann es vorkommen, dass \"GoTo Definition\" im Code Editor bei gedrückter STRG-Taste erst bei einem zweiten Click aufgerufen wird. 2024015007 - IDE: Führt man bei CodeFiles den Befehl \"Format Dokument\" aus, dann werden Kommentare, die vor der Klasse stehen, entfernt. 2024015027 - IDE: CodeFiles können im ServiceRelease Modus ausgecheckt, jedoch nicht bearbeitet werden. 2024025056 - IDE: Im Method History Brwoser funktionieren die Compare-Buttons nicht, wenn an der Methoden-Declaration nur die Formatierung oder die Parameter-Namen geändert wurden. 2024025073 - IDE: Das Kommando \"Format Code\" wirft eine \"Can't change the declaration in Service Release.\"-Exception, wenn in der Deklaration einer SR-Methode ein Leerzeichen enthalten ist. 4.6.2 (02.02.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.2_Setup_x64 FS4.5.13_AuthService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates Der HTML Client wurde auf Angular 17.1.1 upgedated Neuerungen Im Package Manager können an der Package Version die Basis-Workspaces fixiert werden. Mit Hilfe von Hotfix-Branches ist es möglich, parallel zum laufenden Service-Release Änderungen vorzunehmen und diese kurzfristig auszuliefern. Maintenance-Routine \"Double Form Doc Cleanup\" zur Bereinigung doppelter Form-Dokumentationen. Korrigierte Fehler 2024014859 - AuthService: Wird ein Benutzer mit \"Angemeldet bleiben\" erneut angemeldet, dann wird im Auth-Service die Login-Info des Benutzers nicht aktualisiert. In der Runtime Administration werden dadurch veraltete Login-Zeiten angezeigt. 2024025113 - AuthService: Wenn eine Anwendung mit Hilfe eines zuvor gespeicherten Tokens einen aktualisierten Token anfragt (RenewToken / Angemeldet bleiben), wird nicht geprüft, ob der Benutzer weiterhin gültig ist. 2024015018 - Package Manager: Bekommt ein Basis-Package einen neuen Service-Release-Stand, dann müssen davon abhängige importierte Packages neu compiliert werden. Hat diese importierte Package-Version den Version State \"Sealed\", dann wird dieser Compile nicht ausgeführt. In der Folge kann das dazu führen, dass Service-Release-Änderungen im Basis-Package nicht greifen. Importierte Package-Versionen werden jetzt nicht mehr als \"Sealed\" angezeigt. 2024014896 - IDE: Die im Options-Dialog angegebene Schriftart und Schriftgröße hat nur Einfluss auf C#-Editoren. Editoren für HTML, CSS, XML und DocML nutzen fälschlicherweise immer die Standardwerte. 4.6.1 (05.01.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuheiten Im DocML werden Inline Images ohne Größenangabe anhand der Schriftgröße skaliert Im Package-Manager können Dokumentationen im HTML-Format exportiert werden Dokumentationen werden mit automatisch generierten Ordnernamen in das gewählte Output-Verzeichnis exportiert Updates Die Bibliothek Oracle.ManagedDataAccess wurde von Version 21.8.0 auf die neuste Version 21.12.0 aktualisiert. DevExpress wurde auf Version 23.1.6 upgedated. Aus diesem Grund gibt es auch einen neuen Print-Service. Korrigierte Fehler 2023114564 - IDE: Kopieren und das anschließende Einfügen eines Basis-Properties, wenn der Parent (Form, Component) gecustomized ist, funktioniert nicht. Wird das Property jedoch aus der Basis kopiert, ist das Einfügen erfolgreich. 2023124671 - Doku-System: Beim Einfügen von Font-Tags über die Toolbar kann es zu einer Exception kommen. Dies betrifft den Font-Style, die Font-Size, die Font-Color und die Background Color. 2023124770 - Doku-System: Es wird eine Exception geworfen, wenn beim Export der Dokumentation über FSConsole die Sprache groß geschrieben wird, z.B. \\ISO DE 2023124781 - Doku-System: Bei einer Suche mit mehreren Wörtern in der Online-Hilfe werden ggf. zu wenige Ergebnisse angezeigt. 2023114565 - PackageManager: SaveAll speichert Änderungen nicht, sondern verwirft diese. 4.6.0 (01.12.2023) Die Auslieferung umfasst die folgenden Pakete: FS_4.6.0_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler In der Version 4.6 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.5.11 enthalten. Zusätzlich wurden die folgenden Bugs behoben. keine weiteren"
  },
  "articles/release-4-7.html": {
    "href": "articles/release-4-7.html",
    "title": "Release-Information Framework Studio 4.7",
    "keywords": "Release-Information Framework Studio 4.7 4.7.3 (07.03.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.7.3_Setup_x64 Weitere Pakete (Dateinamen ohne ZIP-Endung) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.41.5 auf Version 7.42.0 aktualisiert. Das entspricht Chromium 132. Release-Notes des Control-Herstellers: https://teamdev.com/jxbrowser/release-notes/2025/v7-42-0/ Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Neuerungen Der Sql-Parser versteht jetzt WITH-Statements, auch bekannt als Common Table Expression (CTE). Neue Client-Action BrowserControlAction.ExecuteJavaScript() Korrigierte Fehler 2025027380 - Java Client: Wenn an einer Registerkarte das Event OnFirstSelect implementiert ist, dann kann es passieren, dass bei der ersten Eingabe in einem TextFeld das OnLeave-Event nicht korrekt gefeuert wird. 2025017265 - Java-Client: Wenn ein Form, das über ein Event geschlossen werden soll, im selben Zug fokussiert wird, kommt es zu einer Fehlermeldung. 2025027375 - Package-Manager: In einem Oracle-Repository kann es passieren, dass das Update einer Package-Version zu einem Fehler führt. Im Script 4.6.0.0 2022.11.18 DeprecatedLayoutCheck.ora wird eine Sql-Exception ausgegeben FS.DataClient.FrameworkDbException: ORA-00932: Inkonsistente Datentypen: CHAR erwartet, NUMBER erhalten. 2025017231 - IDE: Wird nach dem Kopieren und Einfügen eines Combobox- oder ListBox-Controls das Property, das als ListDataSource definiert ist nicht eingefügt, so kommt es beim Speichern des Forms zu einer Unhandled Exeption und die Anwendung stürzt ab. 2025017263 - IDE: Wenn im Wörterbuch für einen MLKey ein mehrzeiliger Text mit einfachen Zeilenumbrüchen ( \\n / LF ) statt den üblichen ( \\r\\n / CR+LF ) definiert wurde, dann gibt es Probleme bei der Verarbeitung des Textes: In der Tabelle im Multilanguage Text Editor wird der Text mehrzeilig angezeigt - das zieht die Tabelle auseinander. Der Exception-Editor erzeugt einen mehrzeiligen Code, der Compile-Fehler produziert und der Exception-Editor erkennt diesen Code nicht korrekt. 2025027305 - Framework: Die Methode LoadCount() liefert bei GroupBy-Components falsche Werte zurück. Die Anzahl der Sätze wird in einer Gruppierung ermittelt. 4.7.2 (07.02.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.7.2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Updates DevExpress wurde auf die Version 24.2.3 aktualisiert. Der HTML Client wurde auf Angular 19.1.1 upgedatet. Neuerungen Bei Klicken auf einen Link im Errors and Warnings Tab wird dieser farblich hervorgehoben, um zu visualisieren, dass der Link bereits besucht wurde. Bei den Aktionen Open, Save (im FS Report Designer), sowie Choose Report wird nun das Verzeichnis der tatsächlichen Report-Datei geöffnet, statt das Haupt-Reportverzeichnis. Korrigierte Fehler 2025017196 - Reporting: Im WebDesigner ist der Expression Editor nicht nutzbar, da weder Formeln angezeigt noch bearbeitet werden können. 2025017210 - Publish2Go: Wird ein Publish2Go-Paket mit mehreren Applications erstellt, dann enthält das Paket nur eine FSJavaClient.jnlp. In der Folge ziehen einige Einstellungen der Application (z.B. Java Heap Size) nicht korrekt. 2024127103 - IDE: Im Formula Converter des DevExpress Report-Designer werden Properties mit einem Package-Prefix nicht korrekt erkannt. Der Unterstrich wird durch einen Punkt erstzt. oObject_oP01_MyColl.shtK07_MyProperty wird zu oObject.oP01.MyColl.shtK07.MyProperty anstatt zu oObject.oP01_MyColl.shtK07_MyProperty 2025017187 - IDE: Der MultiLanguageText-Editor erzeugt Excpetions, wenn es einen überschriebenen Text ohne passenden Text aus dem Basis-Package gibt. 2025017272 - Code-Generierung: Wenn man eine Code-Transformation customized, dann erzeugt falsch generierter Code einen Compile-Error \"Type expected\". 2024096531 - DevExpress: Wird in einem Report mit Gruppen in einigen Positionen eine RunningSum angezigt, dann stimmt der angezeigte Wert nicht. Es handelt sich um einen Fehler in DevExpress: https://supportcenter.devexpress.com/ticket/details/t1255491 4.7.1 (03.01.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.7.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.40.0 auf Version 7.41.5 aktualisiert. Das entspricht Chromium 131. Release-Notes des Control-Herstellers: https://teamdev.com/jxbrowser/release-notes/2024/v7-41-5/ Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Weitere Updates Das CefSharp Browser-Control in der IDE wurde auf Version 131.3.10 upgedatet. Korrigierte Fehler 2024127052 - Java-Client: Der Fokus eines neu geöffneten Forms geht verloren, wenn während des Öffnens ein Event (z.B. SelectedTabPageChanged) gefeuert wird. 2024126997 - Reporting: Bei der Generierung der xsd-Datei werden FSTypen nicht gefunden und deshalb nicht in die xsd-Datei geschrieben. Dies hat zur Folge, dass die Datenbankverknüpfungen im Crystal Report Designer gelöscht sind. 2024127053 - Broker: Der vom Client aufgerufene Filter für Grid-Spalten arbeitet Case Sensitive (beachtet Groß-Klein-Schreibung). Note Die Korrektur greift, wenn die Filterung im Hauptspeicher der Broker-Anwendung stattfindet. Auf unvollständig geladenen Grids wird der Filter über die Datenbank ausgeführt. Dabei zieht weiterhin das Standard-Verhalten der jeweiligen Datenbank (Collation). 2024126994 - Package-Manager: Wird für eine Package-Version ein Hotfix importiert, dann kommt es zu Null-Exceptions beim Compile und beim Export von darauf aufsetzenden Package-Versionen. 2024126982 - IDE: Bei einer Service Method mit aktiviertem GenerateGlobalObject wird bei gedrückter STRG-Taste und Hovern über Methoden, oder beim Aufrufen der Go To Defintion eine InvalidOperationException geworfen. 2024127022 - IDE: Bei einer Änderung der AccessUnits im FormDesigner wird der Speicherbutton nicht aktiv. 2024127040 - IDE: Wenn beim Laden des FrameworkStudio Layouts ein Fehler auftritt, ist dies nicht abgesichert. Ein Arbeiten mit FS ist nicht mehr möglich. 2024127026 - Framework: Wird bei einem Aufruf von Clone() oder AdoptValue() ein AdoptMode.NoHistory übergeben, dann wird dieser nicht in den Clone() der Unterobjekte übergeben. In der Folge funktioniert in eNVenta das Kopieren von historisierten Belegen nicht korrekt. 2024126996 - FS-Broker: Wird im Publish-Setting ein Load-Balancing konfiguriert, dann zieht dieses nicht. Die Application startet in diesem Broker anstatt auf die konfigurierten URLs umzulenken. 2024127005 - Package Manager: Wird ein Owner Key aus einem Repository mit FS Version 4.6 oder früher exportiert und in einem Repository in FS Version 4.7 importiert, hat das Repository einen kaputten Datenstand und kann ohne DB-Korrekturskript nicht mehr verwendet werden. 4.7.0 Fix 2 (16.12.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.7.0_Fix_2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2024127026 - Framework: Wird bei einem Aufruf von Clone() oder AdoptValue() ein AdoptMode.NoHistory übergeben, dann wird dieser nicht in den Clone() der Unterobjekte übergeben. In der Folge funktioniert in eNVenta das Kopieren von historisierten Belegen nicht korrekt. 4.7.0 Fix 1 (09.12.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.7.0_Fix_1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler 2024126996 - FS-Broker: Wird im Publish-Setting ein Load-Balancing konfiguriert, dann zieht dieses nicht. Die Application startet in diesem Broker anstatt auf die konfigurierten URLs umzulenken. 2024126997 - Reporting: Bei der Generierung der xsd-Datei werden FSTypen nicht gefunden und deshalb nicht in die xsd-Datei geschrieben. Dies hat zur Folge, dass die Datenbankverknüpfungen im Crystal Report Designer gelöscht sind. 4.7.0 (06.12.2024) Die Auslieferung umfasst die folgenden Pakete: FS_4.7.0_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Important Wenn Sie die Version 4.7.0 Beta 3, 2 oder 1 installiert haben, müssen Sie diese zuerst deinstallieren. Ein Update von diesen Versionen ist nicht möglich. Neuerungen Siehe Neuheiten Framework Studio 4.7. Korrigierte Fehler In der Version 4.7 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.6.12 enthalten. Zusätzlich wurden die folgenden Bugs behoben. 2024116805 - Publish / Runtime-Lizenzen: Wird im Basis-Package eine neue AccessUnit angelegt und die Lizenz-Datei nicht aktualisiert, dann enthält die Lizenz-Datei keine Information über diese AccessUnit. Wird in einem darauf aufsetzenden Customizing-Package eine Lizenz angelegt, und diese AcessUnit freigeschalten, dann hat die Anwendung Zugriff auf diese AccessUnit. AccessUnits müssen aber vom jeweiligen Package freigegeben sein, damit man Zugriff darauf erhält. Note Mit Version 4.7 wird die Lizenz direkt im Broker \"aktualisiert\" und ausgewertet. Bei Änderungen am AccessUnit-Baum müssen Lizenzen deshalb nicht mehr zwingend aktualisiert werden. Siehe auch Neuheiten 2024025119 - IDE: Der Name eines CodeFiles darf . als Sonderzeichen enthalten, dies kann später zu Folgeproblemen führen. Note Der Name muss ein gültiger C#-Identifier sein. Beim Compile werden jetzt entsprechende Warnings erzeugt und im Designer wird ein ungültiger Wert gekennzeichnet. 2024076125 - Code Generierung: Ein ServiceHost mit aktiver Option \"Generate REST Endpoint\" generiert die Warning FSWarn[2033] At least one endpoint has to be defined in order to use this service host. Diese Warning ist nicht notwendig, da ein Endpoint automatisch angelegt wird. 2024096503 - Code-Generierung: ist einem alten Deprecated Control, das nicht in das neue Layout übernommen wurde (z.B. einem Label), ein Event zugeordnet, dann wird der Aufruf noch immer in den Code generiert. Zudem kann die Event-Methode nicht gelöscht werden, weil die Event-Zuordnung als Dependency erkannt wird."
  },
  "articles/release-4-8.html": {
    "href": "articles/release-4-8.html",
    "title": "Release-Information Framework Studio 4.8",
    "keywords": "Release-Information Framework Studio 4.8 4.8.0 Alpha 4 (07.03.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.8.0_Alpha_4_Setup_x64 Weitere Pakete (Dateinamen ohne ZIP-Endung) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen In den Modular Components können Interfaces definiert und implementiert werden. Der Sql-Parser versteht jetzt WITH-Statements, auch bekannt als Common Table Expression (CTE). Korrigierte Fehler 2025027380 - Java Client: Wenn an einer Registerkarte das Event OnFirstSelect implementiert ist, dann kann es passieren, dass bei der ersten Eingabe in einem TextFeld das OnLeave-Event nicht korrekt gefeuert wird. 2025027375 - Package-Manager: In einem Oracle-Repository kann es passieren, dass das Update einer Package-Version zu einem Fehler führt. Im Script 4.6.0.0 2022.11.18 DeprecatedLayoutCheck.ora wird eine Sql-Exception ausgegeben FS.DataClient.FrameworkDbException: ORA-00932: Inkonsistente Datentypen: CHAR erwartet, NUMBER erhalten. 2025027305 - Framework: Die Methode LoadCount() liefert bei GroupBy-Components falsche Werte zurück. Die Anzahl der Sätze wird in einer Gruppierung ermittelt. 4.8.0 Alpha 3 (21.02.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.8.0_Alpha_3_Setup_x64 Weitere Pakete (Dateinamen ohne ZIP-Endung) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen In den Modular Components können nun Basis-Klassen definiert werden, sowie deren Properties mit der neuen Override-Checkbox überschrieben werden. Neue Client-Action BrowserControlAction.ExecuteJavaScript() Der Java-Client wurde auf Java 21 upgedatet. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.41.5 auf Version 7.42.0 aktualisiert. Das entspricht Chromium 132. Release-Notes des Control-Herstellers: https://teamdev.com/jxbrowser/release-notes/2025/v7-42-0/ Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Korrigierte Fehler 2025017265 - Java-Client: Wenn ein Form, das über ein Event geschlossen werden soll, im selben Zug fokussiert wird, kommt es zu einer Fehlermeldung. 2025017231 - IDE: Wird nach dem Kopieren und Einfügen eines Combobox- oder ListBox-Controls das Property, das als ListDataSource definiert ist nicht eingefügt, so kommt es beim Speichern des Forms zu einer Unhandled Exeption und die Anwendung stürzt ab. 2025017263 - IDE: Wenn im Wörterbuch für einen MLKey ein mehrzeiliger Text mit einfachen Zeilenumbrüchen ( \\n / LF ) statt den üblichen ( \\r\\n / CR+LF ) definiert wurde, dann gibt es Probleme bei der Verarbeitung des Textes: In der Tabelle im Multilanguage Text Editor wird der Text mehrzeilig angezeigt - das zieht die Tabelle auseinander. Der Exception-Editor erzeugt einen mehrzeiligen Code, der Compile-Fehler produziert und der Exception-Editor erkennt diesen Code nicht korrekt. 4.8.0 Alpha 2 (07.02.2025) Die Auslieferung umfasst die folgenden Pakete: FS_4.8.0_Alpha_2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Neuerungen Crystal Reports abgekündigt Bei Klicken auf einen Link im Errors and Warnings Tab wird dieser farblich hervorgehoben, um zu visualisieren, dass der Link bereits besucht wurde. Bei den Aktionen Open, Save (im FS Report Designer), sowie Choose Report wird nun das Verzeichnis der tatsächlichen Report-Datei geöffnet, statt das Haupt-Reportverzeichnis. Für die Vererbung können in Modular Components Properties als Override markiert werden. Updates DevExpress wurde auf die Version 24.2.3 aktualisiert. Das CefSharp Browser-Control in der IDE wurde auf Version 131.3.10 upgedatet. Update JxBrowser für JavaClient Das JxBrowser Control für den Java-Client wurde von Version 7.40.0 auf Version 7.41.5 aktualisiert. Das entspricht Chromium 131. Release-Notes des Control-Herstellers: https://teamdev.com/jxbrowser/release-notes/2024/v7-41-5/ Es sind keine besonderen Aktionen erforderlich. Mit dem Publish der Application wird die neue Version automatisch auf alle Clients verteilt. Korrigierte Fehler 2024127052 - Java-Client: Der Fokus eines neu geöffneten Forms geht verloren, wenn während des Öffnens ein Event (z.B. SelectedTabPageChanged) gefeuert wird. 2024127053 - Broker: Der vom Client aufgerufene Filter für Grid-Spalten arbeitet Case Sensitive (beachtet Groß-Klein-Schreibung). Note Die Korrektur greift, wenn die Filterung im Hauptspeicher der Broker-Anwendung stattfindet. Auf unvollständig geladenen Grids wird der Filter über die Datenbank ausgeführt. Dabei zieht weiterhin das Standard-Verhalten der jeweiligen Datenbank (Collation). 2025017196 - Reporting: Im WebDesigner ist der Expression Editor nicht nutzbar, da weder Formeln angezeigt noch bearbeitet werden können. 2025017210 - Publish2Go: Wird ein Publish2Go-Paket mit mehreren Applications erstellt, dann enthält das Paket nur eine FSJavaClient.jnlp. In der Folge ziehen einige Einstellungen der Application (z.B. Java Heap Size) nicht korrekt. 2024127103 - IDE: Im Formula Converter des DevExpress Report-Designer werden Properties mit einem Package-Prefix nicht korrekt erkannt. Der Unterstrich wird durch einen Punkt erstzt. oObject_oP01_MyColl.shtK07_MyProperty wird zu oObject.oP01.MyColl.shtK07.MyProperty anstatt zu oObject.oP01_MyColl.shtK07_MyProperty 2025017187 - IDE: Der MultiLanguageText-Editor erzeugt Excpetions, wenn es einen überschriebenen Text ohne passenden Text aus dem Basis-Package gibt. 2025017272 - Code-Generierung: Wenn man eine Code-Transformation customized, dann erzeugt falsch generierter Code einen Compile-Error \"Type expected\". 2024096531 - DevExpress: Wird in einem Report mit Gruppen in einigen Positionen eine RunningSum angezigt, dann stimmt der angezeigte Wert nicht. Es handelt sich um einen Fehler in DevExpress: https://supportcenter.devexpress.com/ticket/details/t1255491 2024127040 - IDE: Wenn beim Laden des FrameworkStudio Layouts ein Fehler auftritt, ist dies nicht abgesichert. Ein Arbeiten mit FS ist nicht mehr möglich. 4.8.0 Alpha 1 (03.01.2025 - intern) Die Auslieferung umfasst die folgenden Pakete: FS_4.8.0_Alpha_1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier. Korrigierte Fehler In der Version 4.8 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.7.Z enthalten. Zusätzlich wurden die folgenden Bugs behoben. keine weiteren"
  },
  "articles/requirements-package.html": {
    "href": "articles/requirements-package.html",
    "title": "Requirements-Paket",
    "keywords": "Requirements-Paket Die Requirements für Framework Studio stehen in einem separaten Download zur Verfügung. FS4.5.4_Requirements_64Bit.zip Die Requirements werden benötigt, wenn Sie das erste mal eine Installation von Framework Studio durchführen. Damit die Installation der Requirements direkt von der Setup.exe angestoßen werden kann, kopieren Sie den Ordner Requirements (samt Inhalt) aus dem entsprechenden Paket direkt in den Ordner mit der Setup.exe. Die Struktur der Ordner muss dann folgendermaßen aussehen: FS_4.5.4_Setup_x64\\ FS_4.5.4_Setup_x64.exe Neuheiten.pdf Requirements_Readme.txt Requirements\\ CRRuntime_64bit_13_0_29.msi ... Enthaltene Bestandteile .net Framework 4.8 ndp48-web.exe Es wird empfohlen, diesen Web-Installer auszuführen. Damit erhalten sie automatisch die aktuellste Version und das passende Sprachpaket. ndp48-x86-x64-allos-enu.exe Der Offline-Installer spart den Download der Runtime. Er beinhaltet das .net Framework in englischer Sprache und die Version ist ggf. nicht mehr die aktuellste. Bei Bedarf gibt weitere Pakete direkt von Microsoft unter https://dotnet.microsoft.com/download/dotnet-framework/net48 Das .net Framework 4.8 muss installiert werden, bevor die Setup.exe ausgeführt wird. Es muss auf den folgenden Rechnern installiert werden: Anwendungs-Server Authentication-Server Print-Server Entwicklungs-Rechner FS Client Launcher 64-Bit: FSCL_4.4.0_Setup_x64.exe Die 32-Bit-Version FSCL_4.4.0_Setup_x86.exe steht als separater Download zur Verfügung Der Framework Studio Client-Launcher beinhaltet eine Java-Runtime zum Ausführen des Java-Clients. Er muss auf folgenden Rechnern installiert werden: Alle Rechner, auf denen die eNVenta-Anwendung ausgeführt wird Entwickler-Rechner zum Ausführen der Anwendung ggf. Anwendungs-Server, sofern auf ihnen die Anwendung ausgeführt werden soll"
  },
  "articles/requirements.html": {
    "href": "articles/requirements.html",
    "title": "Systemvoraussetzungen",
    "keywords": "Systemvoraussetzungen Entwicklungs-Rechner Ein Rechner auf dem mit der Framework Studio IDE entwickelt wird bzw. ein Rechner oder Server auf dem der Framework-Compiler ausgeführt wird. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows 10 - mind. Version 18.03 Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Die Framwork Studio IDE läuft seit der Version 4.5.6 nicht mehr auf einem Windows Server 2012. .NET Framework .NET Framework 4.8 - oder höher https://dotnet.microsoft.com/download/dotnet-framework/net48 Weitere Software Client Launcher Visual Studio: empfohlen zum Debuggen von Anwendungen Visual Studio 2017 oder höher Andere Versionen können auf eigene Verantwortung in den IDE-Options konfiguriert werden. Anwendungs-Server Rechner, auf dem Broker oder mit Framework Studio veröffentlichte Services laufen. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Windows Server 2012 R2 Client-Betriebssysteme: Ein Broker oder Service kann prinzipiell auf einem Client-Betriebssystem (Windows 10) installiert werden. In einer Produktiv-Umgebung wird aber dringend der Einsatz eines o.g. Server-Betriebssystems empfohlen. Auf Client-Betriebssystemen können nur sehr wenige Benutzer parallel arbeiten. Die Framweork Studio IDE läuft seit der Version 4.5.6 nicht mehr auf einem Windows Server 2012. Auf so einen Server muss die Anwendung deshalb mit Hilfe von Pulish2Go installiert werden. .NET Framework .NET Framework 4.8 - oder höher Weitere Software IIS Print-Server Der Print-Service benötigt eine Verbindung zur Runtime-Repository-Datenbank und er muss die gewünschten Drucker ansprechen können. Er wird nicht von der Anwendung direkt kontaktiert, deshalb kann auch ein Client-Betriebssystem verwendet werden. Print-Service Die hier aufgeführten Systemvorrausetzungen gelten für den Print-Service Version 4.2. Framework Studio ist kompatibel mit älteren Versionen des Print-Service. Kommen diese zum Einsatz, gelten die Systemvorrausetzungen für die jeweilige Version. Framework Studio Print-Service 4.2.18 Framework Studio Print-Service 4.0.29 Framework Studio Print-Service 3.11.67 Betriebssystem siehe Entwicklungs-Rechner Es wird der Einsatz eines 64-Bit Betriebssystems empfohlen. Wenn z.B. ein spezieller Drucker-Treiber nur unter 32-Bit funktioniert, kann der Print-Service auch unter 32-Bit eingesetzt werden. Weitere Software .NET Framework 4.8 - oder höher Einer der folgenden PDF Reader, wenn der PDF-Print-Adapter verwendet werden soll. Adobe Reader https://get.adobe.com/de/reader/ Foxit Reader https://www.foxitsoftware.com/de/pdf-reader/ Sumatra PDF https://www.sumatrapdfreader.org/ Microsoft Office 2003 oder höher, wenn der MSOffice-Print-Adapter verwendet wird oder bei der Benutzung einer Faxsoftware (z.B. Tobit-Fax). Open Office, wenn der OpenOffice-Print-Adapter verwendet wird. Authentication-Server Authentication-Service Framework Studio Authentication-Service 4.6 Betriebssystem siehe Anwendungs-Server Weitere Software .NET Framework 4.8 oder höher Client-Rechner Rechner, auf dem die Anwendung mit dem Java-Client ausgeführt wird. Betriebssystem Es werden ausschließlich folgende Windows-Versionen unterstützt: Windows 10 oder höher Windows Server 2016 oder höher Je nach Framework-Studio-Anwendung kann es ggf. weitere Einschränkungen geben. Weitere Software Client Launcher Je nach Framework-Studio-Anwendung ggf. weitere Software Client Launcher Der Client Launcher stellt die Java Runtime bereit, die für das Ausführen des Java-Clients benötigt wird. Framework Studio Client Launcher 4.2.16 / 4.4.0 Der aktuelle Client Launcher ist im Requirements-Paket enthalten. Datenbank-Server Microsoft SQL Server 2016 - oder höher (Standard / Enterprise / BI) Die Express- und Developer-Editionen des SQL Server können zu Entwicklungs- und Test-Zwecken eingesetzt werden. Dabei sind aber entsprechende funktionale und lizenzrechtliche Einschränkungen seitens Microsoft zu beachten. Der Einsatz erfolgt auf eigene Verantwortung. Oracle 19c - oder höher (Standard / Enterprise) Es ist kein Oracle Client erforderlich. Framework Studio bringt mit dem Oracle Managed Provider eine eigene Client-DLL mit. Runtime Supervisor Systemvoraussetzungen für den Datenbankserver siehe allgemeines Kapitel \"Datenbank-Server\" Client (für Web Application) Browser: Google Chrome Microsoft Edge Mozilla Firefox Safari Runtime Supervisor Betriebssystem: Windows 10 Update 1803 oder höher Windows Server 2012 R2 Windows Server 2016 Windows Server 2019 Windows Server 2022 Software: .NET Framework 4.8 oder höher Internet Information Services 7.0 oder höher ASP.NET 4.8"
  },
  "articles/update-4-2/mlkey-migration.html": {
    "href": "articles/update-4-2/mlkey-migration.html",
    "title": "MLKey Migration",
    "keywords": "MLKey Migration Ziel ist es, dass alle Texte aus den Records entfernt und in das Wörterbuch übertragen werden. Die Records erhalten dafür Verweise auf Einträge im Wörterbuch, die MLKeys. Generell teilt sich die Migration in zwei große Phasen auf: MLKeys erzeugen und zuordnen: Diese Phase kann parallel zur Weiterentwicklung durchgeführt werden. Es werden zum Einen neue Einträge im Wörterbuch angelegt und zum Anderen vorgemerkt, wo diese später verwendet werden sollen. MLKeys übertragen: In dieser Phase werden primär die vorbereiteten Zuordnungen an die Elemente übertragen: angegebene Texte werden entfernt und statt dessen die gewünschten MLKeys eingetragen. Dazu müssen alle betroffenen Elemente ausgecheckt werden. Zusätzlich werden weitere Umstellungen (z.B. bestehende Messages und Exceptions) durchgeführt. Abwärts-Kompatibilität Texte, die bisher an den Records definiert sind, funktionieren auch weiterhin, weil jeder MLString neben dem MLKey explizit gesetzte Texte versteht. So kann man nach dem Update auf die Version 4.2 die Migration in aller Ruhe angehen. Note In Kunden-Packages ist die Umstellung der eigenen Texte auf MLKeys empfohlen. Sie ist aber nicht zwingend notwendig. Das hat aber langfristig einige Nachteile zur Folge - insbesondere in Hinblick auf die Mehrsprachigkeit der Anwendung: Der Language Export / Import funktioniert nur für das Wörterbuch. Individuelle Texte an Records werden nicht (mehr) berücksichtigt. Das Pflegen von Fremdsprachen an den Records ist sehr aufwändig. Die MLKeys aus dem Wörterbuch bringen hingegen die Übersetzungen automatisch in alle Bereiche der Anwendung. Important Funktionale Packages, die als Produkt an mehrere Kunden vertrieben werden, sollten in jedem Fall migriert werden. MLKeys erzeugen und zuordnen Diese erste Phase der MLKey Migration dient zum Einen der Erzeugung der benötigten Einträge im Wörterbuch (MLKeys) und zum Anderen der Zuordnung, wo diese später verwendet werden sollen. Zentrales Werkzeug für diese Phase ist der Dialog Multilanguage Text Migration, welcher über das Menü Tools / Multilanguage Text Migration geöffnet werden kann. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Alle durch den Benutzer definierten Zuordnungen werden in der Ressource Migration.xml im Verzeichnis FSGeneral/Resources/lang gespeichert, welche automatisch bei der ersten Benutzung angelegt wird. Ist diese Datei bei der Bearbeitung mit dem Multilanguage Text Migration Dialog nicht ausgecheckt, so wird beim Speichern mit dem Button Save automatisch die neueste Version ausgecheckt, die Änderungen ergänzt und anschließend sofort wieder eingecheckt. Dieses Verhalten ist dann hilfreich, wenn mehrere Benutzer gleichzeitig mit dem Multilanguage Text Migration Dialog arbeiten. Andernfalls empfiehlt es sich, die Datei vor Beginn der Arbeit auszuchecken und erst nach Beendigung der Arbeit wieder einzuchecken. So werden unnötige Checkin- und Checkout-Vorgänge vermieden. Beim Speichern werden außerdem ggf. ungespeicherte Änderungen am Wörterbuch gespeichert. Generelles Vorgehen Die zu leistende Arbeit besteht in erster Linie darin, logisch identische Begriffe zusammenzuführen und logisch unterschiedliche Begriffe, die ggf. in einzelnen Sprachen Überlappungen mit anderen Begriffen haben, zu trennen. Beispiel: Die Begriffe Suche mit SQL, Suchen mit SQL, SQL Suche, SQL-Suche, Suchen SQL, Sql Suche und weitere Varianten sollten zu einem einzigen Eintrag zusammengefasst werden. (1) Load Data Important Zunächst sollten Tooltips außen vor gelassen werden. Dazu darf die Checkbox Include Tooltips NICHT gesetzt sein, wenn mit dem Button Load Data alle im Package angegebenen Texte eingelesen werden. Erst wenn allen Texten ein MLKey zugeordnet wurde, werden die im Folgenden beschriebenen Schritte nach dem erneuten Laden der Daten inklusive Tooltips ein zweites Mal durchgeführt. Note Wenn durch ein Basis-Package bereits Einträge im Wörterbuch existieren, so wird Framework Studio nach dem Laden automatisch einem mehrsprachigen Text aus dem Custom-Package den MLKey zuweisen, der mindestens in den angegebenen Sprachen die Texte in exakt der Schreibweise enthält. Die mit dem Button Load Data eingelesenen Texte werden in einer Tabelle angezeigt. Die einzelnen Spalten haben folgende Bedeutung: Record: Name des Elements, an dem der Text angegeben ist, z.B. frmArticle. Element: Name des Unterelements, an dem der Text angegeben ist, z.B. edtsName. Type: Typ des Unterelements, z.B. FormControl. Property: Eigenschaft, an der der Text angegeben ist, z.B. Caption. MLKey: Der MLKey, welcher zugeordnet werden soll, z.B. LBL_Name. {Sprachen...}, z.B. German, English usw.: Der Text, welcher in der jeweiligen Sprache angegeben ist, z.B. Name. Die Spalten können durch anklicken der Spaltenüberschrift sortiert werden. Meist wird man nach deutschem Text sortiert arbeiten. Ein Doppelklick in die Spalten Record oder Element öffnet das Designerfenster für das Element und springt soweit möglich zum Unterelement. In allen anderen Spalten wird beim Doppelklick der Text der Zelle als Filterkriterium in das Feld Search: gesetzt. Für die Filterfunktion mit dem Feld Search: gelten folgende Regeln: Groß-Kleinschreibung wird ignoriert Es wird in allen Spalten gesucht Es werden nur die Zeilen angezeigt, die ALLE der durch ein Leerzeichen getrennten Buchstabenfolgen enthalten In Anführungsstriche \" gekapselte Buchstabenfolgen müssen genau so in der Zeile enthalten sein, damit diese angezeigt wird Beispiel: Die Suche nach LBL_Quantity \" geliefert\" zeigt nur die Zeilen an, welche geliefert mit einem führenden Leerzeichen und LBL_Quantity in irgendeiner Spalte enthalten. (2) Auto Create MLKeys Nach dem Einlesen der Daten (zunächst ohne Tooltips, siehe Load Data) sollten einmalig mit dem Button Auto Create MLKeys alle automatisch erzeugbaren MLKeys in das Wörterbuch eingefügt werden. Automatisch erzeugt werden MLKeys dann, wenn es zu gleichen Texten in einer Sprachen keine abweichenden Texte in anderen Sprachen gibt. Note Framework Studio weist danach automatisch den Zeilen einen MLKey zu, die nur Texte enthalten, welche zu einem MLKey aus dem Wörterbuch keinen Wiederspruch aufweisen. (3) Manuelle Zuweisungen Ist die Checkbox Show only missing keys gesetzt, so wird die Anzeige aller Texte in der Tabelle auf die Einträge reduziert, welchen bisher noch kein MLKey zugewiesen wurde - die noch zu bearbeitenden Einträge. Im unteren Bereich des Multilanguage Migration Dialogs werden im Bereich Details zum aktuell in der Tabelle selektierten Eintrag alle Eigenschaften angezeigt. Ist bereits ein MLKey zugewiesen, werden die Texte des MLKeys in der Tabellenspalte In MLKey angezeigt. In der oberen Tabelle können auch mehrere Zeilen gleichzeitig ausgewählt werden. So kann mehreren Zeilen gleichzeitig ein MLKey zugewiesen werden. Für die Zuweisung stehen mehrere Optionen zur Verfügung: Mit dem Button im Bereich Details kann ein bereits existierender MLKey ausgewählt werden, siehe Multilanguage Text Editor, insbesondere Suchen von MLKeys. Wurde bereits ein MLKey zugewiesen, so wird ein weiterer Button Set ... angeboten, mit dem der zuletzt zugewiesene MLKey den aktuell selektierten Zeilen zugewiesen werden kann. Mit dem Button im Bereich Details kann ein neuer MLKey (basierend auf den selektierten Zeilen) erzeugt werden. Wenn beim Erzeugen eines neuen MLKeys mehrere Zeilen ausgewählt wurden und diese in einzelnen Sprachen abweichende Texte enthalten, so wird pro Sprache bei Bedarf der folgende Dialog geöffnet: In diesem werden alle Varianten, sortiert nach Häufigkeit absteigend, aufgeführt. Durch Selektion und Bestätigung mit dem Button OK oder durch Doppelklick wird die Auswahl als Vorbelegung für den neuen MLKey verwendet (siehe Erfassen neuer MLKeys). Important Bei der Zuweisung und Erzeugung von MLKeys sind die eNVenta Regeln für MLKeys zu beachten. Mit dem Button Rename MLKey ist es im Rahmen der Migration möglich, einen bestehenden MLKey umzubenennen. Alle manuellen Zuordnungen dieses MLKeys werden automatisch angepasst. (4) Bereinigungen Im Wörterbuch werden sich durch die vorangegangenen Schritte (z.B. durch die von Framework Studio automatisch generierten MLKeys) einige Unsauberkeiten eingeschlichen haben. Daher sind die folgenden Maßnahmen empfehlenswert: Maßnahmen im Wörterbuch: Sortierung nach MLKey: Folgen aufeinander logisch identische Begriffe? Suche Nach _1, _2, _3 usw: Sind diese Varianten nötig oder sollten anders benannt werden? Sortierung nach deutschem Text: Folgen aufeinander logisch identische Begriffe? In Custom-Packages sind dabei nur die MLKeys aus dem eigenen Package (zu erkennen an der Fettschreibung) und ihre Vorgänger und Nachfolger interessant. Außerdem können im Multilanguage Text Migration Dialog mit dem Button Find unused MLKeys alle MLKeys aus dem eigenen Package aufgelistet werden, welche im Wörterbuch existieren, jedoch nirgendwo zugeordnet sind. Diese gilt es, kritisch zu prüfen. (5) Abschluss Phase 1 Wurden die vorigen Schritte (zunächst ohne Tooltips, danach mit Tooltips) abgeschlossen, so kann nun mit Phase 2 (MLKeys übertragen) fortgefahren werden. MLKeys in Custom-Packages Im Customizing kann man grundsätzlich 2 verschiedene Arten von überschriebenen Texten unterscheiden: Texte, die eine ganz neue Bedeutung haben. Wenn z.B. ein relativ allgemeiner Metadatentyp in einem Component-Property verwendet wird, wird dort am Default-Label ein neuer Text formuliert. In diesen Fällen sollte auf jeden Fall ein entsprechender (ggf. neuer) MLKey zugeordnet werden. Ändern eines bestehenden Textes. Es wird z.B. ein Metadatentyp customized und das Default-Label geändert - aus dem Begriff \"Angebot\" wird z.B. \"Offerte\". Die Bedeutung bleibt aber dieselbe. In solchen Fällen gilt es zu prüfen, ob es evtl. ratsam ist, diese Änderung direkt im Wörterbuch vorzunehmen. So zieht diese für die gesamte Anwendung. Bei der Migration weist man dann diesen Einträgen den existierenden MLKey zu - auch wenn er identisch mit dem bereits zugeordneten MLKey aus dem Basis-Package sein sollte. In einem späteren Schritt der Migration wird eine redundante Zuordnung dann automatisch eliminiert. MLKeys übertragen Ist das Wörterbuch komplett vorbereitet (siehe MLKeys erzeugen und zuordnen), ist es an der Zeit, die MLKeys in die Records zu übertragen. In diesem Schritt werden alle Aktionen ausgeführt, die einen Checkout der Records zur Folge haben. So wird die ggf. erhebliche Menge an Checkouts auf das nötigste reduziert. (1) Als FCUser anmelden Weil nach der Konvertierung sehr viel kompiliert werden muss, ist es empfehlenswert als FCUser zu arbeiten. So kann direkt nach dem Kompilieren der Complete Framework Compiler aufgerufen werden und es ist kein zusätzlicher FrameworkCompiler nötig. Mit dem Benutzer FrameworkCompiler anmelden - mit Refresh Workspace. Get DLLs ist nicht notwendig. Framework Studio direkt wieder beenden. Jetzt als FCUser anmelden - mit Refresh Workspace. Das übernimmt den Workspace vom Benutzer FrameworkCompiler. (2) Apply MLKeys Im Fenster Multilanguage Text Migration mit dem Button Load Data (inkl. den Tooltips) alle Daten einlesen. Es sollte jetzt keine offenen Zuordnungen mehr geben - wenn man die Checkbox Show only missing keys setzt, dürfen keine Einträge angezeigt werden. Mit dem Button Apply MLKeys wird die Routine gestartet. Es werden alle zugeordneten MLKeys an die entsprechenden Properties der Records übertragen. Dabei werden ALLE in den jeweiligen Sprachen gesetzten Texte aus den Records entfernt. Somit ziehen ab diesem Zeitpunkt die Texte nur noch aus dem Wörterbuch. (3) Convert Messages Mit dem Button Convert Messages im Fenster Multilangage Text Migration wird die Routine gestartet. Für diese Routine müssen keine Daten eingelesen werden - das gilt auch, wenn sie zu einem späteren Zeitpunkt erneut gestartet wird. Es werden alle Methoden-Codes analysiert und nach Exceptions- und MessageBox-Aufrufen gesucht. Diese werden in das neue Message-Format umgewandelt und die Verweise auf die Text-Collections werden durch den entsprechenden MLKey ersetzt. Warning Die Routine Apply MLKeys muss zuvor ausgeführt worden sein, damit die Message-TextCollections sauber zugeordnete MLKeys besitzen. Alter Exception-Code vor der Konvertierung: #region Required for Exception Editor support. Do not modify manually. //Component type is required. //Severity: 0 ; Buttons: OK; Icon:Error throw new FrameworkApplicationException (String.Format(FSGeneral.ctMessagesFactory.Get(this.Global,3550).Value[Global.SelectedLanguage],new object []{}),0 ); //<ExceptionEditor TextColl=\"Messages\" ID =\"832e0e50c2b748068ba38a2c4422aaab\" Severity=\"0\" EHID=\"\" ></ExceptionEditor> #endregion End of generated section Neuer Exception-Code nach der Konvertierung: // FSCodeMessage: Component type is required. throw new FrameworkApplicationException(MLUtil.GetMLKeyText(MLKeys.MSG_445559f2ca44452e8d49ca9515b3a83e), 0); Es ist relativ wahrscheinlich, dass Warnings oder sogar Errors ausgegeben werden. Diese können erst einmal ignoriert werden. Es handelt sich dabei um inhaltliche Probleme und nicht um Compile-Errors. Die Convert Code Messages Routine kann zu einem späteren Zeitpunkt erneut ausgeführt und diese Probleme dann behoben werden. Important Damit sind die Message-Text-Collections jetzt obsolete. Sie dürfen aber nicht gelöscht oder geleert werden, weil sie ggf. noch von Customizing-Packages referenziert werden. (4) MLStrings Cleanup Nachdem alle MLKeys übertragen wurden, können jetzt noch einige Bereinigungen durchgeführt werden. Über das Menü Tools / Checks / MLStrings Cleanup kann das Cleanup-Fenster geöffnet werden. Dort stehen mehrere Routinen zur Auswahl. Diese sollten einer nach der anderen ausgeführt werden. Dabei ist es ratsam zuerst den Button Analyze zu benutzen. Erst nach der Sichtung der Infos und Warnings wird die Routine mit dem Button Cleanup ausgeführt. Clean MLKeys Wird in einem Record (z.B. DBColumn, Form-Control) der MLKey mit demselben Wert überschrieben, wie er in der Basis (z.B. Metadatentyp, Basis-Package) definiert ist, dann wird diese Überschreibung entfernt. Transfer translations Wurden trotz vererbtem MLKey Übersetzungen nur an Records gepflegt, dann wurden diese mit der Migration ggf. nicht in das Wörterbuch übertragen. Das wird mit dieser Routine nachgeholt. Wird an einem Record, der einen MLKey besitzt, eine Übersetzung gefunden und das Wörterbuch kennt diese noch nicht, wird diese in das Wörterbuch übertragen und der Text vom Record entfernt. Dabei gewinnt pro MLKey der erste Record. Wird ein weiterer Record mit gleichem MLKey aber einer anderen Übersetzung gefunden, dann wird dieser als Warning ausgegeben. Beim Cleanup verbleibt dieser Text am Record. Bei einem weiteren Lauf würde dieser Record mit der Routine Clean individual texts gefunden werden. Clean individual texts Die MLKey-Migration berücksichtigt nur Texte, die mindestens in Deutsch und Englisch gepflegt sind. Sind an einem Record nur andere Sprachen definiert, dann wird dieser Text nicht migriert. Oftmals erben diese Records schon einen Text aus der Basis und es sind nur einige Übersetzungen gepflegt. Diese sollen hier bereinigt werden. Es werden Texte, die identisch mit dem Wörterbuch sind, entfernt. Vom Wörterbuch abweichende Texte werden als Warning ausgegeben und NICHT entfernt. Diese müssen in einem weiteren Schritt bearbeitet werden. Warnings bearbeiten Jetzt müssen die aufgetretenen Warnings begutachtet und ggf. manuell bearbeitet werden. Clean individual texts mit Remove different Wurden im vorherigen Schritt die Warnings begutachtet, können mit dieser Aktion alle abweichenden Texte entfernt werden. (5) Compile und CheckIn Jetzt müssen alle Änderungen compiliert werden. Menü Compile / Compile Changes. Nachdem der Compiler erfolgreich beendet wurde, werden alle Elemente eingecheckt. Dabei sollte ein CheckIn-Kommentar z.B. MLKey Migration angegeben werden. Zum Abschluss noch über den Compile-Manager den Button Complete Framework Compiler aufrufen."
  },
  "articles/update-4-2/neue-text-funktionen.html": {
    "href": "articles/update-4-2/neue-text-funktionen.html",
    "title": "Neue Text-Funktionen",
    "keywords": "Neue Text-Funktionen In Framework Studio 4.2 wurden im Zuge der Umstellung auf die MLKeys auch die Text-Zugriffe auf Text-Collections und DevMLStrings überarbeitet. Note Auch wenn keine MLKey-Migration ausgeführt wird, muss die Convert Messages Routine trotzdem ausgeführt werden, damit die Verarbeitung der Fremdsprachen-Texte korrekt funktioniert. Siehe Abschnitt Migration auf Version 4.2 Bei der Verwendung von this.Global.SelectedLanguage erfolgt kein Fallback auf andere Sprachen. Aus diesem Grund sollte dies nicht mehr verwendet werden. Für das ermitteln des Textes wurden deshalb einfachere Varianten geschaffen, die ohne explizite Angabe der Sprache arbeiten. Andere Stellen erhalten jetzt stattdessen das komplette this.Global um daraus die Sprach-Hierarchie inkl. Fallbacks zu ermitteln. Die Text-Ermittlungen benötigen auch immer einen Zugriff auf das GlobalObject, damit die zentralen Einsprungpunkte immer angelaufen werden. Text-Collection Soll für einen bestimmten Text-Collection-Eintrag der Text ermittelt werden, dann erfolgt dies idealerweise über die Factory-Klasse. Dort wird eine Methode GetText(global, id) angeboten. Diese Methode Liefert den Text in der aktuellen Sprache / Sprach-Hierarchie, welche über das GlobalObject festgelegt ist. string sText = ctTextCollFactory.GetText(this.Global,7); Wird der Text in einer bestimmten Sprache benötigt, dann muss über die Methode Get(global, id) der Text-Collection-Eintrag ermittelt und an diesem mit der Methode GetText(iso) der gewünschte Text ermittelt werden. string sText = ctTextCollFactory.Get(this.Global,7).GetText(sIsoCode); Text-Collection-Eintrag Manchmal wird auch mit bestimmten Einträgen der Text-Collection gearbeitet. Dieser bietet die folgenden Möglichkeiten, den Text zu ermitteln. Das Property Text liefert den Text in der aktuellen Sprache / Sprach-Hierarchie, welche über das GlobalObject festgelegt ist. string sText = oTextCollEntry.Text; Die Methode GetText(iso) liefert den Text in einer gewünschten Sprache. Dabei erfolgt kein Fallback auf eine andere Sprache. Ist in der angegebenen Sprache kein Text formuliert, wird String.Empty zurückgegeben. string sText = oTextCollEntry.GetText(sIsoCode); Über das Property Value wird ein Objekt mit dem Typ DevMLString zurückgegeben. Dieses hat aber selber keinen Bezug zum GlobalObject, weshalb ihm zur Ermittlung der Texte ein GlobalObject übergeben werden muss. Es sollten wenn möglich die o.g. Wege zur Ermittlung der Texte benutzt werden. Das Property Value ist nur in Ausnahme-Fällen zu verwenden. DevMLString Zur Ermittlung eines Textes muss ein GlobalObject übergeben werden. Es gibt dazu die folgenden Möglichkeiten: // Text in aktueller Sprache / Sprach-Hierarchie string sText1 = oDevMLString.GetString(this.Global); string sText2 = oDevMLString[this.Global]; // Text in bestimmter Sprache string sText3 = oDevMLString.GetString(this.Global, sIsoCode); Obsolete Schnittstellen Am DevMLString wurden einige Properties/Methoden auf Obsolete gesetzt, weil sie kein GlobalObject verwenden. Beim Compile werden betroffene Stellen als Warning ausgegeben. // Diese Aufrufe sind Obsolete!!! string sText1 = oDevMLString.GetString(sIsoCode); string sText2 = oDevMLString[sIsoCode]; string sText2 = oDevMLString.German; Die Methode GetDefinedLanguagesAsIso() macht keinen Sinn mehr, weil die Texte nicht mehr dieser Stelle definiert sind. Nach der Umstellung auf den MLKey wird als Iso-Code nur noch der Wert \"_key\" zurückgegeben. Migration auf Version 4.2 Um eine saubere Funktion der Fremdsprachen-Texte zu gewährleisten, müssen diese Aufrufe mit dem Update auf die Version 4.2 umgestellt werden. Ein sehr großer Teil der Aufrufe wird mit der Convert-Messages Routine in der MLKey-Migration automatisch umgesetzt. Es bleiben aber einige wenige Stellen übrig, die manuell nachgearbeitet werden müssen. Sie werden beim Compile durch die Obsolete-Warning erkannt. Im folgenden werden ein paar Code-Beispiele aufgeführt, die verdeutlichen, wie die Umstellung zu erfolgen hat. Alter Code neuer Code ctAbcFactory.Get(this.Global,7).Value[this.Global.SelectedLanguage] ctAbcFactory.GetText(this.Global,7) ctAbcFactory.Get(this.Global,7).Value[sIsoCode] ctAbcFactory.Get(this.Global,7).GetText(sIsoCode) oTextCollEntry.Value[Global.SelectedLanguage] oTextCollEntry.Text oTextCollEntry.Value.GetString(sIsoCode) oTextCollEntry.Value[sIsoCode] oTextCollEntry.GetText(sIsoCode) oTextCollEntry.Value.German oTextCollEntry.GetText(\"de\") oDevMLString.GetString(sIsoCode) oDevMLString[sIsoCode] oDevMLString.GetString(this.Global, sIsoCode) oDevMLString.German oDevMLString.GetString(this.Global, \"de\")"
  },
  "articles/update-4-3/property-changed.html": {
    "href": "articles/update-4-3/property-changed.html",
    "title": "Umstellung auf PropertyChanged",
    "keywords": "Umstellung auf PropertyChanged Die Components arbeiten nutzen jetzt das Event PropertyChanged um Änderungen an Properties zu kommunizieren. Sie implementieren dazu das Standard-Interface INotifyPropertyChanged. Die bisher verwendeten Events, welche für jedes einzelne Component-Property sparat generiert wurden, entfallen. Wenn eigener Code existiert, der mit diesen Events arbeitet, muss dieser angepasst werden. Im folgenden werden einige Situationen beschrieben. Die Beispiele verwenden eine Component cdArticle mit den Properties sArticleID und sArticleName. Event-Handler umstellen Bisher gab es die folgenden Events public event EventArgs sArticleIDChanged; public event EventArgs sArticleNameChanged; Diese wurden auf die folgende Weise verwendet: // anhängen des Event-Handlers oArticle.sArticleIDChanged += OnArticleIDHasChanged; // Event-Handler-Methode protected void OnArticleIDHasChanged(object sender, EventArgs args) { // Code für geänderte Artikel-ID } // Event mit Lambda-Expression oArticle.sArticleNameChanged += (sender, args) => { // Code für geänderte Artikel-Bezeichnung }; Jetzt gibt es nur noch ein Event, welches in der Basis-Klasse DevFrameworkBaseObject implementiert ist. public event PropertyChangedEventArgs PropertyChanged; Dieses wird auf folgende Weise verwendet: // anhängen des Event-Handlers oArticle.PropertyChanged += OnArticleIDHasChanged; // Event-Handler-Methode protected void OnArticleIDHasChanged(object sender, PropertyChangedEventArgs args) { if (args.IsProperty(nameof(IcdArticle.sArticleID))) { // Code für geänderte Artikel-ID } } // Event mit Lambda-Expression oArticle.sArticleNameChanged += (sender, args) => { if (args.IsProperty(nameof(oArticle.sArticleName))) { // Code für geänderte Artikel-Bezeichnung } }; Aufrufe von Fire-Methoden Alter Code: this.FiresArticleIDChanged(); this.FiresArticleNameChanged(); Neuer Code: this.FirePropertyChanged(nameof(this.sArticleID)); this.FirePropertyChanged(nameof(this.sArticleName)); Muss man viele dieser Aufrufe ersetzen, kann man dafür im Code-Editor die Funktion Find/Replace verwenden. Suche mir Regular Expression: this.Fire(?<prop>(?!Property)\\w+)Changed\\s*\\(\\s*\\) Ersetzen durch: this.FirePropertyChanged(nameof(this.${prop})) StateChanged, IsModifiedChanged Die Component-Properties State und IsModified, werden jetzt ebenfalls über PropertyChanged behandelt. Die virtuellen Methoden OnStateChanged und OnIsModifiedChanged sind entfallen. Stattdessen kann diese Logik in die neue Methode OnPropertyChanged verschoben werden. Alter Code: protected override void OnStateChanged() { // Status hat sich geändert } protected override void OnIsModifiedChanged() { // IsModified hat sich geändert } Neuer Code: protected override void OnPropertyChanged(string propertyName) { // Base-Aufruf ist wichtig !!! base.OnPropertyChanged(propertyName); if (propertyName == nameof(this.State)) { // Status hat sich geändert } if (propertyName == nameof(this.IsModified)) { // IsModified hat sich geändert } } Neuer Code für Event-Handler: // anhängen des Event-Handlers oArticle.PropertyChanged += OnArticleStateChanged; // Event-Handler-Methode protected void OnArticleStateChanged(object sender, PropertyChangedEventArgs args) { // Die Prüfung auf PropertyName == null macht hier keinen Sinn if (args?.PropertyName == nameof(this.State)) { // Status hat sich geändert } } Reflection Caution Wenn die alten Changed-Events per Reflection angesprochen wurden, dann muss das gezielt umgebaut werden. Diese Fälle werden nicht durch den Compiler gefunden. Mit einer Volltext-Suche nach folgendem Regulären Ausdruck könnten potentielle Stellen leicht gefunden werden: \\bEventInfo\\b Beispiel für einen problematischen Code: System.Reflection.EventInfo oChangedEventInfo = this.oTarget.GetType().GetEvent(sPropertyNameP + \"Changed\"); if (oChangedEventInfo != null) { oChangedEventInfo.AddEventHandler(this.oTarget, oXmlPropertyInfo.oChangedEventHandler); }"
  },
  "articles/update-4-7/update-4-7.html": {
    "href": "articles/update-4-7/update-4-7.html",
    "title": "Update auf Version 4.7",
    "keywords": "Update auf Version 4.7 Dieser Leitfaden stellt dar, wie ein Update auf die Version 4.7 durchgeführt wird. Update der Lizenzdatenbank Bei der Anmeldung an einem Repository in FS 4.7 kommt die Meldung, dass die Lizenzdatenbank upgedated werden muss. Dieses notwendige Update begründet sich in unserer Lizenzumstellung (siehe Neuheiten). Nach dem Upgrade der Lizenzdatenbank kommt bei dem Versuch einer Anmeldung an einem Package die Meldung, dass die Lizenz nicht valide ist. Aus diesem Grund muss mit Hilfe der FrameworkStudioAdministration eine neue FS-Lizenz eingespielt werden, welche von uns bereitgestellt wird. Die neu benötigte Lizenz hat die Dateiendung .fslx. Update einer Package-Version Für das Update einer Package-Version arbeiten Sie bitte die folgende Anleitung durch. Package-Manager 4.7 starten und an Repository anmelden Die Checkbox Show only applicable packages abhaken, weil die Package-Version noch nicht die Version 4.7 hat. Die gewünschte Package Version öffnen und den Button Lock drücken Mit dem Button Upgrade die Package-Version auf 4.7 upgraden In der Using-Hierarchy passende Version für die Basis-Packages auswählen Button UnLock drücken, um die Package-Version wieder freizugeben Compile-Wizard macht in der Regel keinen Sinn, weil es aufgrund der vielen Änderungen sowieso zu Compile-Fehlern kommen wird. Stattdessen wird jetzt mit dem FCUser weitergearbeitet. IDE starten und mit dem FCUser an der Package-Version anmelden. Die Checkbox Maintenance-Mode anhaken - Get Latest Version und Get Dlls sollten sollten angehakt sein. Nacheinander die folgenden Maintenance-Routinen ausführen Menüpunkt Update / FS 4.7 / (1) Namespace CleanUp Menüpunkt Update / FS 4.7 / (2) MsgBox.Show() Cleanup Menüpunkt Update / FS 4.7 / (3) Remove Global Cleanup Menü Compile / Compile-Manager öffnen und alles kompilieren. Wenn dabei Fehler auftreten, diese korrigieren und anschließend weiter kompilieren. Important Es kann ggf. eine große Anzahl von neuen Warnings geben. Diese müssen jetzt oder zu einem späteren Zeitpunkt manuell nachgearbeitet werden. Nähere Details dazu finden Sie in den Beschreibungen der oben aufgeführten Cleanup-Routinen. Über die Checked-Out-Suche alles einchecken - Check-In-Kommentare sind durch die Maintenance-Routinen bereits gefüllt. Im Compile-Manager den Button Complete FrameworkCompiler drücken. Die IDE schließt sich im Anschluss. Die Package-Version ist jetzt komplett upgedated und kompiliert. Bei Bedarf kann jetzt das nächste Package upgedatet werden. Zum Abschluss ist es empfehlenswert für alle upgedateten Package-Versionen noch einmal den Compile-Wizard über den Package-Manager auszuführen. So werden bei der ersten Benutzer-Anmeldung keine unnötigen Compiles ausgeführt."
  },
  "doc/access-units/access-unit-hierarchie.html": {
    "href": "doc/access-units/access-unit-hierarchie.html",
    "title": "Access Unit Hierarchie",
    "keywords": "Access Unit Hierarchie Über den Menüpunkt Tools / Access Unit Treeview ... kann das Fenster zum Bearbeiten der Access Unit Hierarchie aufgerufen werden. Über diese Hierarchie wird letztendlich festgelegt, wie das Programm durch Access Units in einzelne Programmteile unterteilt wird. Unter die Access Unit auSales sollten beispielsweise alle Access Units eingehängt werden, die mit dem Verkauf zu tun haben. Access Unit Tree: Im obigen Beispiel gehören die beiden Form Access Units aufrmAccountInfo und auftmAccountSelect (und somit die entsprechenden Forms) zur Access Unit auAccount_Information. Diese wiederum gehört zur Access Unit auAccount. Wenn eine neue Access Unit angelegt wird, wird diese automatisch unter dem Wurzelknoten Root eingehängt. Eine Access Unit hat ihre Parent Access Units als Eigenschaft. Jede AccessUnit kann an mehreren Stellen im Hierarchiebaum eingehängt sein. Es dürfen dabei aber keine Kreise entstehen. Die Parent Beziehungen werden per Drag & Drop im Hierarchiebaum geändert. Analog zu Windows wird dann, wenn man dabei die Strg-Taste drückt, kopiert, ohne Strg-Taste verschoben."
  },
  "doc/access-units/access-units.html": {
    "href": "doc/access-units/access-units.html",
    "title": "Access Units",
    "keywords": "Access Units Eine Access Unit repräsentiert einen Programmbereich. Für jede Access Unit kann für 5 verschiedene Zugriffsarten (Access, AccessDerived, Insert, Update und Delete) abgefragt werden, ob der entsprechende Zugriff (nach Auswertung der Lizenzen und der Rechte des Benutzers) erlaubt wird. Für ein Form haben die Zugriffsarten folgende Bedeutung: Access: Das Form darf geöffnet werden AccessDerived: Ableitungen dieses Forms dürfen geöffnet werden Insert: Einfügen von Datensätzen ist mit diesem Form erlaubt Update: Vorhandene Datensätze dürfen aktualisiert werden Delete: Datensätze dürfen gelöscht werden Der Entwickler kann folgende Eigenschaften über das Designerfenster einer Access Unit definieren: Name Name der Access Unit. Aus diesem ergibt sich automatisch der im generierten Code verwendete Name Name in code. Label Mehrsprachige Bezeichnung der AccessUnit. Diese wird im externen Werkzeug zur Rollenverwaltung (Bestandteil der Runtime Administration) angezeigt. Description Hier kann (mehrsprachig) beschrieben werden, welchen Programmbereich diese Access Unit repräsentiert. Die Beschreibung wird u. a. im externen Werkzeug zur Rollenverwaltung als Tooltip zur AccessUnit angezeigt. Im Designerfenster wird über die Checkbox is form AccessUnit angezeigt, ob diese Access Unit die spezielle Form Access Unit (s.u.) ist, die beim Öffnen des Forms in der Anwendung ausgewertet wird. Diese Eigenschaft kann durch den Benutzer nicht geändert werden. Unter dem Punkt Parents werden alle Access Units aufgeführt, von denen diese Access Unit eine Unterkomponente ist, also alle Elternknoten im Access Unit Treeview. Diese Eigenschaft kann über den Access Unit Treeview (Access Unit Hierarchie) oder hier direkt geändert werden. Über die Textbox kann ein neuer Parent ausgewählt und über den Plus-Button hinzugefügt werden. Über den Löschen-Button kann eine zuvor selektierte Parent-AccessUnit gelöscht werden. Der letzte Parent kann jedoch nicht entfernt werden. Sowohl die Children als auch die Parent-AccessUnits können über einen Doppelklick geöffnet werden. Access Units können im Namespace angelegt werden (z.B. auSales, um den kompletten Verkauf zu repräsentieren). Für diese Access Units steht der gewohnte Checkin/Checkout-Mechanismus zur Verfügung. Außerdem können Access Units in einem Form angelegt werden (Menü File / New / Access Unit oder Button New ... / Access Unit). Diese Access Units sind Unterkomponenten des Forms und werden daher automatisch mit dem Form aus- und eingecheckt. Jedes Form besitzt automatisch eine besondere Access Unit, die das Form selber repräsentiert. Der Name dieser Form Access Unit ist der Name des Forms mit dem Präfix au (also z.B. für frmSalesOrder aufrmSalesOrder). Wenn ein Form in der Anwendung geöffnet wird, so wird vorher automatisch überprüft, ob das Recht „Access“ für die FormAccessUnit des Forms erteilt wurde und ob für alle FormAccessUnits der Basisforms das Recht „AccessDerived“ erteilt wurde. Für jedes Form wird automatisch eine FormAccessUnit angelegt. Diese Access Unit kann nicht gelöscht werden. Ist ein oder mehrere Parents ungültig, wird der Button Fix the parent Access Unit angezeigt. Wird dieser Button gedrückt, hat dies zur Folge, dass die ungültige Beziehung gelöscht wird. Sollte kein anderer gültiger Parent verfügbar sein, wird 'Root' als Parent definiert. Form Designer Registerkarte Access Units: Aus dem Code heraus kann ein Zugriffsrecht einer AccessUnit von einem Form aus folgendermaßen abgefragt werden: bool InsertGranted = Global.AUHelper.Granted(this.aufrmSalesOrder, AUPermissionType.Insert); bool FormAccessGranted = Global.AUHelper.Granted(this.FormAccessUnit); bool AuSalesGranted = Global.AUHelper.Granted(AUList.auSales, AUPermissionType.Delete); Wenn kein AUPermissionType angegeben wird, wird automatisch Access abgeprüft. Auf die FormAccessUnit kann aus dem Form sowohl über ihren Namen als auch über FormAccessUnit zugegriffen werden. Über die Klasse AUList sind alle global verfügbaren AccessUnits ansprechbar."
  },
  "doc/access-units/allgemeine.html": {
    "href": "doc/access-units/allgemeine.html",
    "title": "Rechteverwaltung / Access Units",
    "keywords": "Rechteverwaltung / Access Units Allgemeiner Überblick Für die mit Framework Studio erstellte Anwendung wird eine umfangreiche Rechteverwaltung bereitgestellt. Diese Rechteverwaltung hat im Wesentlichen zwei Aufgaben: Programmbereiche, für die ein Kunde keine Lizenz erworben hat, sollen für den Kunden gesperrt werden. Benutzerabhängiges Verhalten der Anwendung: Abhängig von den Aufgaben, die ein Benutzer im Unternehmen hat, sollen gezielt Programmteile gesperrt werden können. Beispiel: Ein Hausmeister muss Bestellungen aufgeben können, darf aber keine Informationen über Zahlungsrückstände von Kunden bekommen. Zentraler Punkt bei der Entwicklung sind sogenannte Access Units. Diese repräsentieren Programmbereiche. Bei der Entwicklung mit Framework Studio werden Access Units definiert und hierarchisch angeordnet. Ein Packagehersteller kann zu einem Repository eine Lizenz erstellen, die definiert, welche Access Units frei geschaltet werden sollen und welche gesperrt werden sollen. Diese Lizenz kann als signierte Xml-Datei weitergegeben werden. Dazu wird der Runtime License Manager (Laufzeitlizenzen) verwendet. Mit diesem können auch Lizenzen zu allen installierten Packages in eine einzige Xml-Datei gespeichert werden. Eine solche Xml-Datei muss zur Laufzeit der Anwendung im Brokerverzeichnis mit dem Namen FSLicense.xml bereit liegen. Wenn das benutzerabhängige Verhalten erwünscht ist, muss für die entsprechende Application die Authentifizierung aktiviert werden (\uF0E0Authentication). Des Weiteren muss zur Laufzeit ein Authentifizierungsdienst zur Verfügung stehen. Der Broker wird diesen Dienst kontaktieren, um einen Benutzer mit Passwort zu authentifizieren. Der Authentifizierungsdienst teilt dem Broker dabei mit, welche Rollen ein Benutzer innehat."
  },
  "doc/access-units/laufzeitlizenzen.html": {
    "href": "doc/access-units/laufzeitlizenzen.html",
    "title": "Laufzeitlizenzen",
    "keywords": "Laufzeitlizenzen Mit dem Runtime License Manager werden Laufzeitlizenzen für die mit Framework Studio erstellte Anwendung erzeugt und verwaltet. Dieses Werkzeug wird über den Menüpunkt Tools / Runtime License Manager in Framework Studio oder im Package Manager gestartet. Außerdem wird das Tool über den Button Change configuration unter dem Navigationspunkt Runtime License sowohl im Run Wizard als auch im Publish Wizard gestartet. Allgemeines / Hintergrund Laufzeitlizenzen werden im Repository gespeichert. Dort können für jede Package-Version beliebig viele Lizenzen abgelegt werden. Wenn eine Applikation gestartet werden soll, muss zuvor im Brokerverzeichnis die Datei FSLicense.xml erstellt werden. Diese Datei enthält für jede Package-Version der Applikation eine Lizenz. Mit dem Runtime License Manager wird gesteuert, welche der vorhandenen Lizenzen für die erstellten Applikationen und Service Hosts verwendet werden sollen. Wenn Sie den Runtime License Manager aus dem Run Wizard oder aus dem Publish Wizard heraus starten, werden die Einstellungen im aktuellen Setting gespeichert. Sollte für ein Package, von dem man der Besitzer ist, noch keine Lizenz existieren, wird für das Package automatisch eine Developer Lizenz erzeugt. Wenn Sie den Runtime License Manager über den Menüpunkt Tools / Runtime License Manager starten, werden die Einstellungen, welche Lizenzen verwendet werden sollen, nicht gespeichert. Runtime License Manager: Auf der linken Seite wird ein Baum dargestellt, der sogenannte Lizenzbaum. In diesem Baum werden auf der ersten Ebene hierarchisch sortiert alle Packages der Anwendung angezeigt. In den Unterknoten der Packages werden alle im Repository (zur aktuellen Package Version) abgelegten Lizenzen angezeigt. Wenn im Lizenzbaum durch einfachen Klick mit der Maus eine Lizenz ausgewählt wird, werden alle Details zu dieser Lizenz im rechten Fensterbereich dargestellt. Dort stehen die Registerkarten Access unit tree (Registerkarte Access unit tree), License parameters (Registerkarte License Parameters) und Language (Registerkarte Language) zur Auswahl. Buttons Im Runtime License Manager stehen folgende Buttons zur Verfügung: New Anlegen einer neuen Lizenz für das aktive Package Save Alle Änderungen an der ausgewählten Lizenz werden in die Datenbank gespeichert. Dieser Button ist nur aktiv, wenn die ausgewählte Lizenz seit dem letzten Laden oder Speichern geändert wurde. Copy Es wird eine Kopie einer Lizenz aus dem aktiven Package angelegt. Dieser Button ist nur aktiv, wenn eine Lizenz aus dem aktiven Package ausgewählt ist. Delete Die ausgewählte Lizenz wird aus der Datenbank gelöscht Refresh all Alle Lizenzen des aktiven Packages werden aktualisiert. Dieser Schritt ist dann nötig, wenn sich die Access Unit Hierarchie (\uF0E0Access Unit Hierarchie) für eines der verwendeten Packages geändert hat, beispielsweise wenn eine neue Version eines Basispackages importiert wurde oder im aktiven Package neue Access Units eingecheckt wurden. Außerdem empfiehlt sich diese Aktion nach dem Upgrade von Lizenzen und nach dem Import von Lizenzen für das aktive Package. Import Eine einzelne, zuvor in eine XML-Datei exportierte Lizenz wird importiert. Export Die ausgewählte Lizenz wird in eine XML-Datei exportiert. Export all Alle Lizenzen des aktiven Packages werden in je eine XML-Datei in einem gemeinsamen Ordner exportiert. Upgrade Lizenzen, die im Repository für eine ältere Package Version (Label) des ausgewählten Packages gespeichert sind, können in die aktuelle Package Version kopiert werden. Siehe Lizenz aus einem anderen Label übertragen. Search Startet den Dialog zum Suchen nach AccessUnits. Siehe \uF0E0Suche nach Access Units. Save Configuration Die Lizenzauswahl wird in das aktuelle Setting gespeichert und der Runtime License Manager geschlossen. Siehe \uF0E0Konfiguration speichern. Dieser Button steht nur dann zur Verfügung, wenn der Runtime License Manager über den Run Wizard oder den Publish Wizard geöffnet wurde. Save FSLicense.xml Die Xml-Datei FSLicense.xml wird im Brokerverzeichnis erzeugt, die für jedes Package der Anwendung eine Lizenz erhält, und der Runtime License Manager wird geschlossen. Siehe Konfiguration speichern. Dieser Button steht nur dann zur Verfügung, wenn der Runtime License Manager über den Menüpunkt Tools / Runtime License Manager gestartet wurde. Language Mit diesem Drop Down Button wird die Sprache ausgewählt, in der die Access Units im Access Unit Tree (Registerkarte Access unit tree) dargestellt werden. Zur Auswahl stehen alle Sprachen, die im Default Package definiert wurden und , um den technischen Namen der AccessUnit darzustellen. Lizenz aus einem anderen Label übertragen Wenn im Lizenzbaum ein Package ausgewählt ist, kann mit dem Button Upgrade der Dialog zum Kopieren von Lizenzen aus einer anderen Version des Packages (Label) geöffnet werden. Runtime License Manager - Upgrade: In der Combobox Source Label wird das Label ausgewählt, von dem Lizenzen kopiert werden sollen. Mit dem Button Upgrade werden die ausgewählten Lizenzen kopiert. Wird ein bereits gelöschtes Label ausgewählt, können Lizenzen mit dem Button Delete endgültig aus dem Repository entfernt werden. Beim Upgrade wird der Gültigkeitsbereich der Lizenzen (Version from und Version to) auf die aktuelle Packageversion erweitert, wenn diese eine gültige .NET Version ist (2 bis 4 natürliche Zahlen getrennt durch je einen Punkt) und die aktuelle Packageversion nicht durch den Versionsbereich abgedeckt ist. Andernfalls wird der Gültigkeitsbereich unverändert übernommen. Warning Beim Upgrade von Lizenzen aus einem Basispackage werden diese nicht verändert, wenn man nicht Besitzer des Packages ist. Neue Funktionalität ist also ggf. nicht freigeschaltet. Dazu muss eine neue Lizenz vom Hersteller des Basispackages eingespielt werden. Suche nach Access Units Wenn im Lizenzbaum eine Lizenz ausgewählt ist, die keine Developer-Lizenz ist, kann mit dem Button Search der Dialog zum Suchen nach Access Units gestartet werden. Access Unit Search: Im Textfeld Search for geben Sie den Suchtext an. Im Bereich Search in geben Sie an, wo nach diesem Text gesucht werden soll: Name Technischer Name der Access Unit, z.B. aufrmArticle Label Bezeichnung, die im Access Unit Tree angezeigt wird Description Beschreibung, die für die Access Unit hinterlegt wurde ID ID, die die Access Unit eindeutig identifiziert Mit der Checkbox Search Up legen Sie fest, ob von der aktuellen Position im Access Unit Tree aus aufwärts gesucht werden soll. Im Bereich Permissions kann nach bestimmten Zugriffsrechten gesucht werden. Durch setzen der Checkboxen Access, Access Derived, Update, Insert oder Delete werden Vergleiche für die jeweilige Zugriffsart aktiviert. Für jede Zugriffsart kann der Wert mit einem der folgenden verglichen werden: access-unit-permissions-options In der folgenden Übersicht wird für jede Option angegeben, auf welche Werte die Option einschränkt: None None und Explicit None Allowed Hierarchic Allowed und Explicit Allowed Denied Hierarchic Denied und Explicit Denied Explicit None Explicit None Explicit Allowed Explicit Allowed Explicit Denied Explicit Denied Gray Alle Rechte, jedoch nur die, die durch eine verwendete Lizenz verboten sind. Das entspricht allen Checkboxen, die mit grauem Hintergrund dargestellt werden. Ändern Sie das Recht durch Anklicken oder über das Kontextmenü der Rechte-Checkbox. Mit dem Button Find Next wird die Suche gestartet, mit dem Button Done beenden Sie die Suche und schließen das Suchfenster. Die Suchergebnisse werden im Access Unit Tree blau und unterstrichen dargestellt. Mit dem Button Show List werden alle Access Units, die den Suchkriterien entsprechen in einer Liste angezeigt. In diesem Dialog kann mit dem Button Copy to clipboard (Tastenkombination Strg-C) die gesamte Liste mit Suchkriterien in die Zwischenablage kopiert werden. Mit dem Button Copy selected to clipboard werden alle ausgewählten Einträge in die Zwischenablage kopiert. Durch Doppelklick auf einen Eintrag wird dieser im Access Unit Tree ausgewählt. Konfiguration speichern Mit dem Button Save Configuration / Save FSLicense.xml werden die aktuell ausgewählten Lizenzen in das aktuelle Setting übernommen bzw. in die Datei FSLicense.xml geschrieben und anschließend der Runtime License Manager geschlossen. Diese Funktion kann nur dann aufgerufen werden, wenn im Lizenzbaum eine Lizenz des aktiven Packages ausgewählt ist. Außerdem muss für jedes Basispackage eine Lizenz im Lizenzbaum ausgewählt sein (gelbe Markierung). Wenn Sie für ein Basispackage eine andere Lizenz als die zurzeit gelb hinterlegte verwenden wollen, öffnen Sie das Kontextmenü der gewünschten Lizenz und wählen dort den Eintrag Use as Basic License aus. Registerkarte Access unit tree Auf dieser Registerkarte werden alle Access Units im so genannten Access Unit Tree dargestellt. Der Access unit tree stellt die Hierarchie dar, in der die Access Units angeordnet sind. Warning Damit die Hierarchie auf dem aktuellen Stand ist, müssen an allen Packages, nach der letzten Änderung der Hierarchie des jeweiligen Packages, AccessUnits als FrameworkCompiler „recursive from root“ kompiliert worden sein! Dabei ist zu beachten, dass die Hierarchie eines Packages sich nicht nur über den Access Unit Treeview (Access Unit Hierarchie) ändern lässt, sondern auch bei jedem Einchecken eines neuen Forms automatisch geändert wird. Importierte Packages müssen zur Aktualisierung der Hierarchie grundsätzlich nicht neu kompiliert werden, da dies bereits vor dem Export geschehen sein sollte. In der Spalte Name werden alle Access Units hierarchisch dargestellt. Access Units mit einem Schlüsselsymbol , Form Access Units mit einem Schlüssel auf einem Form . In den übrigen Spalten symbolisieren spezielle Checkboxen das erteilte Recht für die einzelnen Zugriffsarten (ACC = Access, ACD = AccessDerived, UPD = Update, INS = Insert, Del = Delete, Bedeutung der Zugriffsarten: Access Units). Die speziellen Checkboxen können verschiedene Symbole darstellen: Leere Checkbox: Keine Angabe durch den Benutzer. Der Anwendung wird diese Zugriffsart für die AccessUnit verwehrt. Blauer Haken: Die Zugriffsart der AccessUnit wird explizit erlaubt. Roter waagerechter Strich: Die Zugriffsart der AccessUnit wird explizit verweigert. Gelbes Prozentzeichen: Zu dieser Zugriffsart der AccessUnit wird explizit keine Angabe durch den Benutzer gemacht. Der Anwendung wird diese Zugriffsart verwehrt. Grauer Haken: Die Zugriffsart der AccessUnit wird erlaubt, weil diese AccessUnit ein Unterelement einer AccessUnit ist, für welche die Zugriffsart erlaubt wird (hierarchisch erlaubt). Grauer waagerechter Strich: Die Zugriffsart der AccessUnit wird verweigert, weil diese AccessUnit ein Unterelement einer AccessUnit ist, für welche die Zugriffsart verweigert wird und diese AccessUnit nicht unter einer anderen AccessUnit hängt, für welche die Zugriffsart erlaubt wird (hierarchisch verboten). Wenn eine Checkbox mit grauem Hintergrund dargestellt wird, so bedeutet dies, dass das repräsentierte Zugriffsrecht bereits durch eine der verwendeten Basislizenzen verweigert wird. Sie können in der Lizenz für das aktuelle Package diese Zugriffsart trotzdem erlauben. Die Endanwendung wird diese Zugriffsart jedoch nur erlaubt bekommen, wenn andere Basislizenzen verwendet werden, die diese Zugriffsart ebenfalls ermöglichen. Mit dem Menüeintrag Parents im Kontextmenü einer Access Unit erhält man eine Liste aller Access Units, die die ausgewählte Access Unit als Unterelement enthalten. Wählt man aus der Liste eine Access Unit aus, wird direkt dorthin gesprungen. Im Access Unit Tree kann mit der Multiplikationstaste * der komplette Teilbaum der ausgewählten AccessUnit aufgeklappt werden, mit der Subtraktionstaste - wird der Teilbaum wieder kollabiert. Registerkarte License Parameters Diese Registerkarte beinhaltet alle allgemeinen Eigenschaften der ausgewählten Lizenz: License ID Automatisch generierte ID der Lizenz. Dieser Wert kann nicht geändert werden. Name Name der Lizenz. Dieser Name wird im Lizenzbaum angezeigt. Customer Person oder Firma, für welche die Lizenz ausgestellt wurde. Type Typ der Lizenz. Zur Auswahl stehen Customer, Demo, Developer und Partner. Lediglich der Typ Developer hat eine besondere Bedeutung: Bei einer Developer-Lizenz werden alle Access Unit Rechte erteilt (soweit sie nicht durch andere Lizenzen für Basispackages gesperrt wurden). Daher steht die Registerkarte Access unit tree bei einer Developer-Lizenz nicht zur Verfügung. Die zweite Besonderheit einer Developer-Lizenz ist, dass die Authentifizierung deaktiviert wird, auch wenn die Applikation so konfiguriert wurde, dass Authentifizierung verwendet werden soll. Category Die Kategorie, der die Lizenz zugeordnet wurde. Kategorien können beliebig benannt werden, dürfen aber nur aus den Buchstaben A-Z, dem Trennstrich, dem Unterstrich und Ziffern bestehen. Groß-Klein-Schreibung ist dabei unerheblich. Wird keine Kategorie angegeben, so ist die Lizenz automatisch mit der Standardkategorie „Standard“ verknüpft. (Kategorien für Laufzeitlizenzen) User Limit Hier kann die Zahl der gleichzeitig aktiven Benutzer begrenzt werden. Valid from Datum, ab dem die Lizenz gültig ist Valid to Datum, an dem die Gültigkeit der Lizenz endet Version from Packageversion, ab der die Lizenz gültig ist. Die Version muss aus zwei bis vier natürlichen Zahlen getrennt durch je einen Punkt bestehen oder leer sein, um keine Einschränkung festzulegen. Version to Packageversion, bis zu der die Lizenz gültig ist. Die Version muss aus zwei bis vier natürlichen Zahlen getrennt durch je einen Punkt bestehen oder leer sein. Nicht angegebene Unterversionen werden mit eingeschlossen. Beispiel: Version 3.9.1 wird freigegeben, wenn die Versionsobergrenze (Version to) auf 3.9 festgelegt wurde. Package Name des Packages, für die die Lizenz erstellt wurde Version Version des Packages, für das die Lizenz erstellt wurde Kategorien für Laufzeitlizenzen Motivation Es gibt Anwendungsfälle, in denen nur ein Bruchteil einer kompletten Anwendung zum Einsatz kommen soll. Typische Beispiele sind Kassen oder Scanner. Sie nutzen nur einen sehr kleinen Umfang der Gesamtanwendung. Häufig kommen diese speziellen Arbeitsplätze in großer Zahl vor. Daher wünschen Endkunden für diese funktional stark eingeschränkten Anwendungen \"günstigere\" Lizenzen. Prinzip Einer Laufzeitlizenz kann eine Kategorie zugeordnet werden. Zur Laufzeit wird pro Kategorie geprüft, ob die in der Lizenz angegebene Benutzerzahleinschränkung erfüllt ist. So können zwei unterschiedliche Lizenzen mit unterschiedlichem Funktionsumfang und abweichender Benutzerzahlbeschränkung, die abweichenden Kategorien zugeordnet sind, parallel eingesetzt werden. Beispiel: Lizenz „Scanner“ schaltet nur einen kleinen Funktionsumfang frei, ist der Kategorie „SCANNER“ zugeordnet und für 25 User ausgelegt. Lizenz „Standard“ schaltet die gesamte Anwendung frei, ist der Kategorie „STANDARD“ zugeordnet und für 10 User ausgelegt. Wenn Sie nun eine Applikation mit der Lizenz „Scanner“ veröffentlichen und eine weitere Applikation mit der Lizenz „Standard“, so können 25 Benutzer die eingeschränkte Applikation „Scanner“ starten und parallel dazu 10 Benutzer die andere Applikation in vollem Funktionsumfang. Insgesamt kann die Anwendung von 35 Benutzern parallel gestartet werden. Details Im Runtime License Manager kann auf der Registerkarte License Parameters der aktuell ausgewählten Lizenz im Textfeld Category eine Kategorie zugeordnet werden (Registerkarte License Parameters). Kategorien können beliebig benannt werden, dürfen aber nur aus den Buchstaben A-Z, dem Trennstrich, dem Unterstrich und Ziffern bestehen. Groß-Klein-Schreibung ist dabei unerheblich. Wird keine Kategorie angegeben, so ist die Lizenz automatisch mit der Standardkategorie Standard verknüpft. Eine Lizenz kann mit Lizenzen für Basispackages zusammen eingesetzt werden, die einer anderen Kategorie zugeordnet sind."
  },
  "doc/allgemein/licenses.html": {
    "href": "doc/allgemein/licenses.html",
    "title": "Lizenzverwaltung",
    "keywords": "Lizenzverwaltung Um mit Framework Studio arbeiten zu können müssen gültige Lizenzinformationen eingespielt werden. Dazu werden beim Starten von Framework Studio oder des Package Managers einige Verwaltungsmöglichkeiten angeboten. Im Menüpunkt Licenses des Repository-Auswahl Dialogs gibt es die Unterpunkte Choose License Database ... und Manage Licenses, diese werden im Folgenden erläutert: Choose License DB Mit diesem Menüpunkt öffnet sich der Choose License DB Dialog. In ihm kann die Datenbank angegeben werden, in der die Lizenz für die Benutzung von Framework Studio abgelegt ist. Wird Use existing license database ausgewählt, so kann eine bereits bestehende Datenbank über Eingabefelder im unteren Dialogbereich konfiguriert werden. Wird Create new license database gewählt, kann eine neue Lizenzdatenbank erzeugt werden. Dazu muss im Feld Framework Studio License File eine Lizenzdatei für Framework Studio angegeben werden. Diese Lizenz wird dann in die neu erstellte Lizenzdatenbank kopiert. Mit dem Button wird ein Dateiauswahldialog geöffnet, mit dem die Lizenzdatei ausgewählt werden kann. Durch die folgenden Angaben wird die Lizenzdatenbank spezifiziert. Connection Type Typ der Datenbank. Zur Auswahl stehen SqlServer und Oracle (managed). Siehe hierzu Connection Einstellungen. Server Name oder IP Adresse des Rechners, auf dem die Datenbank eingerichtet werden soll. Auf diesem Rechner muss der entsprechende Datenbankdienst bereits installiert und in Betrieb sein. Database Name der Lizenzdatenbank. Username Name des Datenbank-Benutzers. Wird bei SQL-Server kein Benutzer angegeben, dann wird Windows-Authentifizierung verwendet. Password Passwort des Datenbank-Benutzers. Mit dem Button Test Connection kann überprüft werden, ob mit den angegebenen Daten eine Verbindung zum Datenbanksystem hergestellt werden kann. Mit dem Button OK werden die Angaben übernommen und gegebenenfalls das neue Repository erstellt. Mit dem Button Cancel verlassen Sie den Dialog, ohne dass Änderungen übernommen werden. Manage Licenses Mit diesem Menüpunkt öffnet sich der Manage Licenses Dialog. Er bietet umfassende Möglichkeiten die Framework Studio Lizenzen zu verwalten. Mit dem Button (Import License) können Sie eine Lizenz-Datei importieren. Es erscheint ein Datei-Auswahl-Dialog in dem Sie eine *.fslx-Datei auswählen können. Nach der Auswahl wird die darin enthaltene Lizenz erstellt. Mit dem Button (Export License) wird die im Baum markierte Lizenz in eine fslx-Datei exportiert. Mit dem Button (Delete) wird die im Baum markierte Lizenz gelöscht. Warning Wenn Sie mehrere Lizenzen importieren, die für das aktuelle Datum und die aktuelle Version gültig sind, wird die Anzahl der Benutzer im User Limit nicht addiert. Es wird zufällig eine gezogen."
  },
  "doc/allgemein/options.html": {
    "href": "doc/allgemein/options.html",
    "title": "Options",
    "keywords": "Options Die Options können in der IDE über den Menüeintrag Tools / Options geöffnet werden. IDE (Registerkarte) Login Auto Debug DLLs Diese Option kann hinterlegt werden und wird im Login-Dialog und im GetDLLs-Dialog verwendet. Auf den \"normalen\" Compile hat diese Option keine Auswirkung. Im Login- und GetDLL-Dialog wird die Einstellung aus den Options übernommen. Die Einstellung kann jedoch in beiden Dialogen temporär geändert werden. Bedeutet, dass Änderungen am Auto Debug im Login- oder GetDLL-Dialog keine Auswirkungen auf die Option im Options-Dialog haben. Es stehen folgende drei Optionen zur Verfügung: Service, Component: Alle Namespaces der Services und Components werden debuggable kompiliert. Service, Component, Form: Alle Namespaces der Services, Components und Forms werden debuggable kompiliert. All: Hier werden alle Namespaces jeden Types debuggable kompiliert. None: Bei dieser Einstellungen wird nichts debuggable kompiliert. Appearance Error Display Wird die Checkbox Legacy Error Window gesetzt, kann erzwungen werden, dass die Errors in derselben Art und Weise ausgegeben werden, wie es bis Framework Studio 2.6 der Fall war. Documentation Indicators Zeigt an den Controls im Form-Designer an, ob eine Dokumentation gepflegt ist, bzw vererbt wurde. Siehe Dokumentationsstatus von Steuerelementen Spell Checker Deaktiviert die automatische Rechtschreibprüfung im Dokumentationseditor. Form Control DoubleClick Gibt an, was im Form-Designer passieren soll, wenn auf ein Control Strg + Doppelklick ausgeführt wird. RadioButton Show Control Events: Zeigt den Events-Dialog für das Control an. Diese Option ist sinnvoll für normale Entwickler. Der Documentation-Editor kann über das Context-Menü des Controls geöffnet werden. RadionButton Show Documentation: Zeigt den Documentation-Editor für das Control an. Diese Option ist sinnvoll für Benutzer, die viel an Dokumentationen arbeiten. Die Control-Events können über das Context-Menü des Controls geöffnet werden. Languages in designer Hier können die Sprachen eingestellt werden, die in den MLStrings und im Wörterbuch angeboten werden sollen. Die Reihenfolge wird - sofern dies möglich ist - von den Designer-Fenstern berücksichtigt. Es werden kommasepariert die Iso-Codes der Sprachen angegeben - z.B. de,en,fr. Wird keine Angabe gemacht, werden in allen Designer-Fenstern immer alle verfügbaren Sprachen angeboten. Code Editor Font Family und Size Hier können Schriftart und -größe für den Code Editor angepasst werden. Disable DocML Word Wrap DocML-Editoren brechen standardmäßig am Ende einer Zeile um. Dies geschieht abhängig von der Breite des Editors. Ist dieses Verhalten nicht gewünscht, so kann über die Option Disable DocML Word Wrap das Umbrechen deaktiviert werden. Der Editor zeigt dann bei Bedarf eine horizontale Scrollbar an. Fold all after load Wenn aktiviert, dann werden nach dem Laden des Codes im Editor alle möglichen Codeblöcke zusammengeklappt dargestellt. In einem C# Editor z.B. #region und #endregion. Compile / Debug (Registerkarte) Broker Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Host Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Compile Rootdirectory Gibt an, unter welchem Ordner Framework Studio die Compile-Verzeichnisse erzeugen soll. Diese Einstellung muss manuell in der Datei FrameworkStudio.exe.config angepasst werden. Beispiel: <configuration> <appSettings> <add key=\"CompileBaseDirectory\" value=\"C:\\FS\\Compile42\" /> [...] Open compiled code in Hier können Sie externe Programme (Visual Studio, VS Code, etc.) konfigurieren, in welchen der kompilierte Code eines Elements angezeigt werden soll. Der Aufruf erfolgt über das Menü View / Compiled code in {Caption} in den Designer-Fenstern oder über die entsprechenden Shortcuts. Standardmäßig versucht Framework Studio die derzeit unterstützten Versionen von Visual Studio zu erkennen und diese beim Path der beiden Konfigurationen zu hinterlegen. Caption Die Captions sind standardmäßig \"Visual Studio\" und \"Visual Studio (new instance)\". Die erste Konfiguration öffnet den Code standardmäßig in einer bestehenden Visual Studio Instanz. Bei der zweiten Konfiguration wird eine neue Instanz von Visual Studio gestartet. Die Captions können bearbeitet werden und dienen als ergänzende Beschreibung für die Menü-Einträge im Designer-Fenster. Path Wie in der Einleitung beschrieben, versucht Framework Studio eine Visual Studio Instanz zu finden und diese als Pfad zu hinterlegen. Wenn eine andere Version oder Edition (z.B. Visual Studio Express) verwendet werden soll, kann das entsprechende Programm angegeben werden. Der Ordner aus der ersten \"Open compiled code\"-Konfiguration wird außerdem dafür verwendet, um für die Arbeit mit Services das Programm WcfTestClient.exe zu finden. Wird bei der zweiten Konfiguration kein Path angegeben, wird auf die erste Konfiguration zurückgegriffen, also dem Visual Studio Path oder auf ein von Ihnen bereits hinterlegtes Programm. Arguments Hier können die Kommandozeilen-Argumente für das Öffnen der Quellcode-Dateien angegeben werden. Beim Einsatz von Visual Studio können die Standard-Einstellungen %file% /Edit beibehalten werden. Der Platzhalter %file% steht für die zu öffnenden Dateien. Dieser werden in dem Format \"Datei1.cs\" \"Datei2.cs\"… übergeben. Wenn dieser Platzhalter nicht angegeben ist, dann werden die Dateien an der Parameter gestellt. Reset Buttons Die Reset Buttons setzen die Felder auf die Default Werte zurück. Utilities (Registerkarte) Mit dem Button [...] kann jeweils ein Dateiauswahldialog geöffnet werden. SvcUtil Gibt den Pfad zur SvcUtil.exe des Windows SDK an. Diese wird für die Generierung des Services verwendet. InstallUtil Gibt den Pfad zur InstallUtil.exe des .NET-Frameworks an. Crystal Report Designer Gibt den Pfad zum Crystal Report Designer an. Diff Tool Hier kann die ausführbare Datei für das Diff Tool angegeben werden. Gut geeignet ist beispielsweise das frei verfügbare Vergleichswerkzeug WinMerge. Diff Tool Data Dir Hier kann das Datenverzeichnis für das Diff Tool angegeben werden. Hier werden temporär die zu vergleichenden Dateien reingeschrieben"
  },
  "doc/application/application.html": {
    "href": "doc/application/application.html",
    "title": "Application",
    "keywords": "Application"
  },
  "doc/authentication-service/authentication-service-common.html": {
    "href": "doc/authentication-service/authentication-service-common.html",
    "title": "Authentication Service",
    "keywords": "Authentication Service Update Sichern Sie den bestehenden Authentication Service in einem neu angelegten Verzeichnis. Deinstallieren Sie den Windows-Service des bestehenden Authentication Service. Dazu kann der AuthenticationServiceConfigEditor verwendet werden (siehe Deinstallation). Kopieren Sie die neuen Dateien aus dem Ordner bin\\ in den Zielordner. Note Die Datei AuthenticationService.exe.config im Zielverzeichnis muss erhalten bleiben. Darin sind alle Konfigurationseinstellungen für den Authentication Service gespeichert. Installieren Sie den neuen Authentication Service wie im Abschnitt Installation ab 3. beschrieben. Note Auch wenn Sie im AuthenticationServiceConfigEditor keine Änderungen vornehmen, speichern Sie in jeden Fall mit der Funktion Save Changes. Update der Datenbank Bei der Datenbank handelt es sich um ein Repository. Ein Update auf die entsprechende Framework-Studio Version passiert folgendermaßen: Handelt es sich um ein Entwicklungs-Repository, dann erfolgt der Update über Framework Studio. Bei einem Runtime-Repository erfolgt der Update über den Publish Wizard oder Publish2Go Wizard. Installation Erstellen Sie den Zielordner für den Service. Empfehlung: C:\\Programme\\enventa Group\\FS AuthService\\ Kopieren Sie den Inhalt des Ordners bin\\ in den Zielordner. Jetzt müssen Sie die Konfiguration des Services festlegen. Führen Sie dazu im Zielordner das Programm AuthenticationServiceConfigEditor.exe aus. Dieses Programm bearbeitet den Inhalt der Konfigurations-Datei AuthenticationService.exe.config. Sie erhalten das folgende Bild: Geben Sie im Abschnitt Database Connection die gewünschte Verbindung zu der Datenbank an, in welcher der Service die Benutzerdaten ablegen soll. Standardmäßig wird dazu das Repository Ihrer Anwendung verwendet. Mit Test connection können Sie prüfen, ob die angegebene Verbindung zur Datenbank hergestellt werden kann. Geben Sie im Abschnitt Service die folgenden Daten ein: Bei Name ggf. einen anderen Namen für den Service. Die ID müssen Sie mit Generate ID neu erzeugen. Dabei wird eine absolut eindeutige Guid generiert. Die URL können Sie mit Set Default auf den eigenen Rechnernamen setzen. Dort ist z.B. auch eine IP-Adresse möglich. Es kann ein anderer Port als 20001 verwendet werden. Dann müssen die Konfigurationen der Clients, die mit dem Service kommunizieren sollen, auf den geänderten Port angepasst werden. Für Private Key und Public Key müssen Sie mit Generate Keypair ein neues Schlüsselpaar generieren. Abschnitt Windows-Service Hier können nur Änderungen vorgenommen werden, solange der Service nicht installiert worden ist. Ändern Sie diese Einstellungen auch niemals manuell in der AuthenticationService.exe.config. Ansonsten kann der Authentication-Service dem Windows-Dienst nicht mehr zugeordnet werden. Service Name: Unter diesem Namen wird der Service in den Windows-Diensten registriert. In dem Feld können Sie einen Namens-Zusatz angeben. Das ist vor allem dann notwendig, wenn Sie mehrere Authentication-Services auf einem Rechner installieren, da der Name in den Windows-Diensten eindeutig sein muss. Description: Diese wird als Description in den Windows-Diensten gespeichert. Wenn Sie diese Einstellung nachträglich ändern möchten, dann müssen Sie: den Dienst mit dem Link stop Service beeneden, ihn dem Link uninstall Service deinstallieren, die Änderungen vornehmen und speichern und den Dienst mit dem Link install Service wieder installieren. Dabei sollte der Benutzer-Account des Dienstes wieder der von vorher sein – ggf. vor der ganzen Aktion merken. Speichern Sie die Änderungen mit Save Changes ab. Auf der Registerkarte Application Security können erweiterte Sicherheitsanforderungen, die für Ihre Anwendungen gelten sollen, konfiguriert werden. Mit Set Default werden die Standardeinstellungen dieser Registerkarte wiederhergestellt. Im Bereich General Settings können Sie zunächst die vom Authentifizierungsdienst geduldete Maximallänge für Benutzernamen ändern (Einstellung Maximum username length). Das Eingabefeld Domain controller muss leer bleiben, wenn die Authentifizierung beim Start der Endanwendung nicht automatisch mit den angemeldeten Windows-Benutzern erfolgen soll. Andernfalls muss hier der zu verwendende Domain Controller (DC) angegeben werden (z.B. mydc.mycompany.com). Das Eingabefeld Domain muss ebenfalls leer bleiben, wenn die Authentifizierung beim Start der Endanwendung nicht automatisch mit dem angemeldeten Windows-Benutzer erfolgen soll. Andernfalls muss hier in Großbuchstaben der Name der Domäne angegeben werden (z.B. MYDOMAIN). Die Authentifizierung über die Domäne kann nur dann funktionieren, wenn Client und Authentication Service zur angegebenen Domäne gehören. Mit dem Schalter Enable advanced security legen Sie fest, ob die erweiterten Sicherheitseinstellungen grundsätzlich aktiviert werden sollen. Wenn Sie diese nicht aktivieren, sind alle weiteren Einstellungen auf dieser Registerkarte bedeutungslos und Sie können mit 10. fortfahren. Die Einstellungen im Einzelnen: Bereich General Settings: Log level: funktionslos (für spätere Erweiterungen vorgesehen). Bereich Password Complexity: Enforce character: Erzwingt, dass in jedem Passwort mindestens ein Buchstabe vorkommen muss. Enforce upper and lower: Erzwingt, dass in jedem Passwort mindestens ein Groß- und ein Kleinbuchstabe vorkommen muss. Enforce special character: Erzwingt, dass in jedem Passwort mindestens ein Sonderzeichen vorkommen muss. Welche Zeichen als Sonderzeichen erkannt werden, definieren Sie im Textfeld Special characters. Enforce number: Erzwingt, dass in jedem Password mindestens eine Ziffer vorkommen muss. Minimum length: Legt die Mindestlänge für Passworte fest. Exclusion list: Durch Leerzeichen getrennt können Sie hier Worte definieren, die im Passwort (unabhängig von der Groß-Kleinschreibung) nicht vorkommen dürfen. username steht dabei für den Namen des Benutzers. Contains excluded: Wenn diese Checkbox gesetzt ist, werden alle Passworte abgelehnt, in denen eines der Worte aus der Exclusion list vorkommt. Ist die Checkbox nicht gesetzt, werden nur die Passworte abgelehnt, die mit einem Wort aus der Exclusion list übereinstimmen. Prohibit recent: Wenn ein Benutzer sein Passwort ändert, können die letzten x Passworte des Benutzers als neues Passwort gesperrt werden. Bereich Password Validity: Minimum change period: Minimale Gültigkeitsdauer von Passworten in Tagen. Maximum change period: Maximale Gültigkeitsdauer von Passworten in Tagen. Maximum failed logins: Anzahl der nicht erfolgreichen Anmeldeversuche, nach welcher der Benutzerzugang temporär gesperrt wird. Lock time: Zeit (im Format Stunden:Minuten:Sekunden), die ein Benutzerzugang gesperrt wird, wenn die maximale Anzahl von nicht erfolgreichen Anmeldeversuchen erreicht ist. Speichern Sie Ihre Änderungen mit Save Changes. Auf der Registerkarte Runtime Supervisor kann angegeben werden, an welchem Runtime Supervisor sich der Authentication Service registrieren soll. Supervisor Checkbox Enable: Diese Checkbox muss gesetzt werden, damit der Runtime Supervisor aktiviert wird. Runtime Supervisor Url: Hier können der Server und der Port angegeben werden. Die vollständige URL wird automatisch aufgebaut. Mit dem Button Test kann versucht werden, ob eine Verbindung zum Runtime Supervisor aufgebaut werden kann. Nähere Informationen dazu sind in der Dokumentation des Runtime Supervisor zu finden. Speichern Sie Ihre Änderungen mit Save Changes. Jetzt müssen Sie das Programm als Dienst im Betriebssystem registrieren. Klicken Sie dazu den Link install Service Sie erhalten folgendes Bild: Geben Sie hier den Benutzer an, mit welchem der Dienst ausgeführt werden soll. Es wird empfohlen nach Möglichkeit einen Domain-User anzugeben, da die System-Konten standardmäßig nicht über die notwendigen Rechte verfügen. Wählen Sie dazu User aus und geben Sie in User credentials die Benutzerdaten an. Der User muss im Format Domain\\User angegeben werden. Je nach Konfiguration des Systems kann ggf. auch eines der Systemkonten verwendet werden. Diese Routine erzeugt einige Protokoll-Dateien über den Installationsverlauf im Zielordner. Diese sind kein Problem. Überprüfen Sie ggf. ob der Dienst erfolgreich installiert wurde. Im oberen Teil des Fensters sollten Sie folgendes Bild sehen: Mögliche Gründe für das Fehlschlagen der Installation: Die Konfiguration ist fehlerhaft. Prüfen Sie die Angaben*.* Der angegebene Benutzer hat nicht die notwendigen Rechte. Prüfen Sie ggf. das Ereignisprotokoll. Deinstallation Warning Es gehen die Einstellungen aus der Konfigurations-Datei AuthenticationService.exe.config verloren. Sichern Sie diese ggf. vorher. Starten Sie das Programm AuthenticationServiceConfigEditor.exe. Wenn der Dienst noch gestartet ist, stoppen Sie ihn mit dem Link stop Service. Klicken Sie den Link uninstall Service um den Dienst aus den Windows-Diensten zu entfernen. Löschen Sie den Zielordner. Client Konfiguration Wenn Sie den Authentifizierungsdienst von einem Client aus ansprechen wollen, muss dort der Service-Endpoint entsprechend konfiguriert sein. Mit Framework Studio erstellte Anwendungen In Framework Studio finden Sie in den Publish Wizard drei Stellen, an denen Sie Angaben zum Authentifizierungsdienst machen müssen. Im Bereich Authentication werden Standardbenutzer und dessen Passwort sowie die ID des Authentifizierungsdienstes festgelegt. Im Bereich Service Proxies geben Sie am AuthServiceProxy die zu verwendende Endpunktadresse an. Bei allen Anwendungen und Diensten finden Sie einen Bereich Authentication, in dem alle Angaben zur Identifikation des Clients festgelegt werden. Runtime Administration Beim Start der Runtime-Administration muss der Sername und ggf. der Port angegeben werden. Start aus der Console Der Authentication Server muss nicht zwingend als Windows Dienst installiert und gestartet werden. Insbesondere zu Testzwecken besteht folgende Möglichkeit, um den Authentication Service zu starten: Rufen Sie die Datei AuthenticationService.exe auf. Alle Meldungen des Services werden in das Console-Fenster ausgegeben. Zum Stoppen des Services drücken Sie im Console-Fenster die Eingabetaste. Beachten Sie bitte, dass der manuelle Start des Authentication Services Administratorrechte erfordert."
  },
  "doc/code-file/codefile.html": {
    "href": "doc/code-file/codefile.html",
    "title": "Code file",
    "keywords": "Code file Framework Studio bietet die Möglichkeit freien C#-Code zu programmieren. Note CodeFiles können nicht gecustomized werden. Aus diesem Grund sollte die Verwendung der CodeFiles gründlich abgewägt werden! Erstellen einer Code file Es wird der Namespace ausgewählt, in dem das neue Element angelegt werden soll. Anschließend wird in der Registerkarte Namespaces über New / Code File ein neues Code file angelegt. Anschließend muss ein Compile Step ausgewählt werden, damit der Code kompiliert wird. Das Code file muss eine Klasse, kann jedoch auch mehrere Klassen beinhalten. Aufgrund gängiger Konventionen sollte ein Code File jedoch nur eine Klasse beinhalten und der Name des Code files identisch mit dem Namen der Klasse sein. Namespaces können nicht definiert werden. Compile step Der Compile step bestimmt, mit welchem Typen das Code file kompiliert wird. Dieser muss angegeben werden, ansonsten wird der Code nicht kompiliert. Soll der Code auch in einem anderen Namespace zur Verfügung stehen, muss auf den Namespace und den ObjectType/Compile step eine Referenz angelegt werden. Ein detailliertes Beispiel finden Sie unter Beispiel. Caution Das Ändern des Compile steps wird nicht empfohlen. Sollten Sie das Code file bereits in anderen Namespaces verwendet haben, werden infolge der Änderung die Referenzen ungültig und der Compile wird nicht erfolgreich durchlaufen. Referenz Beispiel Wird ein Code file im Namespace \"Company\" angelegt und der Compile step wird auf \"Component\" gesetzt, dann wird der Code der Code file in die Dll des Namespace \"Company\" der Component generiert und kompiliert. Für den Zugriff auf den Code außerhalb des Namespaces, muss eine Referenz auf den Namespace und den Object Type bzw. Compile Step hinterlegt werden. In folgender Abbildung wird eine Referenz vom Namespace \"Article\" auf den Namespace \"Company\" angelegt. So kann nun innerhalb der Components im Namespace \"Article\" die cfCompany-Klasse verwendet werden."
  },
  "doc/comp/components.html": {
    "href": "doc/comp/components.html",
    "title": "Components",
    "keywords": "Components Components stellen funktionale Klassen dar. Framework Studio unterscheidet zwischen vier verschiedenen Typen: Textcollections Components ohne Query Components mit Query (DataComponents) Collections In diesem Abschnitt wird auf Components mit Query und Collections eingegangen. Informationen zu Textcollections und Components ohne Query finden Sie in den folgenden Abschnitten. Eine spezielle Sorte von Components stellen in Framework Studio die Data-Components dar. Data-Components werden über den Database-Editor erstellt (siehe Abschnitt Database Editor) und stellen die Verbindung zu den Daten in der Datenbank her. Jeder aus der Datenbank geladene Datensatz entspricht deshalb einem Objekt vom Typ der jeweiligen Component. Zu einer Data-Component können Sie auch zusätzlich Properties definieren, die Sie über Get/Set-Methoden füllen oder setzen. Außerdem können auf einer Component Methoden hinterlegt werden, die mit den Daten operieren und sie validieren. Eine Component besteht aus folgenden Bestandteilen: Query: Sie stellt die Verbindung zu einer Datenquelle (in der Regel) einer Datenbanktabelle dar. Dazu werden eine oder mehrere Tabellen eingebunden und angegeben, welche Spalten in der Query enthalten sein sollen. Die Component stellt genau einen Datensatz aus dieser Query dar. Allerdings kann eine Query auch ein Join sein. Properties: Sie bieten die Spalten der Query nach außen an. Dabei wird jede Spalte in der Query zu einem Property. Properties können aber auch völlig frei ohne Verbindung zur Query definiert werden. Die verschiedenen Arten der Properties werden im Abschnitt Properties behandelt. Methoden: Sie können verschiedene Zwecke erfüllen. Zum einen können Methoden frei wie in einer normalen Klasse definiert werden. Diese können dann irgendwelche Operationen ausführen. Zum anderen gibt es Entrypoints (virtuelle Methoden), die in der Component überschrieben werden können, um z.B. die Daten vor dem Abspeichern in der Datenbank zu validieren. Collections sind (wie in .NET) eine Sammlung von Objekten einer Component. Sie stellen bereits von sich aus Properties und Methoden bereit, um diese Sammlung zu verwalten. Eine Collection verwaltet immer die Objekte von genau einer Component. Sie können zu einer Collection nur Properties und Methoden hinzufügen. Anlegen von Components Eine Component können Sie erzeugen, indem Sie auf der Namespaces-Registerkarte den Namespace auswählen, in dem die Component angelegt werden soll. Abschließend drücken Sie den Button (New) und wählen den Eintrag Component aus. Die neue Component wird gleich im Hauptfenster des Framework Designers geöffnet. Components bearbeiten Sie öffnen eine vorhandene Component, indem Sie auf der Namespaces-Registerkarte einen Doppelklick auf die gewünschte Komponente machen. Auf der Registerkarte ClassView sehen Sie in einer Übersicht alle Properties und Methoden der Component. Sie haben die Möglichkeit über einen Doppelklick auf die Properties und Methoden im Fenster direkt zu dem jeweiligen Element zu springen. Alternativ können Sie auch über das Tabcontrol des Component-Fensters zu den jeweiligen Elementen navigieren. In gewohnter Weise können Sie jetzt Elemente über die Buttons des Hauptmenüs oder das Kontextmenü im Baum hinzufügen, ändern, umbenennen oder löschen. Name Bezeichnung der Komponente. Dieser Name muss pro Namespace eindeutig sein. Es empfiehlt sich, die Namen der Komponenten auch über Namespaces hinweg eindeutig zu vergeben. Check In By Gibt an, wer die Komponente wann das letzte Mal eingecheckt hat und welche Versionsnummer die aktuelle ist. Ist die Komponente ausgecheckt, werden die Daten des ausgecheckten Zustands angezeigt. Inspected Diese Checkbox hat bisher keine Funktion und dient nur zur Information. Registerkarte General Type Bei einer Collection ist hier angegeben, welche Component diese Collection enthält. Datasource: Gibt den Datasource an. Diese Angabe ist notwendig, wenn in der Component eine Query definiert werden soll oder wenn in der Component (oder Collection) eine Transaktion abgehandelt werden soll. For Component (Collections): Zeigt an, welche Component diese Collection enthält. Description Hier kann eine Beschreibung der Komponente hinterlegt werden. Control Types Hier kann ein Control-Type für die Komponente festgelegt werden, was z.B. bei Collections Sinn macht. Wird bei der Collection z.B. ein Grid hinterlegt, wird später im Form-Designer automatisch ein Grid erzeugt, wenn die Collection auf das Form gezogen wird. Load Size (Collections) Hier wird festgelegt, für wie viele Datensätze beim ersten Load Komponenten instanziiert werden sollen. Für alle weiteren Datensätze wird nur der Primärschlüssel verwaltet. Der automatische Nachlademechanismus sorgt dafür, dass die Komponenten nachgelesen und instanziiert werden, sobald der erste Zugriff darauf erfolgt. Ein Wert kleiner gleich Null sorgt dafür, dass sofort alle Komponenten instanziiert werden. Der Wert kann auch dynamisch über das Property LoadSize verändert werden."
  },
  "doc/comp/static-cache.html": {
    "href": "doc/comp/static-cache.html",
    "title": "Statisches Caching",
    "keywords": "Statisches Caching Framework Studio stellt einen statischen Caching-Mechanismus bereit. Wird dieser für eine geeignete Component aktiviert, so können Daten statt von der Datenbank aus diesem Cache geladen werden. Dadurch sind erhebliche Performance-Vorteile möglich, da die Anzahl der Datenbankzugriffe reduziert wird. Anwendungsgebiete In Geschäftsanwendungen gibt es viele kleine Datenbanktabellen mit wenigen Spalten und verhältnismäßig wenigen Datensätzen. Häufig enthalten diese Tabellen Daten, welche im täglichen Betrieb kaum Veränderungen unterliegen. Beispiele sind Tabellen zu Währungen, Sprachen, Versandarten, Lagerorten, Steuerschlüsseln, um nur einige zu nennen. Für diese überschaubar kleinen Datenmengen mit sich eher selten ändernden Daten ist das statische Caching geeignet. Konzept Der Entwickler kann definieren, dass für eine Component ein statischer Cache bereit gestellt werden soll. Der statische Cache läd bei Bedarf die benötigten \"Rohdaten\" (soweit möglich sessionübergreifend, also benutzerunabhängig) pro .NET-Prozess (\"w3wp.exe\") in den Arbeitsspeicher. Wird eine Anfrage an den Cache gestellt und die Daten im Cache sind älter als 5 Minuten, so werden die Daten neu von der Datenbank in den Cache gelesen. Bei der Anfrage an den Cache werden die Rohdaten benutzerabhängig gefiltert und anschließend Objekte daraus erzeugt. Werden Components gespeichert, so liefert der Cache für den speichernden Benutzer die geänderten Daten, für alle anderen Benutzer weiterhin die ungeänderten Daten. Wird nach dem Speichern ein Commit ausgeführt, wird der Cache automatisch invalidiert, sodass der nächste lesende Zugriff auf den Cache (egal durch welchen Benutzer in diesem .NET-Prozess) dafür sorgt, dass die Daten neu von der Datenbank eingelesen werden. Note Der Cache ist streng typisiert. Where-Bedingungen müssen als Function formuliert werden. Die Angabe eines Where-Strings ist nicht möglich. Der Cache berücksichtigt die über die Virtual Columns an der Component definierte Sortierung. Besonders Effizient können Daten über den (an der DBTable definierten) logischen Primärschlüssel (PK) abgefragt werden. Important Zu beachten ist, dass der lesende Zugriff auf den statischen Cache (analog zum \"normalen\" Laden von der Datenbank), für ein Global nicht thread-save ist. Nutzung Aktivieren des Caches Ist eine Component für das statische Caching geeignet, weil sie z.B. wenige hundert Datensätze verwaltet die Datensätze kaum 20 Eigenschaften enthalten, die alle nicht große Datenmengen (wie z.B. Byte-Arrays für Bilder) enthalten die Anzahl der Änderungen pro Tag an zumindest einem Datensatz an den Fingern abzuzählen sind es (bis auf einzelne, spezielle Ausnahmen) völlig ausreichend ist, dass die Daten bis zu 5 Minuten alt sein können dann kann der Entwickler durch setzen der Checkbox Provide Static Cache auf der Registerkarte General im Designerfenster der Component dafür sorgen, dass für diese Component ein statischer Cache generiert wird. Die Checkbox ist generell in jedem bearbeitbaren Package aktivierbar, soweit sich die Package-Version nicht im Service-Release Modus befindet. Wurde die Checkbox in einem Basis-Package gesetzt, kann diese Einstellung in Custom-Packages nicht mehr rückgängig gemacht werden. Nicht gesetzt werden kann die Checkbox, wenn die Component keinen Datenbankbezug hat. Zugriff auf den Cache Wurde für eine Component der statische Cache aktiviert, generiert Framework Studio für die Component eine statische Klasse aus dem Namen der Component gefolgt vom Suffix \"Cache\" in die Interface-Dll. Beispiel: Für die Component cdCurrency wird eine Klasse cdCurrencyCache generiert. Diese Klasse enthält eine statische Methode Get(), welche eine generische Singleton-Instanz zum Zugriff auf den statischen Cache gibt. Diese Instanz implementiert das Interface IStaticCache<TObj, TPK>, wobei TObj der Interface-Typ der Component ist (z.B. IcdCurrency) und PK der Typ des/der Primärschlüssel-Properties ist (z.B. FSshort für shtCurrencyID). Das Ermitteln eines Objektes anhand des Primärschlüssels ist dann beispielsweise über den Indexer möglich: IcdCurrency oCurrency = cdCurrencyCache.Get()[shtCurrencyIDP]; Sollte der Primärschlüssel aus mehreren Properties bestehen, so ist ein ValueTuple mit allen Properties des Primärschlüssels in alphabetischer Reihenfolge anzugeben. Beispiel (Primärschlüssel sType und sCode): var oDemo = cdDemoCache.Get()[(sMyCode, sMyType)]; Der Cache implementiert IEnumerable<TObj>. Der folgende Code IcdCurrencyColl oCurrencyColl = cdCurrencyCollFactory.Create(); oCurrencyColl.Load(\"COALESCE([shtBlocked], 0) = 0\", \"shtCurrencyCode\"); foreach (IcdCurrency oCurrency in oCurrencyColl) { // ... do something } lässt sich daher wie folgt auf die Verwendung des Caches umstellen. foreach (var oCurrency in cdCurrencyCache.Get() .Where(c => c.shtBlocked.Value == 0) .OrderBy(c => c.shtCurrencyCode)) { // ... do something } Der Cache bietet darüberhinaus viele weitere Methoden, um Collections oder Objekte zu befüllen. Note Die detaillierte Beschreibung aller Funktionen ist bei der Beschreibung des Interfaces IStaticCache<TObj, TPK> einzusehen. Sollte es einmal nötig sein, auf Ebene von IDevFrameworkDataObject auf einen Cache zuzugreifen, so bietet die statische Klasse StaticCache ebenfalls eine statische Methode Get() an, mit der (soweit existent) ein untypisierter Cache (IStaticCache) ermittelt werden kann. Relation-Properties An Components können Properties vom Typ Relation angelegt werden. Typischerweise werden als DependsOn Properties die Primärschlüsseleigenschaften angegeben. Relation-Properties verwenden automatisch den Cache, wenn für den Property-Typ der statische Cache aktiviert ist und die DependsOn-Bedingung dem am DBTable definierten logischen Primärschlüssel entspricht. Globale Einsprungpunkte Grundidee des statischen Caches ist, alle Daten sessionübergreifend, also benutzerunabhängig, pro .NET-Prozess (\"w3wp.exe\") in den Arbeitsspeicher zu laden. Dadurch kann der Cache nicht den globalen Einsprungpunkt public virtual void GlobalOnBeforeLoad(DevFrameworkObject obj, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) durchlaufen, da hier pro Session anhand eines beliebigen Where-Strings unterschiedlich gefiltert werden kann. Eine einfache Filterung ist für den Cache jedoch in dem Moment möglich, in dem Objekte (zu einem konkreten Global) aus dem Cache angefragt werden. Dazu wurde der globale Einsprungpunkt protected internal virtual bool GlobalWhereStaticCache(IStaticCacheObject oStaticCacheObject) geschaffen, welcher eine Filterung der Ergebnismenge durch den Cache ermöglicht. Der zuletzt genannte Einsprungpunkt ist jedoch nicht in der Lage, beliebiges SQL im Nachhinein auszuwerten. Sollte jedoch eine Filterung nötig sein, die direkt beim Laden komplexes SQL ermöglicht, kann der statische Cache die Daten nicht sessionübergreifend einlesen. Ebenso ist es in diesem Einsprungpunkt nicht möglich, Einschränkungen auf Werte vorzunehmen, welche zwar als Tabellenspalte existieren, jedoch nicht als Property an der Component angelegt sind. Deshalb wurde ein weiterer globaler Einsprungpunkt protected internal virtual StaticCacheMode GlobalGetStaticCacheMode(IDevFrameworkDataObject oDevFrameworkDataObject) geschaffen, welcher pro Component einmalig durchlaufen wird um festzulegen, in welchem Modus der Cache arbeiten soll. Die beiden Modi Broker (default) und Session sowie ihre Konsequenzen sind im Detail am StaticCacheMode beschrieben. Im Modus Session läd der statische Cache die \"Rohdaten\" nicht global sondern pro Session. Dadurch erhöht sich der Arbeitspeicherverbrauch. Gleichzeitig kann so der erstgenannte Einsprungpunkt public virtual void GlobalOnBeforeLoad(DevFrameworkObject obj, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) wie gewohnt durchlaufen werden. Besonderheiten Distinct und GroupBy Important Ist eine Component als Distinct oder GroupBy definiert, darf der statische Cache zu dieser Component nicht im Modus Broker betrieben werden. Wenn eine Component nicht als Distinct oder GroupBy definiert ist, in einem speziellen Fall jedoch Distinct oder GroupBy gewünscht ist, kann an den Methoden des statischen Caches, die die Angabe eines orderBy ermöglichen, als orderBy die entsprechende Funktion angegeben werden. Beispiel Distinct: public virtual int LoadDistinctByName() { return cdArticleCache.Get().FillCollection(This, l => l.DistinctBy(o => o.sName)); } Beispiel GroupBy: public virtual int LoadGroupByName() { // Gruppiert werden soll nach sName Func<IcdArticle, FSstring> fnKeySelector = oArticle => oArticle.sName; // Ergebnisobjekt vom Typ IcdArticle zu jedem Schlüsselwert und den dazugehörigen Artikeln erzeugen Func<FSstring, IEnumerable<IcdArticle>, IcdArticle> fnResultSelector = (sName, oArticles) => { IcdArticle oResult = cdArticleFactory.Create(); var oFirstArticle = oArticles.First(); oResult.sID = oFirstArticle.sID; oResult.sName = oFirstArticle.sName; oResult.sColor = oFirstArticle.sColor; // Hinweis: Auch wenn mehrere Aggregatfunktionen (Sum, Count, Max, ...) aufgerufen werden, sollte nur einmal über alle Elemente iteriert werden oResult.decPrice = oArticles.Select(oArticle => oArticle.decPrice.Value).Sum(); // Status des Ergebnisobjekts soll unchanged sein oResult.State = FrameworkComponentState.Unchanged; return oResult; }; // GroupBy-Funktionalität als spezielles orderBy übergeben return cdArticleCache.Get().FillCollection(This, l => l.GroupBy(fnKeySelector, fnResultSelector)); }"
  },
  "doc/comp/tab_method.html": {
    "href": "doc/comp/tab_method.html",
    "title": "Registerkarte Methods",
    "keywords": "Registerkarte Methods Bei den Methoden handelt es sich um Methoden im Sinne von .NET. Innerhalb der Methoden können Sie frei nach den Regeln von C# Code schreiben und mit den Properties der Component arbeiten. Die Methoden werden im ClassView-Registerkarte aufgelistet und sind an dem -Icon zu erkennen. Neue Methoden anlegen / löschen Mit dem Button (New) und dem Eintrag Public Method, Protected Method oder Method(override) aus dem sich öffnenden Kontextmenü können Sie eine neue Methode erzeugen. Mit Public Method und Protected Method wird eine leere Methode angelegt. Mit Method(override) haben Sie die Möglichkeit, eine in einer Basis-Klasse definierte virtuelle Methode zu überschreiben. Es erscheint ein Auswahl-Dialog, der die verfügbaren Methoden anbietet. Wenn Sie einen Eintrag auswählen und mit OK bestätigen, wird eine neue Methode angelegt, deren Deklaration entsprechend vorbelegt ist. In der ClassView-Registerkarte hat das Kontext-Menü der Methoden einen Eintrag Delete. Mit diesem Eintrag können Sie die Methode löschen. Methoden bearbeiten Um eine Methode zu öffnen, gibt es zwei Möglichkeiten: Auf der Registerkarte ClassView einen Doppelklick auf die gewünschte Methode. Auf der Registerkarte Method die gewünschte Methode in der Tabelle auswählen. Auf der Registerkarte Method wird in dem großen Edit-Feld der Quellcode der Methode angezeigt, den Sie dort auch bearbeiten können. Methoden in jeder Component / Collection Im folgenden Abschnitt werden die Methoden beschrieben, die jede Component / Collection bereits als Voraussetzung mitbringt, da sie in der Component-Basisklasse DevFrameworkObjekt bzw. DevFrameworkObjektColl implementiert sind. AcceptChanges( ) Verfügbar für Component / Collection. public void AcceptChanges( ) Übernimmt alle Änderungen, indem es die OrgValues auf die PropertyValues und den Status auf Unchanged setzt. Es wird keine Datenbanktransaktion ausgeführt. Bei Collections führt diese Methode dazu, dass Objekte, deren Status Deleted ist, aus der Collection unwiderruflich entfernt werden. AdoptValues() Verfügbar für Component / Collection Übernimmt alle Properties der übergebenen Component / Collection in die eigenen Properties. Von Unterobjekten wird eine Tiefen-Kopie (Clone) erzeugt. void AdoptValues(IDevFrameworkBaseObject fromComponent) void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptMode mode) void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptDictionary dict) void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptDictionary dict, AdoptMode mode) Im Parameter fromComponent wird die Component übergeben, deren Properties übernommen werden sollen. Über die Parameter dict und mode kann optional das Verhalten der Methode gesteuert werden. Siehe auch Kapitel Clone() und AdoptValues() Clear() Verfügbar für Collection. public void Clear() Reinitialisiert die Collection als leere Collection. Clone() Verfügbar für Component / Collection Erzeugt eine Tiefen-Kopie der Component oder Collection und gibt diese zurück. public IDevFrameworkBaseObject Clone() public IDevFrameworkBaseObject Clone(AdoptMode mode) public IDevFrameworkBaseObject Clone(AdoptDictionary dict) public IDevFrameworkBaseObject Clone(AdoptDictionary dict, AdoptMode mode) Über die Parameter dict und mode kann optional das Verhalten der Methode gesteuert werden. Siehe auch Kapitel Clone() und AdoptValues(). Delete( ) Verfügbar für Component / Collection. Diese Methode setzt den Komponentenstatus auf Deleted. Die Komponente wird dabei aus der Collection entfernt. Damit auf dem Datasource ein physikalischer Delete ausgeführt wird, muss noch ein Save aufgerufen werden. Diese Methode ist funktional identisch mit der Methode Remove(). public void Component.Delete() Setzt den Komponentenstatus auf Deleted. public void Collection.Delete() Setzt den Komponentenstatus aller Components der Collection auf Deleted. public void Collection.Delete(DevFrameworkObject obj) Setzt den Komponentenstatus der übergebenen Component auf Deleted. public void Collection.Delete(SelectedRowsCollection selectedRows) Setzt den Komponentenstatus aller Komponenten, deren IDs in der SelectedRowsCollection enthalten sind, auf Deleted. Load( ) Verfügbar für Component / Collection. public int Load() Lädt alle Datensätze aus der verknüpften Query. public int Load(string loadCondition) Lädt Datensätze entsprechend der Bedingung aus der Datenbank und liefert die Anzahl der gefundenen Datensätze zurück. public int Load(string loadCondition, string OrderByClause) public int Load(string loadCondition, string HavingClause, string OrderByClause) Für das Anpassen der Load-Kriterien werden verschiedene Methoden zum Überschreiben angeboten: OnBeforeLoad( ) auf der Ebene der Component bzw. Collection. GlobalOnBeforeLoad( ) auf globaler Ebene. LoadCount( ) Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) Verfügbar für Component / Collection. public void Save( ) Save speichert die Änderungen in die Daten-Datenbank. Component.Save( ) Der Befehl läuft in folgenden Schritten ab: CreateTransaction( ) OnBeforeSaveCustom( ) (Entrypoint) OnBeforeSave() (Entrypoint) GlobalOnBeforeSaveAction( ) (Entrypoint) DeleteMarkedObjects() Aktion auf der Datenbank. AcceptChanges( ) OnAfterSave() (Entrypoint) OnAfterSaveCustom( ) (Entrypoint) Commit( ) Läuft etwas in einem der Entrypoints schief und es wird eine Exception geworfen, wird die gesamte Transaktion abgebrochen und Rollback( ) ausgeführt. Es folgt eine Aufstellung, wie sich der Befehl bei den einzelnen Status verhält. FrameworkComponentState.Unchanged Es wird keine Aktion auf der Datenbank ausgeführt. Die Entrypoints werden nur angestoßen, wenn EntryPoints.CallAllways übergeben wurde. FrameworkComponentState.New Es wird ein Insert in die Daten-Datenbank gemacht. Es werden alle Daten in die OrgValue-Properties übertragen. FrameworkComponentState.Changed Es wird ein Update auf die Daten-Datenbank gemacht. Es werden alle Daten in die OrgValue-Properties übertragen. FrameworkComponentState.Deleted Es wird ein Delete auf die Daten-Datenbank gemacht. Ist die Component ein Eintrag in der Collection, wird sie aus dieser entfernt. Collection.Save( ) Der Befehl läuft in folgenden Schritten ab: CreateTransaction( ) OnBeforeSaveCustom( ) (Entrypoint) OnBeforeSave( ) (Entrypoint) Save( ) auf jedes Objekt in der Collection OnAfterSave( ) (Entrypoint) OnAfterSaveCustom( ) (Entrypoint) Commit( ) Läuft etwas in einem der Entrypoints schief und es wird eine Exception geworfen, wird die gesamte Transaktion abgebrochen und Rollback( ) ausgeführt. Warning Ist der Status einer Component Unchanged, werden die Entry-Points der Save-Methode (OnBeforeSave, OnAfterSave, …) nicht aufgerufen, da der Save-Vorgang abgebrochen wird, und keine Transaktion stattfindet. public void Save(SaveEntryPoints) Diese Überladung der Methode ist dazu da, wenn die Entrypoints abgearbeitet werden sollen, obwohl der Save der Component auf Unchanged steht. // Die Entrypoints werden immer ausgeführt oCompoinet.Save( SaveEntryPoints.CallAllways ) // Die Entrypoints werden nur ausgeführt, wenn der Status nicht Unchanged ist. oCompoinet.Save( SaveEntryPoints. CallOnlyIfChanged ) RollbackChanges( ) Verfügbar für Component / Collection. public void RollbackChanges( ) Setzt alle PropertiesValues auf die OrgValues. CreateTransaction( ) Verfügbar für Component / Collection. public FrameworkDataTransaction CreateTransaction( ) Startet eine Transaktion. Weisen Sie der Komponente einen Datasource zu, damit eine Transaktion gestartet werden kann, da die Transaktion selbst an einen Datasource gebunden ist. Gibt das Transaktionsobjekt zurück, sofern es erzeugt werden konnte. An diesem Transaktionsobjekt kann der Commit bzw. Rollback erfolgen. An geeigneter Stelle muss es mittels Dispose-Aufruf bzw. dem Ende eines using-Blocks abgeräumt werden. Wenn die Transaktion aufgrund eines Fehlers nicht gestartet werden kann, wird eine Exception geworfen. HasDbChanged( ) Verfügbar an DataComponent. public bool HasDbChanged() Damit kann einer RowVersionInvalidException zuvorgekommen werden. Mit der Methode ReloadData() können die Daten des Datensatzes neu eingelesen werden. Gibt zurück, ob sich der Datensatz auf der Datenbank geändert hat. Diese Methode arbeitet sowohl mit der RowID-RowVersion-Logik als auch mit einer PK-RowVersion-Logik. Wenn an einer Component die Save-Methode aufgerufen wird, prüft diese, ob der Datensatz in der Datenbank geändert wurde, um ein konkurrierendes Update zu verhindern. Wenn das zutrifft, dann wird eine RowVersionInvalidException geworfen und die Save-Aktion abgebrochen. Mit dieser Methode kann das im Vorfeld geprüft und ggf. ReloadData() ausgeführt werden. ReloadData( ) Verfügbar an DataComponent. public int ReloadData() Diese Methode aktualisiert die Daten aus der Datenbank. Sie führt einen Load auf die Component aus und verwendet dabei die aktuellen Primary-Key-Informationen für die Suchbedingung. Wenn die Component nicht mit der RowID-RowVersion-Logik arbeitet, dann wird der logische Primary-Key verwendet. Das ist z.B. sinnvoll, wenn mit der Methode HasDbChanged eine Änderung auf der Datenbank festgestellt wurde. Zurückgegeben wird das Ergebnis der Load-Methode: 1 – erfolgreich eingelesen; 0 – es wurde nichts gelesen, weil der Datensatz z.B. nicht mehr existiert. OnBeforeLoad( ) Verfügbar für Component / Collection mit einer Query. Diese Methode kann überschrieben werden. Sie bietet auf Component-Ebene einen zentralen Einstiegspunkt, um vor einem Datenbank-Load die Load-Condition, die Having-Clause oder die Order-By-Clause zu erweitern oder anzupassen. Data-Component: protected virtual bool OnBeforeLoad(ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause, bool fromCollection) Sie wird aufgerufen, bevor an der Component / Collection ein Load() oder an der Component ein GetFetchNext() ausgeführt wird. Der Aufruf erfolgt vor GlobalOnBeforeLoad( ). Beim Aufruf aus der Collection wird im Parameter fromCollection true übergeben. So kann bei Bedarf entsprechend reagiert werden. Es ist jedoch empfehlenswert, die Load-Condition nur einmal zentral in der Component zu erweitern. Der Aufruf folgt nach dem Aufruf der OnBeforeLoad-Method in der Collection. Data-Collection: protected virtual bool OnBeforeLoad(ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) Sie wird aufgerufen, bevor an der Collection ein Load( ) ausgeführt wird. Der Aufruf erfolgt vor GlobalOnBeforeLoad( ). Nach dieser Methode ruft die Collection auch an der Component die Methode OnBeforeLoad() auf. Dazu wird temporär ein neues leeres Objekt erzeugt. OnBeforeSave( ) Verfügbar für Component / Collection. protected virtual bool OnBeforeSave() Diese Methode kann in der Component / Collection überschrieben werden. Siehe auch LoadCount() Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnBeforeSaveCustom( ) Verfügbar für Component / Collection. protected virtual bool OnBeforeSaveCustom() Diese Methode kann in der Component / Collection überschrieben werden. Siehe auch LoadCount() Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnBeforeSaveAction( ) Verfügbar für Component. protected virtual void OnBeforeSaveAction() Diese Methode kann in der Component überschrieben werden. Standardmäßig ruft diese Methode this.Global.ocGlobal.GlobalOnBeforeSaveAction() auf. Siehe auch LoadCount() Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnAfterSave( ) Verfügbar für Component / Collection. protected virtual void OnAfterSave() Diese Methode kann in der Component / Collection überschrieben werden. Wird nach dem Speichern aufgerufen. Siehe auch LoadCount() Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnAfterSaveCustom( ) Verfügbar für Component / Collection. protected virtual void OnAfterSaveCustom() Diese Methode kann in der Component / Collection überschrieben werden. LoadCount( ) Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnAfterInit( ) Verfügbar für Component / Collection protected virtual void OnAfterInit( ) Diese Methode kann in der Component / Collection überschrieben werden. Sie wird aufgerufen, direkt nachdem die Component / Collection instanziiert wurde. Hier können Werte vorbelegt werden, die man ansonsten in einem Konstruktor setzen würde. Warning Innerhalb dieser Methode darf kein Load, Save oder sonst eine Datenbank-Aktion ausgeführt werden. Hintergrund: Es kann sein, dass die Methode aufgerufen wird, wenn eine Component im Rahmen eines Collection-Loads instanziiert wird. In diesem Fall ist bereits ein Datareader auf der Datenbank geöffnet. Eine Datenbank-Aktion würde zu einer Exception führen. OnAfterLoad( ) Verfügbar für Component protected virtual void OnAfterLoad( ) Diese Methode kann in der Component überschrieben werden. Sie wird aufgerufen, nachdem der Inhalt der Component aus der Datenbank gelesen wurde. GetTableName( ) Verfügbar für Component public virtual string GetTableName(string propName) Gibt den Tabellennamen eines bestimmten Properties zurück. Falls es das Property nicht gibt bzw. das Property nicht mit einer Datenbankspalte verknüpft ist, wird String.Empty zurückgegeben. GetDefaultLabel( ) Verfügbar für Component. public string GetDefaultLabel(string propName) Gibt das Default-Label eines bestimmten Properties zurück. Falls es das Property nicht gibt, wird String.Empty zurückgegeben. Das Label wird in der aktuellen Sprache zurückgegeben. GetPropertyMdt( ) Verfügbar an Component / Collection public MLContainer GetPropertyMdt(string propertyName) Ermittelt den Metadatentyp des Properties propertyName. Sie ermöglicht dynamisch den Zugriff auf die mdt_-Properties der Factory-Klasse. Siehe auch Abschnitt \uF0E0Metadaten von Properties. Die öffentlichen Properties können mit dem Property \uF0E0 ComponentProperties ermittelt werden. GetProperty( ) Verfügbar für Component. public virtual object GetProperty(string propertyName) Ermittelt den Wert des öffentlichen Properties propertyName. Die öffentlichen Properties können mit dem Property \uF0E0 ComponentProperties ermittelt werden. SaveCallEntryPointsAllways( ) public void SaveCallEntryPointsAllways( ) Aufruf der LoadCount( ) Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save() Methode, wobei die Entry-Points auch durchlaufen werden, wenn der Status der Komponente Unchanged ist. MarkForDeletion( ) Verfügbar an Component public void MarkForDeletion( ) Mit dieser Methode wird dem Property StateBeforeUpdate Verfügbar für Component. public FrameworkComponentState StateBeforeUpdate {get, set} Dieses Property übernimmt den Wert des Properies State direkt bevor im Save der Datenbank-Befehl ausgeführt wird. Dieser Wert bleibt bis zum nächsten Save() erhalten. Somit steht in den Methoden OnAfterSave() und OnAfterSaveCustom() bzw. nach einem Save-Vorgang der Status der Component weiterhin zur Verfügung. Das Property State hingegen nimmt nach der Datenbank-Aktion den Wert Unchanged an. In den Methoden OnBeforeSave() und OnBeforeSaveCustom() hat dieses Property keinen klar definierten Wert. IsMarkedForDeletion der Wert true zugewiesen. An der dazugehörigen Collection können anschließend mit der Methode die markierten Objekte aus der Collection gelöscht werden. DeleteMarkedObjects( ) Verfügbar in Collection public void DeleteMarkedObjects( ) Mit dieser Methode wird an allen Objekten der Collection, in denen das Property \uF0E0StateBeforeUpdate Verfügbar für Component. public FrameworkComponentState StateBeforeUpdate {get, set} Dieses Property übernimmt den Wert des Properies State direkt bevor im Save der Datenbank-Befehl ausgeführt wird. Dieser Wert bleibt bis zum nächsten Save() erhalten. Somit steht in den Methoden OnAfterSave() und OnAfterSaveCustom() bzw. nach einem Save-Vorgang der Status der Component weiterhin zur Verfügung. Das Property State hingegen nimmt nach der Datenbank-Aktion den Wert Unchanged an. In den Methoden OnBeforeSave() und OnBeforeSaveCustom() hat dieses Property keinen klar definierten Wert. IsMarkedForDeletion den Wert true hat, die Methode Delete() ausgeführt. Remove( ) Verfügbar in Collection Diese Methode entfernt Objekte aus der Collection. Der Status des entfernten Objektes wird dabei auf Deleted gesetzt. D.h., ein Save() hätte ggf. einen physischen Delete auf der Datenbank zur Folge. Diese Methode ist funktional identisch mit der Methode \uF0E0Delete( ). public void Remove( Object ) Entfernt das übergebene Objekt aus der Collection. public void Remove( SelectedRowsCollection ) Entfernt alle in der übergebenen SelectedRowsCollection angegebenen Objekte aus der Collection. Drop( ) Verfügbar in Collection Diese Methode trennt Objekte aus der Collection heraus. Dabei bleibt der Status der Objekte erhalten. public void Drop( guid ) Entfernt das mit der übergebenen Guid definierte Objekt aus der Collection. public void Drop( DevFrameworkObject ) Entfernt das übergebene Objekt aus der Collection. public void Drop( SelectedRowsCollection ) Entfernt alle Komponenten aus der Collection, deren IDs in der übergebenen SelectedRowsCollection enthalten sind. Dispose( ) Verfügbar in Collection Die Collection wird geleert und alle verwendeten Ressourcen freigegeben. Nach dieser Operation kann die Collection nicht mehr verwendet werden. Add( ) Verfügbar in Collection Diese Methode fügt ein Objekt in die Collection ein. Es wird die Index-Position des Objektes zurückgegeben. public int Add( object ) Am eingefügten Objekt wird die Collection-Eigenschaft auf die neue Collection geändert. public int Add( object, bool setCollection ) Wenn der Parameter setCollection mit false angegeben wird, dann wird die Collection-Eigenschaft des Objektes nicht verändert. AddRange() Verfügbar in Collection Diese Methode fügt mehrere Objekte in die Collection ein. Sie können dieser Methode ganze Collections übergeben. So ist es beispielsweise möglich, zwei Collections zusammenzuführen. Die Methode hat als Parameter den Typ IEnumerable<DevFrameworkObject>. So können auch generische Listen übergeben werden, die z.B. mit einer Linq-Query ermittelt wurden. public void AddRange(IEnumerable<DevFrameworkObject> value) An allen hinzugefügten Elementen wird die die Collection-Eigenschaft auf die neue Collection geändert. public void AddRange(IEnumerable<DevFrameworkObject> value, Boolean setCollection) Wenn der Parameter setCollection mit false angegeben wird, dann wird die Collection-Eigenschaft der hinzugefügten Objekte nicht verändert. Insert( ) Verfügbar an Collection Fügt ein Objekt an eine bestimmte Position in die Collection ein. public int Insert( int index, object ) Mit Index 0 wird das Objekt am Anfang der Collection eingefügt. Mit Index größer oder gleich Collection.Count wird das Objekt am Ende der Collection eingefügt. Am eingefügten Objekt wird die Collection-Eigenschaft auf die neue Collection geändert. public int Insert( int index, object, bool setCollection ) Wenn der Parameter setCollection mit false angegeben wird, dann wird die Collection-Eigenschaft des Objektes nicht verändert. MoveItem() Verfügbar an Collection int Collection.MoveItem(DevFrameworkObject itemToMove, int indexDelta) Verschiebt den übergebenen Eintrag und gibt den neuen Index des verschobenen Eintrags zurück. Der Parameter indexDelta gibt an, wie weit der Eintrag verschoben werden soll. Bei negativen Werten wird nach oben und bei positiven Werten nach unten verschoben. Wird ein Wert angegeben, der die Grenzen der Collection sprengt, dann wird der Eintrag maximal an die Grenze der Collection (Anfang oder Ende) verschoben. Wird ein Eintrag übergeben, der nicht Bestandteil der Collection ist, dann wird eine Exception geworfen. Beispiel: // verschiebt den ausgewählten Artikel einen Eintrag nach oben this.oArticleColl.MoveItem(this.oArticleSelected, -1); // verschiebt den ausgewählten Artikel 2 Einträge nach unten this.oArticleColl.MoveItem(this.oArticleSelected, 2); MoveItemTo() Verfügbar an Collection void Collection.MoveItemTo(DevFrameworkObject itemToMove, int targetIndex) Verschiebt den übergebenen Eintrag an eine bestimmte Stelle. Der Parameter targetIndex gibt den Index an, an den der Eintrag verschoben werden soll. Wird ein Eintrag übergeben, der nicht Bestandteil der Collection ist, dann wird eine Exception geworfen. Beispiel: // verschiebt den ausgewählten Artikel an den Anfang der Collection this.oArticleColl.MoveItemTo(this.oArticleSelected, 0); CreateNewRecord( ) Verfügbar an Collection DevFrameworkObject Collection.CreateNewRecord() Erzeugt passend zur Collection einen neuen Record. Der Rückgabetyp ist DevFrameworkObject bzw. IDevFrameworkObject. Es muss ggf. ein entsprechender cast eingebaut werden. Beispiel: IcdCustomer oCustomerNew = this.oCustomerColl.CreateNewRecord() as IcdCustomer; NewRecord( ) Verfügbar an Collection DevFrameworkObject Collection.NewRecord() Erzeugt passend zur Collection einen neuen Record und fügt ihn am Ende der Collection ein. Der Rückgabetyp ist DevFrameworkObject bzw. IDevFramerworkObject. Es muss ggf. ein entsprechender cast eingebaut werden. Beispiel: IcdCustomer oCustomerNew = this.oCustomerColl.NewRecord() as IcdCustomer; UpdateRelationKey( ) Verfügbar innerhalb von Component und Collection protected bool UpdateRelationKey(string propertyName, string key) Diese Funktion speichert an der Instanz der Component bzw. der Collection pro übergebenem Property-Namen einen Schlüssel. Dabei wird geprüft, ob sich der Schlüssel gegenüber dem letzten Aufruf dieser Funktion geändert hat. Bei einer Änderung wird true zurückgegeben. Wenn sich der Schlüssel nicht geändert hat, wird false zurückgegeben. Diese Funktion kann z.B. dazu verwendet werden, um in Individual Properties bei der Änderung eines Schlüssel-Wertes einen Reload zu veranlassen. Die Funktion ist protected und kann somit nur innerhalb der Component bzw. der Collection verwendet werden. Beispiel: // Get-Methode des Individual Properties \"oCustomerIndiv\" if (this.oCustomerMember == null) { this.oCustomerMember = cdCustomerFactory.Create(this.Global); } String sWhere = \"[lngCustomerID] = \" + DB.SqlString(this.lngCustomerID); if (this.UpdateRelationKey(\"oCustomerIndiv\", sWhere) { // Die Suchbedingung – also der Key – hat sich geändert. ==> Reload this. oCustomerMember.Load(sWhere); } return this.oCustomerMember; SetCommandTimeout( ) Verfügbar an Data-Collection public void SetCommandTimeout(int seconds) Damit kann vor einem Load der Timeout des SQL-Commands gesetzt werden. In Framework Studio haben alle Commands per Default einen Timeout von 300 Sekunden. Wenn ein Statement längere Zeit benötigt, dann führt das zu einer Exception. Das kann in seltenen Fällen bei komplexen Statements auf großen Datenbeständen der Fall sein. Mit dem Wert 0 wird der Timeout komplett deaktiviert. Das bedeutet, dass das Statement im schlimmsten Fall endlos laufen kann. Beispiel: // Timeout deaktivieren this.oCollection.SetCommandTimeout(0); // Daten lesen. this.oCollection.Load(\"<very complex condition>\"); Properties in jeder Component / Collection ComponentProperties Verfügbar für Component. public virtual System.Collections.Specialized.StringCollection ComponentProperties {get} Gibt eine Liste mit den Namen aller Properties zurück. Es werden nur Properties ausgegeben, die public sind. Diese Namen kann man mit verschiedenen Methoden verwenden. Z.B: GetProperty( ) GetDefaultLabel( ) State Verfügbar für Component. public FrameworkComponentState State {get, set} Status der Komponente. Dieser kann z.B. im OnBeforeSave() ausgewertet werden. Mit dem Ausführen der Datenbank-Aktion erhält das Property den Wert Unchanged bzw. UnchangedButDeleted. Im OnAfterSave() bzw. nach dem Save() kann der ursprüngliche Wert über das Property StateBeforeUpdate erfragt werden. Das Enum FrameworkComponentState hat folgende Werte: New: Die Komponente wurde instanziiert und es wurden keine Daten mit Load() eingelesen. Werden Properties in dieser Komponente geändert, bleibt der Status weiterhin New. Ein Save() führt einen Insert-Befehl auf der Datenbank aus. Unchanged: Die Komponente wurde mit Load() eingelesen und die Daten wurden danach nicht verändert. Ein Save() führt keine Aktion auf der Datenbank aus. Changed: Die Komponente wurde mit Load() eingelesen und der Wert mindestens eines Properties wurde geändert. Ein Save() führt einen Update-Befehl auf der Datenbank aus. Soll ein Insert-Befehl erzwungen werden, muss der Status manuell auf New gesetzt werden. Deleted: Die Komponente wurde mit Load() eingelesen und es wurde die Methode Delete() aufgerufen. Ein Save() führt einen Delete-Befehl auf der Datenbank aus. NewButDeleted: Die Komponente wurde mit einem new() erstellt und es wurde die Methode Delete() aufgerufen. Ein Save() führt keine Aktion auf der Datenbank aus. UnchangedButDeleted: Nachdem die Methode Delete() aufgerufen und mit Save() der Delete-Befehl auf der Datenbank ausgeführt wurde, erhält die Komponente diesen Status. Ein weiterer Save() führt keine Aktion auf der Datenbank aus. Wird der Wert eines Properties geändert, behält die Component diesen Status – er wird nicht auf Changed gesetzt. StateBeforeUpdate Verfügbar für Component. public FrameworkComponentState StateBeforeUpdate {get, set} Dieses Property übernimmt den Wert des Properies \uF0E0 State direkt bevor im Save der Datenbank-Befehl ausgeführt wird. Dieser Wert bleibt bis zum nächsten Save() erhalten. Somit steht in den Methoden OnAfterSave() und OnAfterSaveCustom() bzw. nach einem Save-Vorgang der Status der Component weiterhin zur Verfügung. Das Property State hingegen nimmt nach der Datenbank-Aktion den Wert Unchanged an. In den Methoden OnBeforeSave() und OnBeforeSaveCustom() hat dieses Property keinen klar definierten Wert. IsMarkedForDeletion Verfügbar für Component. public bool IsMarkedForDeletion {get, set} Über dieses Property ist es möglich, ein mehrstufiges Löschen zu realisieren. Das ist notwendig, wenn z.B. die Datensätze in einem Grid zum Löschen markiert werden sollen, bevor sie gelöscht werden. Wenn Sie die Methode \uF0E0Delete( ) verwenden, werden die entsprechende Zeilen im Grid nicht mehr angezeigt. Dieses Property ist vor allem dann interessant, wenn die Component in einer Collection verarbeitet wird. Wenn an mindestens einem Element in einer Collection diese Eigenschaft true ist, dann liefert Collection.IsModified den Wert true. Ist IsMarkedForDeletion true, dann wird im Grid in der entsprechenden Zeile das im Grid-Property RowDeletedIcon hinterlegte Icon angezeigt. (siehe \uF0E0Grid Properties) Mit der Methode DeleteMarkedObjects an der entsprechenden Collection wird an jedem Objekt, an dem das Property den Wert true hat, ein Delete aufgerufen. IsModified Verfügbar für Component und Collection. Component: public bool IsModified {get} IsModified ist true, wenn State nicht den Wert Unchanged hat. Insbesondere gilt somit für neue Components (State=New) IsModified = true. Collection: public bool IsModified {get} IsModified ist true, wenn bei mindestens einem Element der Liste die Eigenschaft IsModified den Wert true hat oder mindestens ein Element gelöscht oder zum Löschen markiert (IsMarkedForDeletion) wurde. LoadSize Verfügbar für Collection mit Datenbank-Bezug Über dieses Property kann zur Laufzeit festgelegt werden, für wie viele Datensätze beim ersten Laden die Komponenten direkt instanziiert werden sollen. Für alle weiteren Datensätze wird zunächst nur der Primärschlüssel verwaltet. Durch den automatischen Nachlademechanismus werden die Komponenten dann beim ersten Zugriff automatisch nachgeladen und instanziiert. Wenn dieses Property auf einen Wert kleiner oder gleich Null gesetzt wird, werden direkt alle Komponenten instanziiert. Ein Nachladen ist dann nicht mehr nötig. Dies ist vor Allem dann sinnvoll, wenn anschließend ohnehin auf alle Components der Collection zugegriffen wird, beispielsweise durch eine foreach Schleife. LoadMaxCount Verfügbar für Collection mit Datenbank-Bezug. Dieses Property gibt an, wie viele Datensätze maximal eingelesen werden sollen. Es muss gesetzt werden, bevor der Load ausgeführt wird. Der Standardwert ist 0. Das bedeutet keine Begrenzung. // Beispiel: nur die ersten 30 Sätze lesen: this.oContactHistoryColl = new cdContactHistoryColl(this.Global); this.oContactHistoryColl.LoadMaxCount = 30; this.oContactHistoryColl.Load( this.sWhereClause ); Das bringt bei sehr großen Datenmengen einen Geschwindigkeits-Vorteil. Dieses Property hat keinen Einfluss auf das an die Datenbank geschickte Statement. Die Datenbank liefert bei dem ausgeführten Select alle Datensätze. Die Collection bricht bei Erreichen der Grenze die Verarbeitung ab. Dadurch müssen die überflüssigen Primary-Key-Informationen nicht eingelesen werden. Bei sehr vielen Treffern entlastet das auch den Hauptspeicher erheblich. Noch besser ist es, wenn es möglich ist, die Suchbedingung so zu formulieren, dass die Datenbank-Abfrage nicht zu viele Treffer liefert. Dadurch ist der Performance-Gewinn deutlich größer durch setzen dieses Properties. Besonders groß ist der Effekt, wenn die Datenbank-Abfrage eine Sortierung beinhaltet. Denn trotz dem Setzen dieses Properties muss die Datenbank alle Treffer sortieren. Metadaten von Properties Zur Laufzeit kann der Entwickler auf die Metadatentyp-Informationen der Properties zugreifen. Dafür stehen folgende Möglichkeiten zur Verfügung: Über die Factory-Klasse Mit der Methode GetPropertyMdt Die Factory-Klasse, welche mit den Interfaces kompiliert werden, bietet für jedes Component-Property eine Eigenschaft mdt_... an, welche eine Instanz mit den Metadatentyp-Informationen zurückgibt. Beispiel: An der Component cdArticle gibt es ein Property sArticleID. int intMaxSize = cdArticleFactory.mdt_sArticleID.Size; Mit der Methode GetPropertyMdt() kann mithilfe des Property-Namen die Metadatentyp-Information ermittelt werden. Das ermöglicht auch die Arbeit auf der Ebene DevFrameworkObject. Beispiel MLContainer mdt = oArticle.GetPropertyMdt(\"sArticleID\"); if (mdt is MDTStringBase) { int intSize = ((MDTStringBase)mdt).Size; } Folgende Basis-Klassen liegen den Metadatetypen zugrunde: Klasse-Hierarchie Verwendung (Properties) MLContainer Allgemeine Basis. Sie wird für Properties verwendet, die keinen Metadatentyp besitzen: DefaultLabel / MLColumnCaption / MLToolTip/ DragSource MetadatatypeBase Basis für alle Metadatentypen: FormatPattern / FormatMask MDTStringBase Basis für Strings (FSstring): Size/ Values MDTBoolBase Basis für Booleans (FSbool): Values MDTByteArrayBase Basis für Byte-Arrays (FSByteArray): Values MDTDateTimeBase Basis für DateTime (FSDateTime): Values MetadatatypeNumberBase Allgemeine Basis für Numerische Metadatentypen: Precision/ Scale MDTByteBase Basis für Byte (FSbyte): Values MDTDecimalBase Basis für Decimal (FSdecimal): Values MDTDoubleBase Basis für Double (FSdouble): Values MDTFloatBase Basis für Float (FSfloat): Values MDTIntBase Basis für Int (FSint): Values MDTLongBase Basis für Long (FSlong): Values MDTShortBase Basis für Short (FSshort): Values Beschreibungen der o.g. Properties DevMLString DefaultLabel: Das mehrsprachige Default-Label DevMLString MLColumnCaption: Die mehrsprachige Spalten-Beschriftung. Wenn diese nicht gepflegt ist, wird DefaultLabel zurückgegeben. DevMLString MLToolTip: Der mehrsprachige Tooltip. int Precision: Anzahl von Nachkommastellen; wird nur bei numerischen Typen angeboten. int Scale: Maximale Anzahl von Stellen inkl. Nachkommastellen. Wird nur bei numerischen Typen angeboten. int Size: Maximale Länge eines Strings. FrameworkFormatMask FormatMask: Gibt einen Wert mit dem Typ FrameworkFormatMask zurück. Dieses Enum kann folgende Werte beinhalten: FrameworkFormatMask.None FrameworkFormatMask.LowerCase FrameworkFormatMask.UpperCase FrameworkFormatMask.DateOnlyShort FrameworkFormatMask.DateOnlyMedium FrameworkFormatMask.DateOnlyLong FrameworkFormatMask.DateTimeShort FrameworkFormatMask.DateTimeMedium FrameworkFormatMask.DateTimeLong FrameworkFormatMask.TimeOnlyShort FrameworkFormatMask.TimeOnlyMedium FrameworkFormatMask.TimeOnlyLong FrameworkFormatMask.Decimal FrameworkFormatMask.Integer FrameworkFormatMask.PositiveInteger FrameworkFormatMask.NegativeInteger FrameworkFormatMask.UserDefined string FormatPattern: Ein individuelles Format-Pattern. Dieses kann z.B. bei numerischen Typen für die Formatierung von Zahlen in Strings verwendet werden. Bei FSstrings handelt es sich um einen regulären Ausdruck. [,] Values: Dieser Array beinhaltet die im Metadatentyp vorgenommenen Value-Einschränkungen. Die erste Dimension des Arrays bildet die einzelnen Einschränkungen ab. In der 2. Dimension sind der Von- und der Bis-Wert enthalten. Wenn nur der Von-Wert definiert wurde, dann steht dieser auch im Bis-Wert. Beispiel: A, B, E-G bildet folgendes Array new string[,] { {@\"A\", @\"A\"}, {@\"C\", @\"C\"}, {@\"E\", @\"G\"} }; Kopieren / Mergen kompletter Components Es ist möglich, komplette Components zu kopieren oder auch zusammenzuführen. Das funktioniert auch, wenn es sich bei Quelle und Ziel um unterschiedliche Repositories handelt. Zu beachten ist, dass der Dialog sehr viele Freiheiten bietet. Dies ermöglicht natürlich auch fehlerhafte Stände zu erstellen. Dieser Mechanismus ist für versierte Benutzer konzipiert. Grundsätzlich sollte der Benutzer wissen, was er tut und VOR der Aktion sicherstellen, dass alle von der Component benötigten Elemente am Ziel vorhanden sind. Aktionen Eine Component kann über das Kontext Menü an der Component kopiert werden. Eine Component kann über das Kontext Menü am Namespace eingefügt werden. Eine Component kann über das Kontext Menü an der Component gemerged (zusammengeführt) werden. Einfügen Wird eine Component ohne Basis kopiert, kann diese überall eingefügt werden. Eine Customization wiederrum kann nur erstellt werden, wenn im Package noch keine Customization vorhanden ist und die passende Basis existiert. Dialog Registerkarte Summary Die Summary zeigt, ob beim Paste oder Merge Konflikte gefunden wurden. MergeDialog - Summary Framework Studio versucht bei der Aktion die benötigten Elemente im Ziel-Package auf zwei verschiedenen Wegen zu finden: Über die interne ID: Das funktioniert meist dann, wenn Quell- und Ziel-Package identisch sind oder wenn Elemente aus einem gemeinsamen Basis-Package verwendet werden. Über den Namen: Wenn über die ID nichts gefunden wird, wird nach einem gleichnamigen Element (z.B. Metadatentyp, Component, Property) gesucht. Das ist vor allem dann sehr nützlich, wenn nach und nach mehrere Components in ein anderes Package kopiert werden. Wenn diese Wege nicht zum Ziel führen, wird dies als Konflikt betrachtet und der Benutzer muss nach einer Lösung suchen. Teilweise kann das auf den folgenden Registerkarten erfolgen. Manchmal ist es aber auch nötig, die Aktion abzubrechen, erst die Voraussetzungen zu schaffen (z.B. eine DBTable anlegen) und die Aktion anschließend noch einmal auszuführen. Die anderen Registerkarte sollten also der Reihe nach – wie ein Wizard – durchgearbeitet und die entsprechenden Einstellungen vorgenommen werden, um die Aktion am Ende korrekt ausführen zu können. Die Registerkarte sind bei beiden Aktionen Paste und Merge identisch. Registerkarte Needed Types Bei den Needed Types werden alle Typen aufgelistet, die nicht zum Standard gehören. Diese können beliebig ausgetauscht werden. Das kann z.B. dann sinnvoll sein, wenn eine benötigte Component vorher auch schon kopiert wurde und jetzt ggf. unter einem anderen Namen in einem anderen Namespace zu finden ist. Registerkarte General Unter General können die Interfaces, die Description und die ControlTypes überschrieben werden. Registerkarte Join Tables Bei einer JoinTable stehen zwei Aktionen zur Verfügung, wenn dies nicht durch die Checkbox ignoriert wird. Ein Insert fügt eine neue JoinTable an während der Replace die Werte an der JoinTable ersetzt. Registerkarte Virtual Columns Auch bei den VirtualColumns gibt es die Aktionen Replace, Insert oder Ignore. Diese verhalten sich wie bei der JoinTable. Registerkarte Properties Ein Property bietet beim Einfügen noch die weitere Möglichkeit, den Namen anzupassen. Der Replace ersetzt alle Werte für das ausgewählte Property. Registerkarte Methods Bei den Methoden ist wie bei den Properties eine Umbenennung möglich. Merge Mit einem Merge kann erreicht werden, dass Änderungen an einer Component in einer Kopie davon nachgezogen werden. Was nicht möglich ist, sind gelöschte Elemente durch den Merge zu entfernen. Es werden nur neu hinzugekommene oder geänderte beachtet. Für jedes Element wird in der Component das zugehörige Element gesucht und dann ein Replace vorgeschlagen. Ein Replace ändert nur dann die Daten, wenn diese sich in der kopierten Component auch geändert haben. Es kann also eine Component mit sich selbst gemerged werden und diese ist danach nicht modified, da es keine Änderungen gab."
  },
  "doc/comp/tab_properties.html": {
    "href": "doc/comp/tab_properties.html",
    "title": "Registerkarte Properties",
    "keywords": "Registerkarte Properties Neue Properties anlegen Die Properties werden in der ClassView-Registerkarte angezeigt. Hier können neue Properties angelegt werden. Das können Sie über den Button (New) mit dem Eintrag Property bzw. Membervariable oder über das Kontext-Menü der Component (New / Property bzw. New / Membervariable) machen. Eine dritte Möglichkeit besteht darin, eine Component direkt per Drag & Drop aus dem Namespace Treeview auf die Property Tabelle zu ziehen. Drag&Drop von Components Ziehen Sie ein Element aus dem Namespace-TreeView auf die Property-Registerkarte. So wird ein Property angelegt und zugleich im Component-Fenster angezeigt. Properties löschen Properties werden ebenfalls über die Registerkarte ClassView gelöscht. Wählen Sie zunächst das zu löschende Property und anschließend aus dem Kontext-Menü den Eintrag Delete aus. Properties kopieren Sie können ein Property in eine andere Komponente, in ein anderes Form kopieren oder innerhalb der Komponente duplizieren. Dazu wählen Sie das gewünschte Property in der Property-Liste aus. Anschließend verwenden Sie entweder die Standardtastenkürzel Strg+C, Strg+V und Strg+X oder das Kontextmenü, um den gewünschten Kopiervorgang durchzuführen. Properties bearbeiten Sie können ein Property öffnen, indem Sie einen Doppelklick auf den Eintrag in der ClassView-Registerkarte machen. Alternativ können Sie auch im Component-Fenster auf der Registerkarte Property in der Tabelle das gewünschte Property auswählen. Die Properties werden in der Tabelle sortiert, wenn Sie auf die Spaltenüberschrift des gewünschten Sortierkriteriums anklicken. Allgemeine Properties am Property Im Folgenden werden die allgemeinen Schaltflächen für ein Property, welche sich oberhalb der Property-Registerkarten befinden, erläutert. Name Bezeichnung des Properties. Über diesen Namen wird das Property im Code angesprochen. Access Level Legen Sie hier das Access-Level des Properties fest. Die Angabe ist analog zum .NET-Standard. Datatype Siehe Datentyp bearbeiten UseInterface Es besteht die Möglichkeit, ein Property, welches als Datatype eine Component eingestellt hat, als Interface einzubinden, um zirkulare Referenzen zu umgehen. Wenn man an einer Component ein Property anlegt und dabei als Typ eine Component aus einem anderen Namespace verwendet, dann wird bei diesem Property automatisch die Eigenschaft UseInterface gesetzt. Property Type Folgende Typen stehen zur Auswahl: • Membervariable • Generated • Generated (readonly) • Individual • Individual (readonly) • und Relation. Diese Typen werden weiter unten genauer beschrieben. Datentyp bearbeiten Die Eingabe des Datentyps erfolgt über ein Textfeld mit Auto-Vervollständigung. Beim Anlegen neuer Properties wird der zuletzt ausgewählte Datentyp vorbelegt. Diese Angabe kann nicht geändert werden, wenn dieses Property ein Mapping hat. Dann wird der Metadatentyp aus der entsprechenden Database-Column gezogen. Tippen Sie einfach den Namen des gewünschten Datentyps ein. Elemente, die mit dem eingegebenen Text beginnen, werden in der Auto-Vervollständigungsliste angezeigt und können über die Pfeiltasten oder per Maus ausgewählt werden. Wenn Sie den Namen eines Namespaces angeben und anschließend einen Punkt eingeben, wird die Auswahl der Vorschläge auf diesen Namespace eingeschränkt. Beispiel: „Sales.cd“ liefert alle Elemente aus dem Sales Namespace, die mit cd beginnen. Note Durch Verwendung des Platzhalters „%“ können Sie angeben, dass die Ergebnisse nicht mit dem danach folgenden Text anfangen müssen, sondern der Text lediglich enthalten sein muss. Beispiel: „sales.%ordertype“ liefert alle Elemente aus dem Sales Namespace, deren Name ordertype enthält, also z.B. cdOrderType. Wird die TextBox verlassen, wird der Name des ausgewählten Elements durch den vollständig referenzierenden Namen ersetzt. Warning Beim ersten Verwenden der Textbox kann es einige Sekunden dauern, bis der interne Speicher mit allen Elementen gefüllt ist. Es werden maximal 100 Vorschläge angeboten. Externe Typen Properties von Components und Data Contracts sowie Membervariablen von Forms können externe Datentypen zugewiesen werden. Wird die CheckBox „External Type“ gesetzt, wird die Autovervollständigung des Datatype-Textfeldes deaktiviert und ein beliebiger Typ kann angegeben werden (im Beispiel List<List<int>> ). Dies bietet sich z.B. an, wenn in einem Namespace mit externen Assemblies gearbeitet wird, deren Klassen als Datentypen von Properties verwendet werden sollen. Im IntelliSense wird beim Aufruf eines solchen Properties „object“ angezeigt, da im Hintergrund mit „object“ gearbeitet wird. Das Property „lstTest“ aus dem Beispiel kann aber z.B. trotzdem so verwendet werden: int i = this.lstTest[0][1]; // Der Wert von i ist danach 2 Registerkarte General In der Registerkarte General können Sie die Checkbox Autogenerate Membervariable bei Individual/Individual (readonly) Properties setzen. Wird die Checkbox aktiviert, wird automatisch eine Membervariable generiert und das entsprechende Depends on Property gesetzt. Die Textfelder Display MinLength, Display MaxLength, Display MinLines und Display MaxLines und die Comboboxen Mapping und Drag Source befinden sich ebenfalls hier. Des Weiteren können Sie im Textfeld Description eine Beschreibung hinzufügen. Das Control Mapping gibt das Mapping (die Verbindung) des Properties zur Query an. In der Combobox stehen hier alle Spalten (Alias) der Query zur Auswahl. Registerkarten Get Method / Set Method Für die Properties mit dem Type Generated, Generated (readonly), Individual, Individual (readonly) kann bei Bedarf individueller Code, der beim Setzen und Auslesen des Properties durchlaufen werden soll, programmiert werden. Siehe hierzu Individual / Individual (readonly) Properties und Generated / Generated (readonly) Properties Registerkarte Depends On Auf dieser Registerkarte können Sie angeben, welches Property bspw. aus dem Auftrag mit welchem Property aus dem Kunden verbunden werden soll. Sie geben also eine Schlüsselbeziehung an, ähnlich wie Sie das auf einer relationalen Datenbank tun würden. Sie können auch mehrere Properties miteinander verknüpfen, wenn sich der Schlüssel aus mehreren Properties zusammensetzt. Button Add: Fügt ein weiteres Property in die Relation ein. In der Tabelle wird eine neue Zeile angelegt und Sie definieren, welches Property mit welchem wie verknüpft werden soll. Button Remove: Löscht die markierte Zeile aus der Relation. Spalte Depends on Property: Hier wird das Property auf der Seite Component, in der Sie sich gerade befinden, angegeben. Im Beispiel wäre das ein Property des Auftrags, z.B. die „Kundennnr“. Spalte Compare Operator: Gibt an, mit welchem Operator die Properties verknüpft werden sollen. Spalte oXXX.Property: Gibt an, mit welchem Property der eingebundenen Component das eigene Property verknüpft werden soll. Im Beispiel wäre das evtl. „Kunde.Kundennr“. Spalte Generated Load Condition: Zeigt die aus den anderen Spalten entstandene Suchbedingung an. DependsOn und Individual Properties Individual Properties hängen (meist) von anderen Properties ab und besitzen selber keinen eigenen Wert, der getracked werden kann. Dennoch müssen Individual Properties dem Form-DataBinding Bescheid geben, dass sie sich geändert haben. Hierfür gibt es zwei Möglichkeiten: Das Propertiy wir permanent als geändert betrachtet - das passiert, wenn keinerlei DependsOn definiert ist. Die Folge ist, dass dieses Property bei JEDEM Broker Request geprüft und das Property abgefragt wird. Man pflegt die DependsOn-Informationen. Damit führen Änderungen an einem der \"DependsOn\"-Properties dazu, dass auch das Individual Property geprüft wird - aber eben nur dann und nicht mehr bei jedem Request. Wir empfehlen dringend das DependsOn zu pflegen, wann immer dies möglich ist. Je nach Art und Weise des Individual Properties kann das erhebliche Performance-Vorteile bringen. Im einfachsten Fall ist es nur eine einfache Berechnung. Sollte es sich jedoch um ein Objekt handelt, welches aus der Datenbank gelesen werden muss. Und es wurde zusätzlich auch kein Caching implementiert, dann ist die Bremse perfekt. Da das DependsOn immer wieder vergessen wird - vor allem bei einem einfachen Individual Property mit Membervariable - gibt es folgenden Mechanismus: Note In der Registerkarte General können Sie die Checkbox Autogenerate Membervariable bei Individual/Individual (readonly) Properties setzen. Wird die Checkbox aktiviert, wird automatisch eine Membervariable generiert und das entsprechende DependsOn-Property gesetzt. Registerkarte Load Command Das Load Command ist nur in Verbindung mit einem Property mit dem Type Relation Properties aktiv. Mit den Angaben auf der Registerkarte Depends On wird Code generiert, der für das Nachlesen der Daten zuständig ist. Diesen Code können Sie überschreiben, wenn Sie eine eigene Logik wünschen. Sind alle Angaben gemacht, wird die Relation erst beim ersten Zugriff nachgelesen. Dabei werden die gemachten Angaben berücksichtigt. Ändern sich die Inhalte der verbundenen Properties, wird erneut ein Load ausgeführt. Warning Derzeit können nur 1:1 Relationen abgebildet werden. D.h. es ist nicht möglich eine Collection als Relation einzubinden. Registerkarte Control Types Sie haben die Möglichkeit ein Standard-Control zu definieren bzw. ein zusätzliches Control hinzuzufügen. Registerkarte Texts Hier suchen Sie die Bezeichnung des Felds im Form aus. Sie können wählen, ob Sie die Bezeichnung aus der Database-Table bzw. dem Metadatentypen oder eine eigene Bezeichnung nehmen möchten. Die Bezeichnungen sind hierarchisch aufgebaut und können in den aufeinander aufbauenden Ebenen überschrieben werden. Metadatatype-Labels können durch die Database-Labels überschrieben werden, Database-Labels durch die Component-Labels, Component-Labels durch die Form-Labels. Ist in einer tieferen Ebene ein Label vergeben worden, wird dieses angezeigt. Arten von Properties Membervariablen Bei diesem Typ wird kein Property, sondern eine Membervariable erzeugt. Membervariablen haben keine get- und keine set-Methode. Sie sollten nur mit dem Access-Level private versehen werden, um eine externe Manipulation zu unterbinden, da keinerlei Sicherungsmöglichkeiten nach außen definiert werden können. Eine Membervariable wird nicht im Form-Designer angeboten. Sie sollte nur zum Merken von Informationen innerhalb der Komponente verwendet werden. Generated / Generated (readonly) Properties Die get- und set-Methode für das Property wird automatisch generiert, kann aber auch überdefiniert werden. Dazu muss die Checkbox Write Individual auf der Registerkarte Get Method bzw. Set Method gesetzt werden. In Getter und Setter kann mit der Hintergrundvariable this.PropertyNameValue gearbeitet werden. In Customizations sollte mit base.PropertyName gearbeitet werden, damit Getter und Setter aus dem Basis-Package nicht ausgehebelt werden. In der Component wird auch der Original-Wert des Properties gespeichert. Wird dem Property ein Wert zugewiesen, der vom Original-Wert abweicht, wird der Status der Component auf Changed gesetzt. Der Original-Wert kann mit PropertynameOrgValue abgefragt werden. this.prop = „abc“; if (this.prop != this.propOrgValue ) { /*Wert hat sich geändert*/ } Ist Generated (readonly) ausgewählt, steht für das Property nur die get-Methode zur Verfügung. Auf das Property kann somit nur lesend zugegriffen werden. Bei einer Wertzuweisung an das Property liefert der Compiler eine Fehlermeldung. Hat das Property ein Mapping, verwalten die generierten get- und set-Methoden das Resultset der Query. Ohne Mapping wird eine versteckte private Variable verwaltet. Properties mit einem Mapping können nur auf Generated oder Generated (readonly) stehen. Ist in der Query die Spalte ’Readonly’ gecheckt, ist sogar nur Generated (readonly) möglich. Individual / Individual (readonly) Properties Bei diesen Typen können/müssen Sie die get- und die set-Methode manuell ausprogrammieren. Es werden in den Registerkarten Get Property und Set Property die entsprechenden Code-Felder aktiv. Der Aufruf des Setters führt nicht dazu, dass der Status der Component geändert wird. In der Registerkarte Set Method kann bei Properties vom Typ Individual die von Framework Studio generierte Prüfung auf den Getter mit der Checkbox Check before set unterbunden werden. Eine Prüfung findet standardmäßig statt, weshalb die Checkbox per default gesetzt ist. Bei Individual (readonly) wird nur das Code-Feld für die get-Methode aktiv. Warning Achten Sie darauf, dass eine Get-Methode immer einen Rückgabewert vom Typ des Properties besitzen muss. Folgende 3 Anwendungsfälle sind denkbar (Beispiel): 1.Fall: Sie haben z.B. einen Generated Property Status, und wollen in einem weiteren Property den Text zum Status ausgeben. Dann empfiehlt sich ein Individual (readonly) Property. Die get-Methode könnte folgendermaßen aussehen: if (this.Status == 1) return „offen“; else if (this.Status == 2) return “erledigt”; else return “”; 2. Fall: Sie haben ein Generated Property vom Typ string, wollen aber ein int Property haben, mit dem Sie im Code arbeiten. Mit einem Individual Property können Sie dieses entsprechend verpacken: Generated Property sType vom Typ string (z.B. mit einer Column aus der Query verbunden). Individual Property intType vom Typ int: get-Methode: return Convert.ToInt32(this.sType); set-Methode: this.sType = Convert.ToString(value); 3. Fall: Sie wollen ein Property anbieten, das nur bei Bedarf instanziiert und gefüllt wird. Dazu müssen Sie zum einen ein Individual (readonly) Property (z.B. oComp) anlegen und zum zweiten eine private Membervariable (z.B. oCompMember), die den nachgelesen Wert merkt, damit das Einlesen nur einmal erfolgt (Property und Membervariable müssen denselben Typ haben). get-Methode: if (this.oCompMember == null) { this.oCompMember = new cComp(); oCompMember.Load(); } return oCompMember Die Individual Properties müssen dem Form-DataBinding ja irgendwann mal Bescheid geben, dass sie sich geändert haben. Da sie (meist) von anderen Properties abhängen und seilber keinen eigenen Wert besitzen, der getracked werden kann, gibt es 2 Möglichkeiten: 1.) Es wir permanent als geändert betrachtet - das passiert, wenn keinerlei DependsOn definiert ist. Die Folge ist, dass dieses Property bei JEDEM Broker Request geprüft und das Property abgefragt wird. 2.) Man pflegt die DependsOn-Informationen. Damit führen dann Änderungen an einem der \"DependsOn\"-Properties dazu, dass auch das Individual Property grprüft wird - aber ebend nur dann und nicht mehr bei jedem Request. Intern halten wir unsere Programmierer immer dazu an, DependsOn zu pflegen, wann immer das möglich ist. Ja nach Art und Weise des Individual Properties kann das erhebliche Performance-Vorteile bringen. Im einfachsten Fall ist es nur eine einfache Berechnung - da ist das nicht so tragisch. Wenn es sich aber um ein Objekt handelt, was aus der Datenbank gelesen werden muss und dann vielleicht auch noch kein Caching implementiert ist, dann ist die Bremse perfekt. Gerade weil die DependsOn immer wieder vergessen werden - vor allem wenn Programmierer ein einfaches Individual Property mit Membervariable anlegen, haben wir in FS 4.3 folgende Erweiterung vorgenommen: Registerkarte General In der Registerkarte General können Sie die Checkbox Autogenerate Membervariable bei Individual/Individual (readonly) Properties setzen. Wird die Checkbox aktiviert, wird automatisch eine Membervariable generiert und das entsprechende Depends on Property gesetzt. Relation Properties Die Relations dienen dazu, Ihre Komponenten miteinander zu verbinden. (Wenn Sie z.B. einen Auftrag und einen Kunden haben, ist es in der Regel so, dass der Auftrag eine Kundennummer hat, die angibt, welcher Kunde den Auftrag erteilt hat.) Relations stellen eine Möglichkeit dar, diese beiden Komponenten miteinander zu verbinden. Dazu wird im Auftrag beispielsweise ein Property Kunde angelegt. Dieses Property muss dem Typ Relation entsprechen. Anschließend müssen noch Angaben darüber gemacht werden, wie die beiden Komponenten miteinander verbunden sind. Warning Achten Sie darauf, dass als Datatype eine Component ausgewählt ist, da Sie andernfalls Relation nicht als Property Type auswählen können."
  },
  "doc/comp/tab_query.html": {
    "href": "doc/comp/tab_query.html",
    "title": "Registerkarte Query",
    "keywords": "Registerkarte Query Auf der Registerkarte Query Generator kann eine Abfrage definiert werden. Damit das möglich ist, muss auf der Registerkarte General ein Datasource gesetzt sein. Die Query ist nicht bei Collections verfügbar. Die Collection bezieht die Query aus der ihr zugrundeliegenden Component. Toolbar im Query Generator Button Add Jointable Mit diesem Button kann eine neue Tabelle in die Query eingefügt werden. Es erscheint ein Auswahl-Dialog, der alle Tabellen des in der Component hinterlegten Datasources anbietet. Sie können dort eine Tabelle auswählen und diese mit dem Button OK in die Query einfügen. Wenn Sie mehr als eine Tabelle in die Query eingebunden haben, müssen Sie in JoinType und Condition entsprechende Angaben machen. Wenn Sie eine Tabelle mehrmals einbinden, müssen Sie auch einen Alias vergeben. (Diese Felder sind weiter unten genauer erklärt.) Button Remove Jointable Entfernt die momentan ausgewählte Tabelle aus der Query. Button Add Virtual Column Fügt eine neue Spalte in die Query ein. Es wird eine neue Zeile in der Tabelle mit den Spalten angelegt und Sie müssen dann in der Spalte Column die entsprechende Spalte angeben. Evtl. müssen Sie noch den Alias anpassen. Button Remove Virtual Column Löscht die momentan markierte Spalte aus der Query. Das Löschen schlägt fehl, wenn diese Spalte bereits einem Property zugeordnet ist. Button Autogenerate Virtual Columns Öffnet den Dialog Autogenerate Virtual Columns. Autogenerate Virtual Columns Wizard In diesem Dialog werden alle Spalten angeboten, die noch nicht in die Query eingebunden sind. Sind bereits alle Spalten mindestens einmal verwendet, wird der Dialog nicht aufgerufen. In der Spalte Choose können Sie festlegen, welche Spalten zur Abfrage hinzugefügt werden sollen. In der Spalte Alias können Sie den Alias angeben. Diesen können Sie später wieder überschreiben. Mit der Checkbox Generate a property for all new Columns wird automatisch für jede neue Spalte ein neues Property angelegt. Der Name des Properties richtet sich nach dem hier angegebenen Alias. Diesen Vorgang können Sie auch später mit dem Button Autogenerate Properties nachholen. Mit dem Button Next öffnet sich das Fenster Summary. Es zeigt eine Zusammenfassung mit den zu generierenden Spalten und Properties an. Anschließend werden die Spalten (und ggf. auch Properties) mit dem Button Finish generiert. Button Autogenerate Properties Generiert für alle Spalten, die noch nicht einem Property zugewiesen sind, ein neues Property. Basis für den Namen der neuen Properties ist die Spalte Alias in der Tabelle. Wird der Alias nachträglich geändert, wird der Name das Properties nicht angepasst. Button Query with group by clause Schaltet Group By an oder aus. Wird Group by eingeschaltet, wird in der Tabelle eine neue Spalte GroupBy sichtbar. In ihr kann angegeben werden, ob nach der Spalte gruppiert werden soll oder ob eine Aggregatfunktion (SUM, MIN, MAX..) angewendet werden soll. Wenn das der Fall ist, wird die Angabe in der Spalte Criteria in die Having-Clause des SQL-Statements eingebaut. Soll trotzdem für eine Spalte eine Where-Clause angegeben werden, müssen Sie die Spalte noch einmal einbinden, Output deaktivieren, in GroupBy nichts angeben und Criteria wie gewünscht füllen. Button (Distinct Wenn der Button Distinct gedrückt ist, wird das Schlüsselwort „distinct“ in die Abfrage generiert. Distinct-Abfragen führen automatisch zu einer readonly-Komponente. Button ReadOnly Component Wird dieser Button aktiviert, kann auf die Komponente kein Save ausgeführt werden. Button Execute query Dieser Button dient zum Testen der angegebenen Query. Im unteren Teil des Fensters wird die Registerkarte Preview aktiviert und das Ergebnis der Query eingespielt. Die Registerkarte Preview können Sie auch manuell aktivieren, um die Query zu testen. Felder auf der Registerkarte Query In der Listbox werden die an der Query beteiligten Tabellen angezeigt. Es können mit dem Button (Add jointable ...) neue Tabellen hinzugefügt und mit dem Button (Remove jointable ...) die momentan ausgewählte Tabelle entfernt werden. Je nachdem, welche Tabelle ausgewählt ist, können rechts daneben weitere Angaben zur Tabelle gemacht werden. Alias Gibt den Alias an, der in der Query verwendet werden soll. Ist kein Alias angegeben, wird der Name der Tabelle verwendet. Wird eine Tabelle zweimal eingebunden, muss ein Alias angegeben werden, da sonst nicht eindeutig klar ist, welche Tabelle gezogen werden soll. JoinType Dieses Feld ist ab der zweiten Tabelle zugänglich. Es gibt an, welche Art von Join verwendet werden soll (Inner Join, Left Outer Join, Rigth Outer Join, No Join). Je nachdem, was dort angegeben ist, wird auch das Statement zusammengebaut. Wenn als Typ No Join angegeben ist, wird ein Statement erzeugt, das in etwa so aussieht: SELECT ... FROM Table1, Table2 WHERE Tabel1.Spalte1 = Table2.Spalte3... Condition Gibt die Bedingung für den Join an. Haben Sie in den DBTables bei Relations Angaben gemacht, werden diese hier entsprechend gezogen. Tabelle In der Tabelle sind die Spalten der Abfrage angegeben. Tabelle / Spalte Pos In dieser Spalte wird die Reihenfolge der Felder in der Abfrage definiert. Tabelle / Spalte Output Gibt an, ob die Spalte ausgegeben werden soll oder nicht. Dieser wird als gecheckt vorbelegt. Sie können diese Checkbox deaktivieren, wenn Sie z.B. eine Spalte haben, bei der die Suchbedingung interessant ist. Dann kann für diese Abfrage-Spalte kein Property angelegt werden. Mit gesetzter Checkbox (bei „Spalte2“) erhalten Sie folgendes Ergebnis: SELECT Spalte1, Spalte2 FROM Tabelle WHERE Spalte2 = ‘ABC’ Mit deaktivierter Checkbox erhalten Sie in etwa folgendes Ergebnis: SELECT Spalte1 FROM Tabelle WHERE Spalte2 = ‘ABC’ Das ist z.B. dann interessant, wenn Group by aktiviert ist und Sie im Query-Designer für eine Spalte trotzdem eine Bedingung angeben möchten. Tabelle / Spalte Column Gibt an, welches Feld der Tabelle(n) gezogen werden soll. In einer Combobox werden alle Felder der beteiligten Tabellen angezeigt. Es kann eines dieser Felder ausgewählt werden. Soll das Feld eine Formel enthalten, kann diese hier auch frei eingegeben werden. Tabelle / Spalte Alias Gibt den Alias des Felds an. Dieser Name wird als Standard-Name für die generierten Properties gezogen. Als Standard wird der Name des ausgewählten Felds eingetragen. Tabelle / Spalte Sort Type Hier kann festgelegt werden, ob und wenn ja wie nach diesem Feld sortiert werden soll. Zur Auswahl stehen Ascending (aufsteigend) und Descending (absteigend). Tabelle / Spalte Sort Order Gibt die Reihenfolge an, in der die Felder sortiert werden sollen. Es werden Zahlen von 0 aufsteigend vergeben, wenn Sie die Spalte ‚Sort Type‘ setzen. Diese Reihenfolge kann nachträglich geändert werden, indem die Zahlen einfach überschrieben werden. Wird ein Feld nicht sortiert, wird in die Spalte der Wert –1 eingetragen. Wird später mit der Load-Methode eine OrderBy-Clause angegeben, sind die Angaben in Sort Type und Sort Order hinfällig. Tabelle / Spalte Group By Warning Diese Spalte ist nur sichtbar, wenn für die Query Group By eingeschaltet ist. Hier wird angegeben, wie sich die Spalte im Group By verhalten soll. Es kann Group By oder eine Aggregatfunktion (z.B. SUM, MAX, AVG) angegeben werden. Die Spalte kann auch leer gelassen werden. Das macht aber nur Sinn, wenn die Spalte Output nicht gecheckt ist. Tabelle / Spalte Key Field Warning Diese Spalte ist nur sichtbar, wenn für die Query Group By eingeschaltet ist. Um einen Datensatz eindeutig zu identifzieren, werden normalerweise die PK-Spalten verwendet. Dies ist bei einer GroupBy-Anfrage nicht automatisch möglich. Mit der Spalte Key Field können Sie angeben, welche Abfrage-Spalten einen Satz eindeutig identifizieren sollen. Wird hier keine Angabe gemacht, dann greift der Reload-Mechanismus in der Collection nicht. Es werden dann immer alle Datensätze komplett eingelesen. Warning Wenn falsche Angaben gemacht werden, dann kann dies beim Reload zu falschen Daten führen. Im Zweifel sollten besser keine Key-Spalten gekennzeichnet werden. Wenn neben den Key-Spalten nur wenige weitere Abfrage-Spalten vorhanden sind, dann macht es keinen Sinn, die Key-Spalten zu kennzeichnen. Der Reload-Mechanismus bringt in diesem Fall keinen Vorteil - es könnte sogar einen Nachteil für die Performance bedeuten. Tabelle / Spalte Criteria, Spalten Or In den Spalten Criteria, Or, Or, Or können Bedingungen angegeben werden, die in der Query immer gelten sollen. Es können maximal 4 Kriterien angegeben werden. Z.B. „IS NOT NULL“, „>0“... Wird später mit der Load-Methode eine Where-Clause angegeben, wird diese mit einem „And“ an die hier angegebene Bedingung angefügt. Bei Spalten mit ‘Group By‘ oder einer Aggregat-Funktion wird die Kondition automatisch zur Having-Clause. Warning Wird später mit der Load-Methode eine Having-Clause angegeben, sind diese Angaben hier hinfällig. Tabelle / Spalte Readonly Ist diese Spalte gesetzt, wird das Property als Readonly generiert. Registerkarten Framework Studio SQL / Oracle SQL /SQL-Server SQL Unten, auf den Registerkarten Framework Studio SQL / Oracle SQL /SQL-Server SQL, wird das SQL der eigentlichen Abfrage (bezogen auf die jeweilige Datenbank) angezeigt. Registerkarte Preview Hier wird das Ergebnis der Abfrage in einer Tabelle dargestellt. Damit kann auch getestet werden, ob die definierte Abfrage funktioniert."
  },
  "doc/custom-controls/custom-controls.html": {
    "href": "doc/custom-controls/custom-controls.html",
    "title": "Custom Controls",
    "keywords": "Custom Controls Allgemeines Hintergrund Framework Studio stellt eine breite Palette von Standard Controls zur Verfügung. Sie sind jedoch nicht darauf angewiesen, sich auf diese Controls zu beschränken. Mit Custom Controls bietet Framework Studio einen komfortablen Weg, eigene, komplexe oder stark spezialisierte Controls zu entwickeln und in Ihre Anwendung zu integrieren. Beispiele für diese so genannten Graphical Custom Controls sind: dreidimensionale Darstellung von Statistiken Farbauswahldialog HTML-Textfeld ... Ein weiteres Anwendungsgebiet für Custom Controls sind funktionelle Erweiterungen des Clients, die lokal am Client ausgeführt werden müssen. Beispiele für Functional Custom Controls sind: lokaler Dateiauswahldialog Telefonanbindung (TAPI) Darstellung von Daten in externen Programmen (z.B. Word oder Excel) ... Aufgrund der Client-Server Architektur, die Framework Studio unterstützt, muss für ein Custom Control sowohl der Client (ggf. auch mehrere) als auch Ihre Anwendung in Framework Studio um eine entsprechende Definition des Controls erweitert werden. In dieser Dokumentation wird die Erweiterung in Framework Studio beschrieben. Informationen zur Erweiterung der Clients finden Sie in den entsprechenden Dokumentationen. Erstellen und Löschen von Custom Controls Erstellen eines Custom Controls Custom Controls werden wie alle anderen Elementtypen erzeugt. Dazu muss einer der drei Typen Functional, Graphical und Child Custom Control ausgewählt werden. Elemente erstellen Löschen eines Custom Controls Elemente löschen Verwendung von Custom Controls in Forms Um ein Custom Control in ein Form zu integrieren, öffnen Sie das Form im Form-Designer (\uF0E0Forms) und wechseln Sie anschließend auf die Registerkarte Toolbox (\uF0E0Framework Designer). Von dort ziehen Sie das gewünschte Control auf die Registerkarte Default Variant des Form-Designers. Wenn Sie ein Functional Custom Control einfügen, wird dieses im Form-Designer auf der Registerkarte Functional Controls (\uF0E0Registerkarte Functional Controls) angezeigt. Properties Ein Custom Control kann bestimmte statische Eigenschaften besitzen, die der Entwickler im Form-Designer angeben können soll. Diese Properties werden bei der Initialisierung des Custom Controls übertragen. Anwendungsfallbeispiele sind statische Spaltenüberschriften einer Tabelle oder allgemein Initialisierungsparameter für komplexe Controls. Diese Eigenschaften sind Theme-spezifisch, sodass in den Default Control Styles z.B. Farbwerte und Schriftarten je nach Theme angepasst werden können. Die einzige Ausnahme bilden Properties mit dem Typ MLString. Diese sind Theme-übergreifend. Wenn Sie für ein Custom Control ein neues Property anlegen möchten, benutzen Sie entweder den Button New... / Property oder wählen den Menüpunkt File / New / Property. Custom Control Registerkarte Properties: Anschließend können Sie auf der Registerkarte Properties die Eigenschaften des Properties festlegen. In der Auswahlbox oben auf der Registerkarte können alle Properties des Custom Controls ausgewählt werden. Zum ausgewählten Property werden dann darunter die Eigenschaften angezeigt. Name Name des Properties. Type Typ des Properties. Hier werden alle Standard .NET Datentypen, einige speziellere .NET Datentypen wie Color und Font sowie der Framework Studio Datentyp MLString angeboten. Category Hier kann ein Name für die Kategorie angegeben werden, unter der das Property auf der Registerkarte Properties eines Forms bei markiertem Control angezeigt wird. TypeConverter Hier kann ein Typkonverter für die Eingabe im Propertygrid auf der Registerkarte Properties angegeben werden. Beispielsweise NonnegativeInt32Converter, um nur die Eingabe von positiven Ganzzahlen zu ermöglichen. UITypeEditor Ein Typeditor kann für eine komfortable Eingabe eines Wertes im Propertygrid angegeben werden. Zum Beispiel der UrlUITypeEditor, mit dem URLs eingegeben und auf Gültigkeit geprüft werden können. Alle Default Control Styles, auch die von Custom Controls, werden im Namespace FSGeneral / Controls aufgelistet. Wenn Sie dort Ihr selbst definiertes Custom Control öffnen, können Sie für die Properties des Custom Controls Standardwerte vorbelegen. Custom Control Default Control Style: Wenn Sie ein Functional Custom Control auf ein Form ziehen und es markieren, werden Ihnen die selbst definierten Properties auf der Registerkarte Properties angezeigt. Custom Control Instance Properties: Actions Actions ermöglichen dem Programmierer, am Client eine Methode des Custom Controls aufzurufen. Um eine neue Action anzulegen, benutzen Sie entweder den Button New... / Action oder wählen den Menüpunkt File / New / Action. Auf der Registerkarte Actions des Custom Control Designer-Fensters können Sie in der Auswahlbox zwischen allen Actions des Controls auswählen. Die ausgewählte Action wird darunter dargestellt. Custom Control Registerkarte Actions: Name Name der Action. Dieser Name dient am Client zur Identifizierung der Action. Declaration Deklaration der Methode, die über das Control aufgerufen werden kann. Die Methode darf keinen Rückgabewert haben und kann beliebig viele Parameter entgegen nehmen. Die Parameter müssen einfache .NET Datentypen sein. Custom Control Registerkarte Method: Nach der Definition einer Action kann diese Action aus einem Form heraus, wie im obigen Bild dargestellt, aufgerufen werden. Datasources Datasources dienen zum bidirektionalen Datenaustausch zwischen Client und Broker. Die gemeinsame Datenquelle funktioniert genau wie die Datasources an den Standardcontrols. Um einen neuen Datasource anzulegen, benutzen Sie entweder den Button New... / Datasource oder wählen den Menüpunkt File / New / Datasource. Custom Control Registerkarte DataSources: Auf der Registerkarte DataSources können Sie in der obersten Auswahlbox zwischen allen Datasources des Controls auswählen. Die Eigenschaften der ausgewählten Datenquelle werden darunter dargestellt. Name Name des Datasources. Type Typ des Datasources. Zur Auswahl stehen folgende Werte: Value: Die Datenquelle kann mit einem beliebigen FS-Standarddatentypen gefüllt werden (z.B. string, int, object, ...) Record: Objekt vom Typ DevFrameworkObject Collection: Collection vom Typ DevFrameworkObjectColl SelectedRowsCollection: SelectedRowsCollection Inherit: Funktionslos Bei den Typen Record, Collection und SelectedRowsCollection müssen Methoden implementiert werden, welche die gewünschten Daten aus einem Objekt in Xml und zurück in ein Objekt übertragen! Beim Typ Value ist dies nicht nötig. Custom Control Instance Datasource: GetXML Diese Methode wird zum Senden der Daten vom Broker an den Client benötigt. Die Daten müssen aus dem Objekt in einen geeigneten Xml-Knoten umgewandelt werden. Die Methodendeklaration lautet: IEnumerable<XObject> GetDataSourceXml(Dictionary[…] value) Wobei DataSource durch den Namen der Datenquelle ersetzt wird. Alle zurückgegebenen Elemente oder auch Attribute werden in den von Framework Studio generierten XML-Knoten mit dem Typ XElement eingefügt. Diese Methode kann das Ergebnis als Liste zurückgeben. Man kann das Ergebnis aber auch mit Hilfe von „yield return“ enumerieren. Wenn keine Informationen an den Client übergeben werden sollen, dann wird einfach „return null;“ aufgerufen. Beispiel einer GetXML-Methode: List<XObject> xaList = new List<XObject>(); cColor oColor = value as cColor; if (oColor != null) { xaList.Add(new XAttribute(\"A\", oColor.intA.ToString())); xaList.Add(new XAttribute(\"R\", oColor.intR.ToString())); xaList.Add(new XAttribute(\"G\", oColor.intG.ToString())); xaList.Add(new XAttribute(\"B\", oColor.intB.ToString())); } xaList.Add(new XElement(\"EinUnterKnoten\")); return xaList; Dasselbe Beispiel als Enumerator mit yield return: cColor oColor = value as cColor; if (oColor != null) { yield return new XAttribute(\"A\", oColor.intA.ToString()); yield return new XAttribute(\"R\", oColor.intR.ToString()); yield return new XAttribute(\"G\", oColor.intG.ToString()); yield return new XAttribute(\"B\", oColor.intB.ToString()); } yield return new XElement(\"EinUnterKnoten\"); Das erzeugte XML sieht folgendermaßen aus: <Data> <Color A=\"0\" R=\"0\" G=\"0\" B=\"0\"> <EinUnterKnoten /> </Color> </Data> SetXML Diese Methode wird zum Empfangen der Daten vom Client am Broker benötigt. Die Daten müssen aus dem XML-Knoten ausgelesen und in das Objekt kopiert werden. Die Methodendeklaration lautet: void SetDataSourceXML (XElement xeNode, Dictionary<string, string> properties, Dictionary<string, Dictionary<string, string>> children, DevFrameworkObject value) Mit dem Parameter xeNode wird der komplette DataSource-Knoten übergeben. Aus diesem können jetzt die Attribute und Elemente ausgelesen werden. Einfaches Beispiel: cColor oColor = value as cColor; if (oColor != null) { oColor.intA = int.Parse(xeNode.Attribute(\"A\").Value); oColor.intR = int.Parse(xeNode.Attribute(\"R\").Value); oColor.intG = int.Parse(xeNode.Attribute(\"G\").Value); oColor.intB = int.Parse(xeNode.Attribute(\"B\").Value); } foreach(XElement xeSubNode in xeNode.Elements()) { ... Unterknoten auswerten ... } Events Events kann der Client senden. Auf diese Events kann dann am Broker reagiert werden. Um ein Event anzulegen, benutzen Sie entweder den Button New... / Event oder wählen den Menüpunkt File / New / Event. In der Klassenansicht (Registerkarte ClassView im Hauptfenster) können Sie den Namen des Events ändern. Wenn Sie Ihr Custom Control in ein Form gezogen haben, können Sie im Form an das Event wie gewohnt einen Eventhandler anhängen. Custom Control Eventhandler: Child Custom Controls Wenn Sie auf der Registerkarte Namespaces des Framework-Designers im Objekt-Baum ein Custom Control markieren, können Sie über den Menüpunkt File / New / Custom Control / Child Custom Control ein Untercontrol anlegen. Warning An einem Untercontrol können Sie nur Properties definieren. Alle anderen Funktionen müssen über das Hauptcontrol abgewickelt werden."
  },
  "doc/database/connection.html": {
    "href": "doc/database/connection.html",
    "title": "Datenbank-Connection",
    "keywords": "Datenbank-Connection SQL-Server Connection Soll beim Server ein Adresse mit einem Port angegeben werden, dann muss der Port duch ein Komma abgegrenzt werden. Beispiel: Server=MySqlServer,1234 Wird kein Username angegeben, dann wird Windows-Authentifizierung verwendet. Oracle-Connection Server / Database Bei der Angabe von Server und Database erzeugt Framework Studio einen TNS-String in dem folgenden Format: (DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=<SERVER>)(PORT=1521)))(CONNECT_DATA=(SID=<Database>)(SERVER=DEDICATED))) Der Standard-Port 1521 kann über den Server-Namen beeinflusst werden, indem er mit einem : getrennt angegeben wird. Die Database wird standardmäßig als SID angegeben. Durch Angabe von SERVICE_NAME= kann die Angabe als SERVICE_NAME definiert werden. Das kann bei Container-Datenbanken sinnvoll sein. Beispiel 1: Server=MyOraServer:1234 Database=MyDatabase dasselbe wie Database=\"SID=MyDatabase\" Ergibt den folgenden TNS-String: (DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=MyOraServer)(PORT=1234)))(CONNECT_DATA=(SID=MyDatabase)(SERVER=DEDICATED))) Beispiel 2: Server=[2607:f0d0:1002:51::4]:1234 (IPv6-Adresse mit Port) Database=\"SERVICE_NAME=MyDatabase\" Ergibt den folgenden TNS-String: (DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=[2607:f0d0:1002:51::4])(PORT=1234)))(CONNECT_DATA=(SERVICE_NAME=MyDatabase)(SERVER=DEDICATED))) tnsnames.ora Wird kein Server angegeben, dann erzeugt Framework Studio keinen TNS-String sondern verwendet Database direkt als DataSource. So kann man einen in der tnsnames.ora konfigurierten TNS-Alias bei Database angeben. TNS-String Wird kein Server angegeben, dann kann bei Database auch ein kompletter TNS-String angegeben werden. Das kann benutzt werden, wenn der automatisch generierte TNS-String nicht ausreicht. Einstellungen im Detail Im folgenden werden die Parameter für eine Connection erklärt. Neben der Oberfläche können diese Angaben auch in einem Connection-String für die FrameworkDataConnection verwendet werden. Beispiel für einen Connection-String: FSProviderType=SqlServer;Server=MyDBServer;Database=MyBusinessDB;UserID=sa;Password=geheim! Connection Type Gibt an, mit was für einer Datenbank (SQL-Server oder Oracle Managed) gearbeitet werden soll. Name im Connection-String: FSProviderType gültige Werte: SqlServer, OracleManaged Beispiel: FSProviderType=SqlServer Server Der Server, auf dem die Datenbank liegt (siehe oben), Name im Connection-String: Server Beispiel: Server=MyDBServer Database Name der Datenbank (siehe oben) Name im Connection-String: Database Beispiel: Database=MyBusinessDB DB Username Benutzer-Name für die Anmeldung. Wird bei SQL-Server kein UserName angegeben, dann wird Windows-Authentifizierung verwendet. Name im Connection-String: UserID Beispiel: UserID=sysadm Password Das Passwort für die Anmeldung. Name im Connection-String: Password Beispiel: Password=geheim!123 Wird das Password in der Oberfläche eingegeben, dann erzeugt Framework Studio ein verschlüsseltes Passwort. Name im Connection-String: PasswordEncrypted Beispiel: PasswordEncrypted=K96Px6YBomSeHPMr/IgnZg== Diese Vershlüsselung ist nicht sehr sicher - es wird lediglich verhindert, dass ein Benutzer das Passwort einfach lesen kann. Use AnsiString Gibt an, ob die String-Parameter in den Commands als Ansi-String behandelt werden sollen. Name im Connection-String: FSUseAnsiString Standard-Wert: false Beispiel: FSUseAnsiString=true Caution Wenn aktiviert, dann können keine Unicode-Inhalte zur Datenbank transportiert werden. Connection-Pooling Der Connection-Pool stellt eine Menge von freien wiederverwendbaren Datenbank-Verbindungen zur Verfügung. Dabei kann über die FSPooling-Parameter das Verhalten des Pools gesteuert werden. Eine mit Framework Studio entwickelte Anwendung benötigt eine Datenbankverbindung, um mit dem zugehörigen Broker zu kommunizieren. Bei jedem Request wird eine Verbindung aufgebaut und danach wieder geschlossen. Da dieses Verhalten vor allem auf Oracle-Datenbankservern sehr viel Zeit in Anspruch nimmt, kann vom Broker eine bestimmte Anzahl an offenen Datenbankverbindungen vorgehalten werden, auf die die Anwendung zurückgreifen kann. Die Parameter haben die folgende Bedeutung: FSPoolingMin: Wird eine Connection nicht mehr benötigt, wird sie (z.B. am Ende eines Broker-Requests) wieder zurück in den Vorrat / Pool gepackt. Der Pool darf dauerhaft diese Anzahl an Connections beinhalten. FSPoolingMax: Das ist die maximale Anzahl der Connections, die sich im Pool befinden dürfen. Ist der Pool voll, dann wird die Connection nicht in den Pool zurückgepackt sondern sie wird direkt geschlossen. FSPoolingTimeout: (in Sekunden) Die Connections zwischen Min und Max verbleiben maximal diese Zeit im Pool. Werden sie nicht vorher wieder verwendet, werden sie nach dem Timeout aus dem Pool entfernt und geschlossen. Der Timeout wird geprüft, wenn versucht wird, eine Connection in den Pool zu packen. In der Oberfläche kann das Pooling mit der Checkbox Activate FSPooling aktiviert werden. Min Anzahl der Datenbank-Connections, die dauerhaft im Connection-Pool verbleiben sollen. Name im Connection-String: FSPoolingMin Standard-Wert: 5 Beispiel: FSPoolingMin=5 Max Anzahl der Datenbank-Connections, die maximal im Connection-Pool enthalten sein dürfen. Jede weitere Connection wird unmittelbar nach der Verwendung wieder getrennt. Name im Connection-String: FSPoolingMax Standard-Wert: 15 Beispiel: FSPoolingMax=15 Timeout Timeout in Sekunden. Diese Zeit verbleiben die zusätzlichen Datenbank-Connections im Pool, bis auch sie getrennt werden. Name im Connection-String: FSPoolingTimeout Standard-Wert: 60 Beispiel: FSPoolingTimeout=60 FSPoolingDebugOutput Gibt einen Dateinamen an, in dem der Connection-Pool ein Protokoll schreiben soll. Dieses kann für die Analyse des Connection-Pools verwendet werden. (siehe Kapitel Connection Pooling Protokoll) Diese Einstellung kann nicht über die Oberfläche definiert werden. Name im Connection-String: FSPoolingDebugOutput Beispiel: FSPoolingDebugOutput=C:\\temp\\FSPool.txt Weitere Parameter Die von Framework Studio nicht erkannt werden, werden direkt in den nativen Connection-String übernommen. So können auch native Features der jeweiligen Datenbank genutzt werden."
  },
  "doc/database/datasource.html": {
    "href": "doc/database/datasource.html",
    "title": "Datasource",
    "keywords": "Datasource Ein Datasource (Datenquelle) definiert eine Datenbankverbindung, die von der Anwendung zum Lesen und Schreiben der Anwendungsdaten verwendet werden kann. Alle Datenquellen werden im Objekt-Baum (Registerkarte Namespaces) im Namespace FSGeneral / DBTables verwaltet. Das Erstellen und Löschen von Datenquellen funktioniert in diesem Namespace wie bei allen anderen Elementen (Elemente erstellen, Elemente löschen). Durch einen Doppelklick auf eine Datenquelle wird das Designer-Fenster geöffnet. Erläuterungen zu den Standardfunktionen, die im Designer-Fenster für Datenquellen angeboten werden, finden Sie unter Allgemeine Funktionalitäten. Alle weiteren Funktionen werden im Folgenden beschrieben: Name: Über das Textfeld können Sie der Datenquelle einen Namen zuweisen. Die Verbindungs-Einstellungen sin dim Kapitel Connection Einstellungen beschrieben. Test Connection: Über diesen Button können Sie testen, ob mit den angegebenen Verbindungsdaten eine Verbindung aufgebaut werden kann."
  },
  "doc/database/dbtable.html": {
    "href": "doc/database/dbtable.html",
    "title": "DBTable",
    "keywords": "DBTable Ein DBTable ermöglicht Komponenten den Zugriff auf eine Datenbanktabelle, die über einen Datasource angesprochen werden kann. Alle DBTables werden im Objekt-Baum (Registerkarte Namespaces) im Namespace FSGeneral / DBTables unterhalb des Datasources angezeigt, den der DBTable zur Verbindung mit der Datenbank verwendet. Das Erstellen und Löschen von DBTables funktioniert wie bei allen anderen Elementen (Elemente erstellen, Elemente löschen). Zuvor muss allerdings im Objekt-Baum der zu verwendende Datasource markiert werden! Durch einen Doppelklick auf ein DBTable wird das Designer-Fenster geöffnet. Erläuterungen zu den Standardfunktionen, die im Designer-Fenster für DBTables angeboten werden, finden Sie unter Allgemeine Funktionalitäten. Über den Menüpunkt Database / Import kann die auf der Datenbank existierende Datenstruktur ausgelesen werden und der DBTable automatisch konfiguriert werden (Automatisiertes Importieren von Datenbankstrukturen). Über den Menüpunkt Component / Create Component... kann aus dem DBTable eine Komponente generiert werden (Erzeugen einer Komponente). Die Checkbox View legt fest, ob es sich bei dieser Tabelle um einen View handelt. Wenn dies der Fall ist, muss auf der Registerkarte View eine entsprechende View-Definition angegeben werden. Diese Einstellung kann im Customizing nicht verändert werden. Die Checkbox Use History legt fest, ob historische Daten in einer separaten Tabelle ausgelagert sind (Auslagerung historischer Daten). Die Checkbox Imported gibt an, ob es sich bei dieser Tabelle um eine importierte Datenstruktur handelt. Importierte Strukturen werden beim automatischen Datenbank-Update nicht berücksichtigt. Wenn an der, der DBTable zugehörigen, Connection die Eigenschaft Imported gesetzt ist, dann ist auch die Checkbox an der DBTable automatisch gesetzt und kann nicht deaktiviert werden. Diese Einstellung kann im Customizing nicht verändert werden. Die einzelnen Registerkarten werden im Folgenden beschrieben. Registerkarte Columns Auf der Registerkarte Columns werden die einzelnen Spalten der Tabelle angezeigt. Die Eigenschaften der Spalten sind editierbar und müssen mit der Definition des Datenmodells auf der Datenbank vereinbar sein. Außerdem kann ein Metadatentyp zugeordnet werden. Link Preview DBTable Öffnet die Sql Statement Preview Tabelle In der Tabelle werden Informationen zu allen Spalten angezeigt. Die Tabelle ist readonly - die Details der ausgewählten Tabellen-Spalte können im Bereich unter der Tabelle angezeigt werden. Spalte Name: Der Name der Spalte Spalte Default Label: Zeigt den Text des Default-Labels an. Dieser kann auf der Registerkarte Texts bearbeitet werden. Spalte Metadatatype: Der Name des Metadatentyp Spalten Size, Precision, Scale: Die Größe des Feldes. Spalte Column Kind: Die Art der Spalte. RowID, RowVersion oder PK (Primary Key). Spalte MLColumn: Zeigt an, ob es sich um eine MLColumn handelt. Spalte Not Null: Zeigt an, ob die Spalte als Not Null gekennzeichnet ist. Feld Name Feldname in der Datenbank. Dabei muss es sich um einen gültigen \"Identifier\" handeln. Feld Metadatatype Art des Feld-Typs. Hier stehen alle Metadatentypen und Datenbank-Datentypen zur Verfügung. Der Link Open Öffnet den Metadatentyp der momentan ausgewählten Spalte. Checkbox Primary Key Gibt an, ob es sich bei der Spalte um einen Primär-Schlüssel handeln soll. Auf eine so gekennzeichnete Tabellen-Spalte kann kein Update erfolgen. Checkbox RowID, RowVersion Auf jeder Tabelle können die beiden Spalten FSROWID und FSROWVERSION definiert werden. Diese beiden Spalten werden dann jeweils mit der entsprechenden Checkbox gekennzeichnet. Diese Spalten sind für das Update der Daten notwendig, damit konkurrierende Transaktionen erkannt und verhindert werden können. (Siehe auch FSROWID / FSROWVERSION) Checkbox MLColumn Ist die Checkbox aktiviert, kann in der Anwendung der Dateninhalt der Spalte mehrsprachig gepflegt werden (siehe MLColumn). Checkbox Not Null Wenn gesetzt, dann darf diese Spalte keine Null-Werte beinhalten. Diese Information wird bei automatischen Datenbank-Update abgeglichen. Feld Size Größe des Felds bei alphanumerischen Datentyp. Wird eine Größe von 0 angegeben, handelt es sich um ein Langtext-Feld ohne Größen-Beschränkung. Feld Precision Anzahl der Stellen eines numerischen Feldes (inkl. Nachkommastellen). Feld Scale Anzahl der Nachkommastellen. Checkbox Override Wird diese Checkbox gesetzt, dann können die aus dem Metadatentyp geerbten Größen-Angaben Size, Precision und Scale, überschrieben werden. Warning Davon sollte nur in Ausnahmefällen gebrauch gemacht werden. Zuerst sollte versucht werden, einen passenden Metadatypen zu verwenden. Ist keiner vorhanden, dann muss ggf. ein passender Metadatentyp erzeugt werden - insbesondere dann, wenn das mehrere Tabellen-Spalten betrifft. Auch im Customizing-Package sollte man zuerst darüber nachdenken, den zugeordneten Metadatentyp anzupassen. Das beugt Probleme beim Übertragen von Werten in andere Spalten mit demselben Metadatentyp vor. Felder Display Length / Lines In den Feldern Display MinLength, Display MaxLength, Display MinLines und Display MaxLines können die Größen-Angaben für die Form-Controls gesteuert bzw. überschrieben werden. Siehe auch Größe von Controls. Registerkarte Texts Hier können Sie das zu verwendende Default-Label, die Column-Caption, der Tooltip und die Description für eine Datenbankspalte festlegen bzw. überschreiben. Wenn der Spalte ein Metadatentyp zugeordnet wurde, wird das Default-Label vom Metadatentyp verwendet, solange es nicht an dieser Stelle überschrieben wird. Registerkarte ControlTypes Auf der Registerkarte ControlTypes wird angezeigt, welche Controls der Spalte zugeordnet sind. Ist der Spalte ein Metadatentyp zugewiesen, werden die dem Metadatentyp bereits zugewiesenen Controls hier angezeigt. Die Liste kann ggf. ergänzt werden. Ist kein Metadatentyp zugewiesen, können Sie die ControlTypes hier hinterlegen. Mit den Buttons Add und Change öffnet sich das Fenster Assign Controls. Siehe auch Metadatentyp Registerkarte Control Types Registerkarte Documentation Auf der Registerkarte Documentation kann die Benutzer-Dokumentation für die Tabelle hinterlegt bzw. die Dokumentation aus dem verwendeten Metadatentypen überschrieben oder ergänzt werden. Siehe auch Dokumentations-System. Registerkarte Indices Die Indizes einer Tabelle lassen sich auf der Registerkarte Indices festlegen. Ein neuer Index lässt sich wie gewohnt durch das Kontextmenü, die Toolbar oder durch das Menü File / New anlegen. Diesem können nun Spalten zugeordnet werden, die entweder absteigend (DESC) oder aufsteigend (ASC) indiziert sein können. Des Weiteren kann ein Index als Unique (eindeutig) deklariert werden und er kann aktiviert oder deaktiviert werden, wodurch der automatische Abgleich mit der Datenbank beeinflusst wird. Indizes lassen sich nur dann verwalten, wenn es sich bei der Tabelle nicht um einen View handelt. Registerkarte View Wird eine DBTable mit der Checkbox View gekennzeichnet, dann muss auf der Registerkarte View ein SQL-Statement für die View-Definition angegeben werden. Die View-Definition wird beim automatischen Datenbank-Update abgegelichen und der View ggf. angepasst. Das Statement wird in Framework-Studio-Syntax formuliert (SQL-Syntax). Die Bezeichnungen der Ergebnis-Spalten werden aus dem Select-Statement ermittelt. Aus diesem Grund muss ggf. ein Spalten-Alias angegeben werden - z.B. bei berechneten Spalten und wenn die Bezeichnung von der Tabellen-Spalte abweichen soll. Es ist zwingend zu beachten, dass alle in der Registerkarte Columns definierten Spalten in der View-Definition enthalten sind. Die View-Definition kann im Customzing-Package überschrieben werden. Mit dem Link Preview Select öffnet sich die Sql Statement Preview. Damit kann das Statement gestestet werden. Registerkarte Description In dem Textfeld der Registerkarte können allgemeine Informationen zu dieser Tabelle hinterlegt werden. Sql Statement Preview Mit der Sql Statement Preview können SQL-Befehle getestet werden. Sie steht in verschiedenen Programmteilen zur Verfügung um z.B. eine DBTable, die View-Definition oder eine Component-Query zu testen. Registerkarte Select Statement Hier wird der SQL-Befehl angezeigt, der von der Aufruf-Stelle übergeben wurde. Dieser kann hier temporär bearbeitet werden, die vorgenommenen Änderungen werden jedoch nicht übernommen. Im Feld Additional where clause kann optional eine zusätzliche Suchbedingung angegeben werden. Wenn das Statement selber schon eine Bedingung besetzt, dann wird diese ergänzt. Bei Connection wird die aktuell ausgewählte Datenbank angezeigt. An diese wird das SQL-Statement geschickt. Mit dem Button View Result wird auf die Registerkarte View top 50 Results gewechselt. Registerkarte Converted Statement Zeigt den in die Syntax der Zieldatenbank konvertierten SQL-Befehl an. Standardmäßig wird der Typ der aktuell ausgewählten Datenbank vorbelegt. Mit den Buttons kann der Typ gewechselt werden. Falls bei der Konvertierung ein Fehler auftritt, wird dieser statt dem Statement angezeigt. Registerkarte View top 50 Results Beim Wechsel auf diese Registerkarte wird das Statement an die aktuell ausgewählte Datenbank gesendet und die ersten 50 Ergebnisse in einer Tabelle angezeigt. Automatisiertes Importieren von Datenbankstrukturen Framework Studio bietet Ihnen einen Automatismus, der es erlaubt, alle nötigen Angaben über die Struktur der Daten auf der Datenbank auszulesen und daraus die Spaltendefinitionen generieren zu lassen. Benutzen Sie dazu den Menüpunkt Database / Import, der Ihnen sowohl im Designer-Fenster eines Datasources als auch im Designer-Fenster eines DBTables zur Verfügung steht. Zunächst werden Ihnen alle Tabellen, die über die Datenquelle (des DBTables) erreichbar sind, zur Auswahl gestellt. Wenn Sie eine Tabelle ausgewählt haben, die in Framework Studio bisher noch nicht bekannt ist, wird diese automatisch als neuer Table in Framework Studio eingebunden. Danach sehen Sie im Fenster Update Table eine Tabelle, in der alle Columns (Spalten der Datenbanktabelle) aufgelistet werden. Update Table (Spalten): In der Tabellenspalte mit der Überschrift Column Name wird der Name der Datenbankspalte aufgeführt. In der Tabellenspalte Action wird ein Symbol dargestellt, an welchem Sie erkennen können, welche Art von Änderung bei einer Aktualisierung durchgeführt wird. Die Symbole haben folgende Bedeutung: New: Die Spalte ist in Framework Studio bisher unbekannt und wird neu eingefügt. Modified: Einige Eigenschaften der Spalte (z.B. Genauigkeit, Größe oder Metadatentyp) unterscheiden sich von den Vorgaben durch die Datenbank. Diese Eigenschaften werden geändert. OK: Die Konfiguration in Framework Studio stimmt mit der Datenstruktur in der Datenbank überein. Sie haben trotzdem die Möglichkeit, den Metadatentypen zu ändern. Delete: Diese Spalte ist in Framework Studio angelegt worden, existiert aber nicht in der Datenbank. Deshalb wird Sie aus der Konfiguration entfernt. In der Tabellenspalte Metadatatype wird der Metadatentyp, welcher der Spalte zugewiesen wird, festgelegt. In der Combobox stehen alle Metadatentypen zur Auswahl, deren Datentyp sich mit dem der Datenbankspalte vertragen. Außerdem haben Sie die Möglichkeit, über den Eintrag Create ’mdtBeispieldatentyp’ für diese Datenbankspalte einen neuen Metadatentypen generieren zu lassen. In der Tabellenspalte Action Description werden die einzelnen Änderungen aufgeführt, die bei einem Update der Spalte durchgeführt werden. Die alten Werte werden in runden Klammern hinter den neuen Werten aufgeführt. Mit der Checkbox in der Tabellenspalte Update legen Sie für jede einzelne Datenbankspalte fest, ob die vorgeschlagenen Änderungen tatsächlich durchgeführt werden sollen. Mit den Buttons und legen Sie fest, dass alle Datenbankspalten bzw. keine Datenbankspalte aktualisiert werden soll. Durch einen Klick auf gelangen Sie zur Zusammenfassung der vorzunehmenden Änderungen. Sie können den Aktualisierungsvorgang nun mit dem Button starten. Update Table (Zusammenfassung): Wenn Sie automatisch neue Metadatentypen generieren lassen, haben Sie die Möglichkeit, den Namespace auszuwählen, in dem der Metadatentyp angelegt werden soll. Select Namespace: Sie können für jeden neu zu erstellenden Metadatentypen einzeln einen Namespace auswählen oder durch Setzen der Checkbox Create all Metadatatypes in this Namespace alle Metadatentypen im gleichen Namespace erzeugen lassen. Mit dem Button New Namespace können Sie im ausgewählten Namespace einen neuen Namespace anlegen. Auslagerung historischer Daten Sehr große Datenvolumen in Tabellen mit aktuellen und historischen, viele Jahre alten Daten, können die Geschwindigkeit der Anwendung bremsen. Werden die historischen Daten in eine spezielle Tabelle ausgelagert, so kann Framework Studio abhängig von einem Laufzeitschalter beim Laden von Components entweder die aktuellen Daten oder alle Daten berücksichtigen. Der Geschwindigkeitsvorteil entsteht im Wesentlichen dadurch, dass im täglichen Betrieb nur mit den aktuellen Daten, also einer geringeren Datenmenge gearbeitet werden muss. Dem Datenbankadministrator wird außerdem die Möglichkeit gegeben, die historischen Daten auf einer langsameren Hardware zu speichern. Der Mechanismus ist für sehr große Datenmengen interessant. Typische Anwendungsfälle sind Journaltabellen, in denen viele Millionen Datensätze abgelegt sind. Details An DBTables kann über die Checkbox Use History festgelegt werden, ob historische Daten in eine separate Tabelle ausgelagert sind. Diese Eigenschaft kann auch in Customizing Packages nachträglich gesetzt werden. Ist der Schalter für eine Tabelle Xyz gesetzt, geht Framework Studio davon aus, dass eine Tabelle Xyz_H (für die historischen Daten) und ein View Xyz_A, welcher mit Union All die Daten aus Xyz und Xyz_H vereint, vorhanden ist. Tabelle und View können von der Endanwendung (z.B. beim Update) automatisch generiert werden. Note Für das Übertragen von Daten aus der Tabelle Xyz in die Historientabelle Xyz_H ist manuelle Programmierung nötig. Wird versucht, einen historischen Datensatz zu speichern, so wird eine Exception ausgelöst. Am Global Object (this.Global) gibt es einen Schalter Use History, mit dem global entschieden wird, ob beim Laden historische Daten berücksichtigt werden sollen. Ist der globale Schalter Use History gesetzt und an einer Tabelle ist der Schalter Use History ebenfalls gesetzt, so wird beim Laden statt auf die Originaltabelle auf den View zugegriffen. Um temporär den Historienmodus zu aktivieren, kann folgendes Using Konstrukt verwendet werden: // Historienmodus temporär erzwingen: using(this.Global.UseHistoryTemporarily()) { ... } Alle Components, die einen Datenbankbezug haben, bieten die Funktion GetTableName an. Diese Funktion gibt den Tabellennamen inklusive Alias zurück, zum Beispiel „Artikel_A as Artikel“. Diese Funktion eignet sich für die Formulierung von Sub Selects. Für die manuelle Formulierung von Update-, Insert- oder Delete Statements kann an der Component Instanz auf QueryInfo.GetJoinInfo().FirstOrDefault().Table.TableName zugegriffen werden. Erzeugen einer Komponente Über den Menüpunkt Component / Create Component öffnet sich das gleichnamige Fenster. Hier wird eine Abfrage erzeugt, die genau die Daten aus der Datenbank holt, welche Sie über Ihren DBTable definiert haben. New Component Wizard / Create Component Aktivieren Sie die Checkbox Create a Collection for the Component, um gleichzeitig eine Collection zu der Komponente zu erzeugen. Die Collection wird in dem gleichen Namespace erzeugt und trägt das Suffix Coll (also cdXxxColl). Der Button Next auf der Maske Create Component öffnet das Fenster Choose Namespace. New Component Wizard / Choose Namespace Im Fenster Choose Namespace wählen Sie den Namespace aus, in dem die neue Komponente erzeugt werden soll. Über den Button Next öffnet sich das Fenster Summary. Es zeigt Ihnen eine Zusammenfassung Ihrer Einstellungen. Summary Mit Finish wird die Komponente erzeugt. Alle angezeigten Tabellen werden ebenfalls über Source Control gesteuert. Das bedeutet, dass Elemente, die editiert werden sollen, ausgecheckt und zum Übernehmen der Änderungen wieder eingecheckt werden müssen. In dieser Ansicht ist nicht direkt erkennbar, welche Elemente ausgecheckt sind und welche nicht. Sie sollten es sich deshalb zur Gewohnheit machen, Ihre Database-Elemente so schnell wie möglich wieder einzuchecken und so für andere Entwickler verfügbar zu machen. Tabellen können eingecheckt werden, indem Sie sie in der Tabelle auswählen und dann über das Hauptmenü Source Control / Check In wählen."
  },
  "doc/database/ml-column.html": {
    "href": "doc/database/ml-column.html",
    "title": "ML-Column",
    "keywords": "ML-Column Framework Studio bietet einen Mechanismus, um Dateninhalte in mehreren Sprachen zu speichern. Eine beliebige Tabellen-Spalte, in der eine Zeichenkette abgelegt ist, kann im Tabelleneditor als MLColumn markiert werden. Vorraussetzung ist jedoch, dass die Tabelle die Spalte FSRowID enthält, weil diese als eindeutige Referenz auf den Datensatz benötigt wird. Ist eine Tabellen-Spalte als MLColumn gekennzeichnet, dann werden die fremdsprachigen Texte in der Tabelle dbRun_MLStrings abgelegt. Die normale Tabellen-Spalte beinhaltet die Texte in Default-Sprache. Caution Fehlt einer Component das Property ROWID (mit Mapping auf die DB-Column FSRowID), ist der Mechanismus für diese Component deaktiviert. Join-Components können keine ML-Columns aus mehreren Tabellen verabreiten, da die Component lediglich ein ROWID-Property betrachtet. Werden mehrere ROWID-Properties aus verschiedenen Tabellen eingebunden, dann ist es Zufall, welche ROWID für den MLColumn-Mechanismus herangezogen wird. Customizing-Package Die Eigenschaft MLColumn kann im Customizing-Package gesetzt werden. Somit kann man in Kunden-Umgebungen den Mechanismus gezielt für die gewünschten Tabellen-Spalten aktivieren. Anwendung in Default-Sprache Die Default-Sprache ist de - außer man definiert der Datenbank-Tabelle dbRun_Config mit dem ConfigKey ML_DEFAULT_LANGUAGE eine andere Default-Sprache. Wird die Anwendung in der Default-Sprache gestartet, dann arbeitet Framework Studio mit der ganz normalen Spalte der Tabelle - ohne jegliche Sonder-Logik. Die fremdsprachigen Texte können nicht beeinflusst werden. Ändert man einen Text, dann bleiben die ggf. existierenden Übersetzungen unverändert erhalten. Bei Bedarf müsste man die Anwendung anschließend in den Fremdsprachen starten und den gewünschten Text dort ebenfalls anpassen. Anwendung in Fremdsprache Startet man die Anwendung mit einer Fremdsprache, dann greifen besondere Mechanismen. Die entsprechenden Component-Properties behandeln dann ausschließlich den fremdsprachigen Text mit einem Fallback auf die Default-Sprache. Die ML-Column-Logik wird von den ganz normalen Component-Properties behandelt. Dadurch wirkt sie sich automatisch auf alle Bereiche der Anwendung aus - inkl. Form-Databinding und Reporting. Load: Beim Zugriff auf das entsprechende Component-Property wird der Text aus der Tabelle dbRun_MLStrings gelesen. Existiert dort kein Eintrag, wird der Text der Default-Sprache aus der normalen Tabellen-Spalte verwendet. Update: Wird der Text geändert, dann wird der Eintrag in der entsprechenden Fremdsprache überschrieben. Der Text in der Default-Sprache kann nicht verändert werden. Wird der fremdsprachige Text geleert, dann wird beim Save der Component der Eintrag aus der Übersetzungs-Tabelle gelöscht und das Component-Property fällt auf die Default-Sprache zurück. Insert: Beim Anlegen eines neuen Datensatzes wird der eingegebene Text sowohl in der normalen Tabelle als auch in der Fremdsprache gespeichert. Delete: Wird der Datensatz aus der Datenbank gelöscht, dann werden auch alle zu dieser FSROWID gespeicherten Texte aus der Übersetzungs-Tabelle gelöscht. Such-Funktion Note Dieses Feature muss in der Datenbank-Tabelle dbRun_Config mit dem ConfigKey ML_SEARCH_ENABLED aktiviert werden. Bei automatischen Suchfeldern werden die Fremdsprachen-Texte zusätzlich berücksichtigt. Wird die Anwendung in einer Fremdsprache ausgeführt, dann enthält die erzeugte SQL-Bedingung beinhaltet sowohl die normale Bedingung, welche den Treffer in der Default-Sprache sucht als auch einen Lookup auf die Texte in der entsprechenden Fremdsprache. -- Beipiel: Select [....] FROM Tabelle WHERE (Spalte LIKE 'abc%' OR EXISTS (SELECT 1 FROM dbRun_MLStrings WHERE ML_TableName = 'TABELLE' AND ML_ColumnName = 'SPALTE' AND ML_Iso = 'en' AND ML_FSROWID = FSROWID AND ML_SearchText LIKE 'abc%')) Note Der Lookup berücksichtigt die ersten 200 Zeichen des Textes. Die Fremdsprachen-Texte können auch Langtexte speichern. Diese lassen sich nicht indizieren. Aus Performance-Gründen erfolgt der Lookup über eine separate indiziere Spalte ML_SearchText. Diese wird (wenn das Feature aktiviert ist) von der Anwendung zusammen mit dem Langtext gespeichert. Sprache zur Laufzeit ändern Die Sprache ist mit dem Start der Anwendung an Global.SelectedLanguage festgelegt. Wird für einen bestimmten Code eine abweichende Sprache benötigt, dann kann dies über Global.UseMLColumnLanguage geschehen. Während der übergebenen Action kann so ein abweichender Iso-Code gesetzt werden. Über das Property Global.MLColumnLanguage kann die aktuell gültige Sprache ermittelt werden. this.Global.UseMLColumnLanguage(\"fr\", () => { // Erzeugen des Reports in französischer Sprache. }); Important Diese Funktion beeinflusst nicht die in der Oberfläche angezeigten Daten. Es gibt keine Möglichkeit dauerhaft auf die Sprache Einfluss zu nehmen. Tips für Entwickler Finden von MLColumns Wird eine DBColumn als MLColumn gekennzeichnet wird dafür der folgende Code generiert: public class Package_FSColumnName : FS.Demo.MDT.ArticleName { public Package_FSColumnName() { this.m_IsMLColumn = true; } } Dadurch können alle MLColumns mit dem Text this.m_IsMLColumn = true; über die Code-Suche gefunden werden. Dabei die Suche auf die DBTables einschränken."
  },
  "doc/documentation/chapter-tree.html": {
    "href": "doc/documentation/chapter-tree.html",
    "title": "Chapter Tree",
    "keywords": "Chapter Tree Allgemein Der Chapter Tree ist die zentrale Instanz, welche alle Form- und Documentation-Elemente in Kapitel organisiert. Zu erreichen ist der Chapter Tree über das Menü Tools -> Documentation -> Chapter Tree. Ein Form- oder Documentation-Element spiegelt in einer exportierten Dokumentation genau ein Kapitel mit eigener Kapitelnummer wider. Chapter Tree für die Organisation der Kapitel: Es gibt zwei Abschnitte im Chapter Tree. Der Documentation (Preparation)-Knoten beinhaltet alle Formulare und Documentation-Elemente, die in einer Anwendung neu hinzugekommen oder noch nicht in die Dokumentation eingebunden wurden. Sie werden alphabetisch aufsteigend aufgelistet. Der Documentation (Release)-Knoten spiegelt den Kapitelbaum der Dokumentation wieder, die mit dem Export Wizard gerendert werden kann. Als Text wird die im Dokumentations-Editor angegebene Caption des Formulars oder Documentation-Elements angezeigt. Ist diese nicht definiert wird in Klammern hinter dem Namen des Formulars oder Documentation-Elements der Zusatz “caption not set” angezeigt. Die Form- oder Documentation-Elemente können aus dem Chapter Tree mit einem Doppelklick auf den Knoten oder mit der Entertaste direkt geöffnet werden. Die Textbox am unteren Rand zeigt den vollen Namespace des aktuell ausgewählten Knoten an. Kapitelstruktur Wird die Dokumentation wie in der Abbildung mit dem Export Wizard in eine Word-Datei exportiert, folgt die Kapitelnummerierung der Ebene des Documentation (Release)-Knotens. Wie im Beispiel zu sehen hätten die folgenden Kapitel die angegebenen Kapitelnummern: Einführung in das Programm eNVenta = 1. eNVenta ERP = 2. Initialisierung = 5. eNVenta Init = 5.1 Da Word bis zu 9 Ebenen unterstützt, können auch im Chapter Tree die Formulare und Documentation-Elemente in bis zu 9 Ebenen (x.x.x.x.x.x.x.x.x) verschachtelt werden. Um ein Kapitel an eine andere Stelle einzufügen bzw. ein Kapitel aus dem Preparation- in den Release-Knoten zu verschieben, muss nur der entsprechende Knoten per Drag&Drop an die richtige Position gezogen werden. Sind nicht alle beteiligten Elemente im Framework Studio ausgecheckt, wird eine entsprechende Meldung angezeigt. Auschecken von beteiligten Elementen: Im Beispiel wurde der Knoten CSV Format Konversion aus dem Preparation-Knoten in den Release-Bereich unter das Kapitel eNVenta ERP -> Wv-Übersicht gezogen. Keines der Elemente war zu diesem Zeitpunkt ausgecheckt."
  },
  "doc/documentation/control-features.html": {
    "href": "doc/documentation/control-features.html",
    "title": "Control Features",
    "keywords": "Control Features Es gibt einige Einstellungen, die speziell an Controls verfügbar sind. Manche dieser Einstellungen sind an allen Controls verfügbar, andere wiederum nur an Controls eines bestimmten Typs. Wenn ein Control im Designer ausgewählt ist, sind alle verfügbaren Einstellungen unter der Kategorie Documentation zu finden. Alle Controls Documentation Öffnet den Dokumentations-Editor (siehe Editor) HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. TabbedWindow ChaptersForTabs Gibt an, ob die Registerkarten des TabbedWindow als eigenständige Kapitel in die Dokumentation gerendert werden sollen. Dieser Schalter ist nur für TabbedWindows auf oberster Ebene vorgesehen. Er zieht also nicht für TabbedWindows, die z.B. in einem Panel verschachtelt sind. ImageButton ShowImageInDocumentation Gibt an, ob das am Control hinterlegte Bild in die Control-Überschrift in der Dokumentation gerendert werden soll oder nicht."
  },
  "doc/documentation/customizing.html": {
    "href": "doc/documentation/customizing.html",
    "title": "Customizing",
    "keywords": "Customizing Sections sind nur in Dokumentationen von Forms und Documentation-Elementen verfügbar und dienen dazu, längere Texte in Abschnitte zu unterteilen, die in Customizations dieser Elemente ausgetauscht oder ergänzt werden können. Beispiel: Eine Dokumentation eines Forms in Package P1 sieht wie folgt aus: Es ist zu sehen, dass der Text in zwei Sections unterteilt ist, die jeweils mit einer einmaligen ID ausgestattet sind. Wird dieses Form nun in einem Package P2 gecustomized und an der Funktion des Forms Änderungen vorgenommen, die danach nicht mehr mit der Dokumentation aus der Basis übereinstimmen, muss die Dokumentation der Customization ebenfalls angepasst werden. Meistens ist es jedoch der Fall, dass nur einzelne Teile oder nur wenige Sätze aus der bisherigen Dokumentation geändert werden müssen, um die Dokumentation zu korrigieren. Im konkreten Beispiel könnte im gecustomizten Form die Möglichkeit geschaffen worden sein, Auftragspositionen auch kopieren zu können. Diese Information sollte nun in die Dokumentation des neuen gecustomizten Forms eingefügt werden. Praktisch wäre natürlich eine Ergänzung nach dem ersten Satz „…editiert oder gelöscht werden.“. Während in einem einzelnen Package die Sections funktionslos sind, stellen sie beim Customizing von Forms oder Documentation-Elementen einen Einsprungpunkt für zusätzliche Dokumentationen bereit. Um die zusätzliche Information in die Dokumentation einzufügen, muss im gecustomizten Form eine neue Section über den Button in der Werkzeugleiste erstellt werden: Customizing einer Section: Framework Studio erkennt, dass das Form gecustomized wurde und listet in der Combobox Base Section alle in der Basis verfügbaren Section-ID’s auf. Über das Panel Other des Editors kann zur Kontrolle der zu editierenden Section(-ID) die Basis-Dokumentation des Formulars angezeigt werden. Im Dialog für die Section-Auswahl gibt es drei Möglichkeiten, eine Section zu überschreiben: Override Die Section aus der Basis wird durch den neuen Text ersetzt. Before Der neue Text wird beim Rendern der Dokumentation des gecustomizten Formulars vor dem Text aus der Basis eingefügt. After Der neue Text wird beim Rendern der Dokumentation des gecustomizten Formulars nach dem Text aus der Basis eingefügt. Wird der Dialog geschlossen, wird eine neue Section erstellt, die ein customize-Attribut beinhaltet, in der die ausgewählte Customizing-Methode steht. Die zusätzliche Information (Auftragspositionen können kopiert werden) kann nun eingegeben werden. Wird eine Vorschau der Dokumentation gerendert, erscheint der neue Text an der gewünschten Stelle in der Basis-Dokumentation (in diesem Fall hinter dem ersten Satz aus der Basis)."
  },
  "doc/documentation/doc2help.html": {
    "href": "doc/documentation/doc2help.html",
    "title": "Doc2Help",
    "keywords": "Doc2Help Important Da Framework Studio mittlerweile auch selbst in der Lage ist, mittels des HTML-Exports (HTML) komplette Online-Hilfen zu generieren, sollte diese Möglichkeit verwendet werden, da Doc2Help Größenbeschränkungen hat, die bei sehr umfangreichen Dokumentationen ggf. zu Fehlern führen können. Doc2Help ist eine Anwendung der Firma ComponentOne, die in der Lage ist, aus Word-Dateien Onlinehilfen in HTML zu generieren. Um normale docx-Dateien jedoch mit Doc2Help verarbeiten zu können, müssen einige Vorkehrungen getroffen werden. Framework Studio bietet die Möglichkeit, mit der Option Doc2Help in den Wizard-Optionen eben diese Vorkehrungen automatisch zu treffen. Um z.B. in einer von Doc2Help generierten Onlinehilfe über einen Url-Parameter ein bestimmtes Kapitel aufzurufen, muss an jede Überschrift in Word eine besondere Formatvorlage eingebunden werden und ein Parameter mit dem Namen asciiname definiert werden. Parameter am Kapitel für Doc2Help: Wird eine Dokumentation über den Export Wizard erstellt und die Option Doc2Help aktiviert ist, sind keine weiteren Anpassungen an der Word-Datei nötig. Die Dokumentation kann in Doc2Help importiert und sofort in eine Onlinehilfe konvertiert werden."
  },
  "doc/documentation/docml.html": {
    "href": "doc/documentation/docml.html",
    "title": "DocML",
    "keywords": "DocML Bei einer Dokumentation in Textform bedarf es grundsätzlich der Möglichkeit, den Text zu formatieren und zu strukturieren. Für diesen Zweck bedient sich Framework Studio der eigens entwickelten Dokumentationssprache DocML. Ein Vorteil dieser Sprache ist, dass sie in beliebige andere Formate konvertiert werden kann. So ist die Vorschau einer Dokumentation in Framework Studio z.B. in Form von HTML realisiert. Es besteht aber auch die Möglichkeit, die gesamte Dokumentation als Worddatei zu exportieren. Um einen ersten Eindruck der Sprache zu bekommen folgt ein kurzer Auszug einer Dokumentation eines Formulars: Und hier die Ausgabe im Preview-Fenster in Framework Studio (HTML): Aufbau der Sprache Die Sprache DocML besteht weitestgehend aus dem Text, welcher die Dokumentation widerspiegelt sowie Tags, die mit Attributen versehen sein können, um den beinhaltenden Text zu formatieren oder zu strukturieren. Tags Ein Tag definiert sich durch eine öffnende eckige Klammer [, einem Bezeichner (um welches Tag es sich handelt), gefolgt von einer schließenden eckigen Klammer ]: [ + Bezeichner + ] Beispiele: [b], [tbl], [f], [ac] Dabei wird zwischen öffnenden und schließenden Tags unterschieden. Das schließende Tag beinhaltet nach der öffnenden Klammer einen Schrägstrich /: [/ + Bezeichner + ] Beispiele: [/b], [/tbl], [/f], [/ac] Angewendet wird ein Tag immer auf den Text, der zwischen dem öffnenden und schließenden Tag steht: [b] Dies ist ein fett gedruckter Text [/b] Tags können ineinander geschachtelt werden um mehrere Formatierungen auf einen Textabschnitt vorzunehmen: [b][i] Dies ist ein fett gedruckter und kursiver Text [/i][/b] Es ist zu beachten, dass öffnende Tags genau in der umgekehrten Reihenfolge geschlossen werden müssen. Folgende Beispiele sind korrekt: [b][i]Ein Text[/i][/b] [i][b] Ein Text [/b][/i] [b][i][u] Ein Text [/u][/i][/b] Folgende Beispiele sind nicht korrekt: [b][i]Ein Text[/b][/i] [i][b] Ein Text [/i][/b] [b][i][u] Ein Text [/b][/u][/i] Eine komplette Auflistung aller verfügbaren Tags in DocML und deren Funktion findet sich im Kapitel Tag Reference. Leere Tags Eine besondere Untergruppe der Tags bilden die leeren Tags. Dies sind öffnende und schließende Tags in einem. Leere Tags können keinen Text oder andere Tags beinhalten. Leere Tags definieren sich durch eine öffnende eckige Klammer [, den Bezeichner, einen Schrägstrich / und die schließende eckige Klammer ]: [ + Bezeichner + / + ] Beispiele: [screenshot/], [img/], [br/] Diese leeren Tags dienen z.B. dem Einfügen eines Bildes oder Zeilenumbruch in die Dokumentation. Tag-Attribute Die meisten Tags können in ihrem Verhalten durch Attribute gesteuert werden. Ein Attribut definiert sich durch einen Bezeichner gefolgt, von einem Gleichheitszeichen = sowie dem Attributwert in Hochkommas. Attribute können in öffnenden und leeren Tags vorkommen: In öffnendem Tag: [f bg=\"ff0000\" ]Text mit roter Hintergrundfarbe[/f] In leerem Tag: [screenshot caption=\"Auftragserfassung\" /] Im Kapitel Tag Reference ist ausführlich beschrieben, welcher Tag mit welchen Attributen gesteuert werden kann. Tag Reference Nachfolgend werden alle verfügbaren Tags und die zugehörigen Attribute der DocML-Sprache beschrieben. Die Tags unterscheiden sich in zwei Klassen, Inline-Tags und Block-Tags . Inline-Tags werden meist für Formatierungszwecke genutzt wie z.B. Fettschrift oder Textfarbe, während Block-Tags Strukturen wie Tabellen, Listen oder Abschnitte definieren. Warning Grundsätzlich gilt: Inline-Tags können keine Block-Tags beinhalten Inline-Tags Font Eigenschaften: Bezeichner: [f] Leeres Tag: nein Funktion: Wendet Schriftart, Schriftgröße, Schriftfarbe und Hintergrundfarbe auf den beinhaltenden Text an Attributes: Bez. Benötigt Mögliche Werte Funktion style nein Normal, Code Stellt die Schriftart zwischen Arial und einer Code-Schriftart um size nein XXXL, XXL, XL, L, Normal, S, XS, XXS oder XXXS Schriftgröße fc nein Systemfarben wie red, black, blue oder Farbangaben in HEX wie z.B. #FF00000 Textfarbe bc nein Systemfarben wie red, black, blue oder Farbangaben in HEX wie z.B. #FF00000 Hintergrundfarbe Beispiel: [f style=\"code\" size=\"xl\" fc=\"red\" bc=\"#00ff00\"]Möglichkeiten des Font-Tags[/f] Bold Eigenschaften: Bezeichner: [b] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als fett geschrieben Attributes: Keine Beispiel: [b]Dieser Text ist fett geschrieben[/b] Italic Eigenschaften: Bezeichner: [i] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als kursiv geschrieben Attributes: Keine Beispiel: [i]Dieser Text ist kursiv geschrieben[/i] Underline Eigenschaften: Bezeichner: [u] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als unterstrichen Attributes: Keine Beispiel: [u]Dieser Text ist unterstrichen[/u] Strikethrough Eigenschaften: Bezeichner: [s] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als durchstrichen Attributes: Keine Beispiel: [s]Dieser Text ist durchstrichen[/s] Subscript Eigenschaften: Bezeichner: [sub] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als tiefgestellt Attributes: Keine Beispiel: [sub]Dieser Text ist tiefgestellt[/sub] Superscript Eigenschaften: Bezeichner: [sup] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als hochgestellt Attributes: Keine Beispiel: [sup]Dieser Text ist hochgestellt[/sup] Align Left Eigenschaften: Bezeichner: [al] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als linksbündig Attributes: Keine Beispiel: [al]Dieser Text ist linksbündig[/al] Center Eigenschaften: Bezeichner: [ac] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als zentriert Attributes: Keine Beispiel: [ac]Dieser Text ist zentriert[/ac] Align Right Eigenschaften: Bezeichner: [ar] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als rechtsbündig Attributes: Keine Beispiel: [ar]Dieser Text ist rechtsbündig[/ar] Justify Eigenschaften: Bezeichner: [aj] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als Blocksatz Attributes: Keine Beispiel: [aj]Dieser Text ist im Blocksatz geschrieben[/aj] Image Eigenschaften: Bezeichner: [img] Leeres Tag: ja Funktion: Bindet eine Bildressource aus Framework Studio in die Dokumentation ein Besonderheiten: Wird nur das width- oder height-Attribut angegeben, wird das Seitenverhältnis des Bildes beibehalten. Wird das inline-Attribut mit dem Wert true gesetzt, jedoch keine Größenangabe gemacht, dann wird die Bildgröße automatisch anhand der Schriftgröße skaliert. Ohne inline-Attribut wird das Bild in Originalgröße ausgegeben. Eine Bildbezeichnung (caption-Attribut) kann nur definiert werden, wenn das inline-Attribut nicht definiert ist oder den Wert false hat. Attributes: Bez. Benötigt Mögliche Werte Funktion src ja ID einer Framework Studio Bildressource Verweist auf das Bild, welches in der Framework Studio Resource eingebunden ist width nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Breite des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“) height nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Höhe des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. height=“4.7in“) caption nein Text Bildbezeichnung inline nein true, false Wenn true wird das Bild wird ein Textzeichen im Textfluss behandelt, sonst wird eine neue Zeile eingefügt Beispiel: [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" height=\"1.5cm\" inline=\"true\"/] [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" caption=“Beispielbild“/] [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" width=“3cm“ height=\"1.5cm\" caption=“Test“/] Screenshot Eigenschaften: Bezeichner: [screenshot] Leeres Tag: ja Funktion: Bindet einen automatisch generierten Screenshot des Forms als Bild in die Dokumentation ein. Besonderheiten: Kann nur in Form-Dokumentationen verwendet werden. Werden keine Größenangaben gemacht, wird die Größe des Forms verwendet. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Breite des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“) caption nein Text Bezeichnung des Screenshots Beispiel: [screenshot/] [screenshot width=\"17cm\"/] [screenshot width=\"14.3in\" caption=\"Kostenrechnung\"/] Link Eigenschaften: Bezeichner: [lnk] Leeres Tag: ja Funktion: Erstellt einen Querverweis auf ein anderes Kapitel oder einen Hyperlink auf eine Url. Attributes: Bez. Benötigt Mögliche Werte Funktion src ja • ID eines Forms oder Documentation-Elements • Url mit führendem http:// Querverweis in der fertigen Dokumentation oder Hyperlink auf die angegebene Url text ja Text Der angezeigte Text des Links Beispiel: [lnk src=\"f037492b790d24c5b9f16cb4120465e25\" text=\"Artikeldetails\"/] [lnk src=\"http://www.google.de/\" text=\"Suchen mit Google\"/] Index Entry Eigenschaften: Bezeichner: [idx] Leeres Tag: ja Funktion: Erstellt einen Eintrag im Index der Dokumentation. Attributes: Bez. Benötigt Mögliche Werte Funktion entry ja text Definiert einen Haupteintrag im Index subentry nein Text Definiert einen Untereintrag unter dem Haupteintrag Beispiel: [idx entry=\"Haupteintrag\"/] [idx entry=\"Haupteintrag\" subentry=\"Untereintrag\"/] Base Eigenschaften: Bezeichner: [base] Leeres Tag: ja Funktion: Bindet die Basis-Dokumentation eines Controls, Component Properties, einer DBColumn oder eines Metadatentyps ein. Besonderheiten: Wird nur an Control, Component Property, DBColumn und Metadatentyp unterstützt. Mehr Information in den Kapiteln Vererbung und Customizing. Attributes: Keine Beispiel: [idx entry=\"Haupteintrag\"/] [idx entry=\"Haupteintrag\" subentry=\"Untereintrag\"/] Line Eigenschaften: Bezeichner: [line] Leeres Tag: ja Funktion: Erstellt eine Line als Absatztrenner über die komplette Seitenbreite. Attributes: Keine Beispiel: [line/] Break Eigenschaften: Bezeichner: [br] Leeres Tag: ja Funktion: Erstellt einen Zeilenumbruch. Attributes: Keine Beispiel: [br/] Block-Tags Section Eigenschaften: Bezeichner: [section] Leeres Tag: optional Funktion: Definiert einen Textabschnitt in einer Form-Dokumentation oder einem Documentation-Element, der durch die angegebene ID customizing-fähig ist. Siehe Customizing. Besonderheiten: Kann sich nur auf oberster Ebene und somit nicht in anderen Tags befinden. Wird nur in Form- und Documentation-Elementen unterstützt. Attributes: Bez. Benötigt Mögliche Werte Funktion id ja 32-stellige GUID Eindeutige ID des Textabschnitts customize Im Custom-Package before, after, override Überschreibungsart der gecustomizten Section Beispiel: [section id=“ f0bcfd1621444f6f9f24bc9305120809“/] [section id=“ f0bcfd1621444f6f9f24bc9305120809“ customize=“after“/] List Eigenschaften: Bezeichner: [lst] Leeres Tag: nein Funktion: Erstellt eine geordnete oder ungeordnete Liste von ListItems (li-Tags). Besonderheiten: Kann nur li-Tags beinhalten. Das Symbol kann nur definiert werden, wenn das type-Attribut als „unordered“ definiert ist. Attributes: Bez. Benötigt Mögliche Werte Funktion type ja ordered, unordered Definiert den Listentyp symbol nein disk, circle, square Definiert das Listensymbol bei ungeordneten Listen Beispiel: [lst type=\"unordered\" symbol=\"square\"] [li]ListItem 1[/li] [li]ListItem 2[/li] [li]ListItem 3[/li] [/lst] [lst type=\"ordered\"] [li]ListItem 1[/li] [li]ListItem 2[/li] [li]ListItem 3[/li] [/lst] ListItem Eigenschaften: Bezeichner: [li] Leeres Tag: nein Funktion: Erstellt einen Eintrag in einer Liste. Besonderheiten: Kann nur innerhalb von lst-Tags verwendet werden. Attributes: Keine Beispiel: [lst type=\"unordered\" symbol=\"square\"] [li]Ein ListItem[/li] [li]Noch ein ListItem[/li] [/lst] Table Eigenschaften: Bezeichner: [tbl] Leeres Tag: nein Funktion: Erstellt eine Tabelle. Besonderheiten: Die Breite der Tabelle kann absolut als auch prozentual angegeben werden. Wird keine Breite angegeben, definiert sich die Tabellenbreite über die Summe der Spaltenbreiten. Ist die Tabellenbreite in Prozent angegeben, müssen auch die Spaltenbreiten in Prozent angegeben werden. Ist keine Tabellenbreite angegeben, müssen die Spaltenbreiten in absoluten Werten angegeben werden. Eine Tabelle muss eine Spaltendefinition (coldef-Tag) inkl. Spalten (col-Tags) sowie mindestens eine Zeile (row-Tag) beinhalten. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein • Absolute Angaben wie z.B. „2.3cm“, „3.3in“, „14,34cm“ • Prozentuale Angaben wie z.B. „50%“, „75%“ Breite der Tabelle. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“). Die prozentuale Angabe bezieht sich auf die Seitenbreite bzw. die Fensterbreite im HTML fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. Beispiel: Ausgabe: Column Definition Eigenschaften: Bezeichner: [coldef] Leeres Tag: nein Funktion: Beinhaltet die Spaltendefinition einer Tabelle. Besonderheiten: Muss ein oder mehrere Spalten (col-Tags) beinhalten. Kann nur innerhalb eines tbl-Tags vorkommen. Kann innerhalb eines tbl-Tags nur einmal vorkommen. Kann nur col-Tags beinhalten. Muss innerhalb des tbl-Tags als erstes auftreten (vor jeglichen Zeilendefinitionen bzw. row-Tags). Attributes: Keine Beispiel: [coldef] [col width=\"50%\"/] [col width=\"50%\" fc=\"#ddee32\" bc=\"#dd3331\" align=\"right\"/] [/coldef] Column Eigenschaften: Bezeichner: [col] Leeres Tag: ja Funktion: Definiert eine Spalte innerhalb einer Tabelle. Besonderheiten: Kann nur innerhalb eines coldef-Tags vorkommen. Die Breite der Spalte kann absolut oder prozentual angegeben werden. Ist die Tabellenbreite (im tbl-Tag) prozentual angegeben, muss die Spaltenbreite ebenfalls prozentual angegeben werden. Ist keine Tabellenbreite (im tbl-Tag) angegeben, muss die Spaltenbreite absolut angegeben werden. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein • Absolute Angaben wie z.B. „2.3cm“, „3.3in“, „14,34cm“ • Prozentuale Angaben wie z.B. „50%“, „75%“ Breite der Tabelle. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“). Die prozentuale Angabe bezieht sich auf die Seitenbreite bzw. die Fensterbreite im HTML fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. align nein left, center, right Horizontale Ausrichtung der Spalte. Kann durch das colalign-Attribut an der Zelle überschrieben werden. Beispiel: [col width=\"4.5cm\"/] [col width=\"50%\" fc=\"#ddee32\" bc=\"#dd3331\" align=\"right\"/] Row Eigenschaften: Bezeichner: [row] Leeres Tag: nein Funktion: Definiert eine Zeile innerhalb einer Tabelle. Besonderheiten: Kann nur innerhalb eines tbl-Tags vorkommen. Muss innerhalb des tbl-Tags unterhalb des coldef-Tags stehen. Kann nur cell-Tags beinhalten. Attributes: Bez. Benötigt Mögliche Werte Funktion fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. align nein top, middle, bottom Vertikale Ausrichtung der Zeile. Kann durch das rowalign-Attribut an der Zelle überschrieben werden. Beispiel: [row fc=“#ddee43“] [cell]Zelle links oben[/cell] [cell rowalign=“top“]Zelle rechts oben[/cell] [/row] [row fc=\"GreenYellow\" bc=\"Linen\" align=\"bottom\"] [cell]Zelle links unten[/cell] [cell bc=\"black\" colalign=\"left\" rowalign=\"middle\"]Zelle rechts unten[/cell] [/row] Cell Eigenschaften: Bezeichner: [cell] Leeres Tag: nein Funktion: Definiert eine Zelle innerhalb einer Zeile. Besonderheiten: Kann nur innerhalb eines row-Tags vorkommen. Muss innerhalb eines row-Tags genauso oft vorkommen wie die Anzahl der Spalten im coldef-Tag der Tabelle. Attributes: Bez. Benötigt Mögliche Werte Funktion fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. rowalign nein top, middle, bottom Vertikale Ausrichtung der Zelle. colalign nein left, center, right Horizontale Ausrichtung der Zelle. Beispiel: [row fc=“#ddee43“] [cell fc=“#3434ee“]Zelle links oben[/cell] [cell colalign=“center“]Zelle rechts oben[/cell] [/row] [row fc=\"GreenYellow\" bc=\"Linen\" align=\"bottom\"] [cell]Zelle links unten[/cell] [cell bc=\"black\" colalign=\"left\" rowalign=\"middle\"]Zelle rechts unten[/cell] [/row] Headline Eigenschaften: Bezeichner: [h1] Leeres Tag: nein Funktion: Erstellt eine Überschrift. Besonderheiten: Es gibt drei verschiedene Headline-Tags h1, h2 und h3. Headline-Tags können nicht in anderen Headline-Tags eingefügt werden. In Headline-Tags können [i], [u] und [s] Format-Tags benutzt werden. Attributes: Keine Beispiel: [h1]Überschrift h1[/h1] [h2]Überschrift h2[/h2] [h3]Überschrift h3[/h3] [h3]Überschrift [i]h3[/i][/h3] [h2]Überschrift [s]h2[/s][/h2]"
  },
  "doc/documentation/dokumentations-system.html": {
    "href": "doc/documentation/dokumentations-system.html",
    "title": "Dokumentations-System",
    "keywords": "Dokumentations-System Framework Studio bietet die Möglichkeit, die entwickelten Applikationen mittels eines in die IDE integrierten Dokumentationssystems zu dokumentieren. Im Gegensatz zu herkömmlichen Dokumentationen mittels Microsoft Word oder Latex bietet das System jedoch gravierende Vorteile, da es komplett an die Datenstruktur und –hierarchie von Framework Studio angepasst ist. Features Um den Einstieg in das Dokumentationssystem zu vereinfachen, werden im Folgenden die wichtigsten Features vorgestellt. Automatische Generierung der Dokumentationsstruktur „Wo steht was?“ ist ein großes Problem im Bereich Dokumentation. Ein Mitarbeiter beschreibt erst die Steuerelemente des Formulars und danach dessen Funktionalität, ein anderer macht es genau anders herum. Framework Studio trennt sich vom klassischen Weg der Dokumentationserstellung. Egal, ob die Dokumentation später als Word oder HTML exportiert wird, die Struktur bleibt dieselbe. Jedes Formular folgt dem gleichen Schema, alles hat seinen zugewiesenen Platz durch vordefinierte Formatvorlagen seitens Framework Studio. Vererbung vom Metadatentyp bis zum Steuerelement Hinter fast jedem Steuerelement in Framework Studio verbirgt sich als DataSource ein Component Property, eine DBColumn oder ein Metadatentyp. Hier verhält sich die Dokumentation ähnlich wie die Tooltips. Wird ein Metadatentyp dokumentiert, steht diese Dokumentation auch am Steuerelement zur Verfügung und wird in die endgültige Fassung herausgerendert. Dokumentationen können vererbt, gecustomized und überschrieben werden, sollte sich z.B. der Kontext in einem Formular ändern. Customizing und Package-Struktur Das Herz von Framework Studio bildet das Package-System. Das Dokumentationssystem folgt diesem und bietet voll Customizing-fähige Dokumentationen über Package-Grenzen hinweg. Vererben, überschreiben, anhängen, austauschen… die Dokumentation ist anpassbar bis zum letzten Satz. Mehrsprachigkeit Erfassen Sie die Dokumentation in allen möglichen Sprachen. Der Dokumentationseditor unterstützt das parallele Bearbeiten von mehreren Sprachen. Wenn Sie die englische Dokumentation schreiben, nehmen Sie sich einfach die deutsche Dokumentation als Vorlage für die Übersetzung zur Hand. Screenshot-Generierung Screenshot erstellen, in das Grafikprogramm laden, den Ausschnitt zurechtschneiden, Screenshot in das Dokument einfügen, Größe anpassen… und nach einer Woche ist der Screenshot veraltet, weil drei neue Steuerelemente hinzugekommen sind. Um dieses Problem aus dem Weg zu schaffen, bietet das Dokumentationssystem eine Screenshot-Generierung für Formulare. Bei jedem Herausschreiben der Dokumentation wird von Framework Studio anhand der Steuerelementdaten des Designers ein Screenshot des Formulars erstellt und automatisch in die Dokumentation eingefügt. So sind die Masken in der Dokumentation stets auf dem neuesten Stand und der Benutzer findet jedes Steuerelement wo er es erwartet. Theme Support In Framework Studio 3.5 hielten Themes Einzug in die IDE. Die Dokumentation lässt sich für verschiedene Themes rendern. Sind beispielsweise automatisch generierte Screenshots in die Dokumentation eingebunden, werden diese im jeweiligen Theme gerendert. Auch für eingebundene Bilder können je Theme unterschiedliche Bilder definiert werden. Aufbau des Dokumentationssystems Die beiden Elemente, die das Fundament des Dokumentationssystems bilden, sind das Form- und das Documentation-Element (siehe Documentation-Element). Diese Elemente werden mittels einer Baumstruktur (siehe Chapter Tree) in Kapitel unterteilt. Somit bildet jedes Form- oder Documentation-Element ein Kapitel mit eigener Kapitelnummer in der fertigen Dokumentation ab. Form Sie erkennen Form an einem -Icon. Elemente des Forms mit Dokumentation: Ein Form definiert sich grundsätzlich durch dessen Controls. Jedes Control kann eine DataSource zugewiesen haben, die über ein Component Property auf eine DBColumn verweist, die wiederum einen Wert eines Metadatatypes kapseln kann. Diesem Mechanismus folgt das Dokumentationssystem. Es besteht die Möglichkeit, auf jeder einzelnen Ebene in Framework Studio eine Dokumentation zu hinterlegen, die von der nächst höheren Instanz verwendet werden kann (siehe Vererbung). So können am Metadatentyp z.B. Informationen zum Wertebereich oder zur Genauigkeit angegeben werden. In der Dokumentation des Controls, welches auf diesen Metadatentyp verweist, kann z.B. die Dokumentation des Metadatentyps eingebunden werden und steht dem Leser somit als zusätzliche Information zur Verfügung. Während in der Dokumentation eines Controls ausschließlich auf die Funktion dessen eingegangen werden sollte, dient die Dokumentation des Formulars der generellen Beschreibung, d.h. es können beliebige Texte verfasst werden, die die Funktionalität des Formulars im Gesamten beschreibt. So können Beispiele, Prozesse, Arbeitsanweisungen usw. beschrieben werden. Im Gegensatz zu den Control-Dokumentationen werden Form-Dokumentationen in sogenannte Sections unterteilt. Diese dienen als Text-Trenner für das Customizing (siehe Customizing). Documentation-Element Sie erkennen Documentation-Element an einem -Icon. Die meisten Dokumentationen einer Anwendung beziehen sich auf ein oder mehrere Formulare. Oft muss aber auch ein Hintergrundprozess wie z.B. eine Preisfindung oder ein Importvorgang dokumentiert werden, für den es keine visuelle Repräsentation gibt. Für diesen Zweck bietet Frameworks Studio die Documentation-Elemente. Sie sind eigenständige Elemente wie Forms, Workflows oder Components und können wie diese ein- und ausgecheckt werden. Documentation-Elemente im Namespace TreeView: Die Documentation-Elemente bestehen nur aus einem einzigen Dokumentationseditor. Wie Forms bildet jedes Documentation-Element in der fertigen Dokumentation ein eigenes Kapitel mit eigener Kapitelnummer ab. Anwendungsfall für ein Documentation-Element: Wenn auf einem Formular ein Button existiert, welcher z.B. den Preis eines Artikels anhand eingegebener Konditionen berechnet, könnte der Kalkulationsprozess dokumentiert werden. Hier bietet sich ein Documentation-Element an. In diesem wird der Kalkulationsablauf im Detail beschrieben, ohne Bezug auf das Formular oder den Button, von dem der Prozess ausgelöst wird. In der Dokumentation des Button-Controls kann nun ein Verweis auf das Documentation-Element eingefügt werden, welcher in der fertigen Dokumentation als Hyperlink verfügbar ist. Der große Vorteil ist: Sollte in einem anderen Programmteil derselbe Kalkulationsprozess aufgerufen werden, müsste dort nur auf das bereits existierende Documentation-Element verwiesen werden, ganz nach dem Motto „write once, read anywhere“."
  },
  "doc/documentation/editor.html": {
    "href": "doc/documentation/editor.html",
    "title": "Editor",
    "keywords": "Editor *Dokumentations-Editor in Framework Studio Zugang zum Editor der verschiedenen Elemente Da an verschiedenen Elementen im Framework Studio dokumentiert werden kann, werden nachfolgend alle Einsprungpunkte zum Editor aufgezeigt. Documentation-Element Da das Documentation-Element keine andere Funktion hat außer Freitexte in Form von DocML zu verfassen, besteht das Hauptformular eines Documentation-Elements aus dem Editor selbst. Das Documentation-Element besteht praktisch nur aus einem Editor: Form Um ein Form zu dokumentierten, muss dieses geöffnet werden und auf die Registerkarte Documentation gewechselt werden. Zugang zum Editor über den Reiter Documentation: Form Control Controls auf einem Form werden über den Form Designer dokumentiert. Dazu muss das gewünschte Control markiert werden. Mit einem Rechtsklick auf das Control öffnet sich das Kontextmenü in dem der Menüpunkt Edit Documentation aufgeführt wird. Alternativ kann über das Property-Fenster von Framework Studio im Bereich Documentation auf den Button mit den drei Punkten geklickt werden. Der Editor öffnet sich für die Controls als modaler Dialog über dem Form Designer. Aufrufen des Editors für ein Control: Component Property Um ein Property zu dokumentieren, muss in der Component das jeweilige Property ausgewählt sein. Danach kann die Registerkarte Documentation ausgewählt werden. Dokumentation eines Properties: DBColumn Um eine Datenbankspalte zu dokumentieren, muss an der DBTable die gewünschte Spalte ausgewählt werden. Danach kann die Registerkarte Documentation ausgewählt werden. Dokumentation einer DBColumn: Metadatentyp Um einen Metadatentyp zu dokumentierten, muss dieser geöffnet werden und auf die Registerkarte Documentation gewechselt werden. Dokumentation eines Metadatatypen: Arbeiten mit dem Editor Der Dokumentationseditor ist ähnlich intuitiv bedienbar wie z.B. ein normaler Texteditor in Microsoft Word oder anderen Textverarbeitungsprogrammen. Es wird der Text markiert, auf den eine Formatierung angewendet werden soll und das jeweilige Icon in der Werkzeugleiste geklickt, um die Formatierung an- oder auszuschalten. Bei Textbausteinen wie Tabellen oder Listen wird der Cursor an die Stelle gesetzt, an der das gewünschte Element eingefügt werden soll. Rechtschreibprüfung Beim Bearbeiten eines Textes erfolgt eine automatische Rechtschreibprüfung. Als fehlerhaft erkannte Worte werden rot unterstrichen. Die Prüfung erfolgt an der angegebenen Language. Folgende Sprachen werden unterstützt: Deutsch (de) Englisch (en) Französisch (fr) Italienisch (it) Die Prüfung kann in den Options deaktivert werden. Info Panel Info Panel und Link zum Chapter Tree im Editor: Über die Radiobuttons im Info Panel kann zwischen verschiedenen Ansichten des Editors umgeschaltet werden. None: Zeigt nur den DocML-Editor für die ausgewählte Sprache. Preview: Zeigt zusätzlich zum DocML-Editor das Vorschaufenster an (wird automatisch aktiviert, wenn in der Werkzeugleiste geklickt wird). Other: Zeigt zusätzlich zum DocML-Editor einen zweiten DocML-Editor im Lesemodus an, um zeitgleich eine andere Sprache oder eine andere Dokumentation aus einem anderen Package bereitzustellen. Tooltip: Wenn eine Dokumentation an einem Control bearbeitet wird, gibt es mit diesem Radiobutton die Möglichkeit ein Panel anzuzeigen, in dem der Tooltip des aktuellen Controls bearbeitet werden kann. Wird keine Dokumentation eines Controls bearbeitet, ist dieser Radiobutton nicht sichtbar. Über den Link Open Documentation Tree kann aus jedem Editor heraus der Kapitel-Baum aufgerufen werden. Siehe Chapter Tree. Werkzeugleiste Combobox Language Hier kann die Sprache eingestellt werden, für die im Dokumentations-Editor dokumentiert werden soll. Die DocML-Scripte für die jeweiligen Sprachen sind völlig unabhängig voneinander und beeinflussen sich somit nicht gegenseitig. Textbox Caption Dieses Textfeld ist nur an Form-Dokumentationen und Documentation-Elementen verfügbar. Hier wird die Kapitelüberschrift für das fertige Dokument eingegeben. Die Kapitel werden im Chapter Tree verwaltet. Neue Section Sie erkennen Neue Section an einem -Icon. Fügt an der Stelle des Cursers im Dokumentations-Editor eine neues Section-Tag ein. Dabei wird automatisch eine neue 32-stellige GUID generiert und in das id-Attribut des Tags eingefügt. Von da an steht die Section für Customizing-Zwecke bereit. Siehe Customizing. Preview anzeigen Sie erkennen Preview anzeigen an einem -Icon. Über diesen Button wird das sich im Editor befindliche DocML in HTML konvertiert und im Preview-Panel angezeigt. Kann das DocML aufgrund von Fehlern nicht korrekt umgewandelt werden, werden die entsprechenden Fehler im Common Errors-Panel von Framework Studio aufgelistet. Syntax-Check Sie erkennen Syntax-Check an -Icons. Über diese Buttons kann das DocML auf Validität geprüft werden. Der erste Button überprüft das sich im Editor befindliche DocML für die ausgewählte Sprache. Der Button mit dem Zusatz All überprüft das DocML für alle verfügbaren Sprachen, die über die Combobox Language auswählbar sind. Bei einem Klick auf den Preview-Button wird automatisch erst eine Validierung des DocML’s für die aktuelle Sprache durchgeführt. Schriftart Sie erkennen Schriftart an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Schriftart. Um die finale Dokumentation der Anwendung möglichst homogen zu halten, stehen nur zwei Schriftarten zur Auswahl Normal: Wird in HTML und Word in Arial konvertiert Code: Wird in HTML in ein <code>-Tag geschrieben, im Word wird Courier New verwendet. Schriftgröße Sie erkennen Schriftgröße an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Schriftgröße. Die Einstellung Normal spiegelt die gängige Standardgröße 11pt in Word wider. Die Schriftgrößenangaben sind relativ gehalten, da aus DocML unterschiedliche Ausgabeformen generiert werden können (HTML, Word). Schriftfarbe Sie erkennen Schriftfarbe an -Icons. Formatiert den im Editor markierten Text in der ausgewählten Schriftfarbe. Es können die Schriftfarbe sowie die Hintergrundfarbe für den Text ausgewählt werden. Textformatierungen Sie erkennen Textformatierungen an -Icons. Umgibt den im Editor ausgewählten Text mit dem entsprechenden Formatierungstag. Zur Auswahl stehen: Fett Kursiv Unterstrichen Durchgestrichen Tiefgestellt Hochgestellt Überschriften Sie erkennen Überschriften an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Überschrift. Ausrichtung Sie erkennen Ausrichtung an -Icons. Richtet den im Editor markierten Text nach Wunsch links, mittig, rechts oder als Blocksatz aus. Die Standardeinstellung ist linksbündig. Liste Sie erkennen Liste an einem -Icon. Öffnet einen Dialog zum Erstellen einer neuen Auflistung: List Type Mit List Type wird die Art der Liste definiert. Unordered stellt eine Liste mit Symbolen dar, während Ordered die Listeneinträge aufsteigend nummeriert. List Symbol Nur verfügbar, wenn als Listentyp “Unordered” ausgewählt wurde. Es kann zwischen Disk, Circle und Square gewählt werden. List Item Count Legt die Anzahl der in der Liste befindlichen li-Tags fest. Diese können anschließend im DocML beliebig erweitert werden. Tabelle Sie erkennen Tabelle an einem -Icon. Öffnet einen Dialog zum Erstellen einer neuen Tabelle. Nach dem Klick auf das Symbol wird zunächst ein Panel angezeigt, in dem die Größe der zu konfigurierenden Tabelle ausgewählt werden muss: Wird mit dem Mauszeiger länger als eine Sekunde auf das Quadrat unten rechts gezeigt, vergrößert sich die Auswahl. Wird mit dem Mauszeiger länger als eine Sekunde auf das Quadrat oben links gezeigt, verkleinert sich die Auswahl. Nach der Auswahl der Tabellengröße wird der Dialog zum Konfigurieren der Tabelle angezeigt: Es können alle Parameter der Tabelle eingestellt werden. Dazu gehören Breite, Ausrichtung und Farbe der Tabelle, Spalten, Zeilen und Zellen. Die Werte der Tabelle können durch Spalten, Zeilen und Zellen überschrieben werden. Die Hierarchie der Überschreibungen sieht wie folgt aus: Tabelle -> Spalte -> Zeile -> Zelle Mit einem Klick auf den Button Ok werden für die konfigurierte Tabelle die entsprechenden Tags in den Editor generiert und können anschließend mit Werten befüllt werden. Bild einbinden Sie erkennen Bild einbinden an einem -Icon. Öffnet einen Dialog zum Einbinden eines Bildes in die Dokumentation. Es können nur Bildressourcen aus Framework Studio in die Dokumentation eingebunden werden. Für Bilder von der Festplatte oder aus dem Internet wird eine entsprechende Bildressource angelegt. Sollte sich beim Öffnen des Dialoges ein Bild in der Zwischenablage befinden, wird automatisch die Option From Clipboard ausgewählt. Einfügen eines Bildes in die Dokumentation: Im Bereich Image Source muss zuerst ausgewählt werden, woher das einzubindende Bild stammt. Wenn das Bild schon als Ressource im Framework Studio verfügbar ist, kann diese aus der Baumansicht (Existing Resource) ausgewählt werden. Eine Vorschau des Bildes erscheint auf der rechten Seite. Es kann auch direkt ein Bild aus dem Internet eingebunden werden (From Url). Damit das Bild in der Dokumentation angezeigt wird, wenn beim Betrachten keine Internetverbindung besteht, muss dieses mit dem Button Load geladen werden. Danach erscheint das Bild in der Vorschau. Die Url des Bildes muss mit Fehler! Linkreferenz ungültig beginnen. Soll ein Bild von der Festplatte eingebunden werden, muss zuerst der Radiobutton From File aktiviert werden. Danach kann über den Button […] ein Bild von der Festplatte gewählt werden. Bilder können auch direkt aus der Zwischenablage(From Clipboard) eingebunden werden. Im Feld Name wird der Name der neu anzulegenden Ressource angegeben. Im Bereich Attributes können die Anzeigeeigenschaften des einzubindenden Bildes verändert werden: Original Size Verwendet in der Dokumentation die ursprüngliche Größe des Bildes in cm. Unit Gibt an, welche Maßeinheit in der Dokumentation verwendet werden soll. Zur Auswahl stehen Zentimeter (cm) und Inch (in). Width Breite des Bildes. Height Höhe des Bildes (nur aktiv, wenn Keep aspect ratio deaktiviert ist). Keep aspect ratio Wenn aktiviert (Standard), wird anhand der eingegebenen Breite des Bildes, die zugehörige Höhe anhand des originalen Seitenverhältnisses berechnet. Das Bild wird somit nicht verzerrt. Inline Image Wenn aktiviert, verhält sich das Bild wie ein Schriftzeichen und folgt dem normalen Textfluss. Andernfalls wird vor und nach dem eingefügten Bild ein Zeilenumbruch generiert. Caption Nur verfügbar, wenn die Option Inline Image deaktiviert ist. Es kann eine Bildunterschrift angegeben werden. Warning Wenn das Bild aus dem Internet oder von der Festplatte eingebunden werden soll, wird nach dem Klick auf den Button Ok ein Dialog angezeigt, der darauf hinweist, dass automatisch eine Framework Studio Resource für das Bild angelegt wird. Screenshot Sie erkennen Screenshot an einem -Icon. Öffnet einen Dialog zum Einbinden eines automatisch generierten Screenshots des Formulars in die Dokumentation. Diese Funktion ist nur in der Form-Dokumentation verfügbar. Anhand der Designer-Daten wird ein Screenshot des Formulars generiert. Sollten Tabellen mehr Spalten haben, als in der Breite angezeigt werden können, werden die Spaltenköpfe umgebrochen und mehrzeilig fortgeführt. Im Bereich Attributes können die Anzeigeeigenschaften des einzubindenden Screenshots verändert werden: Original Size Verwendet in der Dokumentation die ursprüngliche Größe des Formulars in cm. Unit Gibt an, welche Maßeinheit in der Dokumentation verwendet werden soll. Zur Auswahl stehen Zentimeter (cm) und Inch (in). Width Breite des Screenshots. Height Die Höhe des Bildes wird automatisch anhand des Seitenverhältnisses des Formulars berechnet. Link Sie erkennen Link an einem -Icon. Öffnet einen Dialog zum Einfügen eines Querverweises oder eines Hyperlinks. Sollte sich beim Öffnen des Dialoges ein Link in der Zwischenablage befinden, wird dieser automatisch in das Textfeld Url eingefügt. Es kann im DocML sehr einfach auf ein anderes Kapitel (Formular oder Documentation-Element) verwiesen werden oder ein Hyperlink ins Internet bereitgestellt werden. Bei einem Querverweis auf ein Kapitel muss das entsprechende Form oder Documentation-Element in dem Textfeld Existing Documentation mithilfe von Autocomplete gesucht werden. Nach der Auswahl einer Dokumentation, wird die Caption(falls verfügbar) der ausgewählten Dokumentation, in der Sprache der Dokumentation, in die der Link eingefügt werden soll, eingefügt. Für einen Hyperlink ins Internet kann eine beliebige URL beginnend mit Fehler! Linkreferenz ungültig eingegeben werden. In der Textbox Text wird festgelegt, wie der Link in der Dokumentation angezeigt werden soll. Indexeintrag Sie erkennen Indexeintrag an einem -Icon. Öffnet einen Dialog zum Einfügen eines Indexeintrages in die Dokumentation. Im Export Wizard kann definiert werden, ob in der gerenderten Dokumentation ein Index erstellt werden soll. Kapitelüberschriften (von Forms und Documentation-Elementen) werden dem Index automatisch hinzugefügt. Über den Dialog ist es möglich, manuell einen Indexeintrag zu generieren. Dabei muss der Haupteintrag definiert werden. Optional kann ein Untereintrag angegeben werden. Basisaufruf Sie erkennen Basisaufruf an einem -Icon. Nur verfügbar in den Dokumentationen von Controls, Component Properties, DBColumns und Metadatentypen. Erstellt ein base-Tag, welches die Basisdokumentation des aktuellen Elements (Controls, Component Properties, DBColumn oder Metadatentyps) in die Dokumentation mit einbindet. Mehr Information hierzu finden Sie im Kapitel Vererbung Linie Sie erkennen Linie an einem -Icon. Erstellt an der Curser-Position im Editor ein line-Tag. Dieses generiert in der Dokumentation eine schwarze Linie über die gesamte Seitenbreite mit anschließendem Zeilenumbruch. Zeilenumbruch Das br-Tag ist sicherlich das am häufigsten verwendete Tag in einer Dokumentation in DocML. Es wäre sehr umständlich, wenn jedes Mal, wenn ein Zeilenumbruch in der Dokumentation eingefügt werden soll, ein Button in der Werkzeugleiste geklickt werden müsste. Dies würde den Schreibfluss mit der Tastatur erheblich behindern. Um ein br-Tag ([br/]) an der Cursorposition einzufügen, muss im Editor nur <ALT + Enter> gedrückt werden. Es wird ein br-Tag eingefügt und automatisch in die nächste Zeile gesprungen. Einfügen mit Zeilenumbruch Teilweise wird mehrzeiliger Text von außerhalb des Editors eingefügt. Wenn dies über das normale Einfügen mit <STRG + V> stattfindet, so werden die Zeilenumbruche anschließend im DocML ignoriert, da diese dort durch [br/]-Tags repräsentiert werden. Über das Kontextmenü kann jedoch die Aktion Paste & Format ausgelöst werden. Eine Alternative bietet der Shortcut SHIFT + STRG + V. Dies hat zur Folge, dass für jeden Zeilenumbruch im eingefügten Text automatisch ein [br/]-Tag hinzugefügt wird. Text markieren Alle Formatierungsfunktionen des Editors wie z.B. Fettschrift oder Ausrichtung des Textes funktionieren ähnlich wie in einem WYSIWYG-Editor. Es wird Text markiert und dann die gewünschte Formatierungsoption aufgerufen. Der Unterschied des DocML-Editors ist allerdings, dass sich im markierten Text auch DocML-Tags befinden können, wie folgendes Beispiel zeigt: Dies ist allerdings absolut kein Problem. Soll z.B. der oben markierte Text kursiv geschrieben werden, kann einfach in der Werkzeugleiste der entsprechende Button geklickt werden. Der Editor erkennt die Markierung und alle Tags darin und wendet die neue Formatierung entsprechend an: Es muss also nicht auf Tags geachtet werden, wenn zusätzliche Formatierungen auf schon zuvor formatierte Textstellen angewendet werden. Auch bei Block-Tags wie Listen kann dieses Verhalten auftreten. Nachfolgend soll z.B. eine gesamte Liste fett gedruckt werden. Da Block-Tags (lst-Tags) nicht in Inline-Tags (b-Tags) auftreten dürfen, kümmert sich der Editor selbst darum und ergänzt die Texte in der Liste automatisch mit den entsprechenden Tags. Folgende Liste soll komplett fett gedruckt dargestellt werden: Nach einem Klick auf den Button für Fettschrift in der Werkzeugleiste werden die Listeneinträge automatisch um die jeweiligen b-Tags ergänzt und die Validität des DocML wird erhalten: Beim Markieren von Texten für Formatierungen muss also nicht explizit an schon vorhandene Tags gedacht werden, der Editor erledigt dies alles automatisch. Kommentare DocML bietet die Möglichkeit, in Dokumentationen Kommentare einzufügen, die nicht in die Ausgabe gerendert werden. So können z.B. kleine Notizen oder Erinnerungen in die Dokumentation eingefügt werden. Ein Kommentar-Tag startet mit der Zeichenfolge [-- und endet mit --]. Kommentare sind im DocML an ihrer grünen Farbe zu erkennen und beeinflussen die Ausgabe in keinster Weise. Kommentare können an beliebiger Stelle im DocML platziert werden. Escape-Zeichen Die Sprache DocML beinhaltet einige Steuerzeichen wie z.B. eckige Klammern ([ und ]), mit denen die Tags abgebildet werden. Allerdings werden diese Zeichen natürlich auch im Fließtext der Ausgabe benötigt. Dass Framework Studio den Unterschied zwischen einer eckigen Klammer eines Tags und einer normalen eckigen Klammer im Fließtext unterscheiden kann, müssen diese Zeichen mit einem Blackslash (\\) escaped werden. Wie zu sehen ist, werden die Backslashes in der Ausgabe eliminiert. Um einen Backslash als Zeichen in die Dokumentation einzufügen, muss dieser ebenso mit einem weiteren Backslash escaped werden. Panel Other Der Editor bietet die Möglichkeit, ein zusätzliches Fenster einzublenden, welches eine Dokumentation aus einem anderen Package oder in einer anderen Sprache anzeigt. So kann z.B. während die englische Dokumentation für ein Formular erstellt wird, parallel die deutsche Dokumentation angezeigt werden, um besser übersetzen zu können. Language Mit dieser Combobox wird die Sprache der anzuzeigenden Dokumentation gewählt. Package Mit dieser Combobox kann zwischen den Dokumentationen des Elementes in unterschiedlichen Packages gewählt werden. Mehr Informationen über Package-übergreifende Dokumentation und das Customizing befindet sich in den Kapiteln Vererbung und Customizing. Panel Tooltip Wenn eine Dokumentation eines Controls bearbeitet wird, bietet der Editor die Möglichkeit, ein zusätzlichen Fenster-Bereich einzublenden, welches das Bearbeiten des Tooltips erleichtert. Der Tooltip Text kann direkt im Tooltip Panel bearbeitet werden. Wird der Inhalt des Textfeldes bearbeitet, dann wird er fett gedruckt und der Tooltip direkt am Control überschrieben. Der Text des MLKey wird dadruch nicht verändert. Wenn man den kompletten Inhalt des Textfeldes löscht, dann wird wieder Text wieder aus dem MLKey bzw. der Basis gezogen. Mit dem Button […] kann ein anderer MLKey ausgewählt werden. Mit einem Klick auf den blauen Link kann der momentan ausgewählte MLKey bearbeitet werden."
  },
  "doc/documentation/export-wizards.html": {
    "href": "doc/documentation/export-wizards.html",
    "title": "Export Wizards",
    "keywords": "Export Wizards Die wichtigste Funktion des Dokumentationssystems ist der Export in ein gängiges Format. Framework Studio bietet die Möglichkeit, automatisiert alle Dokumentationen, die an Forms, Controls, Metadatentypen usw. getätigt wurden, anhand der im Chapter Tree definierten Kapitelstruktur zu exportieren. Die Dokumentation kann als HTML Webapplikation (zum Hosten auf einem Webserver) oder als Word-Datei (.docx) exportiert werden. Zusätzlich dazu gibt es einen besonderen Modus, mit dem ausschließlich Dokumentationen von Component-Properties exportiert werden können, um diese mittels des Browser-Controls in der Endanwendung anzeigen zu können. HTML Dieser Export-Modus exportiert die gesamte Dokumentation oder ein ausgewähltes Kapitel als Webapplikation, welche auf einem beliebigen Webserver (z.B. IIS, Apache, Nginx) gehostet werden kann und somit von nahezu allen Endgeräten mit Webbrowser erreichbar ist. Der Modus HTML (Properties) ist in diesem Export-Modus integriert. Es werden alle Component-Properties von Components, die mit dem Marker {ExportDoc} markiert sind, exportiert. Der Wizard für den Export der Dokumentation als HTML Webapplikation befindet sich im Menü Tools > Documentation > Export > HTML. Wizard-Optionen Die Baumansicht bietet die Struktur des Release-Knotens an. Hier muss ausgewählt werden, welches Kapitel exportiert werden soll. Wird der Release-Knoten selbst angewählt, wird die gesamte Dokumentation, die im Framework Studio hinterlegt ist, exportiert. Combobox Language Definiert die Sprache, für die die Dokumentation exportiert werden soll. Dies ändert auch die Sprache der automatisch generierten Screenshots (siehe Screenshot ). Beim Export über die FSConsole kann die Sprache über den Parameter \\Iso gesteuert werden. Checkbox Include Tooltips Ist an einem Steuerelement eines Formulars ein Tooltip hinterlegt, wird dieser mit in die Dokumentation des Steuerelements aufgenommen. Checkbox Include DB-Tables Ist diese Checkbox gesetzt, dann wird auf der ersten Ebene ein zusätzliches Kapitel Tabellen-Beschreibungen erzeugt, unter dem die Beschreibung aller Datenbank-Tabellen enthalten ist. Beim Export über die FSConsole kann das über den Parameter \\ExportDBTables gesteuert werden. Checkbox Use License Wenn diese Checkbox aktiviert ist, wird die Lizenz bei dem Export der Dokumentation berücksichtigt. Forms und Controls, die nicht die nötigen Berechtigungen besitzen, werden nicht mit in die Dokumentation aufgenommen. Textbox Output Directory Hier wird das Verzeichnis angegeben, in den die Dokumentation exportiert werden soll. Um mehrere exportierte Dokumentationen voneinander unterscheiden zu können, wird bei jedem Export automatisch ein generierter Unterordner mit dem Schema [Datum]_[Uhrzeit]_[Package]_[Version]_[Sprache]_[SettingName] erstellt. [SettingName] wird nur ergänzt, wenn die Checkbox Use License aktiviert ist. Export-Vorgang Für den eigentlichen Export-Vorgang wird ein Dialog mit Statusinformationen bereitgestellt. Über den Button Abort kann der Vorgang jederzeit abgebrochen werden. Treten beim Export-Vorgang Infos, Warnungen oder Fehler auf, werden diese detailliert in das Ausgabefenster protokolliert und der Statustext ändert ggf. seine Farbe (orange für Warnungen, rot für Fehler). Webapplikation Nach dem Export-Vorgang befindet sich die Webapplikation im zuvor ausgewählten Ausgabeordner. Die Webapplikation ist eine HTML 5 Anwendung, die ausschließlich auf den Technologien HTML, JavaScript und CSS basiert. Damit ist sie kompatibel zu nahezu allen Endgeräten mit einem Browser (Webapplikation Voraussetzungen beachten). Inhalt Nach dem Öffnen der Webapplikation im Browser ist standardmäßig der Bereich Contents selektiert. Hier kann im Baum auf der linken Seite das gewünschte Kapitel ausgewählt werden, welches dann rechts im Viewer angezeigt wird. Bei einem Klick auf einen Link wird der Baum automatisch aktualisiert und zum neuen Kapitel gesprungen. Index Im Bereich Index kann der gesamte Index der Dokumentation durchsucht werden. Ist einem Index-Eintrag nur ein einziges Kapitel zugeordnet, wird dieses sofort nach dem Klick in den Baum ausgewählt. Sind einem Index-Eintrag mehrere Kapitel zugeordnet, kann das gewünschte Kapitel im Bereich Select Chapter links unten im Baum ausgewählt werden. Suche Mit Hilfe der Suchfunktion können alle Kapitel nach Wörtern durchsucht werden. In der Ergebnisliste werden dann alle Kapitel angezeigt, die das eingegebene Wort enthalten. Drucken Um den Inhalt des gerade angezeigten Kapitels zu drucken, steht der Button Print zur Verfügung. Anders als die Druckfunktion des Browsers, welche die gesamte Webapplikation inkl. Baum drucken würde, wir über den Button Print nur der Inhalt des Viewers berücksichtigt. Webapplikation Voraussetzungen Um die von Framework Studio generierte Webapplikation zu hosten, wird einer der folgenden Webserver vorausgesetzt: IIS 7 oder höher Apache 2.2.x oder höher Nginx 1.9 oder höher Es wird empfohlen, einen der folgenden Browser zur Anzeige der Webapplikation zu verwenden: Google Chrome Mozilla Firefox Microsoft Edge Microsoft Internet Explorer 11 Warning Internet Explorer 10 und niedriger werden NICHT unterstützt. Export aus Package-Manager Der Export Wizard kann über das -Icon oder über das Kontextmenü einer Package-Version gestartet werden. Export Wizard Bei einem Export aus dem Package Manager heraus wird immer die gesamte Dokumentation exportiert. Die Auswahl eines bestimmt en Kapitels entfällt. Combobox Language Definiert die Sprache, für die die Dokumentation exportiert werden soll. Dies ändert auch die Sprache der automatisch generierten Screenshots (siehe Screenshot ). Checkbox Include DB-Tables Ist diese Checkbox gesetzt, dann wird auf der ersten Ebene ein zusätzliches Kapitel Tabellen-Beschreibungen erzeugt, unter dem die Beschreibung aller Datenbank-Tabellen enthalten ist. Checkbox Use License Wenn diese Checkbox aktiviert ist, wird die Lizenz beim Export der Dokumentation berücksichtigt. Forms und Controls, die nicht die nötigen Berechtigungen besitzen, werden nicht mit in die Dokumentation aufgenommen. Wenn Use License aktiviert ist, muss zusätzlich ein Setting ausgewählt werden, welches die Lizenz bereitstellt, die beim Export genutzt werden soll. Combobox Setting Bietet alle Settings für die gewählte Package-Version aus dem Repository an, die nicht als Personal markiert sind. Textbox Output Directory Hier wird das Verzeichnis angegeben, in den die Dokumentation exportiert werden soll. Um mehrere exportierte Dokumentationen voneinander unterscheiden zu können, wird bei jedem Export automatisch ein generierter Unterordner mit dem Schema [Datum]_[Uhrzeit]_[Package]_[Version]_[Sprache]_[SettingName] erstellt. [SettingName] wird nur ergänzt, wenn die Checkbox Use License aktiviert ist. Export-Vorgang Für den Export-Vorgang wird ein Dialog mit Statusinformationen bereitgestellt, der nach Abschluss des Vorgangs geschlossen werden kann. Export mit FSConsole Neben dem Export-Wizard kann die Webapplikation auch über die FSConsole.exe generiert werden. Hierzu gibt es die Parameter \\DOCUMENTATION, \\ISO und \\OUTPUT. \\DOCUMENTATION Dieser Parameter ist nur ein Marker für die FSConsole, dass die Dokumentation gerendert werden soll. \\ISO Gibt die Sprache an, in der die Dokumentation gerendert werden soll. Der Parameter hat auch Einfluss auf die automatisch generierten Screenshots. \\OUTPUT Gibt das Verzeichnis an, in welches die Webapplikation gerendert werden soll. Zusätzlich zu den neuen Parametern müssen die obligatorischen Connection- und Package-Version Parameter angegeben werden (\\LABELID, \\SERVER, \\DBUSER usw.) Beispiel: FSConsole.exe \\DOCUMENTATION \\ISO de \\OUTPUT „C:\\Temp\\Dokumentation“ \\PACKAGE MyPackage \\VERSION 3.8 \\CONNECTIONTYPE SqlServer \\SERVER Server01 \\DBUSER demo \\DBPASSWORD demo123 Word Der Wizard für den Export der Dokumentation als Word-Datei (.docx) befindet sich im Menü Tools > Documentation > Export > Word. Wizard-Optionen Die Baumansicht bietet die Struktur des Release-Knotens an. Hier muss ausgewählt werden, welches Kapitel exportiert werden soll. Wird der Release-Knoten selbst angewählt, wird die gesamte Dokumentation, die im Framework Studio hinterlegt ist, exportiert. Title Page Wird diese Option aktiviert, wird in der Word-Datei zusätzlich ein Deckblatt mit dem definierten Titel und Info Text generiert. Language Definiert die Sprache, für die die Dokumentation exportiert werden soll. Dies ändert auch die Sprache der automatisch generierten Screenshots (siehe Screenshot ). Create TOC Erstellt ein Inhaltsverzeichnis für alle in der Dokumentation enthaltenen Kapitel am Anfang der Word-Datei. Create Index Erstellt einen Index für alle Kapitel und manuell in den Dokumentationen definierten Indexeinträgen am Ende der Word-Datei. Die Überschrift jedes Kapitels aus dem Chapter Tree wird automatisch zum Index hinzugefügt. Include Tooltips Ist an einem Steuerelement eines Formulars ein Tooltip hinterlegt, wird dieser mit in die Dokumentation des Steuerelements aufgenommen. Doc2Help Zusätzlich zum Indexeintrag wird jede Kapitelüberschrift mit einer zusätzlichen Formatvorlage versehen, die es Doc2Help erlaubt, einen Verweis über eine Url in der Onlinehilfe auf das jeweilige Kapitel zu generieren. Für mehr Information hierzu siehe Kapitel Doc2Help. Checkbox Use License Wenn diese Checkbox aktiviert ist, wird die Lizenz bei dem Export der Dokumentation berücksichtigt. Forms und Controls, die nicht die nötigen Berechtigungen besitzen, werden nicht mit in die Dokumentation aufgenommen. Export-Vorgang Für den eigentlichen Export-Vorgang wird ein Dialog mit Statusinformationen bereitgestellt. Über den Button Abort kann der Vorgang jederzeit abgebrochen werden. Treten beim Export-Vorgang Infos, Warnungen oder Fehler auf, werden diese detailliert in das Ausgabefenster protokolliert und der Statustext ändert ggf. seine Farbe (orange für Warnungen, rot für Fehler). Besonderheit bei TOC und Index Wurde im Export Wizard eine der Optionen Create TOC oder Create Index ausgewählt, muss Microsoft Word (2007 oder höher) auf dem PC installiert sein, um das Inhaltsverzeichnis oder den Index nach einem erfolgreichem Exportvorgang zu aktualisieren. Zu diesem Zweck wird nach dem Speichern der docx-Datei auf der Festplatte diese automatisch von Framework Studio aus mit Word geöffnet (als Prozess - es wird kein Fenster geöffnet) und eine Aktualisierung der jeweiligen Kataloge angestoßen. Anschließend wird die Datei nochmals gespeichert und Word geschlossen. Im Ausgabefenster des Export-Vorgangs ist zu erkennen, dass seitens Framework Studio geprüft wird, ob Word installiert ist. Sollte dies nicht der Fall sein, werden im exportierten Dokument zwar ein Inhaltsverzeichnis und ein Index enthalten sein, die jedoch aufgrund der fehlenden Aktualisierung keine Einträge enthalten. In diesem Fall muss die Aktualisierung der Kataloge manuell mit Word durchgeführt werden. HTML (Properties) Zusätzlich zu den anderen Modi steht ein weiterer Export-Modus zur Verfügung. Dieser ist in der Lage, ausschließlich Dokumentationen von Component-Properties in einzelne HTML-Dateien zu rendern. Er rendert also nicht wie der HTML- oder Word-Exporter die gesamte zur Verfügung stehende Dokumentation, sondern nur ausgewählte Component-Properties. Soll die Dokumentation eines Component-Properties z.B. an der Oberfläche der Endanwendung angezeigt werden, ist dies nun mit Hilfe des Browser-Controls möglich. Der neue Export-Modus befindet sich wie nun auch der bisherige Word-Export-Modus im Menü Tools > Documentation > Export > HTML (Properties). Markieren der Components Eine Endanwendung besteht im Normalfall aus extrem vielen Components und Component-Properties. Der neue Export-Modus wird aber meist nur für einen gewissen Bereich der Anwendung benötigt. Deshalb muss auf Component-Ebene definiert werden, welche Components beim neuen Export-Modus beachtet werden sollen. Um eine Component für den neuen Modus zu markieren, muss die Zeichenfolge \"{ExportDoc}\" in das Description-Feld der Component eingetragen werden. Nun werden beim Export alle dokumentierten Properties der markierten Component exportiert. Wizard-Optionen Wird der neue Export-Dialog aufgerufen, wird eine Übersicht mit allen markierten Components angezeigt. Language Definiert die Sprache, in der die Component-Properties gerendert werden sollen Include Tooltips Definiert, ob an den Component-Properties definierte Tooltips zuzüglich zur eigentlichen Dokumentation gerendert werden sollen. Output Directory Über den Button […] muss ein Zielverzeichnis für den HTML-Export definiert werden. Dieses Verzeichnis muss leer sein. Export-Vorgang Es kann nachvollzogen werden, welche Properties Dokumentationen beinhalten und gerendert werden. Sollte nach dem Export-Vorgang festgestellt werden, dass keine Bilder gerendert wurden, wird das zuvor erstellte Verzeichnis images wieder gelöscht. Ausgabe Beim Export wird jedes Property einer markierten Component durchlaufen und in eine separate .html-Datei geschrieben. Der Name dieser Dateien setzt sich allein aus dem Namespace-Pfad des Properties zusammen. Wird der Export-Ordner nun an einem im Netzwerk zugänglichen Pfad abgelegt (vorzugsweise auf dem Webserver, auf dem auch schon die bisherige Dokumentation liegt), können die Property-Dokumentationen in der Endanwendung mittels eines Browser-Controls eingebunden werden. Struktur der Ausgabe Der größte Vorteil der Generierung der Anwendungsdokumentation mit Framework Studio ist die strukturierte Ausgabe. Ziel ist es, jedes Kapitel bzw. Formular in genau demselben Schema auszugeben. Dokumentations-Elemente sind hier sehr einfach gehalten, da sie nur eine Dokumentation enthalten. Sie werden als einzelnes Kapitel mit dem zugehörigen Text gerendert. Formulare hingegen bestehen aus vielen Steuerelementen und ggf. Menüeinträgen, die wiederum ihre eigene Dokumentation beinhalten. Hier folgt Framework Studio folgendem Schema: Die Dokumentation eines Formulars beginnt wie ein Documentation-Element mit einem eigenen Kapitel. Danach folgt die Formular-Dokumentation. Die Steuerelemente werden anhand ihrer Position auf dem Form abgearbeitet. Es wird von links nach rechts und von oben nach unten gearbeitet. Wenn ein Steuerelement andere Steuerelemente beinhaltet (z.B. Registerkarten oder Tabellen) werden diese inneren Steuerelemente nach demselben Schema abgearbeitet. Sind alle Steuerelemente gerendert, folgt zum Schluss die Ausgabe der Menüeinträge. Zur Verdeutlichung folgen einige Beispiele in Microsoft Word. Ausgabe einer Dokumentation eines Documentation-Elements: Ausgabe eines Formulars unterhalb eines Documentation-Elements: In diesem Beispiel ist zu sehen, dass im Chapter Tree das Formular Kassenparameter unterhalb des Documentation-Elements Kasse eingefügt wurde. In der Formular-Dokumentation wurde ein automatisch generierter Screenshot eingefügt. Ausgabe der Steuerelemente eines Formulars: In diesem Beispiel ist die Ausgabe der Steuerelemente eines Formulars zu sehen. Ist ein Steuerelement ein Container (d.h. beinhaltet andere Steuerelemente) wird dies mit horizontalen Linien verdeutlicht. Es ist zu erkennen, dass die Buttons Speichern, Schließen, Customizing und Hilfe innerhalb des Panels Haupt-Buttonleiste liegen. Zusätzlich ist erkennbar, dass die Bezeichnungsfelder Gutsch.kürzel und Rechn.kürzel Tooltip-Informationen enthalten, die automatisch mit in die Dokumentation aufgenommen wurden (Checkbox Include Tooltips in den Wizard-Optionen). Ausgabe der Bilder bei Steuerelementen Es gibt einige Steuerelemente in Framework Studio, die Bilder anzeigen (z.B. ImageButtons). Um das Auffinden eines solchen Steuerelements in der Dokumentation zu vereinfachen, kann in der Ausgabe des Steuerelements das zugehörige Bild mit angezeigt werden. ImageButtons mit Bild in der Dokumentation: Ob das Bild in der Dokumentation des Steuerelements mit angezeigt wird oder nicht, hängt von einem Schalter direkt am Steuerelement ab. Einstellung zur Anzeige des Bildes in der Dokumentation des Steuerelements: Diese Einstellung kann auch global über die DefaultControlStyles für den jeweiligen Control-Typ definiert werden. Einstellung der Bildanzeige am DefaultControlStyle: Registerkarten als separate Kapitel ausgeben Registerkarten beinhalten in Anwendungen oft Funktionalitäten, die in einer Dokumentation als separates Kapitel betrachtet werden sollte. Standardmäßig werden Registerkarte in der Dokumentation genauso wie andere Container-Steuerelemente in der Liste der Steuerelemente des Formulars mit ausgegeben. Dieses Verhalten ist nicht immer gewünscht, vor allem wenn eine Registerkarte sehr viele Steuerelemente und komplexere Vorgänge beinhaltet. Um für jede Registerkarte eines Registerkartes unterhalb eines Formulars ein eigenes Kapitel in der Dokumentation zu eröffnen, gibt es die Option ChaptersForTabs am Registerkarte. Registerkarten als separate Kapitel Ausgeben: Wird diese Option auf True gesetzt, werden beim Exportieren des Formulars für jede Registerkarte des Registerkartes ein eigenes Kapitel mit eigenem Indexeintrag erstellt. Generierung separater Kapitel für Registerkarten: In der Liste der Steuerelemente, in der die Registerkarten normalerweise ausgegeben werden, befindet sich dann nur noch ein Link auf das entsprechende Unterkapitel. Caution Die Option ChapterForTabs kann je Formular nur für ein einziges Registerkarte auf True gesetzt werden. Vorschau eines ganzen Formulars Die Preview-Ansicht des Dokumentations-Editors zeigt immer nur die Ausgabe des im Editor befindlichen DocML. Um eine Vorstellung zu bekommen, wie ein ganzes Formular in der Endfassung aussieht, kann dieses komplett mit der Steuerelementauflistung und den Menüeinträgen in ein Vorschaufenster gerendert werden. Hierzu reicht im Documenation-Editor ein Klick auf den Link View Render Chapter. Es wird die in der Combobox Language angegebene Sprache verwendet. Dieser Link steht auch im Documentation-Editor der TabPage zur Verfügung. Diese bilden in der Regel ein eigenes Chapter und werden nicht in der Preview des Forms angezeigt. Vollständige Voransicht eines Formulars rendern: Unterstützung von Themes Die Einstellung des Themes in Framework Studio hat unmittelbare Auswirkungen auf die Ausgabe der Dokumentation mittels des Export Wizards. Diese Abhängigkeit betrifft in Framework Studio eingebundene Ressourcen sowie auch die automatisch generierten Screenshots über das Screenshot-Tag (siehe Screenshot ) in der Formular-Dokumentation. Im folgenden Beispiel wurde eine Dokumentation eines Formulars mit zwei unterschiedlichen Themes exportiert, was zu anderen automatisch generierten Screenshots in der Dokumentation führt. Dokumentation exportiert mit Theme 1: Dokumentation exportiert mit Theme 2:"
  },
  "doc/documentation/indicators.html": {
    "href": "doc/documentation/indicators.html",
    "title": "Dokumentationsstatus von Steuerelementen",
    "keywords": "Dokumentationsstatus von Steuerelementen Da die Dokumentation der Steuerelemente eines Formulars über den Designer stattfindet, ist nicht immer ersichtlich, welches Steuerelement schon eine Dokumentation beinhaltet oder ob das Steuerelement beim Rendern eine Dokumentation aus der Basis erhält. Um dies zu visualisieren, gibt es in den Framework Studio Optionen die Option Documentation Indicators. Wird diese Checkbox aktiviert, werden für alle Steuerelemente kleine Vierecke in der rechten oberen Ecke angezeigt. Die Quadrate können dabei zwei Farben annehmen: Gelb Das Steuerelement enthält in diesem Formular keine Dokumentation. Es steht aber eine Dokumentation aus der DataSource des Steuerelements (Component Property, DBColumn, Metadatentyp) oder aus einem Basis-Package zur Verfügung und würde bei einem Export ausgegeben. Grün Das Steuerelement enthält in diesem Formular eine Dokumentation. Wenn an einem Steuerelement kein Quadrat existiert, gibt es an diesem Steuerelement keine Dokumentation sowie auch keine Dokumentation aus der DataSource bzw. eines Basis-Packages."
  },
  "doc/documentation/vererbung.html": {
    "href": "doc/documentation/vererbung.html",
    "title": "Vererbung",
    "keywords": "Vererbung Ähnlich wie bei den Tooltips für Steuerelemente bietet auch die Dokumentation eine Vererbung bis auf Metadatentyp-Ebene an. Diese Vererbung soll dazu beitragen, Dokumentationen für Steuerelemente mit derselben Funktion nicht mehrmals verfassen oder kopieren zu müssen. Vererbung einer Dokumentation: Die Abbildung zeigt die Möglichkeit der Vererbung vom Steuerelement auf dem Form bis zum Metadatentyp ggf. auch über mehrere Packages hinweg, gesetzt den Fall, dass dem jeweiligen Steuerelement eine DataSource zugewiesen wurde. Eingebunden werden kann eine Dokumentation aus einem darunter liegenden Element mit Hilfe des base-Tags (siehe Base). Vererbung in einem einzigen Package Im folgenden Beispiel wird gezeigt, wie mit Hilfe der Vererbung in der Dokumentation des Textfelds T die Dokumentationen aus dessen Component Properties (DataSource), der dazu gehörigen DBColumn und des wiederum damit verbundenen Metadatentyps eingebunden werden kann. Betrachtet wird das Szenario eines einzelnen Packages P1 (blaue Pfeile). Die Dokumentation des Metadatentyps M sieht wie folgt aus: Die Dokumentation der DBColumn D bindet mit Hilfe des base-Tags die Dokumentation des Metadatentyps ein. Beim Rendern wird an die Stelle des base-Tags somit die Dokumentation des Metadatentyps eingebunden: Am Component Property C ist dasselbe Verhalten zu erkennen: Letztlich bindet auch das Textfeld T die Basis-Dokumentation ein, was folgende Ausgabe ergibt: An der Dokumentation des Controls ist nun zu erkennen, dass die Information über das Drücken der F2-Taste am Control auf dem Formular dokumentiert wurde. Dies könnte auf einem anderen Formular z.B. ein anderer Shortcut sein. Die restliche Dokumentation inklusive des rot markierten Beispiels würde aber automatisch übernommen werden. Diese Art der Vererbung ist also immer dann sinnvoll, wenn auf unterschiedlichen Formularen in der Anwendung Steuerelemente existieren, die genau dieselben DataSources verwenden. Beispiel In einer Anwendung gibt es auf 6 verschiedenen Formularen immer wieder ein Textfeld, welches eine Auftragsnummer anzeigt. Die Funktion des Textfeldes ist auf jedem Form dieselbe und beinhaltet auch immer die Daten desselben Component Properties (die Textfelder haben immer die gleiche DataSource), baut somit immer auf derselben DBColumn auf und ist damit auch vom selben Metadatentyp abhängig. Es wäre nun sehr umständlich, jedes Mal am Steuerelement selbst dieselbe Dokumentation zu hinterlegen. Sollte sich diese ändern, müssten alle 6 Stellen angepasst und erneut auf Fehler überprüft werden. Um dies zu vermeiden, kann die Vererbung genutzt werden. Da die 6 Textfelder immer auf demselben Component Property aufsetzen, kann die gesamte Dokumentation an diesem verfasst werden. Der große Vorteil dieses Vorgehens ist, wenn sich an der Dokumentation etwas ändert, muss nur die Dokumentation des Component Properties angepasst werden und beim nächsten Rendern haben alle abhängigen Textfelder die aktualisierte Dokumentation des Component Properties übernommen. Insgesamt gilt also: Die Dokumentation sollte so tief wie möglich im Framework Studio verfasst und auf möglichst viele Elemente vererbt werden. Entstehen in der Datasource Hierarchy an einer Stelle Lücken in der Dokumentation, wird die Dokumentation aus der nächst tieferen Ebene eingebunden. Befindet sich z.B. in der Dokumentation eines Textfelds T ein base-Tag, wird beim Rendern die Dokumentation aus dem Component Property verwendet. Ist jedoch keine Dokumentation an selbigem verfasst, wird automatisch in der tieferen Ebene nach einer Dokumentation geprüft. In diesem Fall würde die Dokumentation der DBColumn verwendet werden. Ist an selbiger auch keine Dokumentation verfasst, wird die des Metadatentyps eingebunden. Beispiel Eine leere Dokumentation verhält sich wie ein base-Tag: An einem Textfeld ist nicht explizit eine Dokumentation hinterlegt. Das per DataSource zugewiesene Component Property beinhaltet jedoch eine Dokumentation. Wie zu sehen ist, wird automatisch die Dokumentation des Component Properties für das Textfeld gerendert, wenn die Preview angezeigt wird. Eine nicht vohandene Dokumentation in einem Control, einem Property, einer DBColumn oder einem Metadatentyp verhält sich also genauso wie ein base-Tag ohne weiteres DocML. base-Tag ohne weiteres DocML: Das gezeigte base-Tag kann also entfernt werden, da sich die leere Dokumentation äquivalent verhält. Vererbung bei mehreren Packages Liegen mehrere Packages übereinander (grüne und orangene Pfeile), wird immer erst die höchste Customization des jeweiligen Elements betrachtet. Vererbung über mehrere Packages hinweg: Beispiel (grüne Pfeile): Wird die Dokumentation für die Customization vom Textfeld T im Package P2 gerendert, wird für ein base-Tag in P1 nach einer Dokumentation gesucht. Wird dort nichts gefunden oder erfolgt dort ein weiterer Base-Aufruf, wird an der Customization des Component Properties C in P2 gesucht usw."
  },
  "doc/editors/editor-cs-code-messages.html": {
    "href": "doc/editors/editor-cs-code-messages.html",
    "title": "Code-Messages",
    "keywords": "Code-Messages Wenn Sie eine Methode eines Forms bearbeiten, stehen Ihnen Editoren zum komfortablen Erstellen und Bearbeiten von mehrsprachigen Ausnahmen (Exceptions) und Meldungen (Message-Boxen) zur Verfügung. Diese können Sie über die Buttons Exception Editor Wizard und Message Box Editor Wizard aufrufen. Wenn Sie eine Textcollection ändern, indem Sie beispielsweise einen neuen Eintrag erzeugen oder einen bestehenden Eintrag ändern, dann muss die Textcollection dazu in der aktuellen Version für Sie ausgecheckt werden. Benutzen Sie dazu den Button Edit Message. Andere Benutzer können nun die Textcollection nicht bearbeiten. Beim Verlassen des Message Box Editors bzw. Exception Editors wird die Textcollection automatisch eingecheckt, so dass auch andere Benutzer wieder auf die Textcollection zugreifen können. Beide Editoren weisen bezogen auf die Oberfläche nur sehr geringfügige Unterschiede auf. Radiobutton ML Key Hier können sie einen MLKey angeben. Mit dem Auswahl-Button neben dem Textfeld öffnet sich der Dialog Select ML Key. Dies ist die Standard-Option. Neue Meldungen sollten immer über das Wörterbuch gezogen werden. Radiobutton New Message Wenn Sie diesen Radiobutton auswählen, wird ein neuer Text in die ausgewählte Textcollection eingetragen. Important Wenn Sie einen neuen Text hinzufügen, müssen Sie auch die Textcollection kompilieren, da es sonst beim Ausführen des Programms Fehlermeldungen gibt. Radiobutton Change Message Wenn Sie diesen Radiobutton auswählen, können Sie mit dem Button Choose existing Message einen bestehenden Eintrag aus der angegebenen Textcollection auswählen oder mit dem Button Search nach einem bestehenden Eintrag suchen. Button Change Collection Mit diesem Button kann die Textcollection geändert werden, aus der ein Text ausgewählt werden soll, bzw. in welcher der neue Text eingetragen werden soll. Als Default-Wert ist die Textcollection ctMessages ausgewählt. Button Choose existing Message Mit diesem Button kann aus der gewählten Textcollection ein existierender Eintrag ausgewählt werden. Feld Collection Zeigt an, welche Textcollection ausgewählt ist. Button Search Mit diesem Button öffnen Sie einen Suchdialog. In diesem Dialog wird die Suche auf die Textcollection, die im Exception Editor / Message Box Editor angegeben ist, eingeschränkt. Die Suchfunktionalität ist identisch mit den Möglichkeiten, die auf der Registerkarte Search im Framework-Designer zur Verfügung gestellt werden. Text-Grid Ist ein MLKey ausgewählt, wird hier nur der Text angezeigt. Der ML Key kann über das Textfeld bzw. den Auswahl-Button geändert werden. Die Bearbeitung der Texte-Inhalte erfolgt über das Wörterbuch. In diesem Grid kann der Text der Message in den verschiedenen Sprachen eingegeben werden. Wurde mit Choose existing Message ein Eintrag ausgewählt, wird dieser geändert und in die Textcollection zurückgeschrieben. Alle vorhandenen Message-Boxen, die diesen Eintrag verwenden, sind ebenfalls davon betroffen. Dem Text können Parameter zugewiesen werden. Die Parameter werden in der Form {0}, {1} usw. angegeben. Jeder Parameter kann mehrmals verwendet werden. Der Beleg {0} für Kunde {1} hat sich geändert. Wollen Sie den Beleg {0} speichern? Die Parameter werden in der Textbox String.Format... gefüllt. Combobox Icon (nur Message-Box) Gibt an, welches Icon verwendet werden soll Error Exclamation Information Question None Combobox Buttons (nur Message-Box) Gibt an, welche Buttons angezeigt werden sollen. Wird OK ausgewählt, ist es nicht notwendig, einen Event-Handler zu hinterlegen. Werden andere Buttons ausgewählt, muss ein Event-Handler hinterlegt werden. AbortRetryIgnore OK OKCancel RetryCancel YesNo YesNoCancel Combobox Default (nur Message-Box) Gibt den Button an, der beim Anzeigen der Message-Box ausgewählt sein soll. So kann z.B. bei den Buttons YesNo durch Angabe von Button2 das versehentliche Betätigen des Yes-Button verhindert werden. Button1 Button2 Button3 Die Nummer des Buttons entspricht der Angabe bei Buttons. z.B. YesNoCancel bedeutet Button1 = OK, Button2 = No, Button3 = Cancel Button Event Handler (nur Message Box Editor) Mit diesem Button kann angegeben werden, ob mit dem Klick in der Message-Box (z.B. auf OK oder Cancel) ein Event angestoßen werden soll oder nicht. Ist der Button gedrückt, erscheint rechts daneben eine Combobox, mit der evtl. bestehende Methoden ausgewählt werden können. Mit dem Button New wird ein neuer Event-Handler angelegt. Es wird eine Methode OnMsgBoxClick1 angelegt. Der Parameter MsgBoxEventArgs hat ein Property DialogResult, damit abgefragt werden kann, welcher Button gedrückt wurde. public void OnMsgBoxClick1(object sender, MsgBoxEventArgs e) { if (e.DialogResult == DialogResult.OK) { //Code for Ok. } } Combobox Severity (nur Exception Editor) Hier können Sie den Schweregrad der Ausnahme (0-3) festlegen. Add Inner Exception (nur Exception Editor) Wenn die Checkbox gesetzt ist, können Sie das Property InnerException füllen. Geben Sie dazu die zu übergebende Variable im Textfeld an. Geben Sie dazu im Textfeld den Namen der lokalen Exception-Variable an. Textbox String.Format... In dieser Textbox können die Parameter der Message angegeben werden. Es ist möglich im Message Text Parameter anzugeben. Dies geschieht mit {0}, {1} usw. Diese Parameter können im Text auch mehrmals verwendet werden. Für jeden dieser Parameter kann hier, mit Komma getrennt, ein Wert angegeben werden. Der erste Parameter steht für {0}, der zweite für {1} usw. this.oOrder.lngOrderID, this.oOrder.lngCustomerID Button OK Schließt den Dialog und fügt den generierten Message-Code in den Code-Editor ein. Button Cancel Schließt den Dialog und verwirft die Änderungen. Wenn der Message-Box-Editor mit OK verlassen wird, wird an die Stelle im Code, an der sich der Cursor befindet der Code generiert. // FSCodeMessage: Really delete article {0}? throw MsgBox.Exception(MLUtil.FormatMLKeyText(MLKeys.MSG_9188180c5ac64a5384141b553eef8105, this.oSelectedArticle.sName), \"\", MsgBoxButtons.YesNo, MsgBoxIcons.Question, new MsgBoxEventHandler(OnDeleteQuestionMsgBoxClick)); Durch den Kommentar // FSCodeMessage: ist dieser Code im Code-Editor gut zu erkennen. Um die Code-Message nachträglich zu ändern, setzen Sie den Fokus irgendwo in den generierten Code-Block und drücken erneut den entsprechenden Wizard-Button. Es öffnet sich wieder der Editor wie oben und die Daten der Code-Message werden angezeigt und können geändert werden. Bei Bedarf können auch einzelne Bestandteile wie z.B. der MLKey oder ein Enum-Wert direkt im Code geändert werden. Caution Die Struktur des Codes darf jedoch nicht geändert werden, weil dieser bei einer späteren Bearbeitung mit dem Editor nicht mehr geparsed werden kann. Der Code darf nicht mehrzeilig sein."
  },
  "doc/editors/editor-cs.html": {
    "href": "doc/editors/editor-cs.html",
    "title": "C# Editor",
    "keywords": "C# Editor Der C#-Editor kommt unter anderem bei Properties, Methoden und Code-Klassen zum Einsatz. In den folgenden Kapiteln werden einige Features näher betrachtet und erläutert. Bracket Colorization Ein generelles Problem in C# ist das Auffinden von zusammenhängenden Klammern im Code. Besonders bei der Programmierung von komplexeren Ausdrücken, wie z.B. mathematische Berechnungen oder verschachtelte Bedingungen. Bracket Guides helfen hierbei, wenn z.B. zu einer öffnenden Klammer die schließende Klammer gesucht wird. Um aber den Gesamtüberblick über die Klammersetzung vor allem in einzeiligen Ausdrücken besser behalten zu können, bietet der C#-Editor zusätzlich die Bracket Colorization an. Dieses Feature bedient sich an drei unterschiedlichen Farben und sorgt dafür, dass direkt aufeinander folgende Klammerpaare niemals die gleiche Farbe haben. Ein Beispiel für eine entsprechende Farbmarkierung der Klammern ist in der nachfolgenden Abbildung dargestellt. Die Bracket Colorization wird auf die Klammerpaare (), {} und [] angewandt. Auch bei einer Mischung der Klammerarten in einem Ausdruck werden diese stets farblich getrennt. IntelliSense Der C# Editor bietet eine kontextabhängige IntelliSense an, die durch CRTL + SPACE oder durch verschiedene Trigger wie z.B. . geöffnet wird. Camel-Case Filter Die IntelliSense bietet einen Camel-Case Filter an, welcher die Ergebnisliste anhand der groß geschriebenen Teilwörter filtert. Im Beispiel wird AUHS getippt (muss nicht zwingend groß geschrieben werden) und der erste Treffer ist der AccessUnitHierarchySerializer. Somit ist das Ausschreiben langer Symbolnamen in den meisten Fällen nicht nötig. Word Filter Der Word Filter sucht in der Ergebnisliste nach Teilwörtern. Im Beispiel könnte ein Programmierer z.B. wissen, dass der Name der gesuchten Klasse mit Access beginnt und mit Serializer endet. Nach dem Tippen von accessseri findet der Filter den entsprechenden Eintrag und bietet den AccessUnitHierarchySerializer an. Tooltip Toggle Standardmäßig wird zusätzlich zur IntelliSense-Ergebnisliste auch der Tooltip für den derzeit ausgewählten Eintrag geöffnet. Für eine Methode werden hier z.B. weitere Informationen wie die Deklaration, Dokumentation oder die Anzahl der Überladungen angezeigt. Bei geöffneter IntelliSense kann durch das wiederholte Drücken von CTRL + SPACE der Tooltip geschlossen bzw. geöffnet werden. Danach werden abhängig vom verfügbaren Platz nur noch die ersten Wörter der Tooltip-Information in der Ergebnisliste angezeigt. Die Einstellung, ob der Tooltip angezeigt wird oder nicht, wird temporär am Editor zwischengespeichert. Wird der Editor neu geladen, wird grundsätzlich der Tooltip wieder angezeigt. IntelliSense für Methoden Methoden haben eine spezielle IntelliSense, welche in der Lage ist für alle etwaigen Überladungen, Parameter, sowie Rückgabewerte die entsprechende Dokumentation aufzubereiten. Die Methoden-IntelliSense wird durch die Trigger ( und [ nach einem Methodennamen ausgelöst oder durch das Tippen von ,, wenn sich der Cursor in der Parameterliste einer Methodendeklaration befindet. Im Beispiel existiert die Methode DoStuff in drei Ausführungen. Mit ArrowUp oder ArrowDown kann durch die Überladungen rotiert werden. Kontextabhängig werden dann folgende Informationen angezeigt (wenn vorhanden): Die Deklaration der gerade ausgewählten Überladung Die XML-Dokumentation zum derzeit aktiven Parameter Die XML-Dokumentation zur Methode Die XML-Dokumentation zum Rückgabewert IntelliSense für Code Snippets Der C# Editor bietet eine eigene IntelliSense-Liste für die im Code Snippets Editor definierten Code Snippets. Die Code Snippet IntelliSense kann über den Shortcut CTRL + J geöffnet werden. Hover Tooltip & Diagnostics Der C# Editor bietet eine breite Unterstützung für das Auffinden von etwaigen Fehlern im Code sowie das Anzeigen von Informationen zum Source Code. Hover Tooltip Befindet sich die Maus im Source Code über einem Symbol (z.B. Klasse, Property, Methode, usw.), so wird ein Tooltip mit allen kontextabhängigen Informationen zu diesem Symbol angezeigt. Im Beispiel befindet sich der Mauszeiger (nicht vom Screenshot erfasst) über der Methode DoStuff. Note In manchen Editoren, wie z.B. der Anzeige des generierten Codes, ist diese Funktionalität deaktiviert. Diagnostics Beim Programmieren wird der Source Code kontinuierlich durch den Roslyn-Compiler geprüft. Werden Fehler oder Unstimmigkeiten entdeckt, so werden diese im Code markiert. Im Beispiel ist die Methode DoStuff(int i, int j) als Obsolete markiert. Sie wird orange unterstrichen und der Hover Tooltip zeigt die entsprechende Information an. Note Fehler und Warnings haben im Hover Tooltip immer die höchste Priorität und werden als erstes angezeigt. Note In Editoren, die entweder den Status CheckedIn oder ReadOnly haben, werden keine Diagnostics ausgeführt. Diagnostics Peeking Befindet sich der Cursor auf einem markierten Fehler oder einer Warning im Code, kann mit den Shortcuts ALT + F8 vorwärts und SHIFT + ALT + F8 rückwärts durch diese gesprungen werden. Dabei wird die Gesamtzahl der sich im Code befindlichen Probleme angezeigt. Code Formatting Über den Shortcut SHIFT + ALT + F kann die Aktion Format Document ausgelöst werden. Diese formatiert den gesamten C# Code im Editor und sorgt für eine einheitliche Einrückung und Klammersetzung. So wird aus folgendem Code schön formatierter Code Customize Wen eine Methode aus dem Basis-Package im C# Editor geöffnet ist und die Möglichkeit besteht das Element (Form, Component, usw.) im aktuellen Package zu customizen, dann kann dies entweder über den Eintrag Customize im Kontextmenü oder über den Shortcut CTRL + T angestoßen werden. Note Die zu customizende Methode muss entweder mit virtual oder override deklariert sein. Go To Definition Der C# Editor erlaubt es über verschiedene Wege zur Definition eines Elements im Code zu springen. Die einfachste Möglichkeit ist das Drücken der CTRL-Taste und das Bewegen der Maus über ein Wort im Code. Im Hintergrund wird abgefragt, ob zu diesem Element überhaupt gesprungen werden kann. Im Beispiel befindet sich der Mauszeiger bei gedrückter CTRL-Taste über der Methode DoStuff. Im Hover Tooltip erscheint nun die Information Click to open App.frmApp.DoStuff. Zusätzlich wird das Wort DoStuff im Code als blauer Link dargestellt. Dies signalisiert zusätzlich, dass nun durch einen Click mit der linken Maustaste zur Definition gesprungen werden kann. Wenn sich der Cursor im Editor innerhalb des Wortes DoStuff befindet oder das gesamte Wort selektiert ist, so kann auch ohne Maus mit dem Shortcut CTRL + F12 oder über das Kontextmenü Go To Definition zur Definition gesprungen werden. Note Go To Definition funktioniert grundsätzlich mit Elementen (Methoden, Properties, usw.) aus Framework Studio, jedoch nicht mit Bibliotheken von Drittanbietern oder dem .NET Framework selbst. Go To Base Wenn eine überschriebene Methode im C# Editor geöffnet ist, die ihren Ursprung in einem Basis-Package hat, kann über den Eintrag Go To Base im Kontextmenü oder über den Shortcut CTRL + B zu dieser Basis gesprungen werden. Compare With Base Wenn eine überschriebene Methode im C# Editor geöffnet ist, kann über den Eintrag Compare With Base oder über den Shortcut CTRL + ALT + B der Diff Editor geöffnet werden und die überschriebene Methode mit deren Basis verglichen werden. Method History Browser Über den Eintrag Method History Browser im Kontextmenü oder über den Shortcut CTRL + SHIFT + M kann für die aktuell angezeigte Methode der Method History Browser aufgerufen werden. Code Snippet Editor Über den Eintrag Edit Code Snippets oder über den Shortcut CTRL + SHIFT + J kann der Code Snippet Editor geöffnet werden."
  },
  "doc/editors/editor-css.html": {
    "href": "doc/editors/editor-css.html",
    "title": "CSS Editor",
    "keywords": "CSS Editor Der CSS-Editor kommt beim Erstellen von Templates für das Template Control oder die ListView zum Einsatz. Syntax Highlighting Der Editor ist ausgestattet mit einem Syntax-Highlighter für CSS. Alle Selektoren, Properties und Werte werden farblich aufbereitet. IntelliSense Mit Tippen innerhalb eines Selektors oder mit dem Shortcut CTRL + SPACE kann die IntelliSense geöffnet werden. Diese deckt die gesamte CSS-Syntax ab und greift für die Beschreibungen einzelner Tags und Attribute auf die MDN Reference zu. Go To Symbol Über das Kontextmenü kann die Aktion Go To Symbol aufgerufen werden. Der Dialog zeigt die Struktur des CSS als Auswahlliste an. Über das Suchfeld kann sehr schnell zu einem bestimmten Selektor im CSS gesprungen werden. Code Formatting Über den Shortcut SHIFT + ALT + F kann die Aktion Format Document ausgelöst werden. Diese formattiert das gesamte CSS im Editor und sorgt für eine einheitliche Einrückung der Selektoren und Properties. Soll nur ein bestimmter selektierter Teil des Codes formatiert werden, so kann über das Kontextmenü die Aktion Format Selection ausgelöst werden. Color Chooser Bei Properties wie z.B. color, background-color oder border-color, welche eine Farbe definieren, wird vor der Farbdefinition ein kleines Viereck in der entsprechenden Farbe angezeigt. Befindet sich der Mauszeiger über dem Viereck, wird ein Dialog zur Farbauswahl angezeigt."
  },
  "doc/editors/editor-diff.html": {
    "href": "doc/editors/editor-diff.html",
    "title": "Diff-Editor",
    "keywords": "Diff-Editor Der Diff-Editor wird in FS im Element History Browser, sowie im Method History Browser verwendet. Der Aufbau und die Bedienung ist dabei immer gleich. Ergänzend zu den sprachübergreifenden Shortcuts gibt es auch spezifische Diff-Shortcuts. Bedienelemente Der Diff-Editor in FS beinhaltet den Monaco Diff-Editor und einige Buttons als Hilfscontrols. Editor Der Editor besteht aus zwei einzelnen Monaco Code-Editoren, die standardmäßig in einer SplitPane angezeigt werden. Der Editor ist immer Read-Only und dient nur zum Vergleichen von bestehendem Code. Standardmäßig sind regions, in denen keine Changes sind mit einem Offset von 8 Zeilen collapsed. Buttons Die Buttons über dem Diff-Editor erleichtern die Arbeit mit dem Editor. Compare in external tool Mit dem Compare in external tool Button werden die Texte aus dem Editor im externen Diff Tool angezeigt. Eventuell werden sie vorher noch mit zusätzlichen vorangestellten Infos bestückt. Next Change (Alt + F5) Mit dem Next Change Button kann direkt zur nächsten Änderung im Editor gesprungen werden. Alternativ kann der Shortcut Alt + F5 genutzt werden, allerdings muss dazu der Fokus im Editor sein. Previous Change (Shift + Alt + F5) Mit dem Previous Change Button kann direkt zur vorherigen Änderung im Editor gesprungen werden. Alternativ kann der Shortcut Shift + Alt + F5 genutzt werden, allerdings muss dazu der Fokus im Editor sein. Toggle View Mit dem Toggle View Button kann zwischen der Side-By-Side-View und der Inline-View gewechselt werden. Der Editor startet immer in der Side-By-Side-View, es sei denn der Editor ist schmaler als 1000px, dann wechselt er automatisch zur Inline-View. Toggle Unchanged Regions Mit dem Toggle Unchanged Regions Button können die regions, die keine changes enthalten collapsed oder expanded werden. Der Editor startet immer mit collapsed regions. Diff Review Pane Wenn der Fokus im Editor ist, kann mit F7 bzw. Shift + F7 die Diff Review Pane geöffnet werden. Diese Ansicht ermöglicht schnelles Navigieren zwischen den Änderungen und bietet eine kompakte Übersicht der Änderung. In der Diff Review Pane kann mit F7 bzw. Shift + F7 schnell zwischen den Änderungen gewechselt werden. Ist eine Zeile markiert kann mit Enter direkt zur entsprechenden Zeile im übergeordneten Diff-Editor gesprungen werden. Mit (Shift) Esc kann die Ansicht verlassen werden."
  },
  "doc/editors/editor-docml.html": {
    "href": "doc/editors/editor-docml.html",
    "title": "DocML Editor",
    "keywords": "DocML Editor Eine ausführliche Beschreibung des DocML-Editors befindet sich im Kapitel Editor für das Dokumentations-System."
  },
  "doc/editors/editor-html.html": {
    "href": "doc/editors/editor-html.html",
    "title": "HTML Editor",
    "keywords": "HTML Editor Der HTML-Editor kommt beim Erstellen von Templates für das Template Control oder die ListView zum Einsatz. Syntax Highlighting Der Editor ist ausgestattet mit einem Syntax-Highlighter für HTML. Alle Tags, Attribute und Werte werden farblich aufbereitet. IntelliSense Mit dem Tippen von Trigger-Zeichen wie < oder dem Shortcut CTRL + SPACE kann die IntelliSense geöffnet werden. Diese deckt die gesamte HTML-Syntax ab und greift für die Beschreibungen einzelner Tags und Attribute auf die MDN Reference zu. Go To Symbol Über das Kontextmenü kann die Aktion Go To Symbol aufgerufen werden. Der Dialog zeigt die Struktur des HTML als Auswahlliste an. Über das Suchfeld kann sehr schnell zu einem bestimmten Tag im HTML gesprungen werden. Rename Symbol Tags und Attribute können durch die Aktion Rename Symbol oder mit dem Shortcut F2 umbenannt werden. Der Vorteil gegenüber dem manuellen Umbenennen ist, dass auch das schließende Tag mit umbenannt wird. Code Formatting Über den Shortcut SHIFT + ALT + F kann die Aktion Format Document ausgelöst werden. Diese formattiert das gesamte HTML im Editor und sorgt für eine einheitliche Einrückung der Tags. Soll nur ein bestimmter selektierter Teil des Codes formatiert werden, so kann über das Kontextmenü die Aktion Format Selection ausgelöst werden."
  },
  "doc/editors/features.html": {
    "href": "doc/editors/features.html",
    "title": "Editor Features",
    "keywords": "Editor Features Die folgenden Kapitel beschreiben die Features der Code-Editoren in Framework Studio, welche unabhängig der Programmiersprache zur Verfügung stehen. Es werden ausschließlich die wichtigsten Features betrachtet, da eine vollständige Dokumentation aller Funktionalitäten zu umfangreich wäre und so keinen Mehrwert bietet. Command Palette Über den Shortcut F1 wird in jedem Code-Editor in Framework Studio die Command Palette geöffnet. Sie gibt einen Überblick über alle Aktionen, die im jeweiligen Kontext ausgeführt werden können. Dabei ist die Verfügbarkeit der Aktionen z.B. von der Selektion, Curserposition oder dem Status des Editors abhängig. Diejenigen Aktionen, die mit einem Shortcut versehen sind, zeigen diesen rechts in der Liste an. Auch Aktionen, die einen separaten Eintrag im Context-Menü des Editors haben, werden hier aufgeführt. Über das Suchfeld der Command Palette können alle verfügbaren Aktionen gefiltert werden. Context Menü Jeder Editor verfügt über ein Context-Menü, welches über die rechte Maustaste erreicht werden kann. Dieses ist sehr schlank gehalten und zeigt nur die wichtigsten Aktionen inkl. Shortcuts für den jeweiligen Kontext an. Shortcut Chords Es gibt einige Aktionen, die nur über einen sogenannten Shortcut Chord ausgeführt werden können. Ein Chord wird in der Command Palette folgendermaßen angezeigt: Dabei wird die CTRL-Taste gedrückt gehalten und erst K und danach C gedrückt, ohne CTRL loszulassen. Dies eröffnet neue Tastenkombinationen, da in modernen Editoren sehr oft mehr Aktionen als freie Shortcuts vorhanden sind. Zoom Mit CTRL + MouseWheel, CTRL + Numpad+ und CTRL + Numpad- kann in jedem Editor gezoomt werden. Dabei wird die Schriftgröße des Codes, nicht aber die Größe des Context-Menüs oder der Command Palette geändert. Die Änderung der Schriftgröße ist dabei nicht persistent und wird beim nächsten Laden des Editors wieder auf die in den Options hinterlegte Schriftgröße zurückgesetzt. Das manuelle Zurücksetzen der Zoom-Einstellung ist über den Shortcut Chord CTRL + K -> CTRL + 0 möglich. Fast Scrolling Wie in jedem Editor kann mit dem Mausrad gescrollt werden. Bei gedrückter SHIFT-Taste wird (wenn eine horizontale Scrollbar verfügbar ist) horizontal gescrollt. In beiden Richtungen kann die Scrollgeschwindigkeit mit zusätzlich gedrückter ALT-Taste um Faktor 5 beschleunigt werden. Dies ist gerade in Code mit sehr vielen Zeilen extrem nützlich. Source Code Minimap Links neben der normalen Scrollbar befindet sich in den meisten Editoren die Source Code Minimap. Diese Minimap ist eine zusätzliche Scrollbar, die den Source Code schemenhaft aufbereitet und somit große zusammenhängende Codeblöcke optisch einfacher erkennbar macht. Zusätzlich zeigt sie den gerade angezeigten Codeausschnitt an, wenn sich die Maus über der Minimap befindet. Sie kann auch als normale Scrollbar verwendet werden. Durch ihre größere Breite ist sie mit der Maus schlichtweg \"einfacher zu treffen\". In Code-Editoren, die aus dem Kontext heraus niemals langen Code anzeigen, ist die Minimap deaktiviert, da hier der Nutzen nicht gegeben ist. Code Folding Abhängig von der angezeigten Programmiersprache kann der Code an bestimmten Stellen für eine bessere Übersicht zusammengeklappt werden. Nachfolgend ein Beispiel in einem C# Editor: Wir empfehlen einen Blick in die Command Palette zu werfen, da dort sehr viele weitere Code Folding Aktionen inkl. Shortcuts aufgeführt sind, wie z.B. Fold oder Unfold All. Welche Codeblöcke zusammengeklappt werden können, wird durch einen kleinen Pfeil sichtbar, wenn sich die Maus über dem Bereich der Zeilennummern befindet. In den unterschiedlichen Sprachen können unterschiedliche Codeblöcke zusammengeklappt werden, diese sind im Folgenen aufgeführt: C# #region / #endregion Jeder mehrzeilige Codeblock beginnend mit einer geschweiften Klammer {, z.B. if, while oder eine Methode DocML [section] und [/section] [lst] und [/lst] [tbl] und [/tbl] [coldef] und [/coldef] [row] und [/row] HTML Alle HTML-Tags, die einen Inhalt besitzen, z.B. <body>, <div> oder <ul> CSS Alle CSS-Selektoren mit geschweiften Klammern { Single Line Copy Sehr oft kommt es vor, dass der komplette Inhalt einer bestimmten Zeile kopiert werden soll. Normalerweise muss hierfür die gesamte Zeile markiert und z.B. mit CTRL + C kopiert werden. Diese Herangehensweise ist mit dem neuen Monaco Editor nicht mehr notwendig. Um eine Zeile zu kopieren muss sich nur der Cursor in der gewünschten Zeile befinden und CTRL + C gedrückt werden. Diese Funktion ist in jedem Editor verfügbar. Es ist zu beachten, dass Single Line Copy nur funktioniert, wenn keine Selektion in der Zeile getätigt wurde, da ansonsten nur die Selektion kopiert wird. Bracket & Vertical Guides Um mit dem Auge eine bessere und schnellere Übersicht zu erhalten, in welchem Kontext sich der Cursor befindet, bietet jeder Code-Editor Bracket & Vertical Guides. Bracket Guides Befindet sich der Cursor innerhalb von Klammern, z.B. () oder {} im C# oder <> im HTML, so werden die nächstgelegenen Klammerpaare optisch hervorgehoben. Bei Code-Konstrukten, die mehrere verschachtelte Klammerpaare haben, ist so immer ersichtlich, welcher Block zur aktuellen Cursorposition gehört. Vertical Guides Hat der Source Code mehrere Einrückungen nach rechts, so werden für zusammenhängende Codeblöcke vertikale Linien angezeigt. So ist die Zuordnung der öffnenden und schließenden Klammer eines Codeblocks auf der vertikalen Achse für das Auge einfacher zu greifen. Find & Replace Der Code-Editor hat einen integrierten Dialog für Find & Replace, welcher über CTRL + F (Find) oder CTRL + H (Replace) aufgerufen werden kann. Mit dem Pfeil links im Dialog kann zwischen den beiden Modi umgeschaltet werden. Multi-Cursor Support Multi-Cursor Support ist ein sehr mächtiges Feature im Code-Editor. Es erlaubt das Selektieren und Manipulieren von Text an mehreren Stellen im Code gleichzeitig. Dabei gibt es mehrere Möglichkeiten diesen Änderungsmodus zu aktivieren. Diese werden im Folgenden näher erklärt. Selektion mit mittlerer Maustaste Die Selektion im Bild wurde mit der mittleren Maustaste (anstatt mit der linken Maustaste) getätigt. Dies hat zur Folge, dass für jede Zeile ein neuer Cursor erstellt wird. Anschließend kann wie gewohnt mit den Pfeiltasten navigiert, Text gelöscht oder normal getippt werden. Alle Aktionen erfolgen an jedem Cursor einzeln. Nächstes Duplikat zur Selektion hinzufügen Die Aktion Add Selection To Next Find Match, ausgelöst durch den Shortcut CTRL + D, sucht ausgehend von der derzeitigen Selektion das nächste Duplikat und fügt dieses als Multi-Cursor-Selektion zur Auswahl hinzu. Die Auswahl im Bild kommt folgendermaßen zustande: Doppelklick auf int in Zeile 3 um das Wort zu markieren 4x CTRL + D ausführen Diese Art der Multi-Selektion ist dann von Vorteil, wenn die zu ändernden Wörter über den gesamten Code verteilt sind und durch anderen Code unterbrochen werden. Dies macht eine Selektion mit der mittleren Maustaste unmöglich. Alle Duplikate ändern Ist ein Wort im Code selektiert, so können mit der Aktion Select All Occurances (CTRL + F2) alle äquivalenten Wörter im Code selektiert und per Multi-Cursor manipuliert werden. Für die Selektion im Bild wurde int in Zeile 3 selektiert und anschließend CTRL + F2 ausgeführt. Zu beachte ist, dass im Gegensatz zum 4-maligen Ausführen von CTRL + D auch das int in Zeile 1 markiert wurde. An welcher Stelle die initiale Selektion stattfindet, ist also nicht von Bedeutung. Es wird immer der gesamte Code nach Duplikaten durchsucht."
  },
  "doc/editors/index.html": {
    "href": "doc/editors/index.html",
    "title": "Editoren",
    "keywords": "Editoren Framework Studio bietet für C#, HTML, CSS, XML und DocML einen speziell für die jeweilige Sprache optimierten Editor an. Als technisches Grundgerüst dient dabei der aus Microsofts Visual Studio Code bekannte Monaco Editor. So stehen die bekannten Features, wie IntelliSense, Code Highlighting, Indent Guides, Multi-Cursor Support oder Code Folding nun auch Framework Studio zur Verfügung. Technische Details Der Monaco Code-Editor ist eine Webanwendung basierend auf HTML, CSS und JavaScript. Der Editor wurde primär für die Integration in Electron-Anwendungen, wie Visual Studio Code, konzipiert, da diese im Gegensatz zu einem Browser auch Zugriff auf Betriebssystem-Resourcen bieten. Dennoch ist der Monaco Editor auch im normalen Browser lauffähig. In dieser Umgebung gibt es zwar Abstriche in der Funktionalität, diese sind für Framework Studio jedoch nicht relevant. Die folgende Abbildung zeigt eine Übersicht, wie der Monaco Code Editor in Framework Studio eingebunden ist. Die Einbindung der Editoren in Framework Studio erfolgt über ein integriertes Chromium Browser Control und einen ebenfalls in FS integrierten Webserver. Jeder Editor nutzt dabei einen separaten Prozess, welcher sich als Sub-Prozess unter den Framework Studio Hauptprozess hängt. Soll z.B. ein C#-Editor in einem Form oder einer Component angezeigt werden, so wird der C#-Editor in FS damit beauftragt eine neue Monaco-Instanz zu initialisieren. Folgender Ablauf findet bei jedem Laden eines Editors in FS statt: Der C# Code-Editor in FS lädt ein Chromium Browser Control Ist das Browser Control geladen, wird anschließend asynchron eine Angular App vom integrierten Webserver geladen und ausgeführt Die Angular App lädt wiederum asynchron den Monaco Code-Editor und zeigt letztendlich den gewünschten Code an Ab diesem Zeitpunkt kann der Code-Editor im jeweiligen Kontext vollumfänglich verwendet werden Der gesamte Initialisierungsprozess ist im Normalfall in wenigen Millisekunden abgeschlossen, sodass keinerlei Unterschiede zu einem normalen Editor-Control erkennbar sind. Die Performance des Monaco Editors ist dabei so hoch, dass beim Arbeiten nicht erkennbar ist, dass es sich tatsächlich um eine Webanwendung handelt. Editor Status In den meisten Fällen wird in Framework Studio ein CheckOut angestoßen, wenn versucht wird an einem eingecheckten Element (Form, Component, usw.) eine Änderung vorzunehmen. Aufgrund des technischen Grundgerüsts des Monaco Editors ist diese Funktionalität innerhalb des Code Editors nicht implementierbar. Dies hat zur Folge, dass das Tippen im Code Editor nicht mehr zu einer automatischen CheckOut Meldung führt. Ein Editor kann die drei unterschiedlichen Status annehmen: Default Der Editor hat eine weiße Hintergrundfarbe und das Element, für welches Code angezeigt wird, ist ausgecheckt. Dies signalisiert, dass der Editor in vollem Umfang im jeweiligen Kontext zur Verfügung steht. CheckedIn Der Editor hat einen gelben Hintergrund und beim Versuch zu tippen wird eine Meldung angezeigt, dass dies gerade nicht möglich ist. Die gelbe Hintergrundfarbe signalisiert jedoch, dass durch ein Auschecken des Elements der Editor in den Status Default wechseln kann. Durch Auschecken wird der für den jeweiligen Kontext angezeigte Code editierbar. Die schnellste Möglichkeit das Element auszuchecken, auch wenn der Fokus im Editor liegt, ist der Shortcut CTRL + F10. ReadOnly Der Editor hat eine graue Hintergrundfarbe und es kann wie beim Status CheckedIn nichts getippt werden. Die graue Hintergrundfarbe signalisiert auch, dass sich am Status des Editors durch ein etwaiges Auschecken des Elements nichts ändern wird. ReadOnly-Editoren bleiben also in jedem Kontext grau. Sie werden z.B. zum Anzeigen des generierten Codes verwendet. Features Die in den Editoren verfügbaren Features sind zum Großteil abhängig von der angezeigten Programmiersprache. Die wichtigsten Features werden in den folgenden Kapiteln im Detail behandelt: Sprachunabhängige Features C# Editor HTML Editor CSS Editor DocML Editor Diff Editor"
  },
  "doc/form/control/browser.html": {
    "href": "doc/form/control/browser.html",
    "title": "Browser",
    "keywords": "Browser Properties/Events Actions Mit dem Browser-Control ist es möglich Html-Inhalte oder Grafiken darzustellen. Hierfür bietet das Control zwei verschiedene Modi an. Der Browser-Modus ist für das Anzeigen von Webseiten geeignet und bietet hierzu eine Addressleiste an, mit der zwischen Webseiten hin und her navigiert werden kann. In der Statusleiste kann der Ladefortschritt der aktuellen Seite, sowie die Links zu denen mit der Maus navigiert werden kann, angezeigt werden. Der Content-Modus ist zum Anzeigen von Grafiken oder lokalen Html-Seiten geeignet. Dieser Modus verfügt über keine Navigations- und Statusleiste. In beiden Modi kann zusätzlich eine Zoomleiste eingeblendet werden, mit der Inhalte vergrößert bzw. verkleinert werden können. Der Inhalt kann außerdem mit dem Mausrad und gedrückter STRG-Taste vergrößert bzw. verkleinert werden. Alle angeklickten Links werden konsumiert und müssen, falls gewollt, über das OnLinkClick-Event abgefangen und manuell über eines der Datasources wieder an den Client geschickt werden. Das BrowserControl bietet keinen vollständigen Browserersatz. Viele elementare Funktionen eines echten Browsers, wie das Herunterladen von Dateien oder die Verwendung von Cookies sind nicht vorhanden. Außerdem ist die Browser-Engine nicht auf dem neusten Stand der Technik, unterstützt aber sowohl Html5 wie auch CSS3. Falls Links in einem echten Browser angezeigt werden sollen, kann mit der Funktion ViewDocument(string url) der Standart Browser geöffnet werden. Developer tools aktivieren Beim neuen JxBrowser können die Developer tools verwendet werden. Zunächst muss die Option aktiviert werden, indem dem FS Client Launcher über die VM-Arguments folgender Wert mitgegeben wird: -Dfs.browser.developertools=1 Anschließend können Sie die Developer tools in der gestarteten Applikation über den Kontextmenüeintrag Developer tools des Browsers öffnen."
  },
  "doc/form/control/button.html": {
    "href": "doc/form/control/button.html",
    "title": "Button",
    "keywords": "Button Properties/Events Actions"
  },
  "doc/form/control/checkbox.html": {
    "href": "doc/form/control/checkbox.html",
    "title": "Checkbox",
    "keywords": "Checkbox Properties/Events Actions"
  },
  "doc/form/control/combobox.html": {
    "href": "doc/form/control/combobox.html",
    "title": "ComboBox",
    "keywords": "ComboBox Properties/Events Actions Lazy-Loading Wenn ein Form Comboboxen beinhaltet, die sehr viele Listen-Einträge besitzen, dann kann das zu spürbaren Verzögerungen in der Anwendung führen, weil diese Listen zum einen im XML kommuniziert und auch vom Client aufbereitet werden müssen. Für diesen Fall gibt es einen neuen Mechanismus, bei dem solche Combobox-Listen erst bei Bedarf an den Client übertragen werden - und zwar dann, wenn die Combobox aufgeklappt wird. Comboboxen mit bis zu 50 Listen-Einträgen werden weiterhin komplett übertragen. Bei so kleinen Listen würde sich eine extra Anfrage an den Broker nicht rechnen."
  },
  "doc/form/control/context-menu.html": {
    "href": "doc/form/control/context-menu.html",
    "title": "ContextMenu",
    "keywords": "ContextMenu Properties/Events Actions Buttons und ImageButtons können bei Betätigung ein Kontextmenü öffnen. Dazu muss dem Button über das Property ContextMenu ein ContextMenu zugeordnet werden. Das Control ContextMenu stellt lediglich eine Hülle dar, in der alle Menüeinträge gesammelt werden, die angezeigt werden sollen, wenn das Kontextmenü geöffnet wird. Ein neues ContextMenu lässt sich im Form-Designer (Allgemeiner Überblick) auf zwei Arten per Drag&Drop anlegen: Aus der Toolbox (Registerkarte Toolbox) heraus auf die DefaultVariant des Forms (also auf den Hintergrund des Forms) im Designer-Fenster: Das Kontextmenü wird angelegt und ist keinem Button zugeordnet. Aus der Toolbox heraus direkt auf einen Button (oder ImageButton): Das Kontextmenü wird angelegt und dem Button zugeordnet. Der Name wird dabei mit men, gefolgt von dem Namen des Buttons, vorbelegt. Kontextmenüs werden im ClassView (Registerkarte Class) immer im Teilbaum unterhalb der DefaultVariant ggf. parallel zum Hauptmenü (MainMenu) angezeigt. Am Kontextmenü können im ClassView (wie bei anderen Menüs) neue Menüeinträge über den Eintrag New MenuItem im Kontextmenü des Treeviews angelegt werden. Warning Beim Löschen eines Kontextmenüs wird nicht überprüft, ob das Kontextmenü bereits einem Button zugeordnet ist."
  },
  "doc/form/control/dashboard-container.html": {
    "href": "doc/form/control/dashboard-container.html",
    "title": "DashboardContainer",
    "keywords": "DashboardContainer Properties/Events Actions Der Dashboard Container kann Dashboards enthalten. Dashboards werden in Form von Registerkarten angezeigt und bestehen aus einer oder mehreren Spalte(n), die die Dashboard Items beinhalten. Das Dashboard Container Steuerelement ermöglicht es, mehrere Instanzen eines Formulars in einer vom Benutzer bestimmten Weise anzuzeigen. Das bedeutet, dass der Benutzer diese Instanzen erstellen, verschieben, maximieren, nach dem Maximieren wiederherstellen, vergrößern, verkleinern und schließen kann. Jedoch sind alle Aktionen auf das jeweilige Dashboard beschränkt. Folglich kann kein Dashboard Item aus dem Dashboard Container herausgeschoben werden. Am Dashboard lässt sich eine DataSource festlegen. Darin wird, sobald Änderungen am Layout vorgenommen werden, das neue Layout als XML-string hinterlegt. Wird die DataSource Broker-seitig verändert, so wird das neue Layout vom Client umgesetzt. Zusätzlich gibt es ein OnLayoutChanged-Ereignis am Dashboard Container, welches am Broker aufgerufen wird, sobald am Client eines dieser Layout ändernde Ereignisse auftritt: Positions-/Größenänderung der Dashboard Items Hinzufügen/Entfernen von Dashboard Items Maximieren/Wiederherstellen von Dashboard Items Hinzufügen/Entfernen von Registerkarten Umbenennen von Registerkarten Registerkartenwechsel Damit dies nicht zu oft geschieht, gibt es einen Bearbeitungsmodus, der für solche Aktionen (mit Ausnahme des Registerkartenwechsels) aktiviert sein muss. Der Bearbeitungsmodus kann durch die Methode SetEditable am Dashboard Container Steuerelement gesteuert werden. Ein Dashboard Item kann durch Spezifizierung des Dashboard Containers am Workflow Link geöffnet werden:"
  },
  "doc/form/control/dockpanel.html": {
    "href": "doc/form/control/dockpanel.html",
    "title": "DockPanel",
    "keywords": "DockPanel Properties/Events Actions Mit dem DockPanel ist es möglich, einen Fenster-Bereich in horizontal oder vertikal angeordnete Bereiche aufzuteilen. Alle Child-Controls des Dock-Panels werden abhängig von der am DockPanel eingestellten DockPanelOrientation nebeneinander (Horizontal) oder übereinander (Vertical) platziert. Mit der Einstellung HorizontalOrVertical „klappt“ das DockPanel auf die Seite, wenn der Platz horizontal nicht ausreicht. Jedes Control, welches sich direkt in einem Dock-Panel befindet, hat die Eigenschaft DockPanel.ItemSize. Hier kann eine Gewichtung angegeben werden, mit der der zur Verfügung stehende Platz vom jeweiligen Control aufgefüllt werden soll. Grundsätzlich soll dort möglichst der Wert „100“ eingegeben werden – auch bei mehreren gleichberechtigten Controls („100“, „100“). Verschiedene Gewichtungen werden z.B. mit „100“ / „50“ angegeben. Mit dem Wert „None“ wird das Control in seiner minimalen Größe angezeigt."
  },
  "doc/form/control/editfield.html": {
    "href": "doc/form/control/editfield.html",
    "title": "Editfield",
    "keywords": "Editfield Properties/Events Actions Unterstütztes HTML Wenn die Eigenschaft Editor auf den Wert HTML gesetzt ist, wird am Datasource des Controls HTML Text erwartet. Das Control bietet keine vollständige Unterstützung von Html. Es folgt ein Überblick über die Einschränkungen: Das Control ist zur Darstellung von formatiertem Text gedacht. Daher werden keinerlei Eingabefelder o.ä. unterstützt. Textinhalt müssen (selbstverständlich) HTML-Encodiert dargestellt werden. Das Control kann nur Zeichen darstellen, die im Zeichensatz der eingestellten Schrift enthalten sind. Wenn am Control WordWrap eingeschaltet ist, wird (im Gegensatz zum Plain Text Modus) nur zwischen Worten getrennt. Wenn also ein Wort länger ist als die Control Breite, wird nicht umgebrochen! Dabei ist zu beachten, dass Sonderzeichen wie beispielsweise &nbsp; als Wortteil betrachtet werden. Schriftgrößen, die in Punkten (pt) angegeben sind, werden analog zu allen Schriftgrößenangaben in Framework Studio im Java Client skaliert und in mit Crystal Reports erstellten Dokumenten korrekt angezeigt. Die Definition von Schriftgrößen in einer anderen Einheit als pt wird nicht unterstützt. Ist keine Schriftgröße im Html angegeben, wird am Control die im Form Designer angegebene Größe verwendet, in Reports die dort angegebene Größe. Jeder Textinhalt muss innerhalb eines <p> Tags (Absatz) geklammert sein. Insbesondere werden deshalb die folgenden Tags nicht unterstützt: Überschriften <h1> .. <h6> Horizontale Linie <hr> Tabellen <table> <tr> <td> Aufzählungen <ol> <ul> <li> Scripte <script> Zeilenumbrüche dürfen nicht mit <br> Tags realisiert werden, da mehrere <br> Tags hintereinander vom Crystal Reports nicht korrekt dargestellt werden können. Stattdessen müssen mit den Tags <p style=\"margin-top: 0\"> und </p> Absätze umschlossen werden. <p> Tags können neben der Definition von margin-top im style Attribut weitere Attribute und Stilangaben enthalten sein. Bilder können mithilfe eines <img alt=\"bild\" src=\"data:image/png;base64, BORw0KGgoAAAANSUhEUgA.../> Tags und im base64 Format eingebunden werden. Auch das Einfügen aus der Zwischenablage im Java-Client wird unterstützt. Im Html-Modus liefert der Datasource den Inhalt eines Body-Elements. Gesetzt werden darf auch ein vollständiges Html-Dokument. In diesem Fall wird der Body automatisch extrahiert. Note Hinweise zu Bildern: Reports, die mit DevExpress® erstellt werden, unterstützen diese Bilder. Reports, die mit Crystal Report erstellt werden, unterstützen diese Bilder nicht. Wenn Bilder aus der Zwischenablage nicht von dem Dateityp PNG oder JPEG sind, werde diese zu einem der Dateitypen konvertiert. Bei der Konvertierung wird auf die entstehende Dateigröße geachtet und die Datei (entweder PNG oder JPEG) genommen, die am wenigsten Speicher verbraucht. Sollte die PNG Datei bis maximal 20 Prozent größer als die JPEG Datei sein, wird trotzdem wegen der besseren Qualität die PNG Datei verwendet."
  },
  "doc/form/control/erzeugen-suchdialogs-property.html": {
    "href": "doc/form/control/erzeugen-suchdialogs-property.html",
    "title": "Erzeugen eines Suchdialogs durch Property-Funktionalität",
    "keywords": "Erzeugen eines Suchdialogs durch Property-Funktionalität Wenn Sie sich die Properties der Controls aufmerksam angesehen haben, ist Ihnen sicher aufgefallen, dass Sie z.B. Buttons als IsSearchButton und Edit-Felder als IsSearchField deklarieren können. Framework Studio bietet die Möglichkeit, relativ einfach Suchbedingungen anhand der vorhandenen Controls zu erzeugen und auch automatisch einen Load an einer Component oder Collection mit dieser Suchbedingung auszuführen. Die Felder, die sich an der Suchbedingung beteiligen sollen, werden entsprechend mit dem Property IsSearchField gekennzeichnet. Damit das funktioniert, muss den Controls als Datasource ein Property der Component zugeordnet sein, aus der die Suchbedingung erstellt werden soll. Wollen Sie z.B. einen Kundensuchdialog erstellen, werden Suchfelder als DataSource Properties der Komponente Kunden haben. Definieren Sie die Felder entsprechend als IsSearchField und stellen unter SearchOperator den Suchoperator ein. Ein weiteres Element der Suche mit Property-Funktionalität sind Buttons. Buttons können als IsSearchButton deklariert werden. In unserem Beispiel würden Sie einen Button oder ImageButton als solchen kennzeichnen. Jetzt müssen Sie dem Button noch sagen, an welcher Collection der Load ausgeführt werden soll. Dies tun Sie mit der Eigenschaft LoadAtComponent. In unserem Beispiel könnte das die KundenCollection sein. Als letztes müssen Sie noch bestimmen, aus welcher Component die Suchbedingung stammt. Das ist immer die Component, aus der die Properties der Suchfelder stammen, also in dem Beispiel Kunden. Tragen Sie die Component entsprechend unter SearchValuesComponent ein. Ihr Suchdialog ist fertig. Bei einem Klick auf den Such-Button wird geprüft, ob in einem als Suchfeld definierten Control ein Wert hinterlegt worden ist. Ist dies der Fall, wird das Feld entsprechend dem Operator in Ihre Suchbedingung aufgenommen. Ist ein Property einer Komponente als SearchField deklariert, steht Ihrem Form eine Methode mit dem Namen GenerateLoadConditionOnXxxXxx zur Verfügung. Diese Methode baut Ihren Select-String zusammen. Die Einstellungen an dem Such-Button bewirken, dass dieser automatisch einen Load in der Form LoadAtComponent.Load( GenerateLoadConditionOnXxxXxx) erzeugt. Wenn Sie die Suche lieber selber ausprogrammieren, können Sie die Suchbedingung auch modifizieren."
  },
  "doc/form/control/events.html": {
    "href": "doc/form/control/events.html",
    "title": "Events",
    "keywords": "Events Events sind Ereignisse, die durch die Interaktion mit einem Formular entstehen. Der Klick auf einen Button ist z.B. ein OnClick-Event. Sie haben in Framework Studio die Möglichkeit, auf solche Ereignisse zu reagieren. Erzeugen Sie dazu ein Event und binden es an Ihr Control. Sie sollten dabei beachten, dass beim Eintreten eines Events jedes Mal eine Interaktion zwischen dem Webserver und dem Client stattfindet. Workflow-Events dienen der Interaktion mit anderen Dialogen, Form-Events der Abarbeitung von Logik aufgrund eines Ereignisses. Der einfachste Weg ein Event zu erzeugen, ist aus dem Kontext-Menü des Controls den Eintrag Event und anschließend das gewünschte Event auszuwählen. Jetzt müssen Sie noch bestimmen, ob Sie ein Form-Event oder ein Workflow-Event wünschen. Es öffnet sich ein kleines Fenster, über das Sie eine vorhandene Event-Handler Methode auswählen oder einfach eine neue erstellen können. MethodAssignerForm: Manche Events verfügen über spezielle EventArgs, über die Sie Kontext-Informationen des aufgetretenen Events ermitteln können. Siehe ControlDesignViewModel"
  },
  "doc/form/control/field-row.html": {
    "href": "doc/form/control/field-row.html",
    "title": "FieldRow",
    "keywords": "FieldRow Properties/Events Actions Stellt eine Zeile in einem Field-Panel dar. Werden Controls in einem FieldPanel platziert, dann erfolgt dies immer mithilfe einer FieldRow."
  },
  "doc/form/control/fieldpanel.html": {
    "href": "doc/form/control/fieldpanel.html",
    "title": "FieldPanel",
    "keywords": "FieldPanel Properties/Events Actions Das FieldPanel dient dazu, eine zusammenhängende Gruppe primär von Feldern – aber auch von anderen Controls – darzustellen. Die Labels der Controls werden automatisch erzeugt und vor die entsprechenden Controls positioniert. Es sind keine separaten Label-Controls nötig. Ein Field-Panel besteht immer aus den FieldRows, in denen die eigentlichen Controls platziert werden. Die Controls werden linksbündig nebeneinander angeordnet. Wenn ein oder mehrere Controls eine flexible Breite besitzen, dann wird der zur Verfügung stehende Platz komplett gefüllt. Die flexiblen Controls teilen sich dabei den kompletten Platz, gewichtet nach ihrer MinWidth auf."
  },
  "doc/form/control/form-container.html": {
    "href": "doc/form/control/form-container.html",
    "title": "FormContainer",
    "keywords": "FormContainer Properties/Events Actions Der Form Container ist ein Panel, welches genau eine Instanz eines Formulars enthalten kann. Um hierin ein Formular zu öffnen, muss am Workflow Link der Container-Wert gesetzt werden: Wird ein Formular in einem FormContainer geöffnet, der bereits ein Formular beinhält, so wird das alte zuvor entfernt."
  },
  "doc/form/control/grid-column.html": {
    "href": "doc/form/control/grid-column.html",
    "title": "Grid-Column",
    "keywords": "Grid-Column Properties/Events Actions Ist einem Grid eine Collection als Datasource zugewiesen, können die Properties des Collection-Objekts dem Grid als Columns zugewiesen werden."
  },
  "doc/form/control/grid.html": {
    "href": "doc/form/control/grid.html",
    "title": "Grid",
    "keywords": "Grid Properties/Events Actions Grid Beispiel Das Grid stellt Daten in tabellarischer Form dar. Grid Sortierung Dem Client bietet das Grid außerdem die Möglichkeit die Daten per Mausklick auf den entsprechenden Spaltenkopf sortiert darzustellen. Gedrückthalten der Umschalttaste ermöglicht es, auch mehrere Spalten eines Grid Controls per Mausklick zu sortieren. Dabei hat die zuerst (ohne Umschalttaste) ausgewählte Spalte die höchste Priorität. Durch weitere Klicks mit Umschalttaste kann das zweite, dritte, … Sortier-Kriterium angegeben werden. Wenn der Kopf einer bereits sortierten Spalte erneut mit gedrückter Umschalttaste angeklickt wird, dann wird für diese Spalte die Sortier-Richtung geändert (aufsteigend, absteigend, unsortiert) und sie wird als Sortier-Kriterium niedrigster Priorität hinten angestellt. Das Kontextmenü eines Spaltenkopfs arbeitet ausschließlich im Mehrfach-Sortierungs-Modus und enthält einen weiteren Eintrag, um sämtliche Sortierungen zurückzusetzen: Grid Filter Außerdem kann auch für jede Spalte ein Filter über das Kontextmenü definiert werden. Hier gilt ebenfalls die Regel, dass das Kontextmenü grundsätzlich Mehrfach-Filterung zulässt und eine Möglichkeit zum Zurücksetzen bietet. Der Filterdialog erscheint durch den Kontextmenüeintrag Filter / Filter anpassen. Bei Spalten mit Datumswerten kann durch Rechtsklick auf das darin enthaltene Eingabefeld ein Kalender aufgerufen werden: Für Checkboxen bietet der Client eine spezielle Filteroption. Es kann nach Checked/Aktiviert oder Unchecked/Deaktiviert gefiltert werden. Gibt es Datensätze mit Null-Werten, werden diese bei der Checkbox-Filterung als Unchecked gewertet. Allgemeines zu den Row-Icons Hinter jedem Grid steckt eine Collection und hinter jeder Zeile ein Objekt aus der Collection. Das Row-Icon zeigt den Status dieses Objekts an (neu, geändert oder gelöscht). Das Property RowHeader muss auf DisplayRowStatus eingestellt sein, damit die Icons angezeigt werden."
  },
  "doc/form/control/image-button.html": {
    "href": "doc/form/control/image-button.html",
    "title": "Image Button",
    "keywords": "Image Button Properties/Events Actions Ein Image-Button ist ein Bild, das sich wie ein Push-Button verhält. Wenn Sie dem Image-Button als Bild eine GIF-Datei mit transparentem Hintergrund zuweisen, können Sie, wie die Abbildung zeigt, Buttons in beliebigen Formen erstellen. Dem Button können Sie vier verschiedene Bilder zuweisen. Ein Bild für den normalen Zustand, eins das angezeigt wird, wenn der Button disabled ist, eins das angezeigt wird, wenn sich die Maus über dem Button befindet und eines, das dann angezeigt wird, wenn auf den Button geklickt wird."
  },
  "doc/form/control/is-visible-editable-au.html": {
    "href": "doc/form/control/is-visible-editable-au.html",
    "title": "IsVisibleAU / IsEditableAU",
    "keywords": "IsVisibleAU / IsEditableAU Die Control-Eigenschaften IsVisibleAU und IsEditableAU stellen jeweils eine Liste von AccessUnit Objekten verknüpft mit je einem AUPermissionType dar. Für jeden dieser Listeneinträge wird bei der Initialisierung der Form-Controls mit Hilfe der Methode IGlobalObjects.AUHelper.Granted(AccessUnit, AUPermissionType) geprüft, ob der Zugriff gewährt wird. Falls dies bei keinem der Einträge zutrifft und die Liste nicht leer ist, so wird das entsprechende Control unsichtbar (bei IsVisibleAU) bzw. kann nicht bearbeitet werden (bei IsEditableAU). Wenn das Property IsVisible bzw. IsEditable bereits auf false gesetzt wurde, haben die Properties keine Auswirkungen. Eine spezielle Access Unit ist die FormAccessUnit. Sie ist, worauf der Name bereits hinweist, dem Form zugeordnet. Im Fall von IsVisibleAU und IsEditableAU ist die äußerste Spezialisierung in der Vererbungskette relevant. Wird eine Eigenschaft in einem vererbten From oder im Customizing überschrieben, so wirken die Listeneinträge als wären sie mit denen aus der Basis vereinigt. Warning Bei kritischen Aktionen sollte weiterhin eine Prüfung der Access Units auf funktionaler Ebene erfolgen. Controls könnten durch Überschreibungen von IsVisibleAU/ IsEditableAU oder den Actions SetVisible(bool)/SetEnabled(bool) sichtbar bzw. zugänglich gemacht werden. Der Dialog zum Festlegen der Properties IsVisibleAU und IsEditableAU, der beim Klick auf den Button im Property Grid erscheint, zeigt links eine AccessUnit-Textbox und die FormAccessUnit zur Auswahl an. Rechts sind die in der Liste enthaltenen Access Units. Die in der Mitte befindlichen Buttons fügen eine im linken Bereich ausgewählte AccessUnit aus der Textbox oder die FormAccessUnit ein (Alle Buttons mit diesem Pfeil: ). Eine selektierte AccessUnit auf der rechten Seite kann über den Button entfernt werden. Dialog zur Bearbeitung von IsVisibleAU/IsEditableAU"
  },
  "doc/form/control/label.html": {
    "href": "doc/form/control/label.html",
    "title": "Label",
    "keywords": "Label Properties/Events Actions Das Label dient dazu, Text in einer Maske anzuzeigen. Sie können einem Label einen festen Text zuweisen und somit z.B. andere Controls mit einer Beschriftung versehen. Dieser Text wird mehrsprachig hinterlegt. Es ist auch möglich einem Label einen Datasource zuzuweisen. So können Sie auch Inhalte von Properties anzeigen."
  },
  "doc/form/control/listbox.html": {
    "href": "doc/form/control/listbox.html",
    "title": "Listbox",
    "keywords": "Listbox Properties/Events Actions Bei einer Listbox handelt es sich im Grunde um eine Combobox, die immer ausgeklappt ist."
  },
  "doc/form/control/listview.html": {
    "href": "doc/form/control/listview.html",
    "title": "ListView",
    "keywords": "ListView Properties/Events Actions Note Dieses Control funktioniert nur im Mobile-Client. Im Java-Client wird das Control nicht angezeigt. ListView Template Editor Der ListView Template Editor bietet die Möglichkeit, das HTML/CSS Template für ListItems sprachabhängig zu definieren. Dabei können Template DataSources definiert werden, auf welche aus dem HTML heraus mittels Template Variablen verwiesen wird. So können sehr einfach Businessdaten ins HTML eingebettet und formatiert werden. Der Editor kann im Property-Grid über das Property Template geöffnet werden. Allgemein Dropdown für Sprachauswahl Das HTML und CSS eines ListItems kann, wenn gewünscht, für jede Sprache einzeln definiert werden. Ist für eine Sprache kein Template definiert, wird auf Deutsch zurückgegriffen. Button Validate Über diesen Button können die im HTML eingebetteten Template Variablen und Template MLKeys überprüft werden. Es werden folgende Fälle geprüft: Ist der Template MLKey parsebar und ist der MLKey-Name gültig? Ist die Template Variable parsebar? Passt das angegebene Format zum Datentyp? Zeigt die Template Variable auf eine existierende Template DataSource? Ist jeder Template DataSource eine valide DataSource zugeordnet Template DataSources Auf der rechten Seite der Registerkarte HTML befindet sich die Liste der definierten Template DataSources. Jede Template DataSource zeigt auf ein Property der der ListView zugeordneten DataSource Collection. Im Beispiel ist der ListView die cdArticleColl aus dem FSDemo als DataSource zugewiesen. Somit stehen einer Template DataSource alle Properties des cdArticle-Objekts zur Verfügung. Wie im Bild zu sehen, verweist die Template DataSource Price auf das Property decPrice von cdArticle. Der Name einer Template DataSource muss eindeutig sein. Aus dem HTML kann nun mittels einer Template Variable auf die Template DataSource zugegriffen und der Wert wie gewünscht im HTML formatiert werden. HTML Auf der linken Seite der Registerkarte HTML befindet sich der HTML-Codeeditor, in dem das HTML für das ListItem definiert werden kann. Note Das benutzerdefinierte HTML wird zur Laufzeit vom HTML Client (Angular) compiliert und optimiert. Grobe Fehler wie z.B. nicht geschlossene Tags oder invalides HTML können zu Anzeigefehlern führen, die unter Umständen auch andere Bereiche des HTML Clients betreffen. ListView Templates sollten vor dem produktiven Einsatz in allen verfügbaren Browsern ausgiebig getestet werden. Button Use Base Mit dem Button Use Base kann das HTML Template z.B. nach einem Customizing wieder auf die Basis zurückgesetzt werden. Button Template Variable Mit dem Button Template Variable kann eine neue Template Variable erstellt, oder eine bestehende geändert werden. Button MLKey Mit dem Button MLKey wird das MLKey-Wörterbuch geöffnet. Dort kann ein neuer Template MLKey erstellt, oder ein bestehender geändert werden. HTML Aufbau Der benutzerdefinierte HTML Code wird im HTML Client in ein <div>-Tag mit der CSS-Klasse lvItem verpackt. Es ist also nicht unbedingt nötig, um den eigenen HTML Code ein <div>-Tag als Container zu implementieren. Der Code aus dem Beispiel sieht im HTML Client z.B. so aus: <hc-listitem-content _nghost-wvt-c19 class=\"ng-star-inserted\"> <div _ngcontent-wvt-c19 class=\"lvItem\"> <img _ngcontent-wvt-c19 src=\"http://localhost:8080/Dev/NV286_1_ListView40_FSDemo_4.0_user1/FSDempApplication//images/NVNew1.png\"> <span _ngcontent-wvt-c19>Laptop SILBER kostet 1,899.00€</span> </div> </hc-listitem-content> Das <div>-Tag mit der CSS-Klasse lvItem kann im CSS wie gewünscht angepasst werden, ohne einen eigenen Container oder eine eigene CSS-Klasse verwenden zu müssen. Placeholder Die Konstante %FILESURL% kann im HTML verwendet werden, um zur Laufzeit die Broker-Url zu erhalten. Dadurch können z.B. in <img>-Tags auf Bilder, welche als Ressourcen im Framework Studio hinterlegt wurden, zugegriffen werden. Dynamische Bilder können über eine binäre Template-Variable realisiert werden. (siehe Abschnitt Images im ListViewItem) Template Variablen Über den Button Template Variable öffnet sich der Template Variable Editor. Befindet sich der Cursor im Codeeditor auf einer bestehenden Template Variable, wird diese im Editor vorselektiert. Auf der linken Seite werden alle zur Verfügung stehenden Template DataSources aufgelistet. Auf der rechten Seite kann für die Template Variable ein passendes Format und/oder FormatPattern definiert werden. Durch die Aufteilung in Template DataSources und Template Variablen werden die Daten und deren Formatierung im HTML strikt voneinander getrennt. Beispielsweise könnte der Wert einer Template DataSource im englischen HTML anders formatiert werden als im deutschen HTML. Template Variablen werden im HTML-Code wie folgt angezeigt: {{ ds:[Name]|f:[Format]|fp:[FormatPattern] }} Dabei verweist [Name] auf den Namen der zugehörigen Template DataSource, [Format] und [FormatPattern] definieren das im Template Variable Editor ausgewählte Format und FormatPattern. PreviewValue ist derjenige Wert, der für die Template Variable angezeigt wird, wenn das Template auf der Registerkarte Preview zur Vorschau gerendert wird. Der Wert wird zur Laufzeit ignoriert. Note Es wird empfohlen, Template Variablen und Template MLKeys immer über den jeweiligen Editor zu ändern, um Syntaxfehler zu vermeiden. Template MLKey Template MLKeys werden im HTML-Code wie folgt angezeigt: {{ mlkey:[MLKey-Name] }} Dabei verweist [MLKey-Name] auf den Namen des zugehörigen MLKeys. Zum Beispiel \"SYS_OK\". CSS Das benutzerdefinierte HTML kann mittels CSS im CSS-Codeeditor auf der Registerkarte CSS beliebig angepasst werden. Beispiel: .lvltem { display: flex; flex-direction: row; align-items: center; background-color: azure; border-radius: 0.3rem; border: 0.1rem solid gray; padding: 0.3rem; padding-right: 2.8rem; } .lvItem[lvdisabled] { background-color: #cccccc; } img { display: inline; } Wie im Kapitel HTML beschrieben, wird ein ListItem mit einem <div>-Tag der CSS-Klasse lvItem umgeben. Im CSS-Code kann somit über den CSS-Selector .lvItem auf das Element zugegriffen werden. Globales CSS für ListViewItems Es ergiebt durchaus Sinn, grundelegende Styles von ListViewItems global zu definieren. ListViewItems könnten z.B. eine einheitliche Border oder Hintergrundfarbe besitzen. Für diesen Zweck existiert der globale CSS Editor für ListViewItems am FSGeneral.Controls.BaseControl. Über das Property ListVIewItem unter der Kategorie Global CSS öffnet sich der CSS Editor. Die globalen Styles können je Sprache definiert werden. Ist für eine Sprache kein CSS definiert, wird auf Deutsch zurückgegriffen. Alle globalen Styles werden vom individuellen CSS am Control überschrieben, wie das folgende Beispiel zeigt: Globales CSS: .lvItem { color: white; background-color: green; } CSS an ListView LV1: .lvItem { background-color: blue; } Die global definierte grüne Hintergrundfarbe wird im CSS von ListView LV1 überschrieben. So haben alle ListViewItems von LV1 eine blaue Hintergrundfarbe und weißen Text. REM anstatt Pixel Im CSS sollten Größenangaben ausschließlich mit rem angegeben werden. Der HTML Client skaliert die gesamte Anzeige anhand der vom Browser vorgegebenen Schriftgröße. Im HTML Client wird global für das HTML- und das BODY-Tag folgendes definiert: html { font-size: 62.5%; } body { font-size: 1.4rem; } In Desktop-Browsern wie z.B. Chrome, Firefox oder Edge ist der Standardwert der Schriftgröße 16px. 1rem ist per Definition genauso groß wie die Schriftgröße des HTML-Tags, also im Standardfall erst einmal 16px. Setzt man nun die font-size des HTML-Tags auf 62.5%, ergibt sich eine Schriftgröße von 10px, womit 1rem nun ebenfalls 10px groß ist. Da meist in Desktop-Browsern entwickelt und getestet wird, ergibt diese Anpassung Sinn, da es viel einfacher zu verstehen ist, mit Faktor 10, als mit Faktor 16 zu arbeiten. 0.5rem sind 5px, 5rem sind 50px usw. Deshalb wird im BODY-Tag auch die Schriftgröße auf 1.4rem gesetzt, was letztenendes 14px sind. Dies spiegelt die Standardschriftgröße des HTML Clients wieder. Probleme können nun enstehen, wenn REM- und Pixelwerte gemischt werden! Ein Beispiel: .tpl .remClass { width: 10rem; } .tpl .pxClass { width: 100px; } Nehmen wir an, es gibt zwei HTML-Elemente im Template mit den Klassen remClass und pxClass. Liefert der Browser eine Standardgröße von 16px, besteht kein Problem, die beiden Elemente sind exakt gleich groß, da 65.5% von 16px = 10px. Damit sind 10rem exakt 100px. Anders sieht es aber aus, wenn z.B. ein mobiler Browser eine Standardschriftgröße von 14px liefert. 62.5% von 14px = 8.75px, damit sind 10rem exakt 87.5px und die beiden HTML-Elemente sind plötzlich unterschiedlich groß. Dies kann je nach Gerät und verwendetem Browser zu unvorhersehbaren Skalierungsfehlern führen. Tip Es wird ausdrücklich empfohlen, im HTML/CSS des ListItems rem als Größeneinheit zu verwenden. IsEditable Im CSS kann auch ein Style für deaktivierte ListItems in einem nicht editierbaren ListView hinterlegt werden. Wird ein ListView im Designer oder per Action auf isEditable = false gesetzt, so wird am <div>-Tag lvItem das HTML-Attribut lvdisabled hinzugefügt: <hc-listitem-content _nghost-wvt-c19 class=\"ng-star-inserted\"> <div _ngcontent-wvt-c19 class=\"lvItem\" lvdisabled=\"true\"> [...] </div> </hc-listitem-content> Im CSS-Code kann über den Attribute-Selector .lvItem[lvdisabled] genau dieser Fall abgefragt werden. Im Beispiel wird der Hintergrund des ListItems auf grau (#cccccc) gesetzt. Preview Wenn der HTML-Code gültig ist, wird auf der Registerkarte \"Preview\" eine gerenderte Vorschau des Templates angezeigt. Für die Vorschau werden die PreviewValues für die einzelnen Template Variablen verwendet. Sollte ein PreviewValue nicht gesetzt sein, wird stattdessen der DataSource Name angezeigt. Template MLKeys zeigen den im Wörterbuch hinterlegten Text an. Fallback für die Standartsprache Wenn für eine Sprache eines bestimmten HTML-Codes nicht gibt, wird den HTML-Code des Standartsprache (Deutsch) verwendet. Diese Regel wird auch für den CSS-Code anwenden. Anderseits, wenn kein Code auch für die Standardsprache gibt, wird die Meldung TEMPLATE NULL angezeigt. Images im ListViewItem Eine Besonderheit ist das Anzeigen von Bildern in einem ListViewItem mittels <img />, wenn dieses über ein byte[] aus der Datenbank gebunden werden soll. Ein Anwendungsfall wäre z.B. das Anzeigen von Artikelbildern. Beispiel: <img class=\"img\" src=\"data:{{ ds:MimeType }};base64,{{ ds:Image }}\" /> Um ein Bild an ein HTML img-Tag zu binden sind zwei Template Variablen notwendig. Das byte[] mit den Bildinformationen alleine reicht abhängig vom genutzten Browser nicht immer aus (siehe Hinweis). Es muss zusätzlich der HTML Mime-Type spezifiziert werden, sodass der Browser weiß, um welches Bildformat es sich handelt. {{ ds:MimeType }} ist eine Template Variable vom typ FSstring oder string und gibt z.B. den Mime-Type \"image/png\" oder \"image/jpg\" zurück. {{ ds:Image }} ist eine Template Variable vom Type FSByteArray oder byte[]. Binärdaten werden als Base64-String zum Client übertragen. Da das HTML src-Attribut Base64 versteht, ist keine weitere Formatierung der Daten nötig. Tip Die Angabe des Mime-Types ist in den meisten Browsern wie Chrome, Firefox, Safari oder Edge (auch auf mobilen Geräten) nicht zwingend nötig. Manche proprietären Browser auf mobilen Geräten haben jedoch Schwierigkeiten, ohne die Angabe des Mime-Types, das Bild korrekt darzustellen. Sollten diese Browser keine Rolle für die Anwendung spielen, kann auch folgendes HTML genutzt werden: <img class=\"img\" src=\"data:;base64,{{ ds:Image }}\" /> Das Semicolon vor base64 ist ohne die Angabe des Mime-Types zwingend notwendig."
  },
  "doc/form/control/menu-item.html": {
    "href": "doc/form/control/menu-item.html",
    "title": "Menu-Item",
    "keywords": "Menu-Item Properties/Events Actions"
  },
  "doc/form/control/picture.html": {
    "href": "doc/form/control/picture.html",
    "title": "Picture",
    "keywords": "Picture Properties/Events Actions Das Picture-Control dient als Positionsrahmen für Bilder. Ziehen Sie dazu das Control Picture per Drag & Drop auf das Form und hinterlegen Sie anschließend die URL für das Bild. Über den Datasource lassen sich auch dynamisch Bilder zuordnen. Das Picture-Control unterstützt, wie der Image-Button, die Formate GIF, JPG und PNG."
  },
  "doc/form/control/radiobutton.html": {
    "href": "doc/form/control/radiobutton.html",
    "title": "Radio-Button",
    "keywords": "Radio-Button Properties/Events Actions Mit Radio-Buttons können Sie den Benutzer zwischen einer definierten Anzahl von Möglichkeiten wählen lassen. Es ist immer ein Radio-Button ausgewählt. Wird ein zweiter Radio-Button geklickt, wird der erste automatisch deaktiviert. Um dies zu ermöglichen, besitzen Radio-Buttons einen gemeinsamen DataSource, über den sie gesetzt werden. Für jeden Radio-Button wird definiert, bei welchem Wert er aktiv ist. Radio-Buttons werden auf einem Panel zusammengefasst, dessen Property ButtonGroupDataSource als gemeinsamer DataSource dient."
  },
  "doc/form/control/tabbedwindow.html": {
    "href": "doc/form/control/tabbedwindow.html",
    "title": "Tabbed-Window",
    "keywords": "Tabbed-Window Properties/Events Actions Durch das Tabbed Window können Sie Registerkarten auf ihrem Formular positionieren. Durch dieses gestalterische Mittel vergrößern Sie deshalb die Oberfläche Ihres Formulars und haben zugleich die Möglichkeit, ihre Controls in einen Kontext zu bringen. Über das Kontext-Menü des Tabbed-Windows können Sie neue Tab-Karteikarten hinzufügen."
  },
  "doc/form/control/tabpage.html": {
    "href": "doc/form/control/tabpage.html",
    "title": "Tab-Page",
    "keywords": "Tab-Page Properties/Events Actions Einzelne Registerkarten eines Tabbed Windows werden TabPage genannt. Sie können entweder über das Kontext-Menü des Tabbed Windows im Form-Designer oder über das Kontext-Menü des Tabbed Windows auf der Registerkarte Class (Default Variant) hinzugefügt werden. TabPages können als separates Control innerhalb eines Tabbed Windows ausgewählt werden, um auf die Properties zuzugreifen."
  },
  "doc/form/control/template.html": {
    "href": "doc/form/control/template.html",
    "title": "Template Control",
    "keywords": "Template Control Properties/Events Actions Note Dieses Control funktioniert nur im Mobile-Client. Im Java-Client wird das Control nicht angezeigt. Template Editor Der Template Editor bietet die Möglichkeit, das HTML/CSS Template für das Template Control sprachabhängig zu definieren. Dabei können Template DataSources definiert werden, auf welche aus dem HTML heraus mittels Template Variablen verwiesen wird. So können sehr einfach Businessdaten ins HTML eingebettet und formatiert werden. Der Editor kann im Property-Grid über das Property Template geöffnet werden. Allgemein Dropdown für Sprachauswahl Das HTML und CSS eines Template Controls kann, wenn gewünscht, für jede Sprache einzeln definiert werden. Ist für eine Sprache kein Template definiert, wird auf Deutsch zurückgegriffen. Button Validate Über diesen Button können die im HTML eingebetteten Template Variablen und Template MLKeys überprüft werden. Es werden folgende Fälle geprüft: Ist der Template MLKey parsebar und ist der MLKey-Name gültig? Ist die Template Variable parsebar? Passt das angegebene Format zum Datentyp? Zeigt die Template Variable auf eine existierende Template DataSource? Ist jeder Template DataSource eine valide DataSource zugeordnet Ist die DataSource einer Template DataSource weder private noch internal Template DataSources Auf der rechten Seite der Registerkarte HTML befindet sich die Liste der definierten Template DataSources. Jede Template DataSource zeigt auf ein Property des Forms in dem sich das Template Control befindet. Im Beispiel hat das Form ein Property oAddress vom Typ cdAddress (eine Component), welches wiederum einige Unterproperties hat. Wie im Bild zu sehen, verweist die Template DataSource Street auf das Property sStreet von oAddress. Der Name einer Template DataSource muss eindeutig sein. Aus dem HTML kann nun mittels einer Template Variable auf die Template DataSource zugegriffen und der Wert wie gewünscht im HTML formatiert werden. HTML Auf der linken Seite der Registerkarte HTML befindet sich der HTML-Codeeditor, in dem das HTML für das Template Control definiert werden kann. Note Das benutzerdefinierte HTML wird zur Laufzeit vom HTML Client (Angular) compiliert und optimiert. Grobe Fehler wie z.B. nicht geschlossene Tags oder invalides HTML können zu Anzeigefehlern führen, die unter Umständen auch andere Bereiche des HTML Clients betreffen. Templates sollten vor dem produktiven Einsatz in allen verfügbaren Browsern ausgiebig getestet werden. Button Use Base Mit dem Button Use Base kann das HTML Template z.B. nach einem Customizing wieder auf die Basis zurückgesetzt werden. Button Template Variable Mit dem Button Template Variable kann eine neue Template Variable erstellt, oder eine bestehende geändert werden. Button MLKey Mit dem Button MLKey wird das MLKey-Wörterbuch geöffnet. Dort kann ein neuer Template MLKey erstellt, oder ein bestehender geändert werden. HTML Aufbau Der benutzerdefinierte HTML Code wird im HTML Client in ein <div>-Tag mit der CSS-Klasse tpl verpackt. Es ist also nicht unbedingt nötig, um den eigenen HTML Code ein <div>-Tag als Container zu implementieren. Der generierte Code aus dem Beispiel sieht im HTML Client z.B. so aus: <hc-tpl-ctrl-content class=\"ng-star-inserted\"> <div class=\"tpl\"> <div class=\"wrapper\"> <div class=\"icon\"> <img class=\"img\" src=\"data:image/png;base64,iVBORw...\"> </div> <div class=\"text\"> <span class=\"header\">Adresse</span> <span>Max Mustermann</span> <span>Musterstraße 7a</span> <span>78333 Musterstadt</span> </div> </div> </div> </hc-tpl-ctrl-content> Das <div>-Tag mit der CSS-Klasse tpl kann im CSS wie gewünscht angepasst werden, ohne einen eigenen Container oder eine eigene CSS-Klasse verwenden zu müssen. Placeholder Die Konstante %FILESURL% kann im HTML verwendet werden, um zur Laufzeit die Broker-Url zu erhalten. Dadurch können z.B. in <img>-Tags auf Bilder, welche als Ressourcen im Framework Studio hinterlegt wurden, zugegriffen werden. Dynamische Bilder können über eine binäre Template-Variable realisiert werden. (siehe Abschnitt Images im Template) Template Variablen Über den Button Template Variable öffnet sich der Template Variable Editor. Befindet sich der Cursor im Codeeditor auf einer bestehenden Template Variable, wird diese im Editor vorselektiert. Auf der linken Seite werden alle zur Verfügung stehenden Template DataSources aufgelistet. Auf der rechten Seite kann für die Template Variable ein passendes Format und/oder FormatPattern definiert werden. Durch die Aufteilung in Template DataSources und Template Variablen werden die Daten und deren Formatierung im HTML strikt voneinander getrennt. Beispielsweise könnte der Wert einer Template DataSource im englischen HTML anders formatiert werden als im deutschen HTML. Template Variablen werden im HTML-Code wie folgt angezeigt: {{ ds:[Name]|f:[Format]|fp:[FormatPattern]|pv:[PreviewValue] }} Dabei verweist [Name] auf den Namen der zugehörigen Template DataSource, [Format] und [FormatPattern] definieren das im Template Variable Editor ausgewählte Format und FormatPattern. PreviewValue ist derjenige Wert, der für die Template Variable angezeigt wird, wenn das Template auf der Registerkarte Preview zur Vorschau gerendert wird. Der Wert wird zur Laufzeit ignoriert. Note Es wird empfohlen, Template Variablen und Template MLKeys immer über den jeweiligen Editor zu ändern, um Syntaxfehler zu vermeiden. Template MLKey Template MLKeys werden im HTML-Code wie folgt angezeigt: {{ mlkey:[MLKey-Name] }} Dabei verweist [MLKey-Name] auf den Namen des zugehörigen MLKeys. Zum Beispiel \"SYS_OK\". CSS Das benutzerdefinierte HTML kann mittels CSS im CSS-Codeeditor auf der Registerkarte CSS beliebig angepasst werden. Beispiel: .tpl { display: flex; flex-direction: column; background-color: lightyellow; border: 0.1rem solid gray; border-radius: 0.3rem; } .tpl[tpldisabled] { background-color: grey; } .wrapper { flex: 1; display: flex; justify-content: left; padding: 1rem; padding-left: 1.5rem; line-height: 1.7rem; } .icon { flex: 0 0 auto; display: flex; flex-direction: column; align-items: center; justify-content: center; } .text { flex: 1; display: flex; flex-direction: column; justify-content: left; padding-left: 1.5rem; line-height: 1.7rem; } .img { max-height: 6rem } .header { font-weight: bold; margin-bottom: 0.3rem; } Wie im Kapitel HTML beschrieben, wird ein ListItem mit einem <div>-Tag der CSS-Klasse tpl umgeben. Im CSS-Code kann somit über den CSS-Selector .tpl auf das Element zugegriffen werden. Globales CSS für Template Controls Es ergiebt durchaus Sinn, grundelegende Styles von Template Controls global zu definieren. Sie könnten z.B. eine einheitliche Border oder Hintergrundfarbe besitzen. Für diesen Zweck existiert der globale CSS Editor für Template Controls am FSGeneral.Controls.BaseControl. Über das Property TemplateControl unter der Kategorie Global CSS öffnet sich der CSS Editor. Die globalen Styles können je Sprache definiert werden. Ist für eine Sprache kein CSS definiert, wird auf Deutsch zurückgegriffen. Alle globalen Styles werden vom individuellen CSS am Control überschrieben, wie das folgende Beispiel zeigt: Globales CSS: .tpl { color: white; background-color: green; } CSS an Template Control TPL1: .tpl { background-color: blue; } Die global definierte grüne Hintergrundfarbe wird im CSS von Template Control TPL1 überschrieben. Somit hat dies eine blaue Hintergrundfarbe und weißen Text. REM anstatt Pixel Im CSS sollten Größenangaben ausschließlich mit rem angegeben werden. Der HTML Client skaliert die gesamte Anzeige anhand der vom Browser vorgegebenen Schriftgröße. Im HTML Client wird global für das HTML- und das BODY-Tag folgendes definiert: html { font-size: 62.5%; } body { font-size: 1.4rem; } In Desktop-Browsern wie z.B. Chrome, Firefox oder Edge ist der Standardwert der Schriftgröße 16px. 1rem ist per Definition genauso groß wie die Schriftgröße des HTML-Tags, also im Standardfall erst einmal 16px. Setzt man nun die font-size des HTML-Tags auf 62.5%, ergibt sich eine Schriftgröße von 10px, womit 1rem nun ebenfalls 10px groß ist. Da meist in Desktop-Browsern entwickelt und getestet wird, ergibt diese Anpassung Sinn, da es viel einfacher zu verstehen ist, mit Faktor 10, als mit Faktor 16 zu arbeiten. 0.5rem sind 5px, 5rem sind 50px usw. Deshalb wird im BODY-Tag auch die Schriftgröße auf 1.4rem gesetzt, was letztenendes 14px sind. Dies spiegelt die Standardschriftgröße des HTML Clients wieder. Probleme können nun enstehen, wenn REM- und Pixelwerte gemischt werden! Ein Beispiel: .tpl .remClass { width: 10rem; } .tpl .pxClass { width: 100px; } Nehmen wir an, es gibt zwei HTML-Elemente im Template mit den Klassen remClass und pxClass. Liefert der Browser eine Standardgröße von 16px, besteht kein Problem, die beiden Elemente sind exakt gleich groß, da 65.5% von 16px = 10px. Damit sind 10rem exakt 100px. Anders sieht es aber aus, wenn z.B. ein mobiler Browser eine Standardschriftgröße von 14px liefert. 62.5% von 14px = 8.75px, damit sind 10rem exakt 87.5px und die beiden HTML-Elemente sind plötzlich unterschiedlich groß. Dies kann je nach Gerät und verwendetem Browser zu unvorhersehbaren Skalierungsfehlern führen. Tip Es wird ausdrücklich empfohlen, im HTML/CSS des Template Controls rem als Größeneinheit zu verwenden. IsEditable Im CSS kann auch ein Style für das Template hinterlegt werden, wenn IsEditable auf false gesetzt wird. Wird ein Template Control im Designer oder per Action auf isEditable = false gesetzt, so wird am <div>-Tag tpl das HTML-Attribut tpldisabled hinzugefügt: ```html <hc-tpl-ctrl-content class=\"ng-star-inserted\"> <div class=\"tpl\" tpldisabled> [...] </div> </hc-tpl-ctrl-content> Im CSS-Code kann über den Attribute-Selector .tpl[tpldisabled] genau dieser Fall abgefragt werden. Im Beispiel wird der Hintergrund des Templates auf grau gesetzt. Preview Wenn der HTML-Code gültig ist, wird auf der Registerkarte \"Preview\" eine gerenderte Vorschau des Templates angezeigt. Für die Vorschau werden die PreviewValues für die einzelnen Template Variablen verwendet. Sollte ein PreviewValue nicht gesetzt sein, wird stattdessen der DataSource Name angezeigt. Template MLKeys zeigen den im Wörterbuch hinterlegten Text an. Preview Size Mit der Preview Size kann im Editor die Größe der Vorschau geändert werden. Damit kann sehr einfach überprüft werden, wie sich das Template in unterschiedlichen Größen verhält. Diese Einstellung hat keinen Einfluss auf die Laufzeit. Fallback auf die Standardsprache Sollte für die im Template Editor ausgewählte Sprache (z.B. Englisch) kein HTML oder CSS vorhanden sein, so wird das HTML oder CSS der Standardsprache (Deutsch) verwendet. So kann z.B. für \"Englisch\" nur das HTML überschrieben werden. im Preview und zur Laufzeit wird dann das englische HTML mit dem deutschen CSS kombiniert. Images im Template Eine Besonderheit ist das Anzeigen von Bildern in einem Template Control mittels <img />, wenn dieses über ein byte[] aus der Datenbank gebunden werden soll. Ein Anwendungsfall wäre z.B. das Anzeigen von Icons. Beispiel: <img class=\"img\" src=\"data:{{ ds:MimeType }};base64,{{ ds:Image }}\" /> Um ein Bild an ein HTML img-Tag zu binden sind zwei Template Variablen notwendig. Das byte[] mit den Bildinformationen alleine reicht abhängig vom genutzten Browser nicht immer aus (siehe Hinweis). Es muss zusätzlich der HTML Mime-Type spezifiziert werden, sodass der Browser weiß, um welches Bildformat es sich handelt. {{ ds:MimeType }} ist eine Template Variable vom typ FSstring oder string und gibt z.B. den Mime-Type \"image/png\" oder \"image/jpg\" zurück. {{ ds:Image }} ist eine Template Variable vom Type FSByteArray oder byte[]. Binärdaten werden als Base64-String zum Client übertragen. Da das HTML src-Attribut Base64 versteht, ist keine weitere Formatierung der Daten nötig. Tip Die Angabe des Mime-Types ist in den meisten Browsern wie Chrome, Firefox, Safari oder Edge (auch auf mobilen Geräten) nicht zwingend nötig. Manche proprietären Browser auf mobilen Geräten haben jedoch Schwierigkeiten, ohne die Angabe des Mime-Types, das Bild korrekt darzustellen. Sollten diese Browser keine Rolle für die Anwendung spielen, kann auch folgendes HTML genutzt werden: <img class=\"img\" src=\"data:;base64,{{ ds:Image }}\" /> Das Semicolon vor base64 ist ohne die Angabe des Mime-Types zwingend notwendig."
  },
  "doc/form/control/treenode.html": {
    "href": "doc/form/control/treenode.html",
    "title": "TreeNode",
    "keywords": "TreeNode Properties/Events Das Funktionsprinzip des Tree-Views ist ähnlich dem einer Combobox: Sie wählen einen Eintrag des Tree-Views aus und bekommen den Objektverweis an den DataSource des Tree-Views zurückgeliefert. Durch abfangen der entsprechenden Events können Sie mit dieser Information operieren. Um eine einfache Auflistung in Baumform zu erstellen, erzeugen Sie eine TextCollection mit den Einträgen und benutzen diese als NodeDataSource. An dieser Stelle soll nun exemplarisch auf den Aufbau eines Baumes eingegangen werden. Am Anfang machen Sie sich bitte Gedanken darüber, woher Sie Ihre Informationen für die Darstellung des Baumes nehmen möchten. Eine gute Möglichkeit besteht in der Schaffung einer Component, wie unter Tree-View beschrieben. Positionieren Sie ein TreeView-Control auf Ihrem Form. Generieren Sie über den Tree-View Column Dialog die gewünschten Spalten, die der Tree-View beinhalten soll. In diesem Beispiel benötigen Sie eine einzige Spalte. Wählen Sie anschließend aus dem Kontext-Menü des Tree-Views den Eintrag New Node. In dem Baum des Controls wird ein neuer Knoten erzeugt, mit dem Sie operieren können. Weisen Sie die erzeugte Component Ihrem TreeNode als NodeDataSource und die Properties als Eigenschaften des NodeDataSource zu. Jetzt dürfen Sie nicht vergessen, die Component auch mit Daten zu füllen. Schreiben Sie eine entsprechende Load-Bedingung in die OnLoad-Methode des Forms. Damit nicht alle Einträge aus der Datenbanktabelle in dem TreeView dargestellt werden, müssen Sie den Load noch auf die Bedingung einschränken, dass bei den gesuchten Datensätzen die ItemIDParent null oder 0 sein soll und nur Datensätze Ihres gewünschten Typs ausgewählt werden. Der nächste Schritt ist das Anzeigen von Unterknoten. Jeder Eintrag des Tree-Views ist ein Objekt. Entsprechend sollten alle Unterknoten Elemente einer Collection sein, die als Property in das Objekt eingebunden ist. Erzeugen Sie deshalb eine Collection als IndividualReadOnly-Property. Diese Collection laden Sie über die Get-Methode. Um das Beispiel aus Tree-View weiterzuführen, werden alle Elemente geladen, die als ItemIDParent die ItemID des Objekts haben. Um unnötige Loads auf die Datenbank zu unterbinden, sollten Sie wieder eine Membervariable anlegen, die unnötige Loads verhindert. Get-Methode der Collection: // Load nur durchführen, wenn noch nicht zuvor geschehen. if (this.oTreeviewItemCollMember == null) { // Laden aller Unterobjekte this.oTreeviewItemCollMember = new cdTreeviewItemColl(); // Setzen des Merkers this.oTreeviewItemCollMember.Load( \"[lngItemIDParent] = \" + lngItemID ); } return this.oTreeviewItemCollMember; Nutzen Sie dieses Collection-Property als NodeDataSource des TreeNode zweiter Ebene. Sind die Display Member, Value Member und Icons richtig eingestellt, ist ihr Navigationsbaum fertig. Benötigen Sie eine tiefergehende Unterschachtelung, können Sie einfach einen TreeNode dritter Ebene hinzufügen und die gleichen Einstellungen wie bei dem Treenode zweiter Ebene vornehmen. Da jedes Objekt des Collection-Properties wiederum ein Collection Property besitzt, das über die Get-Methode alle untergeordneten Objekte liest, brauchen Sie keine weiteren Properties o.ä. schaffen. Um andere Elemente hinzuzufügen wird empfohlen, für jeden Typ einen eigenen Tree-Node anzulegen und eine Collection des jeweiligen Element-Typs als IndividualReadOnly-Property der Component hinzuzufügen. Durch Definition der Get-Methoden können Sie die Collections entsprechend füllen. Tree-Node Lazy-Loading Der TreeView ist in der Lage, ein Lazy-Loading von TreeNodes auszuführen. Beinhaltet ein TreeNode sehr viele SubNodes, werden standardmäßig die ersten 50 Einträge angezeigt und zusätzlich ein Node mit „…“. Durch Klick auf diesen Node können dann die restlichen Nodes nachgeladen werden."
  },
  "doc/form/control/treeview.html": {
    "href": "doc/form/control/treeview.html",
    "title": "TreeView",
    "keywords": "TreeView Properties/Events Actions Multicolumn Tree-Views werden typischerweise zum Darstellen von Baumstrukturen genutzt. Sie bestehen aus den Elementen Tree-View und Tree-Node. Zum Verwalten der Spalten und deren Properties existiert ein Dialog, welcher am TreeView über das PropertyGrid oder Kontextmenü geöffnet werden kann. Sie haben verschiedene Möglichkeiten einen Baum zu erstellen. Die Erstellung von Tree-Views unter Framework Studio ist vor allem wegen der Unterstützung der Mehrsprachigkeit komplex. Sie werden in der Regel für jeden Tree-View eine eigene Component benötigen, in denen die Properties über eine Query oder Get / Set Methoden gefüllt werden. Für eine einfache Auflistung ohne Verschachtelung und grafische Elemente können Sie auch eine einfache TextCollection nutzen. Wird ein Element aus dem Baum durch Klicken ausgewählt, wird die GUID des Elements an den DataSource des Tree-Views zurückgegeben. Deshalb muss der DataSource des Tree-Views entweder den Typ der Baumelemente besitzen, wenn dieser aus homogenen Elementen besteht, oder den allgemeinen Typ Object bzw. DevFrameworkObject haben. Sie müssen für jeden Tree-Node in den Properties eine ObjectCollection als NodeDataSource hinterlegen. Das Databinding für die einzelnen beim TreeView definierten Spalten wird an dieser NodeDataSource eingestellt. Unter Displaymembers werden alle Spalten in alphabethischer Reihenfolge aufgelistet. Aus dem in NodeDataSource ausgewählten Objekt wählen Sie Properties als Eigenschaft für den jeweiligen Display-Member der im TreeView definierten Columns, den Value-Member, das ClosedIcon, das OpenIcon und das HasSubNodes-Flag. Da es sich bei den Icons um graphische Elemente handelt, sollten die Properties einen relativen oder absoluten Pfad zu den Grafiken enthalten. Es empfiehlt sich, eine Datenbank-Tabelle anzulegen, welche alle benötigten Properties als Columns besitzt (ItemIDParent, ItemID, Image1, Image2, Pos, Type). Um die Einträge mehrsprachig zu definieren, erzeugen Sie jetzt eine TextCollection. In einer Text-Collection ist es notwendig eine ID zu definieren, die der ItemID aus der Datenbank-Tabelle entsprechen sollte. Anschließend können Sie zu jeder ID mehrsprachig die Bezeichnungen hinterlegen, die in dem Tree-View angezeigt werden sollen. Wenn Sie aus der Datenbanktabelle mit den Baum-Informationen eine Component und die dazugehörige Collection erstellt haben, öffnen Sie die Component und fügen ein IndividualReadonly-Property (sText) hinzu, das die Bezeichnung über eine Get-Methode aus der Text-Collection ermittelt. In dem Beispiel wurde zusätzlich eine private Membervariable sTextval hinzugefügt, damit die Bezeichnung aus der TextCollection nur das erste Mal ermittelt wird. Die sText Get-Methode könnte folgendermaßen aussehen: // sTextVal ist eine Membervariable, die sich merkt, // ob bereits ein Load ausgeführt wurde if (sTextVal == ““) { // Instanziieren der TextCollection ctTreeviewItemText oTreeviewItemText = new ctTreeviewItemText(); if (oTreeviewItemText.GetOnID( lngItemID ) == null) { // Kein Eintrag für die ID in der TextCollection vorhanden sTextVal = \"<no entry for\" + lngItemID + \">\"; } else { // Zuweisung der Bezeichnung sTextVal = oTreeviewItemText.GetOnID( lngItemID ).Text; } } return sTextVal; Bei dem Zugriff auf das sText-Property, wird Ihnen automatisch die sprachspezifische Bezeichnung aus der Text-Collection zurückgegeben. Die aufgezeigte Möglichkeit zur Unterstützung von Mehrsprachigkeit bei Properties kann selbstverständlich auch in vielen anderen Fällen angewandt werden. Sie müssen nicht für jedes Treeview separate Komponenten erstellen, sondern können die vorhandenen durch Einschränkung der Load-Bedingung auf einen Typ mehrfach verwenden. Tree-View - Rekursiver Baum Um einen rekursiven Baum abzubilden, benötigt man eine rekursive Objekt-Struktur. Dabei ist wichtig, dass alle Objekte denselben Component-Type besitzen. Es müssen 2 Tree-Nodes angelegt werden. Der erste Tree-Node erhält als NodeDataSource eine Collection – z.B. ein Form-Property. Diesem Tree-Node können die Eigenschaften unterhalb dem NodeDataSource (Icons, DisplayMember, …) zugewiesen werden. Unterhalb wird ein zweiter TreeNode angelegt. Dem wird in den Properties bei der Eigenschaft ContinueEqiuvalent der erste Tree-Node zugewiesen. Als NodeDatasource muss eine Collection angegeben werden, die denselben Typ besitzt wie der NodeDataSource des ersten TreeNodes. Unterhalb dem NodeDataSource müssen dieselben Einstellungen vorgenommen werden, wie im ersten TreeNode."
  },
  "doc/form/control/wrappanel.html": {
    "href": "doc/form/control/wrappanel.html",
    "title": "Wrap Panel",
    "keywords": "Wrap Panel Properties/Events Actions Controls werden innerhalb des Panels wie in einem Fließtext angeordnet. Wenn der Platz ausgeht, dann erfolgt ein Umbruch. Dies ist z.B. ideal für Button-Leisten. Besonders ist bei der Eigenschaft WrapArrangement der Wert Vertical. Die Controls werden dabei erst in Spalten von oben nach unten und dann von links nach rechts angeordnet. Dabei wird die Höhe aber so klein wie möglich gewählt und so viele Spalten wie möglich erzeugt. Werden auf diese Weise mehrere Field-Panels platziert, dann ergibt sich die für eNVenta typische spaltenweise Anordnung. Abbildung 148: WrapPanel mit Vertical WrapArrangement"
  },
  "doc/form/default-control-styles.html": {
    "href": "doc/form/default-control-styles.html",
    "title": "Default Control Styles",
    "keywords": "Default Control Styles Default Control Styles sind Standardvorlagen für alle verfügbaren Controls. Durch diese Vorlagen können für alle Eigenschaften der Controls Standardwerte vorbelegt werden. Default Control Styles werden auf der Registerkarte Namespaces im Namespace FSGeneral / Controls angezeigt. Wenn Sie ein Default Control Style auf einem Form verwenden wollen, ziehen Sie das Control von der Registerkarte Toolbox des Framework-Designers auf die Registerkarte DefaultVariant des geöffneten Form-Designers (siehe dazu Design des Forms). Um Eigenschaften eines Default Control Styles zu ändern, öffnen Sie den Control Style Designer durch Doppelklick auf das Default Control Style im Objektbaum auf der Registerkarte Namespaces. Auf der Registerkarte Default Control Style werden in einem Property Grid alle Eigenschaften des Controls angezeigt. Eine komplette Liste der Eigenschaften der einzelnen Default Control Styles finden Sie unter Layout-Konzept. Wenn Eigenschaften an einem Default Control Style statt an der Instanz eines Controls auf einem Form festgelegt werden, hat das den Vorteil, dass diese Eigenschaften einheitlich in der gesamten Anwendung verwendet werden. Wenn dann nachträglich eine Eigenschaft (z.B. Hintergrundfarbe) an einem Default Control Style geändert wird, zieht diese Änderung automatisch an allen Stellen, an denen der Default Control Style benutzt wird und die Eigenschaft nicht explizit überschrieben wird. Custom Control Default Style Editor: Sie haben die Möglichkeit, eigene Default Control Styles zu definieren. Dazu müssen Sie eine Ableitung von einem der Basis Default Control Styles erstellen (Kontextmenü Derive im Objektbaum auf der Registerkarte Namespaces). Für das so erstellte Default Control Style können Sie die Eigenschaften frei definieren, ohne das Original Default Control Style zu ändern. Dadurch erhalten Sie eine weitere Control-Vorlage, die Sie in Ihren Forms verwenden können. Basis Default Control Styles sind Button, Checkbox, Combobox, Editfield, Grid, ImageButton, Label, Line, Listbox, MainMenu, Panel, Picture, RadioButton, TabbedWindow, TrafficLight und TreeView."
  },
  "doc/form/designer.html": {
    "href": "doc/form/designer.html",
    "title": "Forms",
    "keywords": "Forms Der Form-Designer ist ein Tool, ähnlich dem Designer in Visual Studio, in dem Sie Controls per Drag & Drop auf einem Form positionieren und mit Funktionalität beleben können. Er wird entweder durch einen Doppelklick auf ein entsprechendes Form-Element auf der Registerkarte Namespaces oder durch das Erstellen eines neuen Form-Elements geöffnet. Allgemeiner Überblick Kontextabhängige Registerkarten Ist ein Form-Element geöffnet, verhalten sich die Registerkarten auf der linken Seite entsprechend diesem Kontext. Die Registerkarte ClassView zeigt alle Elemente an, über die das Forum verfügt. Über die Registerkarte fügen Sie auch auf gewohnte Weise über das Kontext-Menü des Namespaces neue Properties, Methods, Reports oder Workflow-Events dem Form hinzu. Anschließend können Sie die Properties nutzen, um sie z.B. per Drag & Drop auf dem Form zu positionieren. Es wird entsprechend das für das Property hinterlegte Standard-Control dargestellt. Ist kein Control als Standard-Control für das Property hinterlegt, wird ein Editfield gewählt. Sind mehrere Controls hinterlegt, wird zunächst das Standard-Control angezeigt. Dieses lässt sich aber ändern, indem Sie das Control auf dem Form auswählen und aus dem Kontext-Menü des Controls den Eintrag Change Visualisation auswählen. Dieser Eintrag erscheint nur, wenn zu dem Property mehr als ein Control hinterlegt ist. Interessant in diesem Zusammenhang dürfte auch der Eintrag Default-Variant auf der Registerkarte ClassView sein. Unterhalb des Eintrags sehen Sie eine Auflistung der Controls, die auf dem Formular angezeigt werden. Wenn Sie ein Control z.B. auf einem Panel positionieren, sind die Koordinaten des Controls relativ zur Position des Panels. Wenn Sie wollen, dass sich ein Control in diesem relativen Zusammenhang verhält oder dieser Zusammenhang versehentlich erzeugt wurde, können Sie diesen durch Verschiebung des Controls im Baum per Drag & Drop ändern. Die Registerkarte Inheritance zeigt den Vererbungsbaum des ausgewählten Forms. Ist das Form nicht abgeleitet, wird lediglich ein Eintrag mit der Bezeichnung des Forms angezeigt. Auf der Registerkarte Properties sehen Sie die Eigenschaften des im Hauptfenster ausgewählten Elements. Sie haben zudem die Möglichkeit, über die Combobox oben auf der Registerkarte zu den Eigenschaften eines ausgewählten Elements zu springen. Auf die Eigenschaften zu den Controls wird in der Beschreibung zu den jeweiligen Controls eingegangen. Letztlich zeigt die Registerkarte Toolbox eine Auswahl aller zu Verfügung stehenden Controls an. Die Controls werden ebenso wie die Properties per Drag & Drop auf dem Formular positioniert. Es werden alle Standard-Controls, also auch Controls angeboten, welche von Ihnen im Default Style Editor definiert wurden. Form Designer Registerkarte Toolbox: Registerkarte Property Auf der Registerkarte Property können Sie die einzelnen Properties des Forms bearbeiten. Wählen Sie dazu das gewünschte Property aus der Tabelle aus, oder doppelklicken Sie auf das entsprechende Property auf der Registerkarte ClassView. Sie können die Properties sortieren, indem Sie auf die Spaltenüberschrift des gewünschten Sortierkriteriums klicken. Neue Properties können Sie über New / Public Property bzw. New / Protected Property im Kontextmenü, im Menü des Form Designers oder über den entsprechenden Button anlegen. Alternativ dazu können Sie auch eine Component aus dem Namespace Treeview in die Tabelle ziehen. Dadurch wird automatisch ein Property vom Typ der Component angelegt. Um ein Property zu löschen, wählen Sie Delete entweder aus dem Kontextmenü des Properties in der Tabelle oder im Class View. Name Dient zum Benennen oder Umbenennen des Properties. Access Level Steuert den Access Level des Properties. Datatype Ist als Datentyp eine Component oder Collection ausgewählt, ist das Property ein entsprechendes Objekt. Wenn der Datentyp dagegen ein .Net Datentyp oder ein FS-Datentyp ist, können Sie das Property wie eine formweite Membervariable nutzen. Siehe Datentyp bearbeiten Description Hier können Sie eine Beschreibung für die Dokumentation hinterlegen. Alle in ein Form eingebundenen Properties werden beim Öffnen eines Forms zur Laufzeit automatisch in der Methode Init() instanziiert. Registerkarte Method Auf der Registerkarte Method können analog zu den Components Methoden hinterlegt werden. Sie können prinzipiell 2 Arten von Methoden unterscheiden. Zum einen gibt es ganz normale Methoden, die durch einen Funktionsaufruf angestoßen werden. Zum anderen gibt es sogenannte Form-Events. Sie unterscheiden sich nur durch ihre Deklaration von den anderen Methoden und können auf Events von Controls reagieren. Registerkarte Functional Controls Auf dieser Registerkarte werden alle Functional Custom Controls des Forms angezeigt. Registerkarte Available Reports Vorbereitung für spätere Funktionalität. Sie können bislang einen ReportDocumentType definieren, was Ihnen das Einbinden einer Referenz erspart. Der Code zum Erzeugen des Reports muss aber bislang manuell ausprogrammiert werden. Registerkarte Access Units Zu der Access Unit, die in der Combobox ausgewählt ist, werden in den übrigen Feldern die Details angezeigt. Name Name der Access Unit. Dieses Feld ist insbesondere für die spezielle Form Access Unit, die das Form selbst repräsentiert, nicht editierbar. Name in code Kompilierbarer Name der AccessUnit, der im Source Code verwendet wird. Um Missverständnisse zu vermeiden, sollten Sie darauf achten, dass der Name einer Access Unit keine ungültigen Sonderzeichen enthält, so dass Name und Name in code übereinstimmen. Is form AccessUnit Diese Checkbox zeigt an, ob die Access Unit die spezielle Access Unit ist, die das Form selbst repräsentiert. Für jedes Form wird diese Access Unit automatisch angelegt. Die Eigenschaft kann nicht geändert werden. Description Hier können Sie eine Beschreibung der Access Unit hinterlegen. Parents Die Liste zeigt alle Access Units, unter der die Access Unit in der Access Unit Hierarchie eingebunden ist. Diese Eigenschaft ist hier rein informativ und kann nur über den Menüpunkt Tools / Access Unit Treeview ... (Access Unit Hierarchie) geändert werden. Erstellen, Bearbeiten und Löschen eines Forms Erstellen eines Forms Elemente erstellen Bearbeiten eines Forms Elemente bearbeiten Design des Forms Löschen eines Forms Elemente löschen Design des Forms Gestaltet wird das Form auf der Registerkarte DefaultVariant. Um Controls auf dem Formular zu erstellen, gibt es mehrere Möglichkeiten: In der Registerkarte Toolbox werden alle zur Verfügung stehenden Controls angeboten. Es sind auch die selbst definierten Default-Styles enthalten. Wenn Sie mit der Maus ein Control aus dieser Liste auf das Form ziehen (per Drag & Drop), wird ein entsprechendes Control erstellt. Das Control erhält als Vorgabe die Eigenschaften, die in den Default-Styles definiert sind. Werden die Eigenschaften in den Default-Styles geändert, wirkt sich das automatisch auf alle Controls aus, die aus diesem Default-Style erstellt wurden (auch nachträglich). Wenn allerdings die Eigenschaften manuell geändert werden, haben diese Änderungen höhere Priorität und sie werden nicht nachgezogen. Eine weitere Möglichkeit besteht darin, eine Membervariable auf das Form zu ziehen. Es werden automatisch ein Control und dazu auch ein Label erstellt. Das Label erhält den Wert, der im Property oder im dahinterliegenden Metadatentypen als Default-Label hinterlegt ist. (Siehe dazu Metadatentypen und Components). Als Control wird das gezogen, welches im Property oder im Metadatentypen als Default-Control hinterlegt und als Default gekennzeichnet wurde. Sind noch weitere Default-Controls hinterlegt, können Sie die Darstellung nachträglich ändern. Im Context-Menu des Controls gibt es dazu einen Punkt Change Visualization. Dort werden alle Default-Controls angeboten und das, welches gerade verwendet wird, ist mit einem Haken versehen. Weitere Informationen dazu finden Sie im Abschnitt Membervariablen/Databinding. Actions SetApplicationTitle(string title) Mit dieser Methode kann der Titel der Applikation zur Laufzeit festgelegt werden. Unter Windows wird der Titel sowohl im Java Client-Fenster als auch in der Taskleiste angezeigt. SetDialogPlacement(int value) Standardmäßig werden modale Dialoge in Framework Studio mittig im Hauptfenster der Anwendung angezeigt. Dies lässt sich über die Action SetDialogPlacement(int value) am Form ändern. Beispiel: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.SetDialogPlacement(1); // Absolute } Die Action nimmt einen Integer zwischen 0 und 2 als Parameter: 0 = None 1 = Absolute 2 = Relative None Der JavaClient zeigt alle modalen Dialoge zentriert zur Anwendung an. Absolute Der JavaClient speichert sich die absolute Position und Größe aller modalen Dialoge beim Schließen. Die Dialoge werden genau an der Stelle geöffnet, an der sie geschlossen wurden. Relative Der JavaClient speichert sich die relative Position der modalen Dialoge, bezogen auf die Position der Anwendung und die Größe. Die Dialoge werden relativ zur Anwendung wieder geöffnet. Note Der JavaClient speichert sich den per SetDialogPlacement() übergebenen Wert NICHT. Es muss von der Anwendung aus bei jedem Start die Action aufgerufen werden (z.B. beim Laden des ersten Formulars der Anwendung). SetToolTipDelays(int initialDelay, int dismissDelay) Mit dieser Action kann im JavaClient die Anzeigezeit für Tooltips geändert werden. Die Einstellung gilt dann für den gesamten JavaClient. Der Parameter initialDelay gibt die Zeit in Millisekunden an, wie lange es dauert, bis der Tooltip angezeigt wird, nachdem der Mauszeiger über ein Control bewegt wurde. Der Parameter „dismissDelay“ gibt die Zeit in Millisekunden an, wie lange der Tooltip angezeigt werden soll. Die Action ist an der Form-Klasse zu finden. Beispiel: this.SetToolTipDelay(3000, 10000); Nach diesem Beispiel würde ein Tooltip nach 3 Sekunden eingeblendet werden und dann für 10 Sekunden zu sehen sein. Soll bei einem Aufruf der Action nur ein Parameter geändert werden, muss der andere mit dem Wert -1 übergeben werden: Beispiel: this.SetToolTipDelay(-1, 10000); Somit wird nur die Anzeigedauer der Tooltips auf 10 Sekunden geändert. Beep(long length, double frequency) Erzeugt einen einheitlichen Beep-Ton. length Länge des Tons in Millisekunden. frequency Frequenz des Tons in Herz. Beispiel: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.Beep(500, 750); } Dieser Code erzeugt einen Beep-Ton von einer halben Sekunde bei 750Hz. BeepDouble(long length1, long length2, double frequency1, double frequency2) Erzeugt einen Ton aus zwei Frequenzen, die hintereinander abgespielt werden. Damit lassen sich z.B. Bestätigungs- oder Fehler-Sounds erstellen. length1 Länge des ersten Teils des Tons in Millisekunden. length2 Länge des zweiten Teils des Tons in Millisekunden. frequency1 Frequenz des ersten Teils des Tons. frequency2 Frequenz des zweiten Teils des Tons. Beispiel 1: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.BeepDouble(200, 200, 500, 2000); } Dieser Code erzeugt einen Beep-Ton mit einer Gesamtlänge von 400ms. Die ersten 200ms werden mit 500Hz wiedergegeben, die zweiten 200ms mit 2000Hz. Dies ist ein klassischer Bestätigungs-Sound. Beispiel 2: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.BeepDouble(200, 350, 1000, 400); } Dieser Code erzeugt einen Beep-Ton mit einer Gesamtlänge von 550ms. Die ersten 200ms werden mit 1000Hz wiedergegeben, die restlichen 350ms mit 400Hz. Dies könnte z.B. ein akustisches Signal bei einem Fehler sein. BeepMultiple(int beepCount, long beepLength, long breakLength, double frequency) Erzeugt mehrere Beep-Töne hintereinander mit Pausen dazwischen. beepCount Anzahl der abzuspielenden Töne. beepLength Länder eines einzelnen Tons in Millisekunden. breakLength Länge der Pause zwischen den Tönen in Millisekunden. frequency Frequenz der einzelnen Töne. Beispiel: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.BeepMultiple(3, 200, 100, 800); } Dieser Code erzeugt 3 Beep-Töne hintereinander mit einer Einzellänge von 200ms und jeweils einer 100ms langen Pause dazwischen. Die Töne werden mit 800Hz abgespielt. Events Damit in einem Form eine Aktion ausgeführt werden kann, sind sogenannte Events notwendig. Events reagieren auf Ereignisse, die im Form auftreten. Es ist möglich, diese Events mit Funktionalität zu verbinden. Events können auf unterschiedliche Ereignisse reagieren: öffnen eines Forms, ändern des Inhalts eines Editfields, Klick auf einen Button usw. Es gibt unterschiedliche Arten von Events: Form-Events, Workflow-Events. Form-Events Form-Events spielen sich sozusagen im Form ab. Damit ein Form-Event etwas tut, müssen Sie ihm eine Methode aus dem Form zuordnen. Es wird dann beim Eintreten des entsprechenden Ereignisses die im Form-Event hinterlegte Methode aufgerufen. Ein Form-Event ist immer eine Anfrage an den Broker. Wurden vor dem Absenden des Events im Client Daten im Form geändert, stehen diese Änderungen in den entsprechenden Membervariablen zur Verfügung. Werden im Form-Event Daten der Membervariablen geändert, werden diese Änderungen dem Client mitgeteilt und er ändert die Daten in der Anzeige entsprechend ab. Bevor ein Form-Event an den Broker gesendet wird, werden die in den Metadatentypen hinterlegten Gültigkeitsprüfungen durchgeführt. Workflow-Events Workflow-Events stellen eine Schnittstelle aus dem Form heraus dar. Auf die im Form hinterlegten Workflow-Events kann später im Workflow reagiert werden. So kann z.B. zwischen verschiedenen Forms kommuniziert werden. Warning Sind für ein Ereignis ein Form-Event und ein Workflow-Event hinterlegt, wird zuerst das Form-Event ausgeführt und anschließend das Workflow-Event. Workflow-Events können auch manuell aus einer Form-Method heraus angestoßen (gefeuert) werden. Dazu bietet jedes Workflow-Event eine Fire-Methode an. Beispiel: Zu einem Workflow-Event WE_btnSearch_OnClick existiert eine Methode FireWE_btnSearch_OnClick(). Beim Aufruf dieser Methode wird das Workflow-Event WE_btnSearch_OnClick angestoßen. // FormEvent btn_Search_OnClick public void FE_btnSearch_OnClick(FrameworkButtonClickEventArgs e) { if (!this.GenerateLoadConditionOnoCustomer.IsNull) { FireWE_btnSearch_OnClick(); } } Bearbeiten von Control-Events Die Events von Controls werden in einem Dialog bearbeitet. Dieser öffnet sich z.B. mit einem Doppelklick auf das Control. Dieser Dialog kann auf folgenden Wegen geöffnet werden: Mit einem Doppelklick auf ein Control. Über das Context-Menü des Control – dort gibt es einen Menü-Punkt Events. Über das Property-Grid. Das Control bietet eine Eigenschaft Control Events an. Der Dialog zeigt erst einmal nur an, welche Events dem Control bereits zugeordnet sind. Erst bei Bedarf können diese dann geändert werden. Wenn ein Event in einem Basis-Form oder einem Basis-Package zugeordnet wurde, dann wird dies mit grauem Text angezeigt. Ein Tooltip gibt Information, aus welchen Form oder Package diese Event-Zuordnung genau kommt und in welchem Form oder Package ggf. die letzte Überschreibung der Form-Methode existiert. Ist die Form-Methode im aktuellen Form überschrieben, dann wird der Link mit blauer Schrift dargestellt. Mit einem weiteren Mausklick können folgende Aktionen durchgeführt werden: Mit dem Button Cancel (oder mit Esc, Enter oder Leertaste) wird der Dialog geschlossen. Mit Klick auf den Event-Link wird die entsprechende Form-Methode geöffnet bzw. das Workflow-Event im Class-View angezeigt. Dies funktioniert auch für Events aus einem Basis-Form oder Basis-Package. In diesem Fall wird die letzte überschriebene Form-Methode geöffnet. Mit dem Button kann man ein neues Event anlegen und zuordnnen. Der Dialog wird sofort geschlossen. Bei einem Form-Event wird unmittelbar in die entsprechende Form-Methode gesprungen und ein Workflow-Event wird im Class-View angezeigt. Ist das Event in der Basis zugeordnet, dann wird dieser Befehl unterhalb des Buttons angeboten. Durch diesen Befehl wird die Basis-Event-Zuordnung ausgeblendet, was zur Folge hat, dass es nicht mehr ausgeführt wird. Es dann nur das neu zugeordnete Event ausgeführt. (Anders wäre es, wenn man z.B. eine Form-Event-Methode überschreibt.) Mit dem Button kann eine im Basis-Form zugewiesene Form-Methode im aktuellen Form überschrieben werden. Der Button wird nur angeboten, wenn die Methode virtual ist und wenn sie nicht bereits im aktuellen Form überschrieben ist. Mit dem Button kann ein vorhandenes Event zugeordnet werden. In einem Context-Menü werden alle gültigen Events angeboten. Nach einer Auswahl wird der Dialog sofort geschlossen. Mit dem Button kann eine Event-Zordnung entfernt werden. Nach einer Rückfrage wird die Zuordnung gelöscht und der Dialog geschlossen. Die Form-Event-Methode bzw. das Workflow-Event werden dabei nicht gelöscht.. Properties / Databinding Ein Form dient ja in erster Linie dazu, Daten anzuzeigen und zu verändern. Es ist aber so, dass ein Control selber keinen Wert hat (eine Ausnahme sind Labels). Dies wird über das sogenannte Databinding gelöst. Das funktioniert, indem einem Control eine Membervariable des Forms zugewiesen wird. Diese Zuordnung findet im Property Datasource auf der Registerkarte Property statt. Ist die Zuordnung erfolgt, zeigt das Form im entsprechenden Control den Wert der Membervariablen an. Wird der Wert im Control durch eine Eingabe geändert, wird der neue Wert bei der nächsten Anfrage an den Broker in die Membervariable zurückgeschrieben. Die Controls bieten unterschiedliche Möglichkeiten, Datasources zuzuordnen: Editfields haben einen Datasource. Diesem Datasource kann eine Membervariable vom Typ String, Number (long, int, short...) oder Datum zugewiesen werden. Das Editfield zeigt den entsprechenden Wert an. Labels haben ebenfalls einen Datasource. Diesem kann ebenfalls (wie dem Editfield) eine Membervariable zugeordnet werden. Ist dem Label ein Datasource zugeordnet, wird das, was im Property Caption angegeben ist, ignoriert. Zudem besitzen Labels ein Property LabelOfControl. Ist ein Label einem Control zugeordnet und Control hat ein Property als DataSource, wird in dem Label automatisch die Caption angezeigt, die zu dem Property als DefaultLabel hinterlegt ist. Comboboxen und Listboxen haben neben dem Datasource eine Property List. Der Datasource gibt an, welchen Wert die Combobox repräsentieren soll. Unter List wird angegeben, woher die Werte der Liste hergenommen werden sollen. Hier sind Collections und Textcollections möglich. Nachdem List ausgewählt wurde, müssen noch DisplayMember und ValueMember angegeben werden. DisplayMember: Gibt an, welches Property aus der Component der Collection angezeigt werden soll. (Sollen zusammengesetzte Properties dargestellt werden, muss in der Component dafür ein extra Property erstellt werden, welches dann hier ausgewählt werden kann). ValueMember: Gibt an, welches Property der Component mit dem Datasource verknüpft werden soll. Tabbed Windows können als Datasource eine Membervariable vom Typ short besitzen. Der Inhalt dieser Membervariablen gibt an, welches Tab gerade aktiv ist. Durch Ändern der Membervariable in einem FormEvent kann somit auch beeinflusst werden, welches Tab aktiv sein soll. Radio-Buttons / Panels: Radiobuttons besitzen selber keinen Datasource. Bei Radiobuttons bilden immer mehrere Controls eine logische Einheit, zwischen denen gewechselt werden kann. Um dies zu lösen, werden die Radiobuttons auf einem Panel positioniert. Das Panel, welches die Radiobuttons beinhaltet, bekommt dann im Property ButtonGroupDataSource ein Datasource zugeordnet. Den Radiobuttons wird im Property DatasourceOnValue gesagt, bei welchem Wert er aktiv sein soll. Pictures bekommen im Datasource gesagt, welches Bild dargestellt werden soll. Ist im Picture ein Datasource zugeordnet, wird die Angabe im Property Image ignoriert. Damit ist es möglich, ein Bild dynamisch anzuzeigen. Grids bekommen als Datasource eine Collection. Diese Collection stellt die Tabelle dar, die angezeigt werden soll. Anschließend können Sie aus dem Kontext-Menü des Grids über den Eintrag Grid-Columns / New die Properties aus der Component zu der Collection als Grid-Columns übernehmen. Nur in der Component enthaltene Properties können zu Spalten werden. Es ist nicht möglich, darüber hinaus weitere Spalten zu definieren. Bei Bedarf müssen Sie in der Component zusätzliche Properties definieren und diese dynamisch über die Get/Set-Methoden befüllen. Grids bieten einen weiteren Datasource SelectedRows an. Hier kann eine Membervariable vom Typ System.Framework.SelectedRowsCollection zugeordnet werden. Diese Collection enthält Guids (eindeutige ID eines Objekts), die angeben, welche Zeilen in der Tabelle markiert sind. Die Guids repräsentieren also eine Untermenge der Objekte aus der Datasource-Collection. TreeViews stellen einen Baum aus Objekten dar. Als Datasource muss ein ganzes Objekt angegeben werden. Wenn der TreeView Objekte nur eines Typs darstellt, muss der Datasource denselben Typ besitzen. Stellt der TreeView Objekte verschiedener Typen dar, muss als Datasource ein Objekt vom Typ Object gewählt werden. In dem Fall müssen Sie in den Form-Methoden entsprechende Typenkonvertierungen vornehmen. Framework Studio bietet auch eine ganz einfache Möglichkeit, ein Control mit Datasource zu erstellen. Sie können die Membervariable einfach auf das Form ziehen. Es wird das entsprechende hinterlegte Default-Control erzeugt. Es erhält einen Namen, angelehnt an den der Membervariable. Der Datasource wird automatisch eingetragen und es wird zum Control ein Label erstellt, welches das in der Membervariable hinterlegte Default-Label enthält."
  },
  "doc/form/label-of-control-cleanup.html": {
    "href": "doc/form/label-of-control-cleanup.html",
    "title": "LabelOfControl Cleanup",
    "keywords": "LabelOfControl Cleanup LabelOfControl Cleanup ist eine Wartungs-Routine mit der die veraltete Control-Eigenschaft LabelOfControl am Label-Control bereinigt werden kann. Sie kann in der IDE über das Menu Tools / Checks / LabelOfControl Cleanup aufgerufen werden. Mit dem Button Analyze wird lediglich eine Analyse durchgeführt und die gefundenen Controls in einer Liste ausgegeben. Bitte führen sie zuerst die Analyse durch und prüfen sie ggf. stichprobenartig ob die gelisteten Controls plausible Treffer sind. Mit dem Button Cleanup wir die Bereinigung durchgeführt. Die Routine durchsucht alle Forms nach Label-Controls, an denen die Eigenschaft LabelOfControl gesetzt ist, checkt die betroffenen Forms aus, überträgt die Caption und den Tooltip des zugeordneten Controls, sofern diese nicht bereits am Label-Control überschrieben sind, entfernt die Eigenschaft LabelOfControl vom Label-Control und speichert das Form. Nach dem Cleanup müssen die verarbeiteten Form kompiliert und eingecheckt werden. Hintergrund Das Property LabelOfControl wird seit der Version 4.0 nicht mehr im Form-Designer angeboten. Mit dem neuen Layout zur Version 4.0 wurde die Eigenschaft LabelOfControl überflüssig. Die Beschriftungen der Controls wurden durch automatisch erzeugte Labels abgelöst. Bei der Konvertierung des Layouts wurden deshalb die alten Label-Controls größtenteils nicht in das neue Layout übernommen. In einigen speziellen Fällen, wurden die Labels aber gezielt übernommen und mit ihnen auch die Eigenschaft LabelOfControl. Im Hintergrund hat das immer noch dafür gesorgt, dass die Caption und der Tooltip des zugeordneten Controls in das Label-Control übernommen wurde. Andere Funktionen, wie das automatische Ausblenden mit dem zugeordneten Control haben nicht mehr funktioniert. Mit dem Umbau des Data-Bindings zur Version 4.3 musste auch dieses Feature entfernt werden. Das hat zur Folge, dass jetzt bei betroffenen Labels die Beschriftungen nicht mehr gezogen werden."
  },
  "doc/form/layout-konzept.html": {
    "href": "doc/form/layout-konzept.html",
    "title": "Layout-Konzept",
    "keywords": "Layout-Konzept Control-Hierarchie Die Controls eines Forms sind in einem Baum organisiert. Dabei spielen die Hierarchie und vor allem die Reihenfolge in diesem Baum eine wichtige Rolle. Das Form wird mithilfe von verschiedenen Containern (DockPanel, WrapPanel, FieldPanel), in denen die Controls platziert werden, strukturiert. Ausschließlich die Hierarchie und Reihenfolge der Controls definieren deren Anordnung im Form. Absolute Positionen können nicht angegeben werden. In Ableitungen bzw. im Customizing können neue Container und Controls in der Hierarchie eingefügt werden. Bestehende Container oder Controls können an eine andere Stelle in der Hierarchie verschoben werden. Die Controls ordnen sich auch dann wieder automatisch an. Besonders vorteilhaft ist dies, wenn Sie mehrere Packages miteinander kombinieren. Überlagerungen von Controls kann es so nicht geben – Überlagerungen sind technisch auch gar nicht möglich. Größe von Controls Die Größe von Text-Feldern und Grid-Columns wird durch den Metadatentyp gesteuert. Dort gibt es die Eigenschaften DisplayMinLength, DisplayMaxLength und für Multiline-Felder DisplayMinLines und DisplayMaxLines. Diese Eigenschaften sind in der kompletten Kette von Metadatentyp über DBColumn und Component-Property bis zum Control verfügbar. Am ControlStyle FSGeneral.Controls.BaseControl wird das Property MeasureText angeboten. Die Display-Length-Eigenschaften werden vom Client mithilfe dieses Textes in die realen Größen umgerechnet. Zuzüglich Padding und Border ergibt sich so die Gesamt-Größe des Controls. Die Display-Length Einstellungen sollten soweit wie möglich am Metadatentyp erfolgen. Eine gute Hilfe dabei ist die DataSource Hierarchy Search im Form-Designer. Die Control-Eigenschaften MinSize, MaxSize bzw. GridColumn.Width sollten nur in Ausnahmefällen gesetzt werden, weil dadurch das Control nicht mehr, z.B. auf Änderungen der Schriftgröße, reagieren kann. Tab-Reihenfolge Die Tab-Reihenfolge der Controls wird durch deren Position im Baum bestimmt. Wenn Sie den kompletten Baum von oben nach unten durchlaufen, ergibt sich so die komplette Tab-Reihenfolge. Eine davon abweichende Tab-Reihenfolge kann nicht definiert werden. Individuelle oder von der Situation abhängige Tab-Reihenfolgen können mit dem OnLeave/OnValidate-Event und der SetFocus-Action realisiert werden. Mit dem Property TabStop kann ein Control in der Tab-Reihenfolge übersprungen werden. Deprecated Layout / Migration Öffnen Sie ein „altes“ Form, dann wird mit der Registerkarte Deprecated Layout der alte Form-Designer angezeigt. Dieser funktioniert ganz normal bis zur Umstellung. Form-Designer mit Deprecated Form: Mit dem Button Convert Deprecated Layout wird die Konvertierung in das neue Layout gestartet. Dies geht aber erst wenn alle Basis-Forms in allen Base-Packages dieses Forms umgestellt sind. Es öffnet sich neben dem neuen Form-Designer ein weiteres Fenster Convert Deprecated Layout. Dieses kann auf dem 2. Monitor platziert werden. Convert Deprecated Layout: Form-Designer mit teilwiese migriertem Form: ALLE Controls müssen in den neuen Baum eingehängt werden. Dazu muss das entsprechende Control aus dem alten Control-Baum per Drag & Drap an die richtige Stelle in den Control-Baum des neuen Form-Designers verschoben werden. Im alten Baum wird das Control dann mit einem grünen Hintergrund als verarbeitet markiert. Controls, die nicht in das neue Layout übernommen werden, werden von der Konvertierung ausgeschlossen und mit einem roten Hintergrund markiert. Das sind Controls, die es im neuen Layout nicht mehr gibt (z.B. Panel, StackPanel, Line) – diese sind automatisch ausgeschlossen. Einige Controls können auch vom Entwickler (rechte Maustaste / Exclude) oder einem Automatismus ausgeschlossen werden (Picture, Label). Ist ein Control verarbeitet, erhält es einen grünen Haken . Ein Container erhält diesen Haken erst dann, wenn auch alle seine Unter-Controls verarbeitet sind. Ziel ist es, dass der komplette Baum – also der oberste Knoten DefaultVariant – verarbeitet ist und diesen grünen Haken erhält. Dann kann das Form kompiliert, getestet und die Konvertierung mit dem Button Complete abgeschlossen werden."
  },
  "doc/fsclientlauncher/fsclientlauncher-common.html": {
    "href": "doc/fsclientlauncher/fsclientlauncher-common.html",
    "title": "Framework Studio Client Launcher",
    "keywords": "Framework Studio Client Launcher Allgemeine Informationen Für das Ausführen einer Framework-Studio-Anwendung wird auf dem Client-Rechner eine Laufzeit-Umgebung benötigt. Diese wird durch das Programm \"Framework Studio Client Launcher\" bereit gestellt. Der Client-Launcher wird immer mit der aktuellsten Version installiert. Diese ermöglicht auch die Arbeit mit älteren Programm-Versionen (z.B. Framework Studio 3.11 / eNVenta 3.6) Der Aufruf der Anwendung erfolgt über die Client Start Page, welche vom Anwendungs-Server bereitgestellt wird. Die von der Start Page erzeugten Links können auch kopiert und auf andere Weise zugänglich gemacht werden. Bei der Aktualisierung auf eine neue Version kann es jedoch Änderungen an den Links geben, sodass diese ggf. aktualisiert werden müssen. Starten der Anwendung Der Client-Launcher wird direkt gestartet. Ggf. muss im Browser einmalig die Verwendung der Anwendung FSClientLauncher akzeptiert werden. Der Start erfolgt über einen Link, der alle in der Startseite getroffenen Einstellungen beinhaltet. Er hat bspw. das folgende Format: fsclientlauncher:launch?title=eNVenta%20ERP&broker=http://nvapp01/eNVenta_40/&language=en,de Dieser Link kann auch in eine eigene Verknüpfung – z.B. auf den Desktop kopiert werden. Mit dem eigenen Protokoll fsclientlaucher erfolgt der Start des Client Launchers direkt ohne einen extra Umweg über den Server. Manche Umgebungen – z.B. Content-Management-Systeme wie SharePoint – haben ggf. Probleme mit diesem Link. In diesem Fall kann als Workaround der Download-Link verwendet werden und am Ende das dl=1 durch ein dl=0 ersetzt werden. In diesem Fall wird über den Browser der Server kontaktiert, der dann auf den korrekten Start-Link umleitet. Der jeweilige Link kann im Browser über \"Verknüpfung / Link-Adresse kopieren\" kopiert werden. Kommandozeile Der Client-Launcher kann auch über die Kommandozeile gestartet werden. Dort nimmt er als erstes Argument den fsclientlauncher:... Link oder den Pfad einer .fsclient-Datei. Sowohl der Link als auch die .fsclient-Datei kann über die Client Start Page ermittelt werden. Wenn kein Link und keine .fsclient-Datei als Argument angegeben wird, startet der Client-Launcher in das Konfigurations-Fenster. Jar File Caching Beim Starten des Client-Launchers wird überprüft, ob sich ein .jarcache Ordner unter dem Pfad %userprofile%\\FSClientLauncher\\ befindet. Sollte dem so sein, wird dieser einmalig nach %localappdata%\\FSClientLauncher\\ verschoben, sofern unter diesem Pfad noch kein .jarcache Ordner vorhanden ist. Download Start File Über diesen Link wird eine Datei mit der Endung .fsclient heruntergeladen. Diese beinhaltet ebenfalls die auf der Client Start Page getroffenen Einstellungen. Der Link hat das folgende Format: http://nvapp01/eNVenta_40/api/fsclient?lang=en,de&themeid=DefaultID&metal=1&nodomainauth=false&dl=1"
  },
  "doc/fsclientlauncher/fsclientlauncher-configuration.html": {
    "href": "doc/fsclientlauncher/fsclientlauncher-configuration.html",
    "title": "Konfiguration",
    "keywords": "Konfiguration Allgemeines Wird der FS Client Launcher direkt über das Start-Menü gestartet, dann öffnet sich das Konfigurations-Fenster. Gespeichert werden alle Einstellungen im Benutzer-Kontext in folgender Datei: %userprofile%\\FSClientLauncher\\launcherconfig.json Console Der Client-Launcher gibt Fehler und Informationen über ein Konsole-Fenster aus. Dieses wird bei der ersten Ausgabe eingeblendet und am Ende zusammen mit dem Java-Client beendet. Display Java Console: Die Console-Ausgaben des Java-Clients werden in einem Console-Fenster angezeigt. Trace-Level: Treten Errors auf, dann werden diese im Console-Fenster angezeigt. Durch ändern des Trace-Levels können weitere Informationen – z.B. über den Download der jar-Dateien – im Console-Fenster angezeigt werden. Log Files Directory: Alle Ausgaben werden in automatisch in Log-Datei gespeichert. Diese werden in dem Ordner abgelegt, der mit dem Link geöffnet werden kann. Log-Dateien, die älter sind als 30 Tage werden automatisch gelöscht. Jar File Caching Der Client Launcher speichert die vom Broker heruntergeladenen Jar-Dateien in einem Cache auf der lokalen Festplatte zwischen. Dieser Cache wird automatisch bereinigt. Auto Cleanup: Gibt an, wie viele Tage nach dem letzten Aufruf eine Anwendung aus dem Cache gelöscht werden soll. Directory: Hier kann der Cache-Ordner im Explorer geöffnet werden. Clear Cache: Löscht den kompletten Cache. Network Siehe Abschnitt Proxy-Einstellungen. Java Settings Use Java Version: Über diesen Schalter kann die Java-Laufzeitumgebungs-Version eingestellt werden. Welche Java-Laufzeitumgebung verwendet werden soll kann alternativ auch über Umgebungsvariablen konfiguriert werden, siehe Java-Laufzeitumgebung. Recommended verwendet aktuell die JRE8 Supported verwendet entweder JRE8 oder JDK11 (64 Bit), dies entscheidet der Broker Experimental verwendet aktuell das JDK11 (64 Bit) VM Arguments: Hier können Argumente für die Java-Runtime angegeben werden. Die hier angegebenen Argumente haben die höchste Priorität. Sie überschreiben die Standard- Argumente des Client Launchers und die vom Broker vorgegebenen Argumente. Mehrere Argumente werden durch einen Zeilenumbruch getrennt. Beispiele: -Xmx1024M Setzt die maximale Speicher-Auslastung auf 1024 MB -Xms250M Setzt die initiale Speicher-Auslastung auf 250 MB Proxy-Einstellungen Direct Connection Das ist die Standard-Einstellung. Im Java-Client wird die Verwendung von Proxies deaktiviert und alle Anfragen werden direkt an den Server gesendet. Das umfasst sowohl sie Anfragen an den Broker-Server als auch alle anderen HTTP-Anfragen z.B. durch ein Browser-Control. Der Java-VM wird dafür das folgende Argument übergeben: -Djava.net.useSystemProxies=false Bei Bedarf können individuelle Proxy-Einstellungen auch über die VM Arguments im Konfigurations-Dialog vorgenommen werden. Details zu den Argumenten befinden sich in der Dokumention von Java: https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html Es ist wichtig, ggf. auch an https zu denken. Eine individuelle Proxy-Einstellung sieht z.B. so aus: -Dhttp.proxyHost=192.168.124.37 -Dhttp.proxyPort=3118 -Dhttp.nonProxyHosts=srv-erp-as-test|srv-erp-as01|srv-erp-as02|localhost|127.*|[::1] -Dhttps.proxyHost=192.168.124.37 -Dhttps.proxyPort=3119 -Dhttps.nonProxyHosts=srv-erp-as-test|srv-erp-as01|srv-erp-as02|localhost|127.*|[::1] Caution Die individuellen Proxy-Einstellungen greifen nur innerhalb des eigentlichen Java-Clients. Beim Start-Vorgang werden durch den Client-Launcher auch Informationen vom Anwendungs-Server geladen. Dabei greifen immer die Windows-Einstellungen. Windows Settings Der Java-Client greift auf die Proxy-Einstellungen des Client-Windows-Betriebssystems zurück. Es muss also sichergestellt sein, dass Windows den Anwendungs-Server erreichen kann. Der Java-VM wird dafür das folgende Argument übergeben: -Djava.net.useSystemProxies=true Bei den Proxy-Ausnahmen müssen ggf. die lokalen Adressen localhost; 127.0.0.1 ergänzt werden, auch wenn die CheckBox \"Proxyserver nicht für lokale Adressen\" gesetzt ist. SSL Ein Betrieb wird nur mit vertrauenswürdigen Zertifikaten unterstützt. Wird der Broker per SSL angesprochen, dann ist es erforderlich, dass das Client-Windows-Betriebsystem dem SSL-Zertifikat des Servers vertraut. Der Java-VM wird dafür das folgende Argument übergeben: -Djavax.net.ssl.trustStoreType=Windows-ROOT Java-Laufzeitumgebung Der Client Launcher beinhaltet eine eigene Java Laufzeitumgebung, mit der der Client gestartet wird. Die Installation einer separaten Java Laufzeitumgebung ist für den Betrieb des Client-Launchers nicht erforderlich. Mit der Umgebungsvariablen FSCL_JRE8 und FSCL_JDK11 kann bei Bedarf eine abweichende selbst installierte Java Laufzeitumgebung konfiguriert werden. Das kann sinnvoll sein, wenn man beispielsweise eine andere Version oder eine 64-Bit Variante der Java Laufzeitumgebung genutzt werden möchte. Diese Umgebungsvariable kann in der System-Steuerung von Windows auf Benutzer- oder System-Ebene definiert werden. Nach der Änderung der Einstellung ist ggf. ein Neustart des Prozesses (z.B. auch der Framework Studio IDE) nötig, damit die Einstellung zieht. Important Unter Umständen kann es schwierig sein alle abhängigen Prozesse zu beenden, es empfiehlt sich den Benutzer ab- und wieder anzumelden oder alternativ den Rechner neu zu starten. Es ist aber auch möglich z.B. durch eine Batch-Datei die Umgebungsvariable nur temporär für die aktuelle Situation zu überschreiben. rem Zeigt auf das Verzeichnis für die JRE8 Laufzeitumgebung (Recommended) set FSCL_JRE8=C:\\JAVA\\JRE8 rem Zeigt auf das Verzeichnis für die JDK11 Laufzeitumgebung (Experimental) set FSCL_JDK11=C:\\JAVA\\JDK11_x64 rem Start des Client Launchers mit dem \"Start Application\" Link aus der Broker Start-Seite \"%ProgramFiles%\\Framework Systems\\FS Client Launcher\\FSClientLauncher.exe\" \"fsclientlauncher:launch?broker=http://.....\" Tip Wurde ein falsches Verzeichnis angegeben, beendet sich der Launcher mit einem Fehler, das der \"JVM Launcher\" nicht gefunden wurde. Der \"JVM Launcher\" wird in bin/javaw.exe gesucht, es muss also das Installationsverzeichnis der Java Laufzeitumgebung und nicht dessen bin Verzeichnis angegeben werden."
  },
  "doc/fsclientlauncher/fsclientlauncher-installation.html": {
    "href": "doc/fsclientlauncher/fsclientlauncher-installation.html",
    "title": "Installation",
    "keywords": "Installation System-Voraussetzungen Betriebssystem (jeweils 32 Bit oder 64 Bit): Windows 8 – oder höher Windows 7 SP1 Windows Vista SP2 Windows Server 2012 – oder höher Windows Server 2008 R2 SP1 Windows Server 2008 SP2 Software: Microsoft .NET Framework Version 4.5 oder höher Standard-Installer Der Standard-Installer liefert eine einfache Benutzeroberfläche zur Installation des Programms. Für eine automatische Softwareverteilung kann der Installer auch per Kommandozeile im Silent-Modus ausgeführt werden. Der Standard-Installer ist im Requirements-Paket enthalten und steht auch als separater Download zur Verfügung. Standard Installation ausführen FSCL_4.X.Y_Setup_x64.exe ausführen und der Installations-Routine folgen. Diese Installations-Routine beinhaltet die 32-Bit Version der Java-Runtime. Die FSCL_4.X.Y_Setup_x64.exe ist ausschließlich für 64 Bit Betriebssysteme vorgesehen. Die FSCL_4.X.Y_Setup_x86.exe ist ausschließlich für 32 Bit Betriebssysteme vorgesehen. Kommandozeilen-Parameter Die Setup-Routine kann mit folgenden Kommandozeilen-Parametern aufgerufen werden. Damit ist eine Automatisierung der Installation möglich. Parameter Beschreibung -uninstall Deinstallation ausführen -s Silent-Installation / Update ohne Benutzerinteraktion. Das Programm erkennt die installierte Version und führt bei Bedarf ein Update durch. Es sind Administrationsrechte notwendig. -s -uninstall Silent-Deinstallation ohne Benutzerinteraktion. Es sind Administrationsrechte notwendig. -installdir <dir> Gibt das Verzeichnis an, in welches das Programm installiert werden soll. -l <logfile> Erzeugt ein Logfile zur Analyse von Problemen bei der Ausführung des Installers. MSI-Installer Caution Der MSI-Insaller wird nicht mehr angeboten. Bitte verwenden Sie den Standard-Installer. (Siehe auch Abkündigung des MSI-Installers für den FS Client Launcher)"
  },
  "doc/fsclientlauncher/fsclientlauncher-javaruntime.html": {
    "href": "doc/fsclientlauncher/fsclientlauncher-javaruntime.html",
    "title": "Java-Runtime",
    "keywords": "Java-Runtime Lizenz Der FS Client Launcher verwendet OpenJDK-Builds von Azul.com. Diese sind frei verwendbar - siehe auch Terms of Use von Azul Aktuell werden folgende Versionen verwendet: Java 8 Update 392 Java 11.0.21 (für den experimetallen Einsatz) Eine abweichende Laufzeitumgebung kann konfiguriert werden. Sicherheit Die Sicherheits-Risiken durch den Einsatz einer veralteten Java-Runtime begründen sich durch die enge Integration der Runtime in das System. Dabei spielen insbesondere 3 Aspekte eine wesentliche Rolle: 1.) Integration der installierten Java-Runtime in den Internet-Explorer. Dadurch werden Angriffe über entsprechend präparierte Webseiten ermöglicht. Für den Einsatz von Java Web Start ist die Aktivierung dieser Integration zwingend erforderlich. 2.) Java Web Start selber stellt eine entscheidende Lücke dar, weil damit eine fast beliebige Anwendung / jnlp-Datei aus dem Internet gestartet werden kann. Code-Signierung kann das verhindern - sofern der Benutzer aufmerksam genug ist und nicht jedem Herausgeber blind vertraut. 3.) Globale Erreichbarkeit der Installierten Java-Runtime für alle Java-Programme. Das wird z.B. durch die Umgebungs-Variable java_home erreicht. Der Client-Launcher besitzt seine eigene Java-Runtime. Diese wird in keiner Weise im System registriert. Damit weiß das System und Insbesondere die Browser nichts von dieser Runtime. Der Start einer Anwendung erfolgt mithilfe eines eigenen Dateiformats. Die oben genannten Sicherheits-Risiken bestehen damit nicht."
  },
  "doc/fsconsole/fsconsole.html": {
    "href": "doc/fsconsole/fsconsole.html",
    "title": "FSConsole",
    "keywords": "FSConsole Allgemeines FSConsole.exe ist ein Kommandozeilen-Programm, mit dem man viele Operationen automatisieren kann. Das sind unter anderem: Kompilieren von Package-Version Export und Import von Packages Dieses Programm wird von Framework Studio selber z.B. im Compile-Wizard verwendet. Es kann aber auch für eigene Automatisierungen,, z.B. nächtliche Compile-Läufe, verwendet werden. Kommandozeilen-Parameter Wenn FSConsole.exe ohne Parameter aufgerufen wird, wird eine Beschreibung der Parameter in der Konsole ausgegeben. \\LOGINXML <pathToXML> Pfad einer XML-Datei mit einer Compile-Wizard-Konfiguration. Die Login-Informationen und die zu kompilierenden Labels werden aus dieser Datei gelesen. Mit anderen Parametern angegebene Login- oder Label-Informationen werden ignoriert. So eine Datei kann im Compile-Wizard über das Menü File / Export Settings erzeugt werden. Beispiel: \\LoginXML \"c:\\temp\\FSDemo.xml\" \\ConnectionType <connType> Datenbank-Typ: SqlServer oder Oracle. \\SERVER <servername> \\DATABASE <database> \\DBUser <user> \\DBPassword <passwd> Verbindungsdaten für das Repository. Wenn kein Benutzer angegeben ist, wird Windows-Authentifizierung verwendet. Der Parameter \\ConnectionType muss ebenfalls angegeben werden. Beispiel SQL-Server mit Windows-Authentication: \\ConnectionType SqlServer \\SERVER db01 \\DATABASE Repository Beispiel SQL-Server mit SQL-Server-Authentication: \\ConnectionType SqlServer \\SERVER db01 \\DATABASE Repository \\DBUser sa \\DBPassword Xt4r5w Beispiel Oracle: \\ConnectionType Oracle \\DATABASE OraRep \\DBUser fs \\DBPassword Xt4r5w \\LOGFILE <logFilePath> Pfad der Log-Datei. Platzhalter: \\(datetime\\): Startzeit des Processes im dem Format yyyy-MM-dd_HH-mm-ss Beispiel: \\LogFile \"C:\\CompileLogs\\FSDemo_$datetime$.log\" \\CompileRun <CompileRunName> Kompiliert alle Package-Versionen, bei denen im Package-Manager das Feld Compile Run mit dem entsprechenden Namen angegeben wurde. Der Name ist nicht case-sensitiv. Beispiel: \\CompileRun \"Daily\" \\RefreshWS Aktualisiert den Workspace. Wenn es mit \\Compile kombiniert wird, dann wird die Aktualisierung als erstes ausgeführt werden. \\DebugCode Es werden zusätzlich Debug-Stände kompiliert. \\Compile Führt einen Compile durch. Die Parameter \\Package und \\Version oder \\LabelID müssen angegeben werden. \\Package <name> \\Version <name> Beispiel: \\Package \"MyPackage1\" \\Version \"1.0\" \\OBJECTTYPE <type> Gibt an, welcher Element-Typ kompiliert werden soll. Mögliche Typen: AccessUnitOwner, CodeFile, Component, CustomControl, DBTable, Form, GlobalObject, Interface, Metadatatype, ReportDocument, Resource, Workflow \\LabelID Interne ID einer Package-Version. Beispiel: \\LabelID \"17ab3fe4de22146f87edf715faedcb56\" \\NewProcessPerStep Jeder Element-Typ wird nacheinander in einem separaten Prozess kompiliert. \\Verbose In der Log-Datei werden mehr Detail-Informationen ausgegeben. \\LoginUser <username> Wenn nicht angegeben, wird FrameworkCompiler verwendet. \\CHECK valid values: None,WorkflowBranchAndSwitch,All \\Export <fileName> Exports the label to the file fileName. \\IncludeBasePackages <Mode> Gibt an, ob Basis-Packages in den Export eingeschlossen werden sollen (siehe PBE). \\Import <fileName> Imports the file fileName to the repository. \\PUBLISH Führt einen Publish mit dem angegebenen Setting durch (siehe \\SETTING). \\PUBLISH2GO Erstellt ein Publish2Go mit dem angegebenen Setting (siehe \\SETTING). \\SETTING Definiert das Setting, welches bei \\PUBLISH oder \\PUBLISH2GO verwendet wird. Kann entweder als Name des Settings im Repository oder als Datei angegeben werden. Beispiel 1: \\SETTING Test_Setting Beispiel 2: \\SETTING “C:\\Temp\\Test_Setting.FSSetting” \\DOCUMENTATION Rendert die gesamte Dokumentation als HTML 5 Webapplikation. Benötigt die Parameter \\ISO und \\OUTPUT. Beispiel: \\DOCUMENTATION \\ISO de \\ExportDBTables \\OUTPUT “C:\\Temp\\Dokumentation” \\ISO Gibt an in welcher Sprache die Dokumentation gerendert werden soll. Beispiel: \\ISO de \\ExportDBTables Gibt an, dass die Tabellen-Beschreibungen mit exportiert werden sollen. \\OUTPUT Gibt das Verzeichnis an, in welches die Dokumentation gerendert werden soll. Beispiel: \\OUTPUT “C:\\Temp\\Dokumentation” \\USELICENSE Wenn dieser Parameter gesetzt ist, wird die Runtime-Lizenz aus dem Setting verwendet, welches via \\SETTING übergeben wurde. In der Folge wird nur der Teil der Dokumentation exportiert, der mit der Runtime-Lizenz sichtbar ist."
  },
  "doc/global-events/global-events.html": {
    "href": "doc/global-events/global-events.html",
    "title": "Global Events",
    "keywords": "Global Events Global Events sind dazu da, Events zu feuern, die in der ganzen Anwendung abgefangen werden können. Sie können z.B. dazu dienen, allen offenen Workflows und Forms mitzuteilen, dass sie ihre Daten aktualisieren sollen, weil sich Stammdaten geändert haben. Ein Global Event besteht aus zwei Teilen: einem Sender. einem Event-Handler. Die Global Events können zudem auch eine beliebige Anzahl von Parametern jedes Typs erhalten. Somit können mit dem Event auch Daten an jede Stelle der Anwendung übertragen werden. Global Events sind durch das -Icon gekennzeichnet. Global Events anlegen / löschen Ein neues Global Event legen Sie an, indem Sie den Namespace markieren, unter dem das neue Event angelegt werden soll. Anschließend drücken Sie den Button (New) und wählen den Eintrag Global Event aus. Das Global Event wird angelegt und geöffnet. Ein Global Event kann in jedem beliebigen Namespace angelegt werden. Es ist aber empfehlenswert, die Events alle in einen Namespace zu packen. Löschen können Sie ein Global Event, indem Sie das Event in der Namespaces-Registerkarte markieren und den Button (Delete) drücken. Das Löschen wird erst mit dem Button (Save All) wirksam. Global Events bearbeiten Sie öffnen ein Global Event, indem Sie einen Doppelklick auf das Event der Namespaces-Registerkarte machen. Es öffnet sich der GlobalEvent-Designer im rechten Teil des Framework Designers. Name Gibt den Namen des Global Events an. Parameters In diesem Teil des Fensters werden die Parameter des Global Events verwaltet. Ein Global Event kann beliebig viele Parameter der unterschiedlichsten Datentypen besitzen. In der Listbox werden alle Parameter mit ihrem Namen aufgelistet. Rechts daneben werden die Eigenschaften des ausgewählten Parameters bearbeitet. Parameters Name Name des Parameters. Parameters Datatype Gibt den Datentyp des Parameters an. Zur Auswahl stehen .NET-Datentypen, FS-Datentypen, Metadatentypen und Components. Button Add Fügt einen neuen Parameter in die Liste ein. Button Delete Löscht den momentan markierten Parameter aus der Liste. Global Events verwenden Global Events können im Workflow verwendet werden. Nähere Informationen dazu finden Sie im Kapitel Workflows. (Global Events)"
  },
  "doc/globalobjects/globalobjects.html": {
    "href": "doc/globalobjects/globalobjects.html",
    "title": "Global Objects",
    "keywords": "Global Objects In Framework Studio – bzw. in der Anwendung – gibt es ein globales Objekt, welches überall verfügbar ist. Es kann jederzeit mit this.Global angesprochen werden. Damit das Global Object überall zur Verfügung steht, muss es beim Erzeugen eines neuen Framework-Studio Objektes mit dem Constructor übergeben werden. Variante mit dem new-Operator cdComponent oObject = new cdComponent( this.Global); Nutzen der Interfaces und Factory-Klassen IcdComponent oObject2 = cdComponentFactory.Create( this.Global ); Im automatisch generierten Code werden alle Objekte (Components, Forms, Workflows) in gleicher Weise erstellt. Somit ist dieses Global jederzeit und überall verfügbar. Das Global Object eignet sich hervorragend, um z.B. System- oder Benutzerdaten in der gesamten Anwendung zur Verfügung zu stellen. Welche Daten/Variablen dieses Objekt anbietet, wird im Namespace FSGeneral.GlobalObjects. definiert. Alle Elemente dort werden beim Start der Applikation instanziiert. Global Object Designer: Button New Es wird eine neue Variable angelegt. Sie können gleich den Namen der Variablen eingeben. Button Delete Löscht die markierte Variable. Name Name der Variablen bzw. des Objekts. Datatype Gibt den Datentyp der Variablen an. Über die Combobox kann der Datentyp geändert werden. Es öffnet sich der Namespace-Baum, über den das gewünschte Struct, Metadatatype oder Component ausgewählt werden kann. Autocreate Ist diese Checkbox aktiviert, wird die Variable automatisch beim Start der Anwendung initialisiert. Wenn nicht, wird die Variable einfach nur angelegt, ohne ihr einen Wert zuzuweisen. Dies können Sie dann im Code-Fenster festlegen. Redirect to ocGlobal Wenn diese Checkbox aktiviert ist, dann werden alle Zugriffe auf dieses GlobalObject in das gleichnamige Property in der Component FSGeneral.cGlobal umgeleitet. Dies betrifft Lese- und ggf. auch Schreibvorgänge. Wenn es sich bei dem cGlobal-Property um ein Readonly Property handelt, dann erkennt dies Framework Studio und wird das GlobalObject selber auch entsprechend readonly erzeugen. Das cGlobal-Property kann wie gewohnt als Individual Property mit Membervariable gestaltet werden, welches die Daten erst beim ersten Zugriff aufbereitet. So ist es möglich, ein GlobalObject erst beim ersten Zugriff zu initialisieren und so den Start der Anwendung zu beschleunigen. Init Code Im Code-Fenster können Sie angeben, was mit der Variable beim Start der Anwendung geschehen soll. Sie können den Variablen beispielsweise Werte zuweisen oder wenn Sie eine Component mit einer Query eingebunden haben, an dieser einen Load ausführen, damit die entsprechenden Daten aus der Datenbank gelesen werden. Methoden am GlobalObject Das Globale Objekt stellt neben den selbst definierten Properties auch System-seitig Methoden und Properties bereit. Siehe Methoden am GlobalObject Properties am GlobalObject Siehe Methoden am GlobalObject ocGlobal public IcGlobal ocGlobal Gibt ein Objekt vom Typ IcGlobal zurück. Dieses Objekt ist eine Instanz der Component cGlobal, die im Namespace FSGeneral im SystemPackage definiert ist. Für weitere Informationen siehe cGlobal. SafeInitializing Siehe SafeInitializing"
  },
  "doc/html-client/android-app.html": {
    "href": "doc/html-client/android-app.html",
    "title": "Android App",
    "keywords": "Android App Für die volle Integration des HTML-Clients in die mobile Welt, stellen wir im Google Play Store den Client als Android App zur Verfügung. Die App basiert auf demselben Sourcecode wie die Browser-Version. Einzelne Features greifen im Gegensatz zu einem Browser aber direkt auf die Hardware des mobilen Geräts zu und integrieren sich dadurch besser in die App. Name der App: Framework Studio Mobile Client Store Link: https://play.google.com/store/apps/details?id=com.fs.htmlclient Note Apple verweigert Apps per Richtlinie, dynamische Benutzeroberflächen von einer extenen Quelle (Broker) zu laden und am Client aufzubauen. Durch diese Limitierung sind wir leider nicht in der Lage, den Framework Studio Mobile Client auf IOS bereitzustellen. APK für direkte Installation Für Geräte, die keinen Zugriff auf den Play Store haben, bieten wir die Mobile Client App auch direkt als APK an. Unter folgendem Link stehen alle APK's der einzelnen Releases zum Download bereit: https://github.com/FrameworkSystemsGmbH/HtmlClient/releases Systemvoraussetzungen Unterstützt werden Handys und Tablets mit Android 8.0 oder höher. Der Framework Studio Mobile Client ist eine App basierend auf dem Ionic Capacitor Framework, welches HTML-Applikationen mit Hardware-Unterstützung auf mobile Endgeräte bringt. Ist auf dem Endgerät Google Chrome nicht installiert, so wird zur Anzeige der HTML-Applikation die integrierte Android WebView verwendet. Diese basiert wie Google Chrome ebenfalls auf der Chromium Engine, ist aber auf vielen - vor allem älteren - Endgeräten nur in einer sehr betagten Version verfügbar. Dies kann ggf. zu Fehlern führen. Es gelten folgende Regeln: Ist Google Chrome installiert, wird dessen Chromium Engine für die Ausführung des Framework Studio Mobile Client verwendet Ist Google Chrome nicht installiert, wird die Android WebView verwendet Note Auch auf neueren Geräten ab Android 8.0 empfehlen wir, die aktuellste Version von Google Chrome zu installieren, um die breiteste Unterstützung von Features und die fehlerfreie Darstellung der App zu garantieren. Einrichten eines Brokers Es muss natürlich definiert werden, mit welchem Broker sich der Mobile Client verbinden soll. Nach dem Start der App wird der Login angezeigt. Über den Button „+ New“ können beliebig viele Broker zur Liste hinzugefügt werden. Es ist auch möglich, Urls von Development Brokern hinzuzufügen. Dabei ist zu beachten, dass der Mobile Client nur auf den Development Broker zugreifen kann, wenn dieser über das Netzwerk erreichbar ist. Dazu muss Framework Studio mit Administrator-Rechten ausgeführt werden. Ob der Development Broker vom Netzwerk aus zugreifbar ist, kann über das Tray-Icon geprüft werden:"
  },
  "doc/html-client/controls.html": {
    "href": "doc/html-client/controls.html",
    "title": "Controls",
    "keywords": "Controls Symbol Bedeutung + Property oder Event wird vollständig unterstützt - Property oder Event wird nicht unterstützt o Property oder Event wird teilweise unterstützt (Anmerkung beachten) Allgemein Die folgende Auflistung beinhaltet diejenigen Properties und Events, die an allen verfügbaren Controls im HTML-Client vorhanden sind. Properties Name Unterstützt Anmerkung Alignment + BackColor + BorderColor + BorderRadius + BorderThickness + ButtonGroupDataSource + Caption + DockPanel.ItemSize + Font Family - Ist im Client hart definiert auf die Hierarchie Arial -> Helvetica -> Sans-Serif. Font Bold + Font Italic + Font Underline + ForeColor + IsEditable + LabelTemplate + MapEnterToTabAction - Margin + MaxSize + MinSize + Name + Padding + Shortcut - TabStop + ToolTip + Visibility + Events Name Unterstützt OnCanDrop - OnDrag - Form Properties Name Unterstützt BadgeImage DataSource + HideModalHeader + IsCloseIconVisible + MainMenu - PreferredSize - SymbolImage - Title + VerticalScrollbarOverlay - Events Name Unterstützt OnLoad + OnClose + Dock Panel Properties Name Unterstützt Anmerkung BackgroundImage - BackgroundScaleMode - DockPanelOrientation + Scrolling o Es wird immer VerticalOverlay verwendet, auch wenn Normal ausgewählt wurde, da in vielen Browsern die Breite der Scrollbar nicht berechnet werden kann. Spacing + Events Name Unterstützt OnEnter - OnLeave - Wrap Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - ContentAlignment + InvertFlowDirection + Spacing + WrapArrangement + Events Name Unterstützt OnEnter - OnLeave - Field Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - RowLabelTemplate + SynchronizeColumns + Events Name Unterstützt OnEnter - OnLeave - Field Row Properties Name Unterstützt FieldRowSize + LabelMode + OptimizeGeneratedLabels + Button Properties Name Unterstützt ShowCaption + TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + ImageButton Properties Name Unterstützt BadgeImage DataSource + CaptionAlign - ContextMenu - DataSource - DisabledImage + HighlightImage - Image + MouseOverImage + PressedImage + ScaleMode - ShowCaption + SymbolImage - TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + Label Properties Name Unterstützt DataSource + TextAlign + Events Name Unterstützt OnEnter + OnLeave + CheckBox Properties Name Unterstützt DataSource + ShowCaption + Events Name Unterstützt OnClick + OnEnter + OnLeave + Editfield Properties Name Unterstützt Anmerkung CaptionAsPlaceholder + DataSource + DisabledBackColor o Wird dynamisch im Client berechnet DisplayLength + Editor o Nur \"PlainText”, \"HTML” wird nicht unterstützt Format + FormatPattern o Funktioniert nur mit Format \"Decimal\" Multiline + PasswordChar + Client generiert ein Password-Feld, wenn gesetzt. Das Passwort-Zeichen selbst kann aber nicht geändert werden (in Web Browsern technisch nicht möglich). ScrollBars + SelectionEnd - SelectionStart - TabStop + TextAlign + WordWrap + Events Name Unterstützt OnEnter + OnLeave + OnValidated + ComboBox Properties Name Unterstützt CaptionAsPlaceholder + DataSource + DisplayLength + EditStyle + List + ListOrder + MaxDropDownSize + TabStop + Events Name Unterstützt OnEnter + OnLeave + OnSelectionChanged + RadioButton Properties Name Unterstützt CaptionDataSource + DataSourceOnValue + Events Name Unterstützt OnEnter + OnLeave + OnClick + Picture Siehe Picture. Note Im HTML Client muss einem Picture Control eine MinSize zugewiesen werden. Eine automatische Größenanpassung eines Picture Controls an den Inhalt ist nicht möglich. Properties Name Unterstützt CaptionAlign + DataSource + ScaleMode + ShowCaption + Events Name Unterstützt OnClick + OnEnter - OnLeave - ListView Siehe ListView. Properties Name Unterstützt DataSource + ItemArrangement + ItemSize + SelectedItems + SelectionMode + SelectorPosition + Spacing + Template + Events Name Unterstützt OnEnter - OnLeave - OnItemActivated + OnItemSelectionChanged + Template Control Siehe Template Control. Properties Name Unterstützt Template + Events Name Unterstützt OnEnter - OnLeave - Tabbed Window Properties Name Unterstützt DataSource + TabTemplateActive + TabTemplateDisabled + TabTemplateInactive + Events Name Unterstützt OnSelectedTabPageChange + OnSelectedTabPageChanged +"
  },
  "doc/html-client/fokussystem.html": {
    "href": "doc/html-client/fokussystem.html",
    "title": "Hinweis zum Fokussystem",
    "keywords": "Hinweis zum Fokussystem Ein besonderes Augenmerk muss auf die SetFocus Action in Verbindung mit den OnEnter und OnLeave Events an Controls gelegt werden, da in diesem Zusammenhang der JavaClient und HTML Client unterschiedlich reagieren. Vergleich zum JavaClient In der Programmierung für den JavaClient wird sehr oft der Fokus in einem OnLeave Event in ein anders Control gesetzt, welches nicht das direkt nachfolgende ist. Z.B. werden nach der Eingabe mehrere Textfelder übersprungen oder der Fokus in ein Grid gelegt. Diese Art der Programmierung funktioniert im JavaClient, da dessen Eventsystem synchron aufgebaut ist. D.h., der JavaClient kann bei einem OnLeave Event auf eine Antwort des Brokers warten, bevor er den Fokus tatsächlich in das gewünschte Control setzt. Dadurch wird das Fokussystem auch durch länger andauernde Requests nicht \"gestört\". Asynchrones Eventsystem in Browsern Das Eventsystem eines Web Browsers läuft hingegen asynchron ab. Bei einem Fokuswechsel kann zwar ein Broker Request abgesetzt werden (z.B. in einem OnLeave Event an einem Textfeld), auf dessen Response kann allerdings nicht gewartet werden. Dies hat zur Folge, dass der Fokus vom Browser ggf. in das nachfolgende Control gesetzt wird, bevor der Broker Request abgeschlossen ist. Je nachdem wie viel Zeit der Broker Request benötigt, kann dies in Verbinung mit der SetFocus Action zu seltsamen Effekten am Client führen. Das kann im schlimmsten Fall einen \"Focus-Lock\" hervorrufen, bei dem der Fokus in einem Control \"festhängt\". Dieses Dilemma kann technisch nicht gelöst werden. Aus diesem Grund gilt für die HTML Client Programmierung folgende Gundregel: Note In einem OnEnter oder OnLeave Event darf niemals eine SetFocus Action aufgerufen werden!"
  },
  "doc/html-client/funktionsumfang.html": {
    "href": "doc/html-client/funktionsumfang.html",
    "title": "Funktionsumfang",
    "keywords": "Funktionsumfang Der HTML-Client befindet sich noch in der agilen Entwicklung. Verglichen mit dem ausgereiften JavaClient ist der Funktionsumfang des HTML-Clients noch überschaubar. Neue Funktionen und die Unterstützung für weitere Controls werden kontinuierlich weiter entwickelt und veröffentlicht. Note Wird in diesem Kapitel etwas nicht erwähnt, wie z.B. ein Property eines Controls, eine Action oder andere Client-Funktionalitäten, so muss davon ausgegangen werden, dass diese noch nicht unterstützt werden. Handhabung von nicht unterstützten Funktionalitäten Es gibt im Form Designer oder im Code Editor von Framework Studio keine Limitierungen, die den Entwickler auf den Funktionsumfang des HTML-Clients einschränken. Werden Controls, Actions oder anderweitige Funktionalitäten genutzt, die vom HTML-Client nicht unterstützt werden, so werden diese (so weit es möglich ist) vom Client ignoriert. Wenn z.B. ein Grid-Control in ein Form eingebaut wird, so wird dieses erst garnicht vom HTML-Client interpretiert. Dasselbe gilt für nicht unterstützte Properties an Controls. Frameset Der HTML-Client besitzt kein Frameset. Alle geöffneten Forms werden in einer einzigen Liste organisiert. Es ist irrelevant, welchem Frame ein Form in einem Workflow zugeordnet ist. MessageBox und ExceptionBox Werden vollständig unterstützt inkl. Buttons, Icons, DialogResult und EventHandler. Werden im Client als modale Popups angezeigt. Modale Forms Modale Forms, die das Wechseln zu einem anderen Form unterdrücken, werden vom HTML-Client vollflächig angezeigt. Dabei wird der Menü-Button ausgeblendet. Verhalten beim Drücken des „Zurück“-Button auf einem mobilen Gerät: Wenn am Form das Property IsCloseIconVisible auf true gesetzt ist, wird der modale Dialog geschlossen. Wird dem Form über die Action SetCloseButton ein Button zugewiesen, dessen Click-Event beim Schließen ausgelöst werden soll, wird dies beim Drücken des Zurück-Button ebenfalls ausgelöst. Ist das Property HideModalHeader am Form auf true gesetzt, so wird der Header mit dem Titel und ggf. dem Close Button komplett ausgeblendet, um mehr Platz für Controls zu schaffen. In diesem Fall muss das Schließen des Dialogs über einen eigens implementierten BUtton erfolgen, der am Form die Methode Close() aufruft. Drag & Drop Drag & Drop und alle damit verbundenen Events werden vom HTML Client nicht unterstützt. Shortcuts und ToolTips Da für den HTML-Client die mobile Welt im Vordergrund steht, werden Shortcuts und ToolTips noch nicht unterstützt, da diese auf einem Handy bzw. Tablet keinen Sinn machen. Control Styles Control Styles werden für alle im HTML-Client verfügbaren Controls unterstützt. Wird im Form Designer einem Control ein Control Style zugeordnet, so werden dessen Properties korrekt interpretiert bzw. die Property-Hierarchie beachtet. Actions Es werden derzeit folgende Actions unterstützt: Beep (ab FS 4.4) BeepDouble (ab FS 4.4) BeepMultiple (ab FS 4.4) GetGeoLocation ScanBarcode SetCaption SetCloseButton SetEnabled SetImage SetTitle SetVisible TakePhoto PrintReport ViewDocument ViewDocument Action Die ViewDocument Action ist im HTML Client auf folgende Url-Schemen limitiert: fsbroker://*/* http://*/* https://*/* mailto:* geo:* \\* sms:* Zurück-Button auf mobilen Geräten Mobile Geräte (z.B. Android) besitzen teilweise einen Zurück-Button. Der HTML Client unterstützt diesen kontextabhängig. Es gibt drei Prioritätsebenen, die nacheinander durchlaufen werden. Wird in einer Ebene auf das Drücken des Zurück-Buttons reagiert, so werden die darunter liegenden Ebenen nicht mehr behandelt. Die Ebenen geordnet nach Priorität sind: Overlays Modale Dialoge Normale Anzeige Overlays Als Overlay definiert sich alles, was sich mit einem ausgegrauten Hintergrund über die restliche Anzeige legt, wie z.B. MessageBoxen oder die ComboBox-Auswahl. Wenn ein Overlay geöffnet ist und der Zurück-Button gedrückt wird, wird das Overlay geschlossen. Eine MessageBox kann nur durch den Zurück-Button geschlossen werden, wenn ein Abbrechen-Button vorhanden ist. Modale Dialoge Modale Dialoge können mit dem Zurück-Button geschlossen werden, wenn das Property IsCloseIconVisible am Form auf true gesetzt ist. Wurde dem Form über die Action SetCloseButton ein Button mit einem Click-Event zugeordnet, so wird beim Drücken des Zurück-Buttons das Click-Event ausgelöst. Normale Anzeige Befindet sich der HTML Client in einem normalen Form, wird beim Drücken des Zurück-Buttons das Beenden der Application angestoßen, was mit der Rückfrage, ob die Session beendet werden soll, einher geht. Befindet sich der HTML Client im Broker-Auswahldialog, wird die Anwendung ohne Rückfrage geschlossen. Szenarien beim Schließen des letzten Forms Wird das letzte Form der Applikation geschlossen, so muss die Session beendet werden, da eine Applikation ohne Forms keinen Sinn ergibt. Allerdings müssen 2 Szenarien bei der Entwicklung bedacht werden, die auftreten können, wenn das letzte Form geschlossen wird: Das letzte Form hat keinen CloseButton zugewiesen und sendet beim Schließen somit keinen Request zum Broker. Wird dieses Form über das \"X\" (vorausgesetzt IsCloseIconVisible am Form ist auf auf true gesetzt) geschlossen, so wird eine Rückfrage angezeigt, ob die Session beendet werden soll. Wird diese mit \"Ja\" beantwortet, beendet der HTML Client die Session und zeigt die Broker-Auswahl an. Wird \"Nein\" ausgewählt, so bleibt das Form sowie die Applikation offen. Das letzte Form hat einen CloseButton zugewiesen, über dessen Handler brokerseitig mit der CloseForm() Action das Form geschlossen wird. Wird im gleichen Request kein anderes Form geöffnet und existiert somit nach dem Request kein offenes Form, so wird die Applikation vom Client ohne Rückfrage geschlossen. Da das Schließen des Forms vom Broker ausgeht, hat der Client \"kein Mitspracherecht\" mehr. Eine Rückfrage müsste brokerseitig über eine MessageBox implementiert werden. Wird im gleichen Request ein neues Form geöffnet, so wird die Applikation nicht beendet und ganz normal das neue Form am Client angezeigt. Beispielsweise könnte nach dem Schließen des letzten Forms ein Login-Dialog angezeigt werden."
  },
  "doc/html-client/index.html": {
    "href": "doc/html-client/index.html",
    "title": "HTML-Client",
    "keywords": "HTML-Client Neben dem Java Client bietet Framework Studio auch einen HTML-Client für Desktop- sowie mobile Geräte an. Dieser unterstützt noch deutlich weniger Funktionen und Controls als der Java Client. Was derzeit schon mit dem HTML-Client möglich ist, erfahren Sie in diesem Kapitel. Aktivieren des HTML-Clients Damit der HTML-Client über den Run Wizard und die Broker-Startseite gestartet werden kann, muss in der Application die Checkbox Supports Html Client gesetzt werden. Dies soll vermeiden, dass bisher existierende Applikationen ohne Weiteres im HTML-Client gestartet werden können, da diese sehr wahrscheinlich auf Controls und Funktionalitäten aufbauen, die derzeit vom HTML-Client noch nicht oder nicht vollständig unterstützt werden. Note eNVenta ERP ist nicht mit dem HTML-Client kompatibel und kann weder im Browser, noch auf Mobilen Geräten verwendet werden. eNVenta ERP nutzt nicht unterstützte Controls wie z.B. Grids, TreeViews oder Custom Controls. Auch die Fokus-Logik ist derart komplex, dass sie im HTML an ihre technischen Grenzen stößt. Um den HTML-Client nutzen zu können, muss eine speziell dafür ausgelegte Application erstellt werden, die den Funktionsumfang des HTML-Clients respektiert. Browser-Unterstützung Desktop Der HTML-Client basiert auf modernster Webtechnologie und benötigt deshalb auch einen aktuellen Browser für die Ausführung. Für Desktopsysteme empfehlen wir folgende Browser: Chrome Firefox Auch alle weiteren Browser, basierend auf der Chromium-Engine (Edge, Vivaldi, Opera), funktionieren problemlos. Note Microsoft Edge (ohne Chromium) und Internet Explorer 11 werden nicht unterstützt. Mobile Endgeräte Eine auf den HTML-Client ausgelegte Applikation kann über die Broker-Startseite natürlich auch von einem beliebigen mobilen Gerät aus gestartet werden, welches über einen aktuellen Browser verfügt. Die Unterstützung der Browser im mobilen Umfeld ist sehr schwer zu beurteilen, da es gerade auf Android eine extrem große Auswahl gibt. Wir empfehlen deshalb folgende mobilen Browser: Chrome Firefox Edge Dolphin Safari (ab iOS 10)"
  },
  "doc/html-client/lizenzen.html": {
    "href": "doc/html-client/lizenzen.html",
    "title": "Hinweis zu Lizenzen",
    "keywords": "Hinweis zu Lizenzen Timeout Aus technischen Gründen kann der HTML-Client weder im Browser, noch in der App auf einem mobilen Gerät dem Broker mitteilen, dass er beendet wurde. Z.B. kann auf einem Android-Gerät nicht unterschieden werden, ob eine App nur in den Ruhezustand gewechselt hat oder komplett geschlossen wurde. Dies hat zur Folge, dass Broker-Sessions, die von einem HTML-Client aus gestartet wurden, offen bleiben, bis der Broker sie von sich aus verwirft. Diese Zeitspanne beträgt 12 Stunden. ClientID Um dem Verbrauch von Lizenzen entgegen zu wirken, wird im HTML-Client eine ClientID generiert, die den Browser bzw. das mobile Gerät identifiziert und mit zum Broker geschickt wird. Im Browser ist die ClientID eine UUIDv4, die im Code generiert wird, auf mobilen Geräten wird die Cordova-Geräte-ID herangezogen. Über die ClientID kann der Broker den Browser bzw. das mobile Gerät identifizieren und bei einem erneuten Start einer Anwendung diesem die bisherige Lizenz zuordnen. Zusatz für mobile Geräte Die ClientID auf mobilen Geräten ist immer gleich. Ein mobiles Gerät verbraucht am Broker eine Lizenz unabhängig vom Benutzer. Zusatz für Browser Ein Browser hat keinen Zugriff auf das Betriebssystem und den Computer. Die generierte ClientID wird deshalb im sogenannten „Local Storage“ des Browsers gespeichert. Dieser Speicher ist je nach Konfiguration benutzerabhängig. Beispiel: Ist auf einem Computer, den drei Benutzer verwenden, Firefox als Browser installiert, so hat jeder Benutzer seinen eigenen Local Storage. Dies bedeutet, dass jeder Benutzer seine eigene ClientID bekommt und somit auch drei Lizenzen am Broker verbraucht werden. Dies gilt auch, wenn ein Benutzer dieselbe Applikation einmal im Firefox und einmal im Chrome öffnet. Die beiden Browser haben separate Local Storages und verbrauchen somit auch wieder zwei Lizenzen am Broker."
  },
  "doc/html-client/mobile/barcode.html": {
    "href": "doc/html-client/mobile/barcode.html",
    "title": "Barcode Scanner",
    "keywords": "Barcode Scanner Note Dieses Feature steht nur in der Android-App zur Verfügung. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser. Über die in einem mobilen Gerät integrierte Kamera können im HTML Client Barcodes unterschiedlicher Formate eingescannt werden. Unterstützte Formate Name Beispiel Name Beispiel AZTEC EAN_13 CODABAR ITF CODE_39 PDF_417 CODE_93 QR_CODE CODE_128 UPC_A DATA_MATRIX UPC_E EAN_8 Action ScanBarcode() Der Scan-Vorgang wird am Form über die Action ScanBarcode() gestartet. Note Es wird dringend empfohlen, nur diejenigen Barcode-Formate zu übergeben, die auch tatsächlich beim Scan-Vorgang unterstützt werden sollen, um Fehler beim Scannen zu vermeiden. Je geringer die Anzahl der unterstützten Formate ist, desto unwahrscheinlicher ist es, dass der Scan fehlschlägt. // Aufruf der Action beim Click des Scan-Buttons protected virtual void FE_btnScanArticle_OnClick(FrameworkButtonClickEventArgs e) { this.ScanBarcode( this.ScanBarcodeCallback, BarcodeFormat.EAN_8 | BarcodeFormat.EAN_13, \"Article\" ); } Wenn der Scan-Vorgang am Client abgeschlossen ist, wird die übergebene Callback-Methode aufgerufen. In ihr können die gescannten Daten weiterverarbeitet werden. Der Callback-Methode wird dafür ein Objekt mit dem Typ IFrameworkBarcodeScanInfo übergeben. // Callback-Methode protected virtual void ScanBarcodeCallback(IFrameworkBarcodeScanInfo e) { if (e.HasError) { this.sValue = e.ErrorMessage; } else if (e.Cancelled) { this.sValue = \"Cancelled\"; } else { if (e.Identifier == \"Article\") { this.sArticle = e.Value; } else { this.sAmount = e.Value; } this.sFormat = e.Format.ToString(); } } Berechtigung für Kamera Der Barcode Scanner benötigt auf dem mobilen Gerät Zugriff auf die Kamera. Diese muss z.B. auf einem Android-Gerät einmalig erteilt werden:"
  },
  "doc/html-client/mobile/deeplinks.html": {
    "href": "doc/html-client/mobile/deeplinks.html",
    "title": "Deep Links",
    "keywords": "Deep Links Der Android Mobile Client unterstützt das Öffnen von Deep Links. Damit kann z.B. aus einem Browser heraus per Link der Mobile Client geöffnet und automatisch ein Login an einem Broker ausgeführt werden. Zudem kann der Broker-Liste ein Eintrag hinzugefügt werden. Beispiel im HTML: <a href=\"fsbroker://framework-systems.de?name=Demo&url=http%3A%2F%2FAwesomeServer%3A8080%2FAwesomeApplication&login=true&save=true\">Open Deep Link</a> Der Link beginnt immer mit der Custom-Url fsbroker://framework-systems.de. Diese wird vom Mobile Client im Android-System registriert und sorgt für das Öffnen der App. Zusätzlich kann die Url aus bis zu vier der folgenden Parameter bestehen: Parameter Typ Benötigt Funktion name string (url-encoded) Ja Der Name des Brokers url string (url-encoded) Ja Die Broker-Url login boolean (true/false) Nein Steuert, ob sich die App nach dem Öffnen sofort am gegebenen Broker angemelden soll. Bei false wird lediglich die Startseite angezeigt. Der Standardwert ist true. save boolean (true/false) Nein Steuert, ob der angegebene Broker in der Login-Liste des Mobile Client gespeichert werden soll. Existiert ein Eintrag mit demselben namen, so wird dessen Url überschrieben. Der Standardwert ist false. Die Parameter name und url müssen immer url-enkodiert sein. So muss wie im Beispiel statt http://AwesomeServer:8080/AwesomeApplication die url-enkodierte Variante http%3A%2F%2FAwesomeServer%3A8080%2FAwesomeApplication angegeben werden. Einen entsprechenden Url-Encoder finden Sie z.B. unter https://www.urlencoder.org Note Ein Klick auf einen Deep Link wird vom Mobile Client nur dann interpretiert, wenn folgende Bedingungen erfüllt sind: Die App ist nicht bereits an einem Broker angemeldet Die App findet beim Start keine alte Session, die fortgeführt werden kann"
  },
  "doc/html-client/mobile/index.html": {
    "href": "doc/html-client/mobile/index.html",
    "title": "Funktionalitäten für mobile Endgeräte",
    "keywords": "Funktionalitäten für mobile Endgeräte Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser."
  },
  "doc/html-client/mobile/kamera.html": {
    "href": "doc/html-client/mobile/kamera.html",
    "title": "Kamera",
    "keywords": "Kamera Über die in einem mobilen Gerät integrierte Kamera können im Mobile Client Bilder gemacht und zum Broker geschickt werden. Alternativ können schon vorhandene Bilder aus der Bildergallerie ausgewählt werden. Action TakePhoto() Der Vorgang wird am Form über die Action TakePhoto() gestartet. // Aufruf der Action beim Click eines Buttons protected virtual void FE_btn_OnClick(FrameworkButtonEventArgs e) { this.TakePhoto(this.TakePhotoCallback, CameraSource.CAMERA, \"Camera\"); } Wenn der Vorgang am Client abgeschlossen ist, wird die übergebene Callback-Methode aufgerufen. In ihr können die empfangenen Bilddaten weiterverarbeitet werden. Der Callback-Methode wird dafür ein Objekt mit dem Typ IFrameworkPhotoInfo übergeben. public virtual void TakePhotoCallback(IFrameworkPhotoInfo info) { this.Reset(); if (info.HasError) { this.sMessage = info.ErrorMessage; } else if (info.ImageBytes == null) { this.sMessage = \"ImageData is null\"; } else { if (info.Identifier == \"Camera\") { this.sMessage = \"Image from camera\"; } else { this.sMessage = \"Image from gallery\"; } this.binImage = info.ImageBytes; } } Berechtigung für Kamera und SD-Karte Die TakePhoto-Action benötigt auf dem Endgerät Berechtigungen für die Benutzung der Kamera sowie für das Lesen und Schreiben von Daten (Bildern) auf die SD-Karte bzw. den internen Gerätespeicher. Diese Berechtigungen müssen z.B. auf einem Android-Gerät einmalig erteilt werden."
  },
  "doc/html-client/mobile/standort.html": {
    "href": "doc/html-client/mobile/standort.html",
    "title": "Standortbestimmung",
    "keywords": "Standortbestimmung Der Mobile Client unterstützt die Bestimmung des aktuellen Standorts. Abhängig vom Gerät und abhängig davon, ob GPS aktiviert ist, wird entweder der GPS-Sensor angesprochen oder eine Annäherung des Standoprtes über das Mobile Netzwerk angestoßen. Action GetGeoLocation() Der Vorgang wird am Form über die Action GetGeoLocation() gestartet. // Aufruf der Action beim Click eines Buttons protected virtual void FE_btn_OnClick(FrameworkButtonEventArgs e) { this.GetGeoLocation(this.GetGeoLocationCallback, \"Start\"); } Wenn der Vorgang am Client abgeschlossen ist, wird die übergebene Callback-Methode aufgerufen. In ihr können die empfangenen Standortdaten weiterverarbeitet werden. Der Callback-Methode wird dafür ein Objekt mit dem Typ IFrameworkGeoLocationInfo übergeben. public virtual void GetGeoLocationCallback(IFrameworkGeoLocationInfo info) { this.Reset(); if (info.HasError) { this.sError = info.ErrorMessage; } else { if (info.Identifier == \"Start\") { this.sInfo = \"Start location of our journey\"; } else { this.sInfo = \"Destination location of our journey\"; } this.sIdentifier = \"Identifier: \" + info.Identifier; this.sLatitude = \"Latitude: \" + (info.Latitude.HasValue ? info.Latitude.ToString() : \"N/A\"); this.sLongitude = \"Longitude: \" + (info.Longitude.HasValue ? info.Longitude.ToString() : \"N/A\"); this.sAltitude = \"Altitude: \" + (info.Altitude.HasValue ? info.Altitude.ToString() : \"N/A\"); this.sAccuracy = \"Accuracy: \" + (info.Accuracy.HasValue ? info.Accuracy.ToString() : \"N/A\"); this.sHeading = \"Heading: \" + (info.Heading.HasValue ? info.Heading.ToString() : \"N/A\"); this.sSpeed = \"Speed: \" + (info.Speed.HasValue ? info.Speed.ToString() : \"N/A\"); this.sTimestamp = \"Timestamp: \" + (info.Timestamp.HasValue ? info.Timestamp.ToString() : \"N/A\"); } } Note Wie an den Nullable-Typen zu sehen ist, können Abhängig vom Gerät und dessen Sensorik ggf. einzelne Werte der oben gegebenen Auflistung nicht verfügbar sein. Es ist zwingend nötig, vor der Verarbeitung immer auf die Verfügbarkeit der Werte zu prüfen. Berechtigung für die Bestimmung des Standortes Die GetGeoLocation-Action benötigt auf dem Endgerät die Berechtigung zur Bestimmung des Gerätestandortes. Diese muss z.B. auf einem Android-Gerät einmalig erteilt werden."
  },
  "doc/html-client/only-android.include.html": {
    "href": "doc/html-client/only-android.include.html",
    "title": "",
    "keywords": "Note Dieses Feature steht nur in der Android-App zur Verfügung. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser."
  },
  "doc/ide/allgemeine-funktionalitaeten.html": {
    "href": "doc/ide/allgemeine-funktionalitaeten.html",
    "title": "Allgemeine Funktionalitäten",
    "keywords": "Allgemeine Funktionalitäten Buttons Einige der nachfolgend beschriebenen Buttons werden in unterschiedlichen Zusammenhängen angeboten. Die angebotene Funktion des Buttons bezieht sich daher immer auf den Kontext, in dem der Button dargestellt wird. New: Dieser Button erzeugt ein neues Element. Beim Klick auf den Button wird ein Kontext-Menü angezeigt, mit dem Sie auswählen, was für ein Element erzeugt werden soll. Im Detailfenster einer Component zum Beispiel, können Sie mit diesem Button der Component ein neues Property oder eine neue Methode hinzufügen. Auf der Registerkarte Namespaces können Sie mit diesem Button dem im Objekt-Baum (unterer Baum) dargestellten Namespace neue Namespace Elemente hinzufügen, wie zum Beispiel Metadatentypen, Components, Forms. Delete: Das Element im aktuellen Kontext wird mit dem Button Delete gelöscht. Der Löschvorgang wird erst mit betätigen des Buttons Save All wirksam. Wird das ausgewählte Element noch von einem anderen Element benutzt, wird eine Fehlermeldung mit dem entsprechenden Hinweis angezeigt: Mit dem Button Details wird eine Liste aller Verwendungen angezeigt. Derive: Wenn Sie diesen Button betätigen, wird das ausgewählte Element vererbt. Dies funktioniert bei Metadatentypen, Reports, Forms und Workflows. Customize: Im aktiven Package, also in dem Package, an dem Sie sich angemeldet haben, wird von dem ausgewählten Element eine Customization angelegt. Das bedeutet, dass ein Element, das in einem Basis-Package definiert bzw. programmiert wurde, im aktiven Package geändert werden kann. Save: Speichert die Änderungen des Elements im aktuellen Kontext ab. Alle Änderungen werden erst beim Save in das Repository zurückgeschrieben. Geänderte, aber noch nicht gespeicherte Elemente werden mit einem Stern nach dem Namen gekennzeichnet. Save All: Alle Änderungen im gesamten Projekt werden über diesen Button gespeichert. Undo Until Last Save: Mit diesem Button nehmen Sie alle Änderungen seit der letzten Speicherung zurück. Source-Control In Framework Studio kann immer nur ein Entwickler an einem Element arbeiten. Dazu muss dieser das zu bearbeitende Element auschecken. Die anderen Entwickler können das Element weiterhin in dem Stand öffnen, wie es war, bevor es ausgecheckt wurde. Wenn alle Änderungen an dem Element durchgeführt wurden, kann es wieder eingecheckt werden. Ab diesem Zeitpunkt werden die Änderungen auch für alle anderen Entwickler sichtbar. Warning Ein Element kann immer nur von einem Entwickler ausgecheckt werden. Für die Bedienung der Source-Control-Funktionalität stehen folgende Buttons zur Verfügung: Check Out: Checkt das Element aus, d.h. sperrt es für Änderungen durch andere Entwickler, damit Sie es bearbeiten können. Ist das Element bereits von einem Entwickler ausgecheckt, bekommen Sie eine entsprechende Fehlermeldung. Check In: Der Button Check In checkt das Element ein. Alle Entwickler sehen ab jetzt das von Ihnen aktualisierte Element. Ein anderer Entwickler kann das Element jetzt erneut auschecken. Undo Check Out: Hiermit machen Sie einen Check Out rückgängig. Dabei werden alle Änderungen, die nach dem Check Out gemacht wurden, verworfen. Bevor diese Funktion ausgeführt wird, werden alle Änderungen an ungespeicherten Elementen gespeichert (Save All). Sollte aufgrund von Abhängigkeiten beim Undo Check Out ein Problem auftreten, so startet Framework Studio neu, um weiterhin Datenkonsistenz garantieren zu können. Warning Diese vier Befehle können Sie auch über das Kontext-Menü des Elements aufrufen. Source Control im Kontext-Menü: CheckIn und CheckOut mit Shortcuts In den Code-Editoren ist es nun auch möglich mit den Shortcuts CTRL + F11 den CheckIn und mit CTRL + F10 den CheckOut auszuführen. Caution Bei der Verwendung des Shortcuts für CheckOut erfolgt keine Abfrage, ob Sie wirklich auschecken möchten. Der CheckOut wird automatisch durchgeführt, wenn er möglich ist. C#-Code-Editor Der Code kann mit dem Shortcut Shift + ALT + F formatiert werden. Compile Compile Options: Der Button Compile Options öffnet ein Kontextmenü, in dem Sie alle Optionen für den nächsten Kompiliervorgang festlegen können. Außerdem können Sie über dieses Kontextmenü einen Kompiliervorgang starten. Ergänzende Informationen erhalten Sie im Abschnitt Code Builder. Applications: Öffnet den Applications–Optionen-Dialog, in dem Sie u.a. einstellen können, in welchem Verzeichnis der IL-Code hinterlegt werden soll und wie sich der Session-Storage verhalten soll. Außerdem werden dort einige grundlegende Einstellungen bezüglich Design und Frameset der jeweiligen Anwendung festgelegt. Ergänzende Informationen können Sie dem Abschnitt Applications entnehmen. References: Der References–Dialog dient dem Einbinden von Assemblies. Wenn Sie weitere Informationen dazu benötigen, lesen Sie bitte den Abschnitt References. Icons Is Not Checked Out: Dieses Icon vor einem Element bedeutet, dass dieses Element bei dem angemeldeten Entwickler eingecheckt ist. Wollen Sie ein Element bearbeiten, müssen Sie es zuvor auschecken. Is Checked Out: Steht dieses Icon vor einem Element, ist das Element bereits von Ihnen ausgecheckt und kann bearbeitet werden. Wenn Sie mit der Bearbeitung fertig sind, können Sie das Element wieder über das Source-Control einchecken. Haben Sie ein Element versehentlich ausgecheckt, können Sie den Checkout-Vorgang mit Undo Checkout rückgängig machen. Warning Sie sollten darauf achten, dass Sie einen kompilierbaren Stand haben, bevor Sie ein Element wieder einchecken. Dazu ist es erforderlich auch in Zusammenhang stehende Elemente einzuchecken. Version History Sowohl über das Kontextmenü eines Objekts im Objektbaum auf der Registerkarte Namespaces als auch über das Hauptmenü können Sie sich unter dem Menüpunkt View/Version History einen Überblick über die einzelnen Entwicklungsstufen eines Objektes verschaffen. Dazu werden von allen bisher eingecheckten Versionen Versionsnummer, Benutzer, Datum, Kommentar und die Information, ob die Version bereits inspiziert wurde, angezeigt. Version History Report: Objekttyp und Name sowie der vollständige Name des Objektes (mit Namespaces) werden im Kopf des Reports angezeigt. Wenn zum Zeitpunkt der Reporterstellung ein Benutzer das Objekt ausgecheckt hat, so wird das mit dem blau gefärbten Kommentar „Checked out.“ unter der neuesten Versionsnummer ebenfalls in der Tabelle dargestellt. Über die Symbole am oberen Fensterrand wird Ihnen die Möglichkeit zum Drucken, Vergrößern, Blättern und Speichern des Reports bereitgestellt. Dieser Report steht Ihnen für alle Access Units, Components, Collections, Control Default Styles, Custom Controls, Datasources, DBTables (Tabellen im Database Editor), Forms, Global Events, Global Objects, Metadatatypes, Namespaces, Report Document Types, Resources and Workflows zur Verfügung. Source Control History Über den Menüpunkt Source Control/History im Hauptmenü von Framework Studio wird ein Report geöffnet, der einen Überblick über alle Check-In und Check-Out Vorgänge innerhalb des aktuellen Labels ermöglicht. Mit diesem Report können Sie sich einen guten Überblick darüber verschaffen, was sich seit einem bestimmten Datum geändert hat, welche Elemente im Moment noch ausgecheckt sind und welche Elemente noch nicht vom FrameworkCompiler kompiliert wurden. Ein Vergleich des generierten Codes mit der Vorgängerversion oder der aktuellen Version ist ebenfalls möglich. Source Control History: Es gibt zwei Modi: Checked In: Es werden nur eingecheckte Elemente ab dem angegebenen Datum angezeigt. Checked Out: Es werden alle im Moment ausgecheckten Elemente angezeigt. Mit dem Button Refresh wird die Tabelle aktualisiert. Durch Anklicken der Spaltenüberschrift kann nach allen Spalten sortiert werden. Die Tabelle kann über die Zwischenablage in andere Programme kopiert werden. Die Druckvorschau und der Druckdialog lassen sich über das Kontextmenü der Tabelle und mit den Buttons Print bzw. Preview öffnen. Besondere Spalten: Date: Ist der Text hellrot hinterlegt, wurde dieses Element noch nicht vom FrameworkCompiler kompiliert (Datum größer als das Datum des letzten „Refresh Workspace“ des FrameworkCompilers). Ist der Text gelb hinterlegt, wurde dieses Element zwar noch nicht vom FrameworkCompiler kompiliert, aber vom Benutzer über Get latest Check Ins im Workspace aktualisiert. Name: Durch anklicken eines Elements in dieser Spalte wird das Element im Designer geöffnet. Version: Durch anklicken einer Version kann der generierte Code des Elements mit der aktuellen Version oder der Vorgängerversion verglichen werden. Dazu öffnet sich nach Auswahl der Vergleichsversion der Diff Editor. Get latest Check Ins Über den Menüpunkt Source Control/Get latest Check Ins kann ein Dialog aufgerufen werden, über welchen der Benutzer-Workspace bis zu einem bestimmten Zeitpunkt aktualisiert werden kann, ohne dass ein FrameworkCompiler angestoßen werden muss. Der Dialog ist ähnlich der Source Control History aufgebaut. Er zeigt allerdings nur Elemente, die die folgenden zwei Kriterien erfüllen: Sie sind NACH dem letzten Refresh Workspace des Users eingecheckt Sie sind von anderen Usern eingecheckt Anders ausgedrückt zeigt die Liste alle von anderen Usern eingecheckten Elemente, die dem Workspace des aktuellen Users noch nicht bekannt sind. Beispiel: Benutzer demo1 und Benutzer demo2 holen sich nach einem nächtlichen Compilerlauf den FrameworkCompiler-Workspace. demo1 checkt Elemente aus, ändert sie und checkt sie wieder ein. Versucht demo2 diese Elemente nun auszuchecken, wird FS feststellen, dass neuere Versionen der Elemente verfügbar sind, die dem aktuellen Workspace noch unbekannt sind. Diese Elemente werden dann in der Liste von „Get latest Check Ins“ angezeigt (siehe Bild). In der Source Control History werden diese Elemente rot markiert dargestellt, da sie nach dem Compilerlauf eingecheckt wurden und dem aktuellen Workspace von demo2 nicht bekannt sind. Im Dialog hat der Benutzer nun die Möglichkeit, über die Checkboxen auszuwählen, bis zu welchem Zeitpunkt/Element er seinen Workspace updaten will. Nach dem Klick auf Refresh Elements startet sich Framework Studio automatisch neu. Dabei wird der Benutzer-Workspace genau bis zum ausgewählten Zeitpunkt/Element (im Beispiel frmCompany, 04.11.2011 14:20:23) aktualisiert. Die Elemente CompanyName, cdCompany und frmCompany können nun vom Benutzer demo2 ausgecheckt und bearbeitet werden, obwohl noch kein FrameworkCompiler gelaufen ist. In Get latest Check Ins verbleibt nur noch das Element OrderText. In der Source Control History erscheinen die aktualisierten Elemente nun gelb. Important Bei der Auswahl des Zeitpunkts/Elements bis zu dem aktualisiert werden soll, muss auf zusammenhängende Check Ins geachtet werden. Wenn z.B. frmCompany den Metadatentyp OrderText benötigt, dieser jedoch nicht mit aktualisiert wird (wie im Beispiel), kann es anschließend zu Compile-Fehlern kommen, da OrderText im Workspace nicht gefunden werden kann. Alle über Get latest Check Ins aktualisierten Elemente werden nach dem Neustart von Framework Studio automatisch zur Compile-Liste hinzugefügt. Copy Fullname. In allen Editoren gibt es im Menü Edit den Menüpunkt Copy Fullname. Dieser legt den Namen des Elementes inkl. Namespace in die Zwischenablage. So kann dieser z.B. in Dokumentationen eingefügt werden. GoTo Customization Top: Wechsel zur obersten Customization. Customization Up: Wechsel zur nächst höheren Customization. Customization Down: Wechsel zur nächst tieferen Customization. Customization Root: Wechsel zur Definition des Elements, also dem Basiselement, auf das die unterste Customization aufsetzt. Vorwärts- und Rückwärtsnavigation Framework Studio merkt sich bei jedem Verlassen eines Code Editors, über den grundsätzlich Methodencode bearbeitet werden kann, die aktuelle Cursorposition zusammen mit der Information, welche Methode gerade verlassen wird. Dies gilt für Methoden an Forms, Components, Proxies, Services, Service Hosts und in den Get- und Set-Methoden von Individual Properties an Components. Neben den Code-Editoren kann zusätzlich zwischen den LabeldRecords und den Controls des Form-Designers hin und her navigiert werden. Es werden maximal 25 Einträge gespeichert. Wenn ein Eintag eingefügt werden soll und alle 25 Speicherplätze bereits belegt sind, wird zuvor der älteste Eintrag verworfen. Mit dem Menüpunkt View/Navigate Backward (Tastenkombination ALT + Pfeil Links) kann jeweils zum zuvor gespeicherten Eintrag navigiert werden. Mit dem Menüpunkt View/Navigate Forward (Tastenkombination ALT + Pfeil Rechts) kann zum jeweils nächsten gespeicherten Eintrag navigiert werden, wenn zuvor rückwarts navigiert wurde. Des Weiteren ist die Navigation über die beiden Navigationstasten an der Seite der Maus möglich. Method History Browser Bei allen Elementen, die Methoden enthalten (z.B. Forms, Components, Services, FSTransformations, …) können Sie im Designer-Fenster mit dem Menüpunkt View / Method History Browser oder über das Kontextmenü im Editor, Methoden in verschiedenen Versionen innerhalb des Packages des Elements vergleichen. Initial wird aus der aktuellen Package-Version die derzeit ausgewählte Methode in der aktuellsten Version geladen und direkt mit der Vorversion der Methode verglichen. Als Vorversion wird die letzte Version mit Änderungen im Vergleich zur aktuellen Version der Methode ausgewählt. Wird eine Version manuell ausgewählt, wird immer automatisch mit der Vorversion verglichen. Um individuell verschiedene Versionen und Methoden miteinander vergleichen zu können, ist es möglich eine Version mit der Pinnnadel anzupinnen. Die angepinnte Version bzw. Methode ändert sich bei Selektion einer anderen Version bzw. Methode nicht mehr. Der Button Compare with current lädt für die rechte Seite die aktuelle Version, pinnt diese an und lädt die selektierte Version in die linke Ansicht. Für den direkten Vergleich der Versionen wird der Monaco Diff-Editor unterhalb der Auswahl angezeigt. Mit dem Button Compare in external tool ist es zudem möglich die Texte, die der Diff-Editor anzeigt mit einem externen Tool zu vergleichen. Das Diff Tool muss in den Framework Studio Optionen konfiguriert werden. Element History Browser Im Designer Fenster aller Elemente für die Code generiert wird (Components, Forms, Workflows, …), lässt sich über den Menüpunkt View / Element History Browser analog zum Method History Browser ein Dialog öffnen, mit dem die Historie des Elements im Package des Elements betrachtet werden kann. Der Element History Browser zeigt initial den generierten Code zu der ausgewählten Version und der Vorversion im Monaco Diff-Editor an. Die grundsätzliche Bedienweise gleicht dem Method Hisory Browser. Note Nur wenn das Package mit dem Framework Compiler compiled wurde exisitert für eine Version auch generated saved code. Methoden-Wächter Für Form-Methoden, Component-Methoden, ServiceProxy-Methoden, FsTransformation-Methoden, ServiceHost-Methoden, sowie get- und set-Methoden von Individual und DataContract Properties steht ein Methoden-Wächter zur Verfügung. Dieser kann bei überschriebenen Methoden alle Basis-Methoden und deren Änderungsstatus überwachen. Wird bei einem Compile festgestellt, dass sich in einer Basis-Methode etwas geändert hat, wird eine Compiler-Warning (FSWarn[2029]) ausgegeben: Methoden-Wächter Warnung: Der Wächter lässt sich über den Button in der Toolbar aktivieren: Aktivierung Methoden-Wächter: Ist der Wächter aktiviert, ändert sich das Symbol des Buttons in ein Refresh-Icon und der Button zum Deaktivieren des Wächters wird aktiv. Refresh- und Disable Buttons: Befinden sich mehrere Packages unter dem aktuellen Package, in dem der Methoden-Wächter aktiviert ist, wird nicht nur die direkte Basis-Methode überwacht, sondern der gesamte Basispfad bis zur virtual-Methode. Werden bei einem Compile Änderungen an einer der Basis-Methoden festgestellt, kann der Methoden-Wächter aktualisiert werden. Damit wird vom Entwickler bestätigt, dass die Änderung in der Basis-Methode keine Auswirkung auf den aktuellen Code hat. Mit dem Aktualisieren des Methoden-Wächters wird auch die Warnung während des Compile-Vorgangs eliminiert. Aktualisierung des Methoden-Wächters: Sollten beim Deaktivieren des Wächters noch nicht bestätigte Änderungen in den Basis-Methoden vorhanden sein, wird zuvor nochmals explizit gewarnt: Warnung beim Deaktivieren:"
  },
  "doc/ide/anwendung-starten.html": {
    "href": "doc/ide/anwendung-starten.html",
    "title": "Anwendung Starten / Fehlersuche",
    "keywords": "Anwendung Starten / Fehlersuche Hintergrundinformationen Application-Broker Das Brokerverzeichnis für den Application-Broker wird mit dem Button Broker Management im Application Dialog erzeugt. Dabei werden die folgenden Dateien in das Verzeichnis kopiert: Alle Ressourcen der Anwendung (z.B. Bilder) Java-Client Framework Studio Laufzeit-Assemblies Assemblies der Applikation (vom Benutzer FrameworkCompiler) Ein Request des Clients ruft im IIS eine ASP.net Seite auf. Der IIS kopiert dann automatisch alle benötigten Assemblies aus dem Brokerverzeichnis in ein temporäres Verzeichnis und verwendet dann diese temporären Kopien, um den Request zu verarbeiten. Der Vorteil des Kopierens liegt darin, dass die original Assemblies nicht direkt vom IIS verwendet werden und dadurch auch nicht blockiert werden. Auf diese Weise wird gewöhnlich der Echtbetrieb einer Anwendung realisiert. Development-Broker Der Development-Broker benötig im Gegensatz zum produktiven Broker keinen IIS für die Ausführung der Anwendung. Er ist ein leichtgewichtiger Katana (OWIN) Webserver, der direkt aus Framework-Studio heraus gestartet wird. Über die darin integrierte WebAPI-Schnittstelle werden alle nötigen Informationen zum Ausführen der Anwendung angeboten. Der Host arbeitet direkt auf dem Compile-Verzeichnis der jeweiligen Anwendung. Wird aus Framework Studio heraus eine Applikation gestartet, wird der Broker automatisch gestartet. Wird ein Compile gestartet, wird der Broker automatisch beendet und neu gestartet. Das ist notwendig, da er im Gegensatz zum IIS die Assemblies sperrt. Man erkennt an einem Symbol in der Task-Leiste, ob der Broker gerade läuft. Compile-Verzeichnis Beim Kompilieren der Anwendung werden alle Dateien in dieses Verzeichnis geschrieben. Das aktuell verwendete Compile-Verzeichnis kann über den Menüpunkt Compile / Open Compile Directory in Explorer geöffnet werden. Auf einem Rechner wird pro Framework Studio Entwickler, pro Package und pro Package-Version je ein eigenes Compile-Verzeichnis verwendet. Falls das aktuell zu verwendende Verzeichnis beim Start von Framework Studio noch nicht existiert, wird es automatisch angelegt. In den Compile-Verzeichnissen existieren immer die folgenden Unterordner: bin: Enthält alle Assemblies und ggf. Textdateien mit den benutzten Referenzen src: Enthält alle Source Dateien, die von Framework Studio generiert wurden. Durch das Kompilieren dieser Dateien werden die Assemblies der Anwendung (im Verzeichnis bin) erzeugt. Anwendung zum Testen starten Wenn Sie Ihre Anwendung während der Entwicklung zum Testen starten wollen, verwenden Sie dazu den Development-Broker. Dieser wird mit den Menüpunkt Compile / Run (oder mit der Taste F5) mit den zuletzt im Run-Wizard vorgenommenen Einstellungen gestartet. Wenn Sie die Einstellungen für den Start der Applikation (z.B. andere Business Datenbank verwenden) ändern möchten, öffnen Sie mit dem Menüpunkt Compile / Run… (oder der Tastenkombination Umschalt + F5) den Run-Wizard. Dort können alle Einstellungen vorgenommen werden. Wenn Sie den Wizard anschließend mit Run beenden, wird die ausgewählte Applikation mit den vorgenommenen Einstellungen gestartet. Debugging Die Anwendung kann mit einem beliebigen .NET Debugger (z.B. Visual Studio) debuggt werden. Dazu müssen Sie die für Sie relevanten Teile der Anwendung Debuggable kompiliert haben (Compile). Dadurch werden entsprechende .cs- und .pdb-Dateien in das Unterverzeichnis \\src des Compileverzeichnisses (Compile-Verzeichnis) geschrieben. Nach dem Start der Anwendung muss der Debugger an den Prozess FSDevBrokerHost.exe angehängt werden (Visual Studio: Menüpunkt Debug / Attach to process). Gegebenenfalls müssen Sie noch die relevanten .cs-Dateien im Debugger öffnen, um beispielsweise einen Breakpoint setzen zu können. Protokollieren der XML-Kommunikation In manchen Fällen ist es hilfreich, die Kommunikation zwischen Client und Broker zu analysieren. Dazu können sowohl die Anfragen des Clients (Request) als auch die Antworten des Brokers (Response) geloggt werden. Mit dem Menüpunkt Compile / Logging ... öffnen Sie den folgenden Dialog: Im Eingabefeld Directory wird das Verzeichnis angegeben, in das die Protokollierungsdaten geschrieben werden sollen. Das Verzeichnis wird beim Verlassen des Dialogs automatisch angelegt, wenn es noch nicht existiert. Der Benutzer Account, unter dem der IIS (Internet Information Services) läuft, muss Schreibzugriff auf dieses Verzeichnis haben. Es stehen vier Modi zur Auswahl: No Logging: Die Protokollierung ist abgeschaltet (Standardeinstellung) Log only last request and last response: Es werden genau zwei Dateien in das angegebene Verzeichnis geschrieben. In der einen Datei wird jeweils die letzte Anfrage des Clients gespeichert, in der anderen Datei jeweils die letzte Antwort des Brokers. Log each request and response to a unique file: Jede Anfrage des Clients und jede Antwort des Brokers wird in eine eigene Datei (mit Zeitstempel und aufsteigender Nummerierung) in das angegebene Verzeichnis geschrieben. Log each request and response to a unique file, for each token a new folder: Für jede Sitzung wird ein eigener Ordner im angegebenen Verzeichnis angelegt, in dem für jede Anfrage des Clients und für jede Antwort des Brokers eine eigene Datei geschrieben wird. Warning Es werden unter Umständen sehr viele Dateien auf der Festplatte angelegt! Diese müssen manuell wieder gelöscht werden. Die Log-Dateien können mit einem beliebigen XML-Viewer betrachtet werden."
  },
  "doc/ide/application.html": {
    "href": "doc/ide/application.html",
    "title": "Application",
    "keywords": "Application Um Ihre Anwendung erzeugen zu können, müssen Sie zunächst Ihre Anwendung geeignet konfigurieren. Mit einem neuen Repository wird unter dem Namespace FSGeneral > Applications automatisch ein Application-Element angelegt. Dieses kann aus dem Namespace-Tree oder über den Menüeintrag Compile > Application aufgerufen werden. Start Workflow: Hier wird angegeben, welchen Workflow die Applikation starten soll, nachdem sie gestartet wurde. Export: Über dieses Häkchen wird definiert, ob die Application bei einem Package-Export mit exportiert werden soll oder nicht. Registerkarte Broker General Supports Html Client Mit dieser Checkbox kann definiert werden, ob die Application mit dem HTML-Client gestartet werden kann. Ist die Checkbox gesetzt, dann wird in der Broker-Startseite der HTML-Client angeboten. Wird der HTML-Client aktiviert, muss sichergestellt werden, dass alle Fenster, die in der Application vom Benutzer erreicht werden auch vollständig vom HTML-Client unterstützt werden. (Siehe auch HTML-Client) Disable Form Navigation (HTML Client) Mit dieser Checkbox kann die Form-Navigation im HTML Client deaktiviert werden. Es ist dem User damit nicht mehr möglich, zwischen Forms zu wechseln. Der Applikations-Workflow muss entsprechend vom Entwickler vorgegeben werden. Service Name Name des Services unter dem der Broker erreichbar ist. Service Address Wenn Sie in der Checkbox Service Address einen Haken setzen, können Sie im dazu gehörigen Textfeld manuell die Adresse angeben, über welche die Applikation zu erreichen ist. Directory Hier wird das Web-Verzeichnis angegeben, in welches die vom Broker benötigten Dateien kopiert werden sollen. Über den Button haben Sie auch die Möglichkeit, das Verzeichnis über einen Auswahldialog zu suchen. Configuration Hier kann die Applikation manuell erweitert werden. Registerkarte Design Auf dieser Registerkarte werden allgemeine Design-Einstellungen für die Anwendung vorgenommen. Beispiele dafür sind: Start- und Hintergrundbild Größe auf dem Bildschirm Icon der Anwendung Unterstützung von Transparenz Standardfarben (z.B. Hintergrundfarbe der Menüs) Anwendungstitel DockLayoutXml Dieses XML ist das initiale Layout für das Docking-Framework des Java-Clients. Beendet ein Benutzer den Java-Client, speichert sich dieser das aktuelle Layout auf dem Client-Rechner. Beim nächsten Programm-Start liest er es wieder ein. Ist kein Layout gespeichert – z.B. beim ersten Start der Anwendung oder nach dem Zurücksetzen des Layouts durch den Benutzer – dann zieht diese Einstellung aus der Application. Das XML muss durch den Java-Client erzeugt und darf nicht von Hand bearbeitet werden. Mit den folgenden Schritten können Sie das XML aktualisieren: Am Client-Rechner das Layout der Anwendung zurücksetzen. Wenn die Anwendung keinen Befehl dafür kennt, dann im Ordner *%USERPROFILE%\\FSJavaClient* den entsprechenden Ordner löschen. Die Anwendung neu starten. Alle Fenster wie gewünscht anordnen. Dabei können auch Fenster aus dem Arbeitsbereich in einen Docking-Bereich platziert werden. Es sollten ausschließlich die notwendigen Fenster angeordnet werden, um unnötige Informationen zu verhindern. Achten Sie darauf, dass sich die gewünschten Fenster im Vordergrund befinden. Beenden Sie die Anwendung. Das Layout wird jetzt vom Client gespeichert. Es befindet sich im entsprechenden Ordner unter *%USERPROFILE%\\FSJavaClient* Öffnen Sie die Datei docking.xml mit einem Editor und fügen Sie deren Inhalt in das Property DockLayoutXml ein. Registerkarte Frameset Wenn in der Checkbox Use General Frame Set ein Haken gesetzt ist, wird ein Standard-Frameset verwendet. Dieses Standard-Frameset können Sie mit dem Button General Frame Set modifizieren. Wenn in der Checkbox Use General Frame Set kein Haken gesetzt ist, können Sie ein eigenes Frame Set im Textfeld Frame Set definieren. In der Combobox legen Sie den Frame fest, in dem Formulare standardmäßig geöffnet werden, wenn für ein solches nicht explizit angegeben wird, in welchem Frame es geöffnet werden soll. Registerkarte Authentication Wenn die Benutzer der Anwendung authentifiziert werden sollen, können Sie auf dieser Registerkarte das Authentifizierungssystem von Framework Studio aktivieren und die nötigen Einstellungen vornehmen. Zum Aktivieren der Authentifizierung muss in der Checkbox Enable Authentication ein Haken gesetzt werden. Im Bereich Default Login wird der Standardbenutzer angegeben, der automatisch von der Anwendung am Authentifizierungsdienst angemeldet wird, bis sich der Benutzer mit eigenem Namen und Passwort angemeldet hat. Programmbereiche, die diesem Default-Benutzer zur Verfügung gestellt werden, können also von allen noch nicht an der Anwendung angemeldeten Benutzern eingesehen werden. Dazu muss insbesondere das Login-Fenster gehören. Default User Name Name des Standardbenutzers Default User Password Passwort des Standardbenutzers Im Bereich Application Identity werden Eigenschaften festgelegt, mit denen sich die Anwendung am Authentifizierungsdienst (als Service) anmeldet. Service Name Unter diesem Namen wird die Anwendung im Authentifizierungsdienst angezeigt. Service ID Über diese Nummer (vom Typ Guid) wird die Anwendung eindeutig identifiziert. Wenn diese Nummer geändert wird, betrachtet der Authentifizierungsdienst diese Anwendung als eine andere Anwendung, auch wenn der Name identisch ist. Mit dem Button New Guid kann automatisch eine neue, eindeutige ID generiert werden. Warning Wenn Benutzern Rollen für eine Anwendung zugeordnet wurden und anschließend die Anwendung eine neue ID bekommt und somit als eine andere Anwendung am Authentifizierungsdienst erkannt wird, dann gelten die Rollen der Benutzer nicht für die Anwendung mit der neuen ID! Service Description In diesem Feld können Sie eine Beschreibung der Anwendung angeben. Diese Beschreibung wird im Verwaltungswerkzeug für den Authentifizierungsdienst angezeigt."
  },
  "doc/ide/bearbeiten-von-elementen.html": {
    "href": "doc/ide/bearbeiten-von-elementen.html",
    "title": "Bearbeiten von Elementen",
    "keywords": "Bearbeiten von Elementen Die Elemente, die in Framework Studio bearbeitet werden können, werden alle auf der Registerkarte Namespaces verwaltet. Es folgt eine Übersicht der Elemente im Framework Studio: Namespace Namespaces bilden eine Ordnerstruktur, in der alle anderen Elemente geordnet abgelegt werden. Ein Namespace kann auch wiederum andere Namespaces beinhalten. Resource Eine Ressource stellt eine beliebige Datei dar, die beim Kompilieren in das Brokerverzeichnis kopiert wird. Dadurch kann die Anwendung diese Datei (z.B. ein Bild oder eine externe DLL) verwenden. (Resources) Access Unit Über Access Units wird die Anwendung in einzelne Bereiche eingeteilt. Diese Bereiche können dann durch Laufzeitlizenzen und abhängig von den Rollen eines Benutzers gesperrt werden. (Access Units, Laufzeitlizenzen)) Metadatentype Ein Metadatentyp ist ein erweiterter Datentyp, der mehr Informationen enthält als ein normaler Datentyp unter .NET. Weitere Informationen sind z.B. Labels, Format und Controls. (Metadatentypen) Datasource Ein Datasource definiert eine Datenbankverbindung, die von der Anwendung zum Lesen und Schreiben der Anwendungsdaten benutzt werden kann. (Datasource) DBTable Ein DBTable ermöglicht Komponenten den Zugriff auf eine Datenbanktabelle, die über einen Datasource angesprochen werden kann. (DBTable) Code File Ein Code File ermöglicht individuellen Code zu definieren. (CodeFile) Component / Collection / Textcollection Eine Component ist eine funktionale Klasse, die bereits Grundfunktionalitäten wie das Lesen und Schreiben von Daten in eine Datenbank beherrscht. Eine Textcollection ist eine Sammlung von mehrsprachigen Texten. (Component / Collections, Textcollections) Modular Component Modular Components basieren auf der Idee eines Baukastens. Mit dessen Hilfe können Objekte ausschließlich mit dem benötigten Funktionsaufwand erstellt werden. Hierfür stehen drei verschiedene Modular Components Arten bereit mit unterschiedlichen Verwendungszwecken: Class/ClassWithInterface Interface UnitTest Die detaillierter Doku findet sich im Kapitel Modular Component. Report Document Type Hier werden ausdruckbare Reports und deren Schnittstelle definiert. (Report Document Type) Custom Control Durch Custom Controls ermöglicht Framework Studio das Hinzufügen von eigenen, spezialisierten Controls, die nicht zu den Standard-Controls gehören. (Custom Controls) Form Forms dienen der Visualisierung der Daten am Bildschirm. Sie enthalten Controls, welche die Daten anzeigen und bearbeiten können. (Form) Global Event Global Events dienen dazu, anwendungsweit Nachrichten zu senden. (Global Events) Workflow In Workflows wird die Kommunikation zwischen den Forms und dem Arbeitsablauf des Anwenders definiert. Workflows können Forms, Global Events, Links, Branches, Switches und andere Workflows enthalten. (Workflow Designer) Data Contract Data Contracts definieren komplexe Datenstrukturen für Service-Schnittstellen. (Data Contract) Service Contract Service Contracts legen fest, welche Operationen ein Service beinhaltet.(Service Contract) Service Implementiert die im Service Contract definierten Operationen. (Service) Service Host Legt Endpunkte und Übertragungsparameter für den Service fest. (Service Host Properties) Service Proxy Kapselt einen Service Host nach außen. (Service Proxy) Transformation Transformationen werden genutzt, um einen Eingangsdatentyp in einen Ausgangsdatentyp umzuwandeln. Häufig wird dies in Bezug auf Data Contracts verwendet. (Transformation) Elemente erstellen Ein neues Element lässt sich erstellen, indem Sie auf der Registerkarte Namespaces den Namespace auswählen, in dem das Element abgelegt werden soll. Mit dem Button der Registerkarte Namespaces oder dem entsprechenden Eintrag aus dem Menü wird im markierten Namespace ein neues Element angelegt. Es wird auch gleich im Hauptfenster geöffnet. Direkt nach dem Anlegen des Elements steht der Cursor in dem sich öffnenden Designer-Fenster auf dem Feld Name. Geben Sie hier den Namen des neuen Elements ein. Der Name lässt sich auch nachträglich noch ändern. Dazu öffnen Sie das Element und ändern die Bezeichnung im Feld Name oder wählen Sie aus dem Kontext-Menü des Elements auf der Registerkarte Namespaces den Eintrag aus. Warning Wird das Element bereits verwendet, kann es zu Problemen kommen, da nicht an allen Stellen der Name automatisch nachgezogen werden kann. Es empfiehlt sich, die Namen folgendermaßen zu vergeben: Namespace: XxxXxx Metadatentyp: mdtXxxXxx oder XxxXxx Component, die eine Datenbank-Tabelle anbietet: cdXxxXxx Andere Components: cXxxXxx Collections: cdXxxXxxColl bzw. cXxxXxxColl Textcollections: ctXxxXxx ReportDocumentTypes: rptXxxXxx Form: frmXxxXxx Global Event: gevXxxXxx Workflow: wflXxxXxx Elemente bearbeiten Um ein Element zu bearbeiten, öffnen Sie es mit einem Doppelklick auf der Registerkarte Namespace. Im Hauptteil von Framework Studio öffnet sich dann ein Desginer-Fenster für das ausgewählte Element. Dort können die gewünschten Änderungen vorgenommen werden. Mit dem Button Save werden die Änderungen gespeichert. Warning Namespaces können nicht geöffnet werden. Mit einem Doppelklick wird der Namespace auf- oder zugeklappt. Elemente löschen Löschen können Sie ein Element mit dem Menüeintrag File / Delete …. Dazu wird das gewünschte Element im Objekt-Baum markiert. Diese Funktion können Sie auch über das Kontext-Menü eines Elements im Objekt-Baum nutzen. Der Löschvorgang wird erst wirksam, wenn Sie den Button (Save All) drücken. Warning Durch das Speichern eines gelöschten Elements wird im Hintergrund automatisch ein CheckIn durchgeführt. Es werden auch alle Änderungen an anderen, geöffneten Elementen gespeichert. Elemente kopieren / einfügen Es ist möglich, verschiedene Elemente zu kopieren oder auch zusammenzuführen (mergen). Das funktioniert auch, wenn es sich bei Quelle und Ziel um unterschiedliche Repositories handelt. Folgende Elemente können kopiert und gegebenfalls zusammengeführt werden: MDT ServiceHost 1 Workflow Resource DBTable Service Proxy 2 DataContract Namespace 1 Collection Report ServiceContract Component TextCollection GlobalEvent 1 Service 2 Form Warning 1 Element kann nicht gemerged werden. 2 Ableitung des Elements kann weder kopiert noch gemerged werden. Allgemein Copy Über das Kontextmenü eines Elements, über den Menüpunkt Copy im Edit-Menü oder über die Copy & Paste Buttons kann ein Element kopiert werden. Paste Wird ein Element ohne Basis und ohne ID kopiert, kann es überall eingefügt werden. Wird ein Element mit ID kopiert, kann dies nur eingefügt werden, wenn ein Element mit derselben ID noch nicht existiert. Eine Customization kann nur erstellt werden, wenn im Package noch keine Customization vorhanden ist und die passende Basis existiert. Grundsätzlich wird zwischen zwei verschiedenen Arten unterschieden, um ein Element einzufügen: Element am Namespace eingefügt: Über das KontextMenü am Namespace kann das kopierte Element in den Namespace eingefügt werden. Dabei wird ein neues Element erstellt. Falls ein Element mit derselben ID bereits existiert wird über ein Dialog vorgeschlagen das kopierte Element in das bestehende Element einzufügen. Element in ein bestehendes Element des gleichen Typs einfügen: Über das Kontextmenü eines Elements oder über den Menüpunkt Paste im Edit-Menü kann das kopierte Element in ein bestehendes Element desselben Typs eingefügt werden. Dieser Vorgang stand in älteren Versionen schon unter Merge bei Components zur Verfügung. Dialog zum Zusammenfügen von Elementen mit gleicher ID: Kompatibilität Elemente bei denen Copy & Paste bereits vorhanden war (Components, Forms) können zwischen der alten und neuen Version kopiert werden. Das Kopieren mit ID wird jedoch erst ab FS 3.11 unterstützt. Paste Dialog Allgemein Über den Paste Dialog kann beim Kopieren in ein bestehendes Element ausgewählt werden, welche Unterelemente wie kopiert werden. Zu beachten ist, dass der Paste Dialog sehr viele Freiheiten bietet. Dies ermöglicht natürlich auch fehlerhafte Stände zu erstellen. Dieser Mechanismus ist für versierte Benutzer konzipiert. Grundsätzlich sollte der Benutzer wissen, was er tut und VOR der Aktion sicherstellen, dass alle benötigten Elemente am Ziel vorhanden sind. Die zu kopierenden Unterelemente sind in Gruppen auf verschiedene Registerkarten aufgeteilt. Jeder Paste Dialog enthält eine Summary und die NeededTypes. Im obersten Bereich des Paste-Dialogs werden der Type und der Pfad des kopierten Elements angezeigt. Der Pfad des kopierten Elements ist nur für Elemente sichtbar, die aus einer Version ≥ FS 3.11 kopiert wurden. Angaben zum kopierten Element: Registerkarte Summary Die erste Registerkarte beinhaltet immer die Summary. Diese zeigt, ob beim Paste oder Merge Konflikte auftreten. Framework Studio versucht grundsätzlich bei der Aktion die benötigten Elemente im Ziel-Package auf folgenden Wegen zu finden: Über die interne ID: Das funktioniert meist dann, wenn Quell- und Ziel-Package identisch sind oder wenn Elemente aus einem gemeinsamen Basis-Package verwendet werden. Über den Namen: Wenn über die ID nichts gefunden wird, wird nach einem gleichnamigen Element (z.B. Metadatentyp, Component, Property) gesucht. Das ist vor allem dann sehr nützlich, wenn nach und nach mehrere Elemente in ein anderes Package kopiert werden. Wenn diese Wege nicht zum Ziel führen, wird dies als Konflikt betrachtet und der Benutzer muss nach einer Lösung suchen. Teilweise kann das auf den restlichen Registerkarten erfolgen. Manchmal ist es aber auch nötig, die Aktion abzubrechen, erst die Voraussetzungen zu schaffen (z.B. eine DBTable anlegen) und die Aktion anschließend noch einmal auszuführen. Für einige Elemente gelten Sonderregeln für das Kopieren und Zusammenfinden von Elementen. Diese sind dem Kapitel (Kopieren von IDs) zu entnehmen. Über verschiedene Buttons kann ausgewählt werden, welche Unterelemente der Registerkarte selektiert und beim Einfügen berücksichtigt werden. Select all: Alle Unterelemente werden selektiert. Select none: Alle Unterelemente werden deselektiert. Select new: Es werden nur neu hinzugefügte Unterelemente selektiert. Beim Einfügen eines Elements am Namespace kann außerdem ausgewählt werden, ob die ID des Elements kopiert werden soll. Note Die Registerkarte Summary zeigt die initialen Merge Actions (Replace oder Insert) der Elemente an. Zu beachten ist, dass diese Übersicht nicht aktualisiert wird, wenn bspw. die Merge Action an einem Element geändert wurde. Registerkarte NeededTypes Bei den Needed Types werden alle Typen aufgelistet, die nicht zum Standard gehören. Diese können beliebig ausgetauscht werden. Das kann z.B. dann sinnvoll sein, wenn ein benötigtes Element vorher auch schon kopiert wurde und jetzt ggf. unter einem anderen Namen in einem anderen Namespace zu finden ist. Zusammenführen von Elementen Mit einem Merge kann erreicht werden, dass Änderungen in einer Kopie nachgezogen werden. Was nicht möglich ist, sind gelöschte Elemente durch den Merge zu entfernen. Es werden nur neu hinzugekommene oder geänderte beachtet. Beim Kopieren in ein bestehendes Element werden zusätzlich alle zu kopierenden Unterelemente gruppiert und in verschiedenen Registerkarten dargestellt. Die Unterelemente sind wiederum nach MergeAction und Name sortiert. Für jedes Unterelement kann separat entschieden werden, ob und wie es im Ziel eingefügt wird. Unterelemente: Unterelemente können einzelne Werte oder komplexere Elemente wie Methoden oder Properties darstellen. Alle Elemente werden gruppiert und in verschiedenen Registerkarten dargestellt. Die einzelnen Elemente können aus einer Liste ausgewählt werden. Für jedes Element kann separat entschieden werden, ob und wie es gemerged wird. Elemente, die im Ziel noch nicht vorhanden sind (Insert) werden in der Liste Grün dargestellt. Merge Action: Es stehen verschiedene Merge-Operationen zur Verfügung: Insert Das Element wird im Ziel neu eingefügt Der Eintrag wird in der Liste Grün dargestellt Replace Unter Target kann das Element, das im Ziel ersetzt werden soll, ausgewählt werden Replace with Das ausgewählte Source-Element ersetzt das „Target“-Element Target: Dieses Element wird beim Mergen ersetzt Source: Das Source-Element ersetzt das „Target“-Element beim Merge Merge Info: Bietet Informationen über das Merge Element z.B. die Art der Übereinstimmung im Ziel Kopieren von IDs Um Parallelentwicklungen zu realisieren, ohne dass die internen IDs von Elementen in verschiedenen Versionen auseinanderlaufen, besteht nun die Möglichkeit die ID von Elementen zu kopieren. In der obersten Leiste des Paste Dialogs ist farblich gekennzeichnet, ob die IDs kopiert oder neu angelegt werden (siehe Bilder). Kopieren von IDs Aktiv: Kopieren von IDs Inaktiv: Für das Kopieren von IDs gelten folgende Regeln: Wenn das zu kopierende Element am Namespace eingefügt wird und aus demselben Package aber unterschiedlicher Version stammt, ist das Kopieren der IDs optional. Beim Zusammenführen von Elementen im selben Package aber unterschiedlicher Version wird die ID automatisch kopiert, wenn die IDs der beiden Elemente übereinstimmen, ansonsten nicht. Wenn das zu kopierende Element aus einem anderen Package stammt, ist das Kopieren der IDs nicht möglich. Kopieren von Unterelementen Es ist möglich Methoden, Controls, Form- und Component-Properties zu kopieren. Methoden können unabhängig von dem Parent-Element eingefügt werden. Die ID wird bei Unterelementen nur dann übernommen, wenn in demselben Package aber unterschiedlichen Versionen kopiert wird und die ID der Parent-Elemente übereinstimmt. Elemente aus einer älteren Version werden nicht mit ID kopiert. Beim Einfügen von Unterelementen in ein anderes Parent-Element wird der Paste-Dialog angezeigt. Beim Einfügen von Unterelementen aus einer älteren Version wird der Dialog nicht angezeigt. Sonderfälle Es gibt Ausnahmen oder Sonderfälle beim Kopieren oder Mergen, die nachfolgend aufgelistet sind: Metadatentype Merge von Indices Falls die ID oder der Name identisch sind, wird ein Replace angeboten. Falls die ID und der Name nicht übereinstimmen, aber dieselbe Konstellation von Spalten im Ziel enthalten ist und ASC/DSC identisch sind, wird ebenfalls ein Replace angeboten. In allen anderen Fällen wird ein Insert angeboten. TextCollection Merge von TextEntries Wenn der PK identisch ist, wird ein Replace vorgeschlagen. Wenn die ID´s oder die Namen identisch sind, aber der PK abweicht, wird ein Replace mit entsprechender Warning angezeigt. Beim Mergen werden ID und Namen als Felder zum Bearbeiten angeboten. Texte, die nicht bekannt sind (ISO nicht bekannt), werden nicht gemerged. Service Elemente Ableitungen von Service Elementen können weder kopiert noch gemerged werden. Report Data Source Die angehakten Checkboxen von DataSources werden beim Kopieren von Ableitungen oder Customizations nicht mit kopiert. Die angehakten Checkboxen von DataSources werden beim Merge nicht berücksichtigt. GlobalEvent Das GlobalEvent kann nicht gemerged werden. Workflow Merge Allgemein Die Position oder Größe eines Elements wird beim Mergen nicht berücksichtigt. Wenn der Name oder die ID eines Elements identisch ist, wird, falls sich eine Eigenschaft geändert hat, ein Replace angeboten. Ein Merge-Konflikt wird angezeigt, wenn: Switch das Event (Name oder ID) nicht identisch sind Branch die Condition abweicht Link eine Eigenschaft des Links geändert wurde Form ISModal, ISEntranceInstance oder IsStartInstance geändert wurde Workflow IsEntranceInstance geändert wurde Resource Ressources können nicht gemerged werden Namespaces Namespaces können nicht gemerged werden Namespace References werden nicht kopiert"
  },
  "doc/ide/code-builder.html": {
    "href": "doc/ide/code-builder.html",
    "title": "Code Builder",
    "keywords": "Code Builder Das Menü, mit dem Sie zum einen die Optionen zur Codegenerierung und zum Kompilieren festlegen, und zum anderen einen Kompiliervorgang starten können, wird über den Button Compile Options geöffnet. In diesem Fenster sehen Sie in der Zeile, beginnend mit Active Application, welche Applikation ausgewählt ist. Für diese Applikation werden dann durch das Starten des Kompiliervorgangs die Dynamic Link Librarys (DLLs) erzeugt. Mit den unten aufgeführten Checkboxen () legen Sie fest, für welche Elementtypen der generierte Code neu kompiliert werden soll. Es ist nicht immer notwendig und wird aus Zeitgründen auch nicht empfohlen, alle Elemente in einem Namespace zu kompilieren. Stattdessen sollten Sie nur die Elemente kompilieren, an denen Sie auch tatsächlich Änderungen vorgenommen haben. Optionen beim Kompilieren Um einen Kompiliervorgang zu starten, stehen Ihnen mehrere Möglichkeiten zur Auswahl: Compile Namespace Der Code für den im Objekt-Baum dargestellten Namespace wird generiert. Danach werden die Dlls erzeugt und in das Compile-Verzeichnis (Compile-Verzeichnis) geschrieben. Die darunter liegenden Namespaces werden nicht berücksichtigt. Compile Namespace Recursively Auch die untergeordneten Namespaces werden in den Kompiliervorgang mit eingebunden. Über die Tastenkombination [Strg]+[Shift]+[B] können Sie aus Framework Studio direkt einen Kompiliervorgang für den Elementtyp des aktuell geöffneten Elements anstoßen, ohne vorher das Menü Compile Options öffnen zu müssen. Checkboxen Checkbox Resources Wählen Sie Resources, um alle Ressourcen neu ins Brokerverzeichnis zu kopieren. Checkbox Access Units Wählen Sie Access Units, wenn Sie neue Access Units (z.B. durch Hinzufügen eines neuen Forms) hinzugefügt haben und diese im Code ansprechen wollen. Warning Wenn Sie für die Anwendung keine Developer-Lizenz verwenden und neue Access Units hinzugekommen sind oder die Hierarchie geändert wurde, müssen Access Units mit dem Benutzer FrameworkCompiler recursive from root kompiliert werden. Checkbox Metadatatypes Wählen Sie Metadatatypes, um die Metadatentypen in einem Namespace zu kompilieren. Checkbox DBTables Wählen Sie DBTables, wenn Sie Änderungen an den DB-Tables vorgenommen haben. Checkbox Interfaces Wählen Sie Interfaces, wenn Sie Änderungen an Komponenten vorgenommen haben, welche die Methodendefinitionen, Methodenparameter oder Properties betreffen. Warning Der Sinn von Interfaces liegt darin, zirkulare Referenzen zu vermeiden. Die Interfaces werden daher grundsätzlich über alle Namespaces hinweg kompiliert. Checkbox Components Wählen Sie Components, wenn Sie Änderungen an den Komponenten vorgenommen haben, welche Methodendefinitionen, Methodenparameter, Properties oder Codes innerhalb von Methoden betreffen. Checkbox Global Objects Wählen Sie Global Objects, wenn Sie Änderungen an diesen vorgenommen haben und wenn Sie neue Komponenten angelegt haben. Checkbox Report Document Types Wählen Sie Report Document Types, wenn Sie Änderungen an diesen vorgenommen haben. Checkbox UnitTests Wählen Sie UnitTests Types, wenn Sie Änderungen an diesen vorgenommen haben. Checkbox Custom Controls Wählen Sie Custom Controls, wenn Sie Änderungen an diesen vorgenommen haben. Checkbox Forms Wählen Sie Forms, wenn Sie Änderungen an den Forms vorgenommen haben. Checkbox Workflows Wählen Sie Workflows, wenn Sie diese geändert haben. Mit dem Button wählen Sie alle genannten Elemente aus, mit keines. Mit den darunter angeordneten Checkboxen legen Sie weitere Optionen zur Codeerzeugung und zum Kompilieren fest. Checkbox Use Saved Code Um die Codegenerierung zu beschleunigen, besteht die Möglichkeit, Framework Studio anzuweisen, auf bereits generierten und im Repository hinterlegten Code (sogenannten Saved Code) zurückzugreifen. Das hat den Vorteil, dass nicht der gesamte Code vor dem Kompilieren neu generiert werden muss, sondern lediglich die Teile, welche sich geändert haben. Falls es dabei allerdings zu Problemen kommt, können Sie Framework Studio anweisen, den Code komplett neu zu generieren. Checkbox Debuggable Um den erzeugten Code zur Laufzeit mit Microsoft Visual Studio bereinigen zu können, aktivieren Sie die Option Debugable. Das führt dazu, dass im Applikations-Verzeichnis, zusätzlich zu den Dynamic Link Librarys (DLL) auch noch Programmdatenbankendateien und Quellcodedateien (.cs) von den einzelnen Namespaces erzeugt werden. Diese können mit Visual Studio geöffnet werden."
  },
  "doc/ide/compile-menu.html": {
    "href": "doc/ide/compile-menu.html",
    "title": "Compile Menü",
    "keywords": "Compile Menü In den folgenden Abschnitten werden die Menüpunkte im Menü Tools beschrieben. Compile Manager Wenn viele Namespaces kompiliert werden sollen und der Kompiliervorgang durch einen Fehler unterbrochen wird, kann mit dem Compile Manager der Kompiliervorgang fortgesetzt werden. In Verbindung mit dem FCUser ist das vor allem bei Update-Szenarien sehr vorteilhaft. Mit den Buttons in der Gruppe Add Namespaces to List werden die zu kompilierenden Elemente typweise in die Liste übernommen. In der Liste auf der rechten Seite werden alle Namespaces gesammelt. Beim Erstellen der Liste wird nicht geprüft, ob ein Namespace auch tatsächlich Elemente eines bestimmten Typs (z.B. Forms) beinhaltet. Es landen immer alle existierenden Namespaces in der Liste. Diese Liste versteht sich als eine Aufgabenliste, die durch kompilieren abzuarbeiten ist. Das Abarbeiten kann auf 2 Arten erfolgen: Der Button Compile in diesem Fenster. Es öffnet sich ein ganz normales Compile-Fenster, das wie z.B. beim Compile-CheckedOut die entsprechenden Namespaces kompiliert. Durch einen herkömmlichen Kompiliervorgang (über das Namespace-Registerkarte, aus einem Element heraus und auch Compile Checked Out). Ganz gleich, von wo aus der Compile gestartet wird, immer wenn ein Namespace erfolgreich kompiliert wurde, wird dieser aus der Liste entfernt. Mit dem Button Save kann die aktuelle Liste in eine Datei gespeichert werden. Die Datei wird in das Compile-Directory geschrieben. Mit dem Button Load kann diese Liste wieder aus einer Datei eingelesen werden. Das ist nützlich, wenn Framework Studio zwischendurch verlassen werden muss. So kann nach dem Neustart dort weitergemacht werden, wo zuletzt aufgehört wurde. Mit dem Button Complete FrameworkCompiler wird der FrameworkCompiler-Vorgang abgeschlossen. Dieser Button wird nur angezeigt, wenn ein FCUser oder der FrameworkCompiler angemeldet ist. Folgende Aktionen werden ausgeführt: Prüfen, ob etwas ausgecheckt ist. Für diese Aktion muss alles eingecheckt sein. Refresh des FrameworkCompiler-Workspaces (nur wenn man als FCUser angemeldet ist). Beim Arbeiten mit dem FCUser können Elemente aus- und eingecheckt werden. Die SavedCodes und Assemblies wurden generiert und jetzt muss noch der Workspace vom FrameworkCompiler aktualisiert werden, damit dieser wieder zu den generierten Informationen passt. Das ist notwendig, wenn das Package exportiert werden soll oder anschließend andere User beim Refresh des eigenen Workspaces den vom FrameworkCompiler verwenden (FrameworkCompiler Version and checked out im Login-Dialog). Aktualisieren des Compile-Stamps. Das beinhaltet die Information, dass der FrameworkCompiler erfolgreich gelaufen ist und sorgt dafür, dass die rote Kennzeichnung im Package-Manager verschwindet. Beim normalen Kompilieren in FrameworkStudio wird das nicht durchgeführt, weil dieser Stempel sicherstellen soll, dass ALLES kompiliert wurde. Warning Diese Aktion sollte nur dann ausgeführt werden, wenn sichergestellt ist, dass auch wirklich alles kompiliert wurde. Complete FrameworkCompiler mit FCUser Sind Sie als FCUser bzw. als User mit aktiviertem FrameworkCompiler-Mode angemeldet, beendet sich FrameworkStudio automatisch, nachdem Sie den FrameworkCompiler-Vorgang (\"Complete FrameworkCompiler\") abgeschlossen haben. Der FCUser ist so definiert, dass vor dem Schließen FrameworkStudios ein Complete FrameworkCompiler durchgeführt werden sollte. Schließen Sie FrameworkStudio normal, wird Ihnen deshalb folgende Meldung angezeigt: Dies soll Sie darauf hinweisen, dass der FrameworkCompiler-Vorgang entgegen unserer Definition nicht abgeschlossen wurde. Compile Checked Out Mit dem Menüeintrag Compile Checked Out werden alle vom Benutzer ausgecheckten Elemente kompiliert. Falls nötig, werden weitere Elemente kompiliert. Das betrifft insbesondere die folgenden Fälle: Wenn mindestens eine Component ausgecheckt ist, werden auch Interfaces und GlobalObjects kompiliert. Wenn mindestens ein Form ausgecheckt ist, werden auch Access Units mit kompiliert. Diese Funktion verwendet im Hintergrund den Compile Manager. Wenn beim Kompilieren ein Fehler auftritt, dann kann der Kompiliervorgang im Compile-Manager fortgesetzt werden. Compile Changes Es werden alle geänderten Elemente kompiliert. Run Mit dem Menüeintrag Run werden die Testumgebung (Start / Stop current development FSDomain) und ein Client für die Applikation gestartet. Es werden dazu die zuletzt im Run-Wizard vorgenommenen Einstellungen verwendet. Mit dem Menüeintrag Run… wird zunächst der Run-Wizard gestartet und anschließend die Testumgebung mit Client für die Applikation gestartet. Run Without Compile Mit dem Menüeintrag werden die Testumgebung (Start / Stop current development FSDomain) und ein Client für die Applikation gestartet. Es werden dazu die zuletzt im Run-Wizard vorgenommenen Einstellungen verwendet. Sollten sich seit dem letzten Compile Elemente geändert haben, werden diese zuvor nicht kompiliert. Run Wizard… Siehe hierzu Run Wizard Start / Stop current development FSDomain Mit dem Menüeintrag Start current development FSDomain starten Sie alle im Run-Wizard konfigurierten Dienste (Service Hosts) und den Development Broker. Mit dem Menüeintrag Stop development FSDomain wird der Development Broker beendet. Open Client Start Page Der Aufruf der Anwendung erfolgt über die Client Start Page, welche vom Anwendungs-Server bereitgestellt wird. Verschiedene Aktionen sind hier möglich: Die Anwendung kann direkt gestartet werden. Die JNLP-Datei kann lokal gespeichert werden, z.B. zum Start der Anwendung über den Desktop. Kopieren der Url, die anschließend in einem eigenen Start-Link verwendet werden kann. Bei der Aktualisierung auf eine neue Version kann es jedoch Änderungen an den Links geben, sodass diese ggf. aktualisiert werden müssen. Development Service Host Options Mit dem Menüpunkt Development Service Host Options können die folgenden beiden Schalter gesetzt werden: Compile forces stop of Development Broker Service Host: Ist diese Option mit einem Häkchen versehen, wird der Development-Broker automatisch beendet, wenn in Framework Studio ein Kompiliervorgang gestartet wird. Andernfalls werden Sie beim Start eines Kompiliervorgangs gefragt, ob der laufende Development-Broker beendet werden soll. Die Beendung des Development-Brokers ist nötig, um kompilieren zu können. Der Schalter ist im Standard gesetzt. Autostop of Development Broker Service Host after run of application: Ist diese Option mit einem Häkchen versehen, wird der Development-Broker automatisch beendet, wenn die Testapplikation geschlossen wird. Logging Mit dem Menüpunkt Logging wird ein Dialog geöffnet, in dem alle Einstellungen zur Protokollierung der Xml Kommunikation zwischen Client und Broker vorgenommen werden. Siehe Protokollieren der XML-Kommunikation AutoCompile Report Dieser Menüpunkt gibt im Output Fenster einen Callstack über die zuletzt hinzugefügten Elemente zum Compile for Run aus. Open Compile Directory In Explorer Mit dem Menüpunkt Open Compile Directory In Explorer wird das Kompilierverzeichnis (Compile-Verzeichnis) im Windows Explorer geöffnet. Open Development Broker Directory In Explorer Mit dem Menüpunkt Open Development Broker Directory In Explorer wird das im IIS freigegebene Verzeichnis des Development-Brokers im Windows Explorer geöffnet. Open User Directory In Explorer Mit dem Menüpunkt Open User Directory In Explorer wird das Verzeichnis im Windows Explorer geöffnet, in dem Framework Studio benutzerbezogene Daten ablegt. Dazu gehören verschiedene Konfigurationsdateien sowie ggf. Trace- und Log-Dateien. Application… Siehe hierzu Application Get Dlls Mit diesem Menüpunkt können die Dlls vom FrameworkCompiler in das eigene Compile-Verzeichnis geschrieben werden. Beachten Sie, dass ausgecheckte Elemente anschließend kompiliert werden müssen. Des Weiteren besteht die Option alle Änderungen zu kompilieren. Ist eben diese Compile Changes-Option aktiviert, können zudem alle, keine oder nur bestimmte Compile Object Types debuggable kompiliert werden. Die Vorbelegung dieses Feldes wird aus den Options verwendet und kann im GetDLL-Dialog temporär verändert werden."
  },
  "doc/ide/dokumentation.html": {
    "href": "doc/ide/dokumentation.html",
    "title": "Dokumentation",
    "keywords": "Dokumentation Einer der größten Kostentreiber eines jeden Softwareprojektes sind schlechte Dokumentationen, welche die Wiederverwendbarkeit von Code einschränken und die Wartung erschweren. Je besser Ihr Code dokumentiert ist, desto effektiver werden Sie ihn nutzen können. Allgemeines Um die Übersichtlichkeit, Wiederverwendbarkeit und Wartbarkeit Ihres Codes zu gewährleisten, sollten Sie ihre Metadatentypen, Properties und Methoden entsprechend beschreiben. Um Metadatentypen und Components mit Kommentaren zu versehen, öffnen Sie diese im Framework-Designer und tragen die Beschreibung in das Feld Description ein. Dabei muss die Eingebesyntax, wie im Folgenden ausgeführt, beachtet werden. Zu Properties können Sie Kommentare hinterlegen, indem Sie die Component, die das Property enthält, über die Combobox auf der Registerkarte Property auswählen und auf der Property-Registerkarte Description einen Kommentar hinterlegen. Component: Bei Methoden sollten Sie Kommentare, Beschreibungen der Parameter, Beispiele u.ä. im Methodenkopf, also noch vor Deklaration der Methode hinterlegen. Ist der Code ordentlich dokumentiert, haben Sie mit NDoc eine einfache Möglichkeit, eine Entwicklerdokumentation im Stil der MSDN zu erstellen. Warning Dazu ist es allerdings notwendig, dass die Kommentare auch in MSDN-konforme Tags eingeschlossen sind. Syntax Damit die Kommentare von NDoc richtig verarbeitet werden, ist es wichtig, diese in Tags einzufassen. Ein Tag ist einfach eine Beschreibung, die den Inhalt definiert. XML benötigt für eine Beschreibung immer 2 Tags, einen öffnenden und einen schließenden. Der schließende Tag unterscheidet sich dabei von dem öffnenden, dass er ’\\’ vor der Tag-Bezeichnung trägt. Wenn Sie verschachtelte Tags benutzen, müssen diese von innen nach außen wieder aufgelöst werden. <summary> Zusammenfassung </summary> Tags, die Sie zum Beschreiben benötigen, sind: <summary> Beschreibung </summary> <param name =\"Parametername\"> Beschreibung </param> <returns> Returnparameter </returns> <remarks> Anmerkungen </remarks> <example> Beispiel </example> Sie können auch ein Code-Template anlegen, welches schon eine komplette Beschreibungsstruktur aufweist, so dass Sie die Tags nicht jedes Mal neu anlegen müssen. Wie Sie es vielleicht auch schon von Visual Studio her kennen, werden Kommentare im Code, die für externe Dokumentationszwecke gedacht sind, durch 3 führende Slashs (///), interne dagegen durch 2 führende Slashs definiert. Beispiel eines Description-Templates: ///<summary> ///??? ///</summary> /// ///<param name=\"???\">???</param> /// ///<returns>???</returns> /// ///<remarks> ///??? ///</remarks> /// ///<example> ///??? ///</example> public void WriteView() Wenn Sie Kommentare in die Description-Felder eingeben, brauchen Sie keinen Slash voranstellen. Diese sind nur direkt im Code, wie bei Methoden notwendig. Weitere gültige Tags können Sie der NDoc-Hilfe entnehmen."
  },
  "doc/ide/framework-compiler.html": {
    "href": "doc/ide/framework-compiler.html",
    "title": "FrameworkCompiler",
    "keywords": "FrameworkCompiler Der FrameworkCompiler ist ein besonderer Benutzer innerhalb von Framework Studio. Seine Hauptaufgabe besteht darin, den kompilierten Code einer Anwendung, den sog. Saved-Code, in das Repository zu schreiben. Hintergrund ist das Entwicklungsmodell von Framework Studio. Mehrere Entwickler arbeiten an einer Anwendung, checken Elemente aus und ein. Der FrameworkCompiler ist die Instanz, die alle Änderungen zu einem gesamten funktionierenden Stand zusammenfügt. Dies könnte z.B. nachts über einen Job stattfinden, da zu dieser Zeit normalerweise auch kein Entwickler angemeldet ist. Warning Der FrameworkCompiler kann selbst keine Objekte auschecken und bearbeiten. Siehe hierzu Benutzer bearbeiten. Ein Compile-Vorgang mit dem FrameworkCompiler hat folgenden Ablauf: Als erstes wird der Workspace des FrameworkCompiler aktualisiert. Hier werden alle von den Entwicklern eingecheckten Objekte herangezogen. Danach wird der gesamte Code kompiliert. Der Quellcode (Saved Code) sowie die daraus erzeugten Assemblies werden nach einem erfolgreichen Compile-Vorgang in die Datenbank geschrieben. Nun wird der Compile-Stamp des FrameworkCompilers aktualisiert. Hieran wird festgesetzt, ob die Entwickler mit einem aktuellen Workspace arbeiten oder nicht. Ein erfolgreicher Durchlauf des FrameworkCompilers stellt somit sicher, dass sich im Repository ein sauberer Entwicklungsstand mit jeglichem Source Code und jeglichen Assemblies befindet, auf dem die Entwickler ihre tägliche Arbeit aufbauen können."
  },
  "doc/ide/framework-designer.html": {
    "href": "doc/ide/framework-designer.html",
    "title": "Framework Studio IDE",
    "keywords": "Framework Studio IDE Mit dem Framework Designer gestalten Sie auf komfortable Weise Resources, Access Units, Metadatatypes, Datasources, DBTables, Components, Global Objects, Reports, Custom Controls, Forms und Workflows. Diese grundlegenden Elemente sind über die Registerkarte Namespaces (Registerkarte Namespaces) erreichbar. Andere Elemente wie Code-Templates, Laufzeitlizenzen und die Access Unit Hierarchie sind über das Menü Tools erreichbar. Nachfolgend werden die Registerkarten auf der linken Seite erklärt. Anschließend folgen allgemeine Funktionalitäten."
  },
  "doc/ide/references.html": {
    "href": "doc/ide/references.html",
    "title": "References",
    "keywords": "References Wenn innerhalb eines Namespaces Klassen eines weiteren Namespaces genutzt werden sollen, müssen diese über ein using-Statement eingebunden werden. Dasselbe gilt, wenn Sie externe Klassen nutzen wollen, wie z.B. die des .Net Frameworks. Über den Dialog References können Sie sowohl interne, als auch externe Referenzen erzeugen. Wenn Sie als Datentyp für ein Property eine Klasse aus einem anderen Namespace auswählen, wird automatisch ein using für diesen Namespace generiert. Referenzen anlegen / löschen Um eine Referenz hinzuzufügen, wählen Sie zunächst den Namespace auf der Registerkarte Namespaces aus, dem die Referenz hinzugefügt werden soll. Öffnen Sie anschließend den Dialog References, in dem Sie im unteren Bereich der Registerkarte das Kontext-Menü zu dem Namespace aufrufen und den Eintrag References... aufrufen oder auf den Button (References) klicken. Erzeugen Sie anschließend eine neue Referenz, indem Sie in der Combobox den Bereich auswählen, für den die Referenz erzeugt werden soll und drücken den Button (New). Sie sehen die neue Referenz jetzt als Eintrag in der Listbox. Nun werden noch die Einstellungen für die Referenz angepasst, wie nachfolgend beschrieben. Löschen können Sie eine Referenz, indem Sie in der Combobox den gewünschten Bereich auswählen und anschließend in der Listbox die zu löschende Referenz markieren. Mit dem Button (Delete) wird die Referenz gelöscht. Wenn ein anderer Namespace innerhalb von Framework Studio referenziert werden soll, wählen Sie als Reference-Type \"Framework Studio\". Über die Combobox Namespace haben Sie dann die Möglichkeit den Namespace auszuwählen, der eingebunden werden soll. Sollten Sie externe Klassen nutzen wollen, geben Sie als Reference-Type External an. Über den Datei-Auswahl-Dialog können Sie anschließend die .Net Assembly auswählen, die Sie einbinden möchten. Referenzen bearbeiten Name Hier können Sie die Namen der Referenz angeben. Framework Studio belegt diesen Namen mit ReferenceXX vor. Combobox Object Type Object-Type definiert, zu welchem Bereich die Referenz gehört. Da die einzelnen Bereiche eigene Assemblies erzeugen, ist dieser hier ebenfalls zu definieren. Der Standardtyp wird Component sein, da zumeist auf Components referenziert werden wird. Checkbox Use In Sub Namespaces Über diese Checkbox können Referenzen an Sub Namespaces vererbt werden. Die vererbten Referenzen werden in den Sub Namespaces als Derived mit dem Zusatz, aus welchem Namespace die Referenz stammt, dargestellt. Sie können hier nicht bearbeitet werden. Radion Button Framework Studio Reference Wählen Sie diesen Radio-Button, wenn Sie eine Framework-Studio-interne Referenz haben wollen. Namespace Hier benennen Sie für eine interne Referenz den Namespace, der verwendet werden soll. Combobox Referenced Object Type Hier geben Sie für eine interne Referenz an, welcher Bereich eingebunden werden soll. Es können grundsätzlich alle Object-Types angegeben werden, die vor oder mit dem eigenen Object-Type compiliert werden. Der Wert Component sollte jedoch nur dann verwendet werden, wenn Interface nicht ausreicht. Wenn man im Methoden-Code eine Component aus einem anderen Namespace verwenden möchte, dann wird in der Regel mit deren Interface bzw. der Factory-Klasse gearbeitet. In diesem Fall reicht eine Reference auf Interface völlig aus. Radio Button External Reference Wählen Sie diesen Radio-Button, wenn Sie eine externe Assembly einbinden möchten. Assembly Hier können Sie ein Assembly angeben, das eingebunden werden soll. Mit dem Button Browse öffnen Sie eine Datei-Auswahl, in der Sie ein Assembly angeben können. In dieser Zeile können folgende Präfixe verwendet werden: $CodeDirectory: Definiert das Compile-Verzeichnis des Brokers. So können Resources aus dem Ordner bin\\ referenziert werden. Beispiel: $CodeDirectory\\MyOwnAssembly.dll $DotNetDirectory: Definiert das Verzeichnis des .NET Framework 4.8 Beispiel: $DotNetDirectory\\System.Drawing.dll $GAC: Die Assembly soll aus dem Global Assembly Cache geladen werden Beispiel: $GAC\\ADODB, Version=7.0.3300.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a $FS: Wird von Framework Studio für Namespace-Referenzen verwendet. Diesen Präfix nicht bei externen Referenzen verwenden. Beispiel: $FS\\NV.ERP.Base.Customer_C.dll From GAC Siehe Referenzen auf GAC-Assemblies Usings Hier können Sie angeben, welche Namespaces der eingebundenen Assembly als using verwendet werden sollen. Die Namespaces müssen zeilenweise in das Textfeld geschrieben werden. Beispiel: System System.Collections System.Text System.Text.RegularExpressions Referenzen auf GAC-Assemblies Es können Assemblies aus dem GAC (Global Assembly Cache) in Framework Studio referenziert werden. From GAC Button: Nach dem Klick auf den Button erscheint eine Auflistung mit allen Assemblies, die im GAC des aktuellen PC‘s oder Servers vorhanden sind: GAC-Assembly Auswahldialog: Wird eine Assembly ausgewählt, erscheint diese mit dem Prefix $GAC und dem starken Namen im References-Dialog: Wie gewohnt können dann Usings definiert und die Assembly im Code verwendet werden. Stammt die ausgewählte Assembly aus dem .net Framework, dann wird diese nach der Auswahl automatisch auf $DotNetDirectory umgestellt. Bestehende $GAC-Referenzen können mit der Reference Cleanup Maintenance-Routine gefunden und korrigiert werden. Caution Welche GAC-Assemblies auf einem PC oder Server vorhanden sind, ist unterschiedlich und von installierter Software abhängig. Wird eine Framework Studio Applikation auf einem PC oder Server veröffentlicht oder kompiliert, auf dem die referenzierten GAC-Assemblies nicht vorhanden sind, kann es zu Laufzeit- oder Compilierfehlern kommen. Es muss dann sichergestellt werden, dass etwaige Drittsoftware korrekt installiert ist."
  },
  "doc/ide/registerkarten.html": {
    "href": "doc/ide/registerkarten.html",
    "title": "Registerkarten im Framework Designer",
    "keywords": "Registerkarten im Framework Designer Registerkarte Namespaces Diese Registerkarte ist noch mal in 2 Teile gegliedert. Im oberen Teil ist der Namespace-Baum abgebildet. In Framework Studio werden zu jedem Package (Packages) die Klassen wie in .NET üblich in Namespaces strukturiert. Diese Namespaces sind wie ein Baum unter ihrem Package aufgebaut und können beliebig tief verschachtelt sein. Im unteren Teil werden die Elemente des im oberen Baum ausgewählten Namespace im so genannten Objekt-Baum angezeigt. Mit einem Doppelklick können diese geöffnet werden. Es öffnet sich für jedes Element ein Designer-Fenster im Hauptfenster. Die Toolbar im mittleren Teil der Registerkarte bezieht sich auf den darunter dargestellten Objekt-Baum. Die einzelnen Elemente der Toolbar werden im Abschnitt Allgemeine Funktionalitäten erläutert. Außer der Registerkarte Search beziehen sich alle anderen Registerkarten, die im Folgenden beschrieben werden, immer auf das gerade aktive Designer-Fenster bzw. das dort ausgewählte Element. Ein Wechsel auf diese Registerkarten ist nur möglich, wenn bereits ein Designer-Fenster geöffnet wurde. Registerkarte ClassView Die Registerkarte ClassView zeigt alle Members des geöffneten Elements an. Über das Kontext-Menü des Elements (oberster Eintrag) können auch neue Member hinzugefügt werden. Mit einem Doppelklick auf einen Eintrag dieses Baums wird das entsprechende Member im Designer-Fenster auf der rechten Seite geöffnet bzw. ausgewählt. Über das Kontext-Menü eines Members lässt sich dieses aus dem Objekt löschen, umbenennen oder ein weiteres Member gleichen Typs erzeugen. Registerkarte Inheritance In dieser Registerkarte wird der Vererbungsbaum für das geöffnete Objekt angezeigt. Warning Nur Metadatentypen, Reports, Forms und Workflows lassen sich vererben. Registerkarte Properties Editor Hier können die Eigenschaften der Elemente eines Objektes geändert werden. Es werden immer die Eigenschaften des im aktiven Designer-Fensters ausgewählten Elements angeboten. Sie können ein Element wählen, indem Sie es im Designer-Fenster anklicken. Diese listet alle Elemente auf, die im Zusammenhang zu der im aktiven Designer-Fenster ausgewählten Registerkarte stehen. Sortierung nach Kategorien: Standardmäßige Sortierreihenfolge der Properties. Sortierung Alphabetisch: Alternativ können Sie sich die Properties alphabetisch sortiert anzeigen lassen. Registerkarte Toolbox Handelt es sich bei dem ausgewählten Objekt um ein Form oder einen Workflow, wird diese Registerkarte zugänglich. Bei Forms werden dort alle verfügbaren Controls angeboten. Ein Control kann per Drag & Drop auf dem Form positioniert werden. Bei Workflows werden über diese Registerkarte Links, Branches und Switches angeboten, welche per Drag & Drop in den Workflow gezogen und dort positioniert werden können. Ergänzende Informationen zu den Tools finden Sie in den Abschnitten zu Form und Workflows Designer. Registerkarte Search Auf dieser Registerkarte werden verschiedene Suchfunktionen zur Verfügung gestellt. Für die Suche gelten folgende allgemeine Funktionen: Suchbegriffeingabe Die Combobox unter der Suchdomänenauswahl ist zur Eingabe des Suchbegriffs vorgesehen. Sie speichert die 15 zuletzt verwendeten Suchbegriffe. Kommt ein sechzehnter Suchbegriff hinzu, so wird der älteste Eintrag verdrängt. Wird ein Suchbegriff verwendet, der schon in der Liste enthalten ist, so wird der Eintrag an den Anfang der Liste verschoben. Button Search Mit dem Button Search wird die Suche gestartet und die Ergebnisse werden in der Liste im unteren Bereich angezeigt. Suchergebnis-Historie Die Links/Rechts Pfeil-Buttons ermöglichen das chronologische Wechseln (links = zurück, rechts = vor) zwischen Suchergebnissen, die in der Suchergebnis-Historie abgelegt wurden. Sobald eine neue Suche ausgeführt wird, wird das Ergebnis dieser Suche ans Ende der Historie angehängt und angezeigt. Die Historie speichert maximal 15 Einträge. Außerdem erscheinen beim Blättern zusätzliche Informationen zum jeweiligen Eintrag unterhalb der Suchergebnisse. Suchergebnis-Historie mit zusätzlichen Informationen Result view style Hier kann ausgewählt werden, ob die Ergebnisse in einer Liste oder in einem Namespace-Baum angezeigt werden sollen. Zusätzlich besteht die Möglichkeit nur Methoden anzuzeigen. Diese Einstellung kann auch nach der Suche verändert werden. Ergebnis-Liste Die Ergebnisse werden wie gewünscht als Liste oder in einem Namespace-Baum angezeigt. Beim Namespace-Baum sind die Einträge mit grauem Text nicht Bestandteil der Ergebnis-Menge sondern dienen dazu, die Ergebnisse in einem Baum anzuordnen. In dieser Ansicht ist das Einchecken von Elementen inklusive aller Unterelemente über das Kontextmenü möglich. So können beispielsweise, nach der Suche nach ausgecheckten Elementen, alle ausgecheckten Elemente des Benutzers in einem Vorgang eingecheckt werden. Durch Doppelklick auf ein Suchergebnis wird das Ergebnis geöffnet. Nun folgt die Beschreibung der verschiedenen Such-Mechanismen. Volltext-Suche in generierten Code Die Suche auf den generierten Code ist ein guter Mechanismus, um z.B. nach bestimmten Verwendungen zu suchen. Der generierte Code beinhaltet sowohl alle im Designer angegebenen Informationen als auch den selbst geschriebenen Code. Der generierte Code wird mit entsprechenden Marken versehen, sodass die Suche bei einem Treffer die gefundene Code-Zeile einem Element (z.B. Component, Form) oder einem Teil (z.B. Property, Methode) zuordnen kann. Wird z.B. eine Zeile in einer selbst geschrieben Methode gefunden, kann diese Code-Zeile aus der Treffer-Liste heraus direkt angesprungen werden. Sie können in dem Textfeld einen zu suchenden Text angeben. Es wird dabei nach dem kompletten Text gesucht. Search Domain Hier wird angegeben, in welchem Bereich die Suche erfolgen soll. Sie können ein gesamtes Package durchsuchen oder den Suchbereich auf einen Namespace mit allen darunter liegenden Namespaces einschränken. Der Suchbereich kann auch über den Menüeintrag Search... im Objektbaum auf der Registerkarte Namespaces oder über den Menüeintrag Edit/Search... im Designerfenster eines LabeledRecords auf einen einzelnen LabeledRecord, also z.B. auf ein Form oder eine Textcollection eingeschränkt werden. Search in Component: In diesem Fall wird der Button Select Namespace angezeigt, mit dem der Suchbereich wieder auf einen beliebigen Namespace festgelegt werden kann. Grundsätzlich gilt: Je kleiner der Suchbereich, desto schneller die Suche. Bei einer großen Anwendung kann die Suche über alle Namespaces sehr lange dauern. Checkbox Case sensitive Bei der Suche wird nach Groß- und Klein-Schreibung unterschieden. Checkbox Regular Expressions Bei dem Suchtext handelt es sich um einen regulären Ausdruck. Es muss ein gültiger Ausdruck angegeben werden. Checkbox Use Saved Code Für die Suche soll der gespeicherte generierte Code verwendet werden. Es wird empfohlen, diese Option zu verwenden, da ansonsten der Code für die Suche komplett neu erzeugt werden muss. Das kann bei einer großen Anwendung sehr lange dauern. Combobox Object Types Hier können Sie angeben, in welcher Art von Elementen die Suche durchgeführt werden soll. (z.B. Components, Forms, …) Suche in Textcollections Mit der Suche in Textcollections ist es möglich, gezielt die in den Textcollections angegebenen Texte zu durchsuchen. Suche in Textcollections: Search Domain Hier wird angegeben, in welchem Bereich die Suche erfolgen soll. Sie können in allen Textcollections eines Packages oder in allen Textcollections, die unterhalb eines bestimmten Namespaces liegen, suchen. Der Suchbereich kann außerdem über den Menüeintrag Search... im Objektbaum auf der Registerkarte Namespaces oder über den Menüeintrag Edit/Search... im Designerfenster einer Textcollection auf eine spezielle Textcollection eingeschränkt werden. Checkbox Textcollection Mit dieser Checkbox wird dieser Suchmodus aktiviert. Combobox Language Hier kann angegeben werden, in welcher Sprache gesucht werden soll. Checkbox Case sensitive Bei der Suche wird nach Groß- und Klein-Schreibung unterschieden. Checkbox Regular Expressions Bei dem Suchtext handelt es sich um einen regulären Ausdruck. Es muss ein gültiger Ausdruck angegeben werden. Wird z.B. als Suchtext ein regulärer Ausdruck ^\\(** angegeben und es wird eine Sprache ausgewählt, lassen sich alle Texte finden, bei denen der Text in dieser Sprache nicht gefüllt ist. (**^** ist ein Zeilen-Anfang, **\\) ist ein Zeilenende und dazwischen soll nichts stehen.) Suche nach ausgecheckten Elementen In diesem Suchmodus werden alle ausgecheckten Elemente des Benutzers im aktuellen Package angezeigt. Checkbox Checked out Damit wird der Suchmodus aktiviert. Es werden alle anderen Controls inklusive des Namespace-Baumes deaktiviert. In der Ergebnis-Liste besteht die Möglichkeit, ein Check In oder ein Undo Check Out durchzuführen. Dabei können auch mehrere Elemente gleichzeitig verarbeitet werden. Dazu gibt es für die Ergebnisse ein Kontext-Menu, welches mit der rechten Maustaste aufgerufen werden kann. Nach einem Check In oder ein Undo Check Out wird die Ergebnis-Liste nicht aktualisiert. Es muss anschließend ggf. noch einmal neu gesucht werden, um die Liste zu aktualisieren. Während der Check In in einem Rutsch durchgeführt wird, wird der Undo Check Out für jedes Element einzeln durchgeführt. Dabei erscheint jedes Mal eine Meldung, die bestätigt werden muss. Es kann auch vorkommen, dass ein Undo Check Out mal nicht durchgeführt werden kann, weil dies durch eine bereits existierende Referenz verhindert wird. Der Vorgang muss ggf. wiederholt werden. Es folgt die Beschreibung des Kontext-Menus. Je nach Ergebnis können die Menu-Einträge variieren. Check In Checkt das einzelne Element ein. Check In all sub records Checkt alle, unterhalb eines Namespaces liegenden Elemente ein – auch über mehrere Ebenen hinweg. Check In with all its sub records Checkt den Namespace und alle unterhalb diesem Namespace liegenden Elemente ein – auch über mehrere Ebenen hinweg. Undo Check Out Führt einen Undo Check Out für das einzelne Element durch. Undo Check Out all sub records Führt einen Undo Check Out für alle unterhalb einem Namespace liegenden Elemente durch – auch über mehrere Ebenen hinweg. Undo Check Out with all its sub records Führt einen Undo Check Out für den Namespace und alle unterhalb dieses Namespace liegenden Elemente durch – auch über mehrere Ebenen hinweg. Suche nach Elementnamen Dieser Suchmodus wird mit der Checkbox Element Name aktiviert und dient dem schnellen Auffinden von Elementen über ihren Namen. Suche nach Elementnamen: Checkbox Case sensitive Bei der Suche wird nach Groß- und Klein-Schreibung unterschieden. Checkbox Regular Expressions Bei dem Suchtext handelt es sich um einen regulären Ausdruck. Es muss ein gültiger Ausdruck angegeben werden. Combobox Element type Hier kann die Suche auf einen Elementtyp (z.B. Components, Forms, ...) eingeschränkt werden. Suche nach Abhängigkeiten Sucht alle Elemente, die vom aktuellen Element abhängig sind. Mit dieser Funktion können Sie beispielsweise von einem Form zu Workflows wechseln, in denen das Form verwendet wird: von einer Component zu anderen Components oder zu Forms wechseln, die diese Component verwenden von einem Metadatentypen zu Components oder Forms wechseln, die den Metadatentypen verwenden von Workflows zu anderen Workflows wechseln, die diesen Workflow verwenden Data Source Hierarchiesuche Eine spezielle Form der Abhängigkeitssuche ist die Data Source Hierarchiesuche. Diese wird an einem Control innerhalb eines Forms ausgelöst und listet eine geordnete Kette von Elementen auf, die sich aus der Datenquelle des Controls ergeben: Das Control, für das die Suche ausgeführt wurde. Das Form-Property. Wenn eine Component beteiligt ist, wird das entsprechende Component-Property ebenfalls dargestellt – wie z.B. cdCall.oPCSInfo. Das Component-Property Die Tabellen-Spalte Der Metadatentyp und ggf. Basis-Metadatentypen Checkbox Dependencies Da diese Option eine spezielle Suchdomäne benötigt, kann die Suche nur durch das Menü Edit/Search Dependencies im Designerfenster bzw. über das Kontextmenü an einem Form Control erfolgen und die Checkbox Dependencies wird erst dann aktiv. Erst wenn das Häkchen entfernt wurde, kann wieder eine normale Suche durchgeführt werden. Registerkarte Comment Auf der Registerkarte Comment können Methoden dokumentiert werden. Wird z.B. ein Form geöffnet und auf der Registerkarte Methods eine Methode ausgewählt, wird die Comment-Registerkarte freigeschaltet. Registerkarte Check In Comment Auf der Registerkarte Check In Comment kann für ein Element (z.B. Form, Workflow, Component usw.) ein Kommentar hinterlegt werden, der beim nächsten Check In verwendet werden soll."
  },
  "doc/ide/shortcuts.html": {
    "href": "doc/ide/shortcuts.html",
    "title": "Shortcuts in Framework Studio",
    "keywords": "Shortcuts in Framework Studio Beschreibung Shortcut Öffnet DropDown-Menü \"New\" Ctrl + N Navigate Backward Alt + Left Navigate Forward Alt + Right Namespaces Ctrl + Alt + N Namespaces Ctrl + Alt + L Namespaces Ctrl + Alt + O ClassView Ctrl + Alt + C Inheritance Ctrl + Alt + I Properties F4 Toolbox Ctrl + Alt + X Search Ctrl + Shift + F Run F5 Run Without Compile Ctrl + F5 RunWizard Shift + F5 Start current development FSDomain Alt + F5 Stop development FSDomain Ctrl + Alt + F5 Open Client Start Page F6 Open Compile Directory in Explorer Ctrl + E Application Alt + A Run UnitTest (N&V Add-On) F7 Run UnitTest Wizard (N&V Add-On) Shift + F7 Online Hilfe F1 Namespace View Beschreibung Shortcut Compile Namespace Alt + B Compile Namespace Recursively Alt + B Open References Ctrl + R Elemente (Form, Component, ...) Beschreibung Shortcut Synchronize ClassView Ctrl + Alt + Shift + C View compiled code in Visual Studio Ctrl + O View compiled code in Visual Studio (new instance) Alt + O Compile Namespace Ctrl + Shift + B Check Out Ctrl + F10 Check In Ctrl + F11 Search Ctrl + Shift + F Customization Top Alt+ Shift + . Customization Up Alt + . Customization Down Alt + , Customization Root Alt+ Shift + , Component Beschreibung Shortcut Generate wrapper for selected property Ctrl + F8 Generate wrappers for all wrapper candidates Ctrl + Alt + Shift + F8 Run UnitTest (N&V Add-On) Ctrl + F7 Run UnitTest Wizard (N&V Add-On) Ctrl + Shift + F7 Editoren Die Anzahl der Shortcuts in Framework Studio Text-Editoren ist so umfangreich, dass nachfolgend nur die wichtigsten aufgelistet sind. Um eine vollständige Auflistung aller Shortcuts zu erhalten, kann in jedem Editor über den Shortcut F1 die Command Palette aufgerufen werden. Sprachübergreifend Beschreibung Shortcut Command Palette F1 Copy Ctrl + C Single Line Copy Ctrl + C Cut Ctrl + X Paste Ctrl + V Find Ctrl + F Replace Ctrl + H Go To Line Ctrl + G Zoom Ctrl + MouseWheel Zoom In Ctrl + Numpad+ Zoom Out Ctrl + Numpad- Zoom Reset Ctrl + K > Ctrl + 0 Expand Line Selection Ctrl + L Delete Line Ctrl + Shift + K Multi Cursor Select MouseMiddle Add Selection To Next Find Match Ctrl + D Fast Scrolling Alt + MouseWheel Change All Occurances Ctrl + F2 Toggle Comment Ctrl + Shift + C Insert Line Above Ctrl + Shift + Enter Insert Line Below Ctrl + Enter Open Developer Tools Shift + Alt + O C# Editor Beschreibung Shortcut IntelliSense CTRL + Space IntelliSense (Code Snippets) CTRL + J Toggle IntelliSense Tooltip CTRL + Space Format Document Shift + Alt + F Customize Ctrl + T Go To Definition Ctrl + MouseLeft oder Ctrl + F12 Go To Base Ctrl + B Compare With Base Ctrl + Alt + B Method History Browser Ctrl + Shift + M Code Snippets Editor Ctrl + Shift + J DocML Editor Beschreibung Shortcut Insert Break Alt + Enter Paste & Format Ctrl + Shift + V HTML Editor Beschreibung Shortcut Rename Symbol F2 Format Document Shift + Alt + F IntelliSense CTRL + Space Toggle IntelliSense Tooltip CTRL + Space CSS Editor Beschreibung Shortcut Format Document Shift + Alt + F IntelliSense CTRL + Space Toggle IntelliSense Tooltip CTRL + Space Diff Editor Beschreibung Shortcut Next Change Alt + F5 Previous Change Shift + Alt + F5 Next Diff (Diff Review Pane) F7 Previous Diff (Diff Review Pane) Shift + F7 Exit Diff Review Pane (Shift) + Esc"
  },
  "doc/ide/start.html": {
    "href": "doc/ide/start.html",
    "title": "Framework Studio starten",
    "keywords": "Framework Studio starten Beim Start des Programms Framework Studio öffnet sich ein Dialog für die Verwaltung der Repositories, die Ihnen für Ihre Arbeit zur Verfügung stehen. Als Repository bezeichnet man eine Datenbank, in der die Quellcodes gespeichert werden. Repositories pflegen und auswählen Repository-Auswahl Mit dem Button New können Sie ein neues Repository in die Liste hinzufügen. Anschließend geben Sie folgende Daten ein: Button Remove Mit dem Button Remove können Sie das ausgewählte Repository aus der Liste entfernen. Name Name der Verbindung, den Sie frei wählen können. Connection Einstellungen Sind im Kapitel Connection Einstellungen beschrieben. Button Test Connection Mit dem Button Test Connection können Sie prüfen, ob eine Verbindung zum Repository hergestellt werden kann. Button OK Um die Arbeit auf einem Repository zu beginnen, wählen Sie den entsprechenden Eintrag in der Tabelle aus und klicken auf OK. Es öffnet sich ein Dialog, mit dem Sie sich an das Repository anmelden können (siehe Login). Weitere Funktionalität im Hauptmenü Unter dem Menüpunkt Repository werden die folgenden Funktionen angeboten: Create new repository [...] Dieser Menüpunkt ermöglicht das Anlegen eines neuen Repositories. Weitere Informationen dazu finden Sie unter Erstellen eines Repositories. FSDemo In diesem Untermenü werden die folgenden beiden Menüpunkte zusammengefasst: Create FSDemo repository [...] Es wird ein neues Repository angelegt, in dem bereits eine einfache Demo-Applikation enthalten ist (siehe auch Erstellen eines Repositories). Create FSDemoData Database [...] Mit diesem Menüpunkt lässt sich eine Datenbank mit Demo-Daten für die Demo-Applikation anlegen. Unter dem Menüpunkt Licenses werden die folgenden Funktionen angeboten: Choose License Database [...] Mit diesem Menüpunkt öffnet sich der Choose License DB Dialog. In ihm kann die Datenbank angegeben werden, in der die Lizenz für die Benutzung von Framework Studio abgelegt ist. Manage Licenses Mit diesem Menüpunkt öffnet sich der Manage Licenses Dialog. In ihm kann die aktuelle Framework Studio Lizenz verwaltet oder exportiert werden, sowie neue Lizenzen importiert werden. Erstellen eines Repositorys Der Aufruf des Create Repository Dialogs erfolgt über das Menü Repositories. Es gibt grundsätzlich zwei Möglichkeiten, wie ein neues Repository erzeugt wird: Ein neues leeres Repository erzeugen, um eine eigene Anwendung zu entwickeln. Ein vorhandenes Default-Package importieren, um die darin enthaltene Anwendung in einen Broker zu generieren oder darauf aufbauend ein Customizing-Package zu erzeugen. Warning Es gibt immer genau ein unterstes Package. Dieses nennt sich Default-Package. Mehrere Default-Packages können nicht miteinander kombiniert werden. Es ist also nicht möglich, nachträglich ein Package zu importieren, bei dem es sich um ein solches Default-Package handelt. Connection Type (SqlServer, Oracle) Hier können Sie angeben, welche Art von Datenbank Sie für das neue Repository verwenden wollen. Server Name (Nur bei SQL-Server) Gibt an, auf welchen Server das Repository abgelegt ist bzw. abgelegt werden soll. Bei Oracle werden die Datenbanken nur mit Namen angesprochen. Diese Namen müssen im Oracle-Client hinterlegt werden. Database Name Gibt den Namen der Datenbank an, in der das Repository eingespielt werden soll. Bei SQL-Server wird eine neue Datenbank erzeugt, falls diese noch nicht existiert. Wenn die Datenbank bereits existiert, muss es sich dabei um eine leere Datenbank handeln. Es darf auch keine Framework Studio Lizenz-Datenbank sein. Bei Oracle muss die angegebene Datenbank existieren. Die Tabellen für das Repository werden in das Profil des angegebenen Benutzers generiert. Es dürfen in dem Profil noch keine Repository-Datenstrukturen existieren. Es darf auch keine Framework Studio Lizenz-Datenbank in diesem Profil installiert sein. Authentication Gibt an, mit welchem Login auf die Datenbank zugegriffen werden soll. Repository with empty default Package Es wird ein leeres Default-Package generiert. Der Name des Packages wird mit „Package“ vorbelegt. Er kann später im Package Manager geändert werden. Dies sollte vor dem Start der Entwicklung gemacht werden. I want to choose my default Package Es wird ein vorhandenes Package importiert. Das Package kann mit dem Button ausgewählt werden. Dabei muss es sich um ein Default-Package handeln. Der Import kann je nach Größe des Packages relativ lange dauern. Button OK Erzeugt das Repository. Button Cancel Schließt den Dialog ohne eine Aktion auszuführen. Login Mit dem Login-Dialog können Sie sich am zuvor ausgewählten Repository anmelden. Listbox Package Eine Liste der existierenden Packages. Importierte Packages werden mit dem Suffix (readonly) gekennzeichnet. Beim Login merkt sich Framework Studio das ausgewählte Package. Es wird beim nächsten Login wieder vorbelegt. Listbox Version Eine Liste der Package-Versionen. Es werden die Versionen des ausgewählten Packages angezeigt. Die Versionen sind nach Versions-Nummer absteigend sortiert. Eine Sortierung ist nur dann gewährleistet, wenn übliche gültige Versionsnummern verwendet werden. Ist eine Package-Version mit einer anderen FS-Version erstellt, dann wird dies in dieser Liste angezeigt (z.B. [FS 3.11] – diese Package-Version kann nur mit FS Version 3.11 bearbeitet werden). Ein Login ist in diesem Fall nicht möglich. Sie müssen den Package-Manager verwenden, um die Package-Version auf eine aktuellere FS-Version zu bringen. Ist ein Package-Version versiegelt, dann wird dies in der Liste mit dem Suffix (sealed) angezeigt. Ein Login ist möglich, es kann jedoch nicht bearbeitet werden. Beim Login merkt sich Framework Studio die zuletzt ausgewählte Version. Die Information wird für jedes Package separat gespeichert. Beim nächsten Login wird bei der Auswahl des Packages die zuletzt gewählte Version vorbelegt. Checkbox \"Show only applicable packages and versions\" Mit dieser Checkbox werden die Packages und deren Versions gefiltert. Es werden nur noch die zur Auswahl bereitgestellt, an welchen sich eingeloggt werden kann. Beispielsweise werden sealed Packages oder Versions, welche nicht passend zur FS-Version sind ausgeblendet. Combobox User Eine Liste aller existierenden Benutzer. Diese Combobox arbeitet mit Autovervollständigung. Man braucht also nur die ersten Buchstaben eintippen. Das ist vorteilhaft bei langen Benutzernamen. Beim Login merkt sich Framework Studio den zuletzt verwendeten Benutzer. Diese Information wird für jede Package-Version separat gespeichert. Beim nächsten Login wird bei der Auswahl einer Version der zuletzt gewählte Benutzer vorbelegt. Wenn Sie sich als FrameworkCompiler anmelden, dann wird die letzte Vorbelegung nicht gespeichert. Wenn Sie nach dem Öffnen des Login-Dialogs einmal einen anderen Benutzer auswählen, wird dieser nicht mehr automatisch verändert. Der FrameworkAdministrator kann sich nicht an einem Package anmelden. Mit diesem Benutzer öffnet sich die Benutzer-Verwaltung. Wenn man diesen Benutzer auswählt, dann werden alle Optionen deaktiviert. Weitere Informationen zu Packages und Version finden Sie unter Package Manager. Password Geben Sie das Kennwort des Benutzers ein. Sollten Sie Ihr Passwort einmal vergessen, gibt es die Möglichkeit über das Menü Benutzer-Verwaltung ein neues Passwort zu vergeben. Checkbox Get latest FrameworkCompiler workspace Gibt an, ob der Workspace aktualisiert werden soll. Bei einem normalen Benutzer wird der eigene Workspace auf den Stand des FrameworkCompiler Workspaces aktualisiert. Gibt es einen neueren vollständig kompilierten und abgeschlossenen FrameworkCompiler Workspace, dann ist diese Checkbox zugänglich und automatisch gesetzt. Ist der eigene Workspace bereits auf dem aktuellsten Stand, dann ist ein erneuter Refresh nicht möglich. Enthält der Benutzer in seinem Workspace bereits aktuellere Elemente als der FrameworkCompiler, dann behält er diese. Auch vom Benutzer ausgecheckte Elemente bleiben im eigenen Workspace erhalten. Alle Elemente, deren Version vom FrameworkCompiler Workspace abweichen, werden mit der Checkbox Compile Changes automatisch kompiliert. Checkbox Get Latest Version Wenn Sie sich als FrameworkCompiler anmelden, dann wird der Workspace auf die \"Latest Version\", also auf den aktuellsten eingecheckten Stand aller Elemente aktualisiert. Bei einer offnenen Package-Version enthält der so neu erzeugte Workspace keinen SavedCode und keine DLLs. Diese werden durch einen vollständigen Compile erzeugt. Der Framework Compiler startet somit den Compile auf der \"grünen Wiese\". Bei einer Service-Release Version werden SavedCode und DLLs aus dem vorherigen abgeschlossenen Workspace kompiliert. Somit müssen nur noch die im Service-Release geänderten Elemente neu kompiliert werden. Checkbox Get DLLs Gibt an, ob die vom FrameworkCompiler erzeugte DLLs geholt werden sollen. Checkbox Compile Changes Gibt an, ob automatisch alle Elemente kompiliert werden sollen, die nicht zum FrameworkCompiler Workspace passen. Das betrifft ausgecheckte Elemente und auch z.B. nach dem Start des FrameworkCompilers eingecheckte Elemente. Während dieses Compiles wird die Compiler-Option \"Use Saved Code\" aktiviert und die Option \"Debuggable\" wird deaktiviert. Anschließend werden die Compiler-Optionen wieder auf die letzte Benutzer-Einstellung zurückgesetzt. Diese Option kann nur in Verbindung mit Get DLLs verwendet werden. Wenn Sie sich als FrameworkCompiler anmelden, steht diese Option nicht zur Verfügung. Wenn der letzte FrameworkCompiler erfolgreich war und der eigene Workspace veraltet ist (älter als der vom FrameworkCompiler), dann werden bei der Auswahl einer Version oder beim Wechseln des Benutzers die Checkboxen Refresh Workspace mit der FrameworkCompiler-Option, Get DLLs und Compile CheckedOut automatisch vorbelegt. Option AutoDebug DLLs Diese Option ist aktiv, sobald die Checkbox Compile Changes aktiviert wird. Die initiale Vorbelegung stammt aus dem Options-Dialog, kann jedoch temporär im Login-Dialog geändert werden. Wird bei der AutoDebug-Option All angegeben, werden alle Namespaces jedes Typen debuggable kompiliert. Wird Service, Component angegeben, werden alle vorgenommenen Änderungen (Compile Changes), Services und Components debuggable kompiliert. Wird Service, Component, Form angegeben, werden alle vorgenommenen Änderungen (Compile Changes), Services, Components und Forms debuggable kompiliert. Mit None wird die AutoDebug-Option entsprechend \"deaktiviert\" und nur die vorgenommen Änderungen (Compile Changes) werden normal/nicht debuggable kompiliert. Informationen Bei der Auswahl einer Version werden unter den Checkboxen einige Informationen ausgegeben. Diese können je nach Anwendungs-Fall variieren. Last FrameworkCompiler succeeded Wird angezeigt, wenn der letzte FrameworkCompiler erfolgreich war. Der letzte FrameworkCompiler wurde erfolgreich abgeschlossen, nachdem der Workspace vom FrameworkCompiler aktualisiert wurde. Last FrameworkCompiler failed Wird angezeigt, wenn der letzte FrameworkCompiler fehlgeschlagen ist. Es wurde ein Refresh Workspace durchgeführt, nachdem der letzte Compiler gelaufen ist. Zusätzlich gibt es noch einige Felder, die immer verfügbar sind: Last Refresh Workspace Gibt an, wenn der Benutzer zuletzt seinen eigenen Workspace aktualisiert hat. Es wird die Differenz in Minuten, Stunden oder Tagen angegeben. Zusätzlich gibt es einen Tooltip mit der kompletten Datum-Zeit-Angabe. Wenn der Benutzer noch keinen Workspace hat, dann wird (no workspace) ausgegeben. Wenn Sie den FrameworkCompiler auswählen, dann wird diese Information ausgeblendet. Last FrameworkCompiler refresh Gibt an, wann der Workspace des FrameworkCompilers zuletzt aktualisiert wurde. Es wird die Differenz in Minuten, Stunden oder Tagen angegeben. Zusätzlich gibt es einen Tooltip mit der kompletten Datum-Zeit-Angabe. Wenn der FrameworkCompiler noch keinen Workspace hat, dann wird (no workspace) ausgegeben. Last FrameworkCompiler compile Gibt an, wenn der letzte FrameworkCompiler erfolgreich durchgelaufen ist. Es wird die Differenz in Minuten, Stunden oder Tagen angegeben. Zusätzlich gibt es einen Tooltip mit der kompletten Datum-Zeit-Angabe. Wenn noch nie ein FrameworkCompiler gelaufen ist, dann wird (never) ausgegeben. Note Diese Information wird generiert, wenn man den Compiler aus dem Package-Manager heraus startet, oder mit dem Programm FSConsole.exe durchführt. Checkbox Maintenance Mode Ist diese Checkbox gesetzt, wird Framework Studio im Wartungsmodus gestartet (siehe Maintenance Mode). Button Login (Eingabetaste) Mit diesem Button erfolgt die Anmeldung am Repository. Auf einem Repository kann sich ein Benutzer nur einmal an einem Label (Package Version) anmelden. Ein Benutzer kann sich dagegen gleichzeitig an verschiedenen Labels anmelden. Dabei wird pro Benutzer nur eine Framework Studio Lizenz verbraucht. Wenn Sie mit mehreren Benutzern in einem Label entwickeln möchten, ist es erforderlich, dass sich jeder mit einem anderen Namen an dem Repository anmeldet. Wenn noch eine Anmeldung mit diesem Benutzer existiert, erscheint eine entsprechende Meldung. Diese Meldung erscheint auch dann, wenn sich Framework Studio unkontrolliert beendet hat (oder beendet wurde) und keine saubere Abmeldung erfolgt ist. In diesem Fall ist das Übernehmen der existierenden Anmeldung unproblematisch. Wird die Anmeldung übernommen, wird der bereits angemeldete Entwickler automatisch abgemeldet, weil ein Benutzer nur einmal angemeldet sein darf. Arbeitet ggf. noch jemand anderes mit diesem Benutzer, wird dessen Anwendung automatisch beendet. Nach erfolgreicher Anmeldung öffnet sich das Hauptfenster von Framework Studio. Button Cancel (Escape-Taste) Damit wird der Anmeldevorgang abgebrochen und es wird wieder die Repository-Auswahl angezeigt. Maintenance Mode Um Framework Studio im Wartungsmodus zu starten, muss im Login-Dialog die Checkbox Maintenance Mode gesetzt werden (siehe Login). Die im Folgenden beschriebenen Funktionalitäten stehen dann in Framework Studio zur Verfügung. Upgrade Workflow Parameters In älteren Framework Studio Versionen (bis einschließlich 2.5) wurden Parameter in Methodenaufrufen von Workflow-Links anhand ihrer Bezeichnung identifiziert. Das hatte zur Folge, dass durch Umbenennung eines Parameters die Verknüpfung zerstört wurde. An solche Parameter wurde dann automatisch der Wert \"null\" übergeben. Da dies meist keinen Kompilierfehler verursacht hat, wurden dadurch ausgelöste Probleme erst spät erkannt. Mit dem Menüpunkt Tools / Upgrade all old workflow parameters wird ein Vorgang gestartet, der dafür sorgt, dass alle Parameter zukünftig über ihre Position identifiziert werden. Ein nachträgliches Umbenennen von Parametern ist dann zukünftig problemlos möglich. Der Vorgang kann nicht mit dem Benutzer FrameworkCompiler ausgeführt werden, da alle Workflows zur Bearbeitung ausgecheckt werden. Dieser Vorgang findet im Hintergrund statt, ohne dass der Benutzer Statusmeldungen erhält. Ist der Vorgang beendet, erscheint eine Meldung mit dem Hinweis auf die automatisch erzeugte Protokoll-Datei. In dieser Protokoll-Datei wird auch festgehalten, welche Links an einen Parameter ein \"null\" übergeben. Diese Links sollten daraufhin überprüft werden, ob durch den oben beschriebenen Fehler bereits ein Parameter abhandengekommen ist. Im Anschluss müssen alle Workflows manuell eingecheckt werden. Dazu bietet es sich an, nach ausgecheckten Elementen zu suchen (siehe Registerkarte Search), da dort über das Kontextmenü alle Elemente in einem Vorgang eingecheckt werden können."
  },
  "doc/ide/tools-menu.html": {
    "href": "doc/ide/tools-menu.html",
    "title": "Tools Menü",
    "keywords": "Tools Menü In den folgenden Abschnitten werden die Menüpunkte im Menü Tools beschrieben. Registered Databases In diesem Dialog werden die im Repository verwendeten Datenbankverbindungen verwaltet. Die Verbindung mit dem Namen RuntimeConnection stellt die Verbindung zum Repository dar. Die in diesem Dialog angelegten Verbindungen stehen allen Benutzern in allen Packages des Repositories zur Verfügung. Caution Die Angaben stehen nicht unter der Versionskontrolle. Sie können von allen Benutzern zu jeder Zeit verändert werden. Die Änderungen wirken sich auf alle Benutzer gleichermaßen aus. Es sollte daher beachtet werden, dass andere Benutzer dadurch nicht behindert werden. Die Verbindungs-Einstellungen sind im Kapitel Connection Einstellungen beschrieben. Access Unit Treeview Über den Menüpunkt Tools / Access Unit Treeview... kann das Fenster zum Bearbeiten der Access Unit Hierarchie aufgerufen werden. Siehe dazu Access Unit Hierarchie. Code Snippets Editor Der Code Snippets Editor ist ein hilfreiches Werkzeug, wenn Sie wiederkehrenden Code haben. Welchen Code Sie hinterlegen, bleibt dabei Ihnen überlassen. Es können C#-Code-Strukturen oder Schleifenkonstrukte gespeichert werden. Auch Methoden, die Sie laufend bei Vererbung benötigen, könnten hilfreich sein. Sie können die hinterlegten Code Snippets im Code Editor über die Tastenkombination CTRL + J aufrufen. Es öffnet sich eine Listbox mit einer Preview (siehe Abbildung). Die Code Snippets werden im Repository an der aktuellen Package-Version gespeichert. Sie werden zusammen mit der Package-Version exportiert und so in das Ziel-Repository übertragen. Im Code Snippet-Editor können die Code Snippets für die aktuelle Package-Version bearbeitet werden. Code Snippets Editor öffnen Sie können den Editor über das Hauptmenü Tools - Code Snippets Editor öffnen, oder indem Sie im Code Editor den Shortcut CTRL + Shift + J ausführen. Auch über das Kontextmenü des CSharp-Code Editors können Sie den Snippet Editor öffnen. Code Snippets anlegen Ein neues Code Snippet kann über den File-Button im Code Snippet Editor angelegt werden. In der Textbox Name kann der entsprechende Name für das Code Snippet eingetragen werden. Die Snippets können mit Parameter-Platzhaltern angelegt werden. Dies ermöglicht nach dem Einfügen des Code Snippets im C#-Editor das Springen mit der TAB-Taste durch die Parameter. Ein Parameter ist wie folgt zu definieren: ${1:name} Note Der erste Parameter muss mit einer 1 beginnen. Die Bezeichnung nach dem Doppelpunkt ist nicht zwingend notwendig, verbessert jedoch die Verständlichkeit. Code Snippet Beispiel foreach-Schleife Sobald Sie das Code Snippet im Editor hinzufügen, werden die Parameter grau markiert. Die blaue Markierung zeigt die derzeitge Bearbeitung an. Mit der TAB-Taste können Sie zum nächsten Parameter springen. Beispiel für mehrere gleiche Parameter Sind an mehreren Stellen gleiche Variablen oder gleiche Werte einzutragen, so können Sie diese Parameter mit der gleichen Zahl definieren. Sobald Sie den ersten Parameter bearbeiten, wird mittels Multicursor der Wert an allen Stellen eingetragen. if(${1:value} != null && ${1:value}.Count > 0){ } Code Snippets überschreiben Es werden die Code Snippets aus den Basis-Packages zusammen mit dem Package-Namen angezeigt – sie sind readonly. Überschreiben können Sie ein Code Snippet indem Sie im aktuellen Package ein weiteres Code Snippet mit identischem Namen erstellen. In der Liste sind die Code Snippets nach der Package-Hierarchie angeordnet, sodass Überschreibungen gut zu erkennen sind. Beispiel Package Hierarchie bei Code Snippets Das aktuelle Package hat FSDemoCustomize und FSDemo als Basis. Deshalb werden auch die Code Snippets dieser beiden Packages angezeigt. Im Code Snippet Editor werden die Snippets in folgender Reihenfolge dargestellt: Snippet1 Snippet1 [FSDemoCustomize] Snippet1 [FSDemo] Snippet2 [FSDemoCustomize] Snippet2 [FSDemo] Snippet3 [FSDemo] Snippet4 Snippet4 [FSDemo] Von den im CodeSnippet-Editor angezeigten CodeSnippets gewinnt jeweils das erste. Die grauen Einträge werden im Intellisense und der Toolbox nicht angezeigt. Checked Out Report Im Menu Tools / Checked Out Report öffnet sich ein Report-Fenster. Checked Out Records: Dieser Report zeigt die ausgecheckten Elemente aller Benutzer an. Die Anzeige ist nach Benutzern gruppiert. Eine Legende mit den Bedeutungen der Farben befindet sich am Ende dieses Reports. Change Password Im Menu Tools / Change Password öffnet sich ein Dialog zum Ändern des eigenen Passworts. Change Password Dialog: In diesem Dialog müssen Sie im Feld Old Password das zurzeit gültige Passwort eingeben. In New Password können Sie das neue Passwort eingeben, welches in Confirm New Password bestätigt werden muss, um Fehleingaben zu verhindern. Mit dem Button OK wird das neue Passwort gesetzt. Wenn Sie kein neues Passwort eingeben und mit dem Button OK bestätigen, wird das Passwort gelöscht und Sie können sich ab sofort ohne Passwort mit Ihrem Benutzernamen anmelden. Wenn Sie im Team mit mehreren Entwicklern arbeiten, wird aus Sicherheitsgründen empfohlen ein Passwort zu verwenden. Sollten Sie Ihr Passwort einmal vergessen, gibt es die Möglichkeit über die Benutzer-Verwaltung ein neues Passwort zu vergeben. Adjust moved customizations Wird ein Element aus einem Basis-Package gecustomized, dann merkt sich Framework Studio aus Performance-Gründen auch im Customizing-Package den Namespace, in dem sich dieses Element befindet. Nun kann es passieren, dass im Basis-Package ein Element mit der Funktion Change Namespace in einen anderen Namespace verschoben wird. Dies führt zu Compile-Fehlern im Customizing-Package. Mit der Routine Adjust moved customizations wird der Namespace der gecustomizten Elemente korrigiert. Diese werden dazu ausgecheckt und müssen anschließend wieder eingecheckt werden, bevor ein Framework Compiler gestartet wird. FSConsole Command Prompt Startet ein Konsolen-Fenster. Dort ist als aktuelles Verzeichnis das Framework Studio Programm-Verzeichnis gesetzt. Runtime Licenses Über den Menüpunkt Tools / Runtime Licenses kann der Runtime License Manager geöffnet werden. Details zur Verwaltung von Laufzeitlizenzen mit dem Runtime License Manager finden Sie unter Laufzeitlizenzen."
  },
  "doc/ide/view-menu.html": {
    "href": "doc/ide/view-menu.html",
    "title": "View Menü",
    "keywords": "View Menü Track Active Item Ist der Menüeintrag Track Active Item mit einem Häkchen versehen, so wird auf der Registerkarte Namespaces automatisch der Namespace ausgewählt, in dem das aktuell fokussierte Element im Framework Designer (z.B. ein Form oder eine Component) angelegt ist. Ist der Menüeintrag nicht mit einem Häkchen versehen, ist dieser Automatismus abgeschaltet. Stattdessen wird in den Designer Fenstern ein zusätzlicher Button (Track Item) angeboten, mit dem auf der Registerkarte Namespaces in den Namespace des Elements gewechselt werden kann."
  },
  "doc/ide/window-menu.html": {
    "href": "doc/ide/window-menu.html",
    "title": "Window Menü",
    "keywords": "Window Menü Beim Verlassen von Framework Studio wird das aktuelle Layout automatisch abgespeichert. Es wird beim nächsten Start wieder ausgelesen. Das betrifft die Anordnung, Größe und Position der dockbaren Fenster. Menüpunkt Reset Window Layout: Setzt das Layout auf den Standard zurück. Menüpunkt Save Window Layout to file: Man kann das Layout also die Anordnung, Größe und Position der dockbaren Fenster in eine Datei speichern. Das ist sehr praktisch, wenn man z.B. auch über eine Remote-Verbindung auf seinem Rechner arbeitet. So kann man für die entsprechende Situation sein eigenes Layout erzeugen. Es wird eine Datei mit der Endung *.FS30Layout.xml erzeugt. Diese Dateien können nur mit der passenden Version von Framework Studio verwendet werden. Menüpunkt Load Window Layout from file: Lädt eine Layout-Datei und passt das Layout entsprechend an. Es können nur Layout-Dateien verwendet werden, die zu dieser Version von Framework Studio passen. Andere Dateien können dazu führen, dass einige Fenster falsch oder auch gar nicht angezeigt werden. Menüpunkt Close All Documents: Schließt alle offenen Elemente."
  },
  "doc/index.html": {
    "href": "doc/index.html",
    "title": "Framework Studio Technische Dokumentation",
    "keywords": "Framework Studio Technische Dokumentation"
  },
  "doc/kommandozeilen-parameter/kommandozeilen-parameter.html": {
    "href": "doc/kommandozeilen-parameter/kommandozeilen-parameter.html",
    "title": "Kommandozeilen-Parameter",
    "keywords": "Kommandozeilen-Parameter Allgemeines Die Datei FrameworkStudio.exe kann mit Parametern gestartet werden. Die Parameter ermöglichen beispielsweise automatisiert den Kompiliervorgang für den FrameworkCompiler anzustoßen. Die Parameter können in beliebiger Reihenfolge angegeben werden. Eine Liste aller möglichen Parameter mit Beschreibung folgt im nächsten Kapitel (Tabellarische Übersicht aller Parameter). Beispiel: FrameworkStudio2_5.exe \\CONNECT \"ConnectionString\" \\CONNECTIONTYPE \"SqlServer\" \\LOGIN \"demo:\" \\PACKAGE \"FSDemo\" \\VERSION \"1.0\" Durch diesen Aufruf wird Framework Studio auf dem durch ConnectionString spezifizierten SqlServer Repository am Package FSDemo in der Version 1.0 für den Benutzer demo gestartet. Tabellarische Übersicht aller Parameter \\CONNECT \"ConnectionString\" Repository Connections-String Beispiel: \"data source=Server;initial catalog=Repository;persist security info=true;User ID=sa;Password=sa;;Pooling=false;\" \\CONNECTIONTYPE \"Type\" Mögliche Werte für Type: Oracle SqlServer \\LOGIN \"UserName:\" Der Benutzername mit dem sich am Repository angemeldet werden soll. z.B \"FrameworkCompiler:\" \\PACKAGE \"PackageName\" Der Name des Packages \\VERSION \"PackageVersion\" Die Version z.B. \"1.0.1\" \\APPLICATION \"ApplicationName\" Gibt an, welche Application gesetzt werden soll. Das ist vor allem dann notwendig, wenn mit dem Parameter \\REFRESHWS gearbeitet wird, damit die Assemblies auch in den richtigen Broker-Ordner geschrieben werden. \\REFRESHWS \"true\" Wenn dieser Parameter mit dem Wert \"true\" angegeben ist, wird ein Refresh Workspace durchgeführt. Ein Compile mit dem FrameworkCompiler macht nur Sinn, wenn dessen Workspace aktualisiert wird, und er die frisch eingecheckten Versionen kompiliert. \\COMPILE \":0000000000000000\" Wenn der Parameter gesetzt ist, wir der Compile automatisch gestartet. Die Ziffern sind eine Folge aus 0en und 1en, die die Schalter für den Compile-Vorgang angibt. Es folgt eine Liste der Schalter. Es müssen immer alle Ziffern entweder mit 0 oder 1 angegeben werden. Ziffer) Recursive Ziffer) Debugable Ziffer) XmlDoc Ziffer) Use Saved Code Ziffer) Muss immer „1“ sein. Ziffer) Ressources Ziffer) AccessUnits Ziffer) Metadatentypen Ziffer) DB-Tables Ziffer) Interfaces Ziffer) Components Ziffer) GlobalObjects Ziffer) ReportDocumentTypes Ziffer) CustomControls Ziffer) Forms Ziffer) Workflows Ein typischer Compile wäre z.B. \":1001111111111111\" Dabei wird alles mit Use SavedCode kompiliert. Note Nach dem Compile wird FrameworkStudio nicht beendet, sondern bleibt am Bildschirm stehen. Wenn beim Compile ein Fehler auftritt, bleibt er an dieser Stelle stehen und der Fehler wird wie bei einem normalen Compile angezeigt."
  },
  "doc/konzepte/form-databinding.html": {
    "href": "doc/konzepte/form-databinding.html",
    "title": "Databinding in Forms",
    "keywords": "Databinding in Forms Die Daten in Forms werden mithilfe von Databinding aus den zugeordneten Objekten gezogen. Die Verarbeitung der Daten im Laufe eines Requests erfolgt immer in 3 Schritten: Der Client sendet einen Request mit Daten, die der Benutzer geändert hat. Das Binding spielt alle Änderungen in die momentan gebundenen Objekt-Instanzen ein. Das Form-Event / Workflow-Event wird ausgeführt. Änderungen an Objekten werden über diverse Events (wie z.B. PropertyChanged) gemeldet. Das Binding registriert diese Events - holt aber noch keine Daten ab. Nach der Event-Verarbeitung, am Ende vom Request aktualisiert das Binding die Daten. Alle zuvor registrierten Änderungen werden abgearbeitet, die Daten abgeholt und an die Controls übertragen. Die Änderungen werden mit dem Response zum Client geschickt. Das Binding greift auf jedes Property maximal einmal zu. Das gilt auch dann, wenn sich während des Requests ein Property mehrfach ändert und mehrfach Changed-Events gefeuert werden. Hierarchische Objekt-Strukturen werden vom Binding hierarchisch verarbeitet. Sie werden intern mit \"Binding-Points\" organisiert. Änderungs-Markierungen werden an jedem einzelnen Binding-Point gesammelt. Beispiel für Binding-Points: FormProperty: oSalesOrder Propery: oMaster Property: lngOrderID <--> Control edtOrderID.Value Property: sOrderType <--> Control cmdOrdertype.Value Szenarien: Wenn sich z.B. lngOrderID ändert, dann gibt es ein PropertyChanged-Event und nur der entsprechende Binding-Point wird markiert. Am Ende des Requests wird dann auch nur dieser eine Binding-Point aktualisiert. Alle anderen Properties werden nicht geprüft. Wurde eine Änderung von oMaster gemeldet, holt das Binding zuerst den neuen Wert von oSalesOrder.oMaster ab. Nur wenn dabei eine andere Objekt-Instanz zurückgegeben wird, dann werden auch die darunterliegendenden Binding-Points für lngOrderID und sOrderType aktualisiert. Individual Properties und DependsOn Das Binding ist auf ein PropertyChanged-Event angewiesen, um Änderungen mitzubekommen. Individual Properties und Relations geben in der Regel berechnete Werte zurück, die von anderen Werten abhängen. Da sie keinen eigenen Wert besitzen, der ein PropertyChanged-Event auslösen könnte, sind sie darauf angewiesen, dass sie von ihren Abhängigkeiten benachrichtigt werden. Diese Aufgabe übernehmen die DependsOn-Properties. Ist kein DependsOn hinterlegt, gibt es keine aktive Benachrichtigung und das Databinding geht davon aus, dass sich der Wert jederzeit ändern könnte. Aus diesem Grund werden diese Binding-Points nach jedem Request überprüft. Dies sorgt für eine schlechte Performance und sollte, wenn möglich vermieden werden. Generell sollten folgende Hinweise beachtet werden, insbesondere jedoch dann, wenn keine (sinnvollen) DependsOn-Angaben möglich sind. Die Get-Methode muss sehr performant sein und darf nicht bei jedem Zugriff einen Datenbank-Load absetzen. Es müssen dieselben Objekt-Instanzen zurückgegeben werden, wenn sich die Bedingungen nicht geändert haben. Das unterbindet eine Aktualisierung der darunterliegenden Binding-Points."
  },
  "doc/konzepte/fs-types.html": {
    "href": "doc/konzepte/fs-types.html",
    "title": "FS-Datentypen",
    "keywords": "FS-Datentypen FS-Datentypen verhalten sich fast genauso wie die .NET-Datentypen mit ähnlich lautenden Namen. Der Unterschied zu den .NET-Datentypen besteht darin, dass sie einen Null-Wert verstehen. Die FS-Datentypen sind die Basis für die Metadatentypen. Sie können aber auch als Datentyp für Properties oder einfach frei im Code verwendet werden. Sie sollten immer dann verwendet werden, wenn die Null-Information nicht verloren gehen darf. Mit diesen Datentypen ist es möglich, Null-Werte aus einer Datenbank auszuwerten und auch wieder in die Datenbank zurückzuschreiben. Außerdem können z.B. Datenfelder in Forms, die eine Zahl oder ein Datum enthalten, komplett leer sein, was z.B. bei Suchfeldern wichtig ist. Bei den FS-Datentypen handelt es sich ebenfalls um Structs. Die Wertzuweisungen zwischen verschiedenen FS-Datentypen erfolgen also ByValue – wie bei den .NET-Datentypen auch. Variablen und Properties von einem FS-Datentyp können genauso verwendet werden wie Variablen und Properties von .NET-Datentypen. Es können auch Zuweisungen zwischen den verschiedenen Datentypen erfolgen. Es erfolgt in den meisten Fällen eine implizite Konvertierung der Datentypen. Die Null-Information geht dabei aber verloren. Properties der FS-Datentypen Value: (Property) Wert des FS-Datentyps als .NET-Datentyp. D.h.: FSdecimal.Value liefert einen Wert vom Typ dezimal. Dieser Wert kann sowohl gelesen als auch geschrieben werden. Ist der Wert der Variable Null, liefert Value den in der folgenden Tabelle angegebenen Wert aus der Spalte Null-Value zurück. Das Setzen des Wertes der Variable auf einen Null-Value hat aber nicht zur Folge, dass die Variable Null wird. Einzige Ausnahme ist FSstring: IsNull bedeutet Value=““ und Value=““ bedeutet IsNull. Beispiel: FSdecimal decVar1 = 0; // Wert auf 0 oder Null prüfen if (decVar1.Value == 0) { … } // Variante ohne Value if (decVar1.IsNull || decVar1 == 0 ) { … } // Wert zuweisen: decVar1 = 5; //oder decVar1.Value = 5; IsNull (Property) Ist vom Typ bool. Gibt an, ob der Wert der Variable Null ist. Um einem FS-Datentypen explizit ein Null zuzuweisen, gibt es zwei Möglichkeiten: Sie weisen dem Property IsNull true zu, oder Sie weisen der Variable FSxxx.Null zu FSdecimal decVar1 = 0; // Wert nur auf Null prüfen if (decVar1.IsNull) { … } // Wert auf Null setzen decVar1.IsNull = true; // oder decVar1 = FSdecimal.Null; Null (Statisches Property) Liefert eine Variable mit einem Null-Wert. // Variable mit Null initialisieren FSdecimal decVar2 = FSdecimal.Null; Es folgt eine Tabelle mit allen FS-Datentypen und deren Null-Value. .NET-Datentyp FS-Datentyp Null-Value bool FSBool false byte FSbyte 0 DateTime FSDateTime DateTime.MinValue decimal FSdecimal 0 double FSdouble 0 float FSfloat 0 int FSint 0 long FSlong 0 short FSshort 0 string FSstring String.Empty HasValue (Property) Ist vom Typ bool. Man kann mit IsNull prüfen, ob ein FSType (FSstring, FSdecimal, …) null ist. Wenn das Gegenteil geprüft werden soll, kann das Property HasValue verwendet werden. So wird der Code deutlich lesbarer, vor allem dann, wenn das zu prüfende Property tief verschachtelt ist. Beispiel: // herkömmlicher Weg (Das Ausrufezeichen wird schnell überlesen): if (!this.oOrder.oCustomer.sCompany1.IsNull) // neuer Weg: if (this.oOrder.oCustomer.sCompany1.HasValue) FSDateTime.Now Statisches Property am Typ FSDateTime, welches das aktuelle System-Datum sekundengenau zurückgibt. Wenn man mit der Datenbank oder auch mit Benutzer-Eingaben arbeitet, werden in der Regel sekundengenaue Werte verarbeitet. Wenn man mit dem System.DateTime.Now arbeitet, erhält man einen um mehrere Zehnerpotenzen genaueren Wert. Bei Vergleichen mit Benutzereingaben weichen diese dann von System.DateTime.Now ab. Es wird daher empfohlen, alle Daten, die mit dem aktuellen Datum initialisiert werden sollen, mit FSDateTime.Now zu initialisieren. Beispiel: // Variable mit sekundengenauem Wert der aktuellen Zeit initialisieren FSDateTime dtMyDate = FSDateTime.Now; Wenn mit genaueren Werten gearbeitet werden soll, ist die folgende Initialisierung ebenfalls möglich: // Variable möglichst genau mit der aktuellen Zeit initialisieren FSDateTime dtMyAccurateDate = DateTime.Now;"
  },
  "doc/konzepte/fscache.html": {
    "href": "doc/konzepte/fscache.html",
    "title": "FSCache (Memory Cache)",
    "keywords": "FSCache (Memory Cache) Warning Dieses Feature befindet sich noch in Entwicklung und sollte noch nicht frei eingesetzt werden. Derzeit werden in eNVenta mit Begleitung durch des FS-Teams noch weitere Grundlagen geschaffen. Framework Studio stellt eine Infrastruktur auf Basis des IMemoryCache von Microsoft bereit. Erreichbar ist diese über einen Singleton FSCache.Instance. FSCache.Instance bietet in erster Ebene Methoden, um an den Cache für den gewünschten Scope zu gelangen - z.B. FSCache.Instance.Static(), FSCache.Instance.Session() oder FSCache.Instance.Request(). Weitere Scopes z.B. für BusinessUnit() und User() werden von eNVenta mihilfe von Extension-Methods für das Interface IFSCache implementiert. An den zurückgegebenen Memory Caches können alle angebotenen Features frei verwendet werden. Vor allem ist es möglich den Lifecycle eines CacheEntries mit Hilfe von Timeouts oder ExpirationTokens zu steuern. Beispiele: // Verwendung des Static-Caches: IcdCountryColl oCountries = FSCache.Instance.Static().GetOrCreate(\"Countries\", entry => { // Verwerfen, wenn 20 Minuten nicht verwendet. entry.SetSlidingExpiration(TimeSpan.FromMinutes(20)); var countries = cdCountryCollFactory.Create(); countries.Load(); return countries; }); // Verwendung des Session-Caches: oCurrencyColl = FSCache.Instance.Session().GetOrCreate(\"Currencies\", entry => { var currencies = cdCurrencyCollFactory.Create(); currencies.Load(); return currencies; }); Spielregeln Bei der Verwendung des FSCache müssen einige Regeln beachtet werden: Der FSCache ist flüchtig. Zugriffe müssen so gestaltet sein, dass die Einträge sich bei Bedarf und jederzeit neu aufbauen können. Existierende Einträge können jederzeit verworfen werden, entsprechende Expiration-Tokens oder -Zeiten zuschlagen. Auch die Methode FSCache.Reset() kann den FSCache jederzeit komplett abräumen. Keine Parameter übertragen. Der FSCache sollte nicht für den Transport von Informationen genutzt werden. Aufgrund der Flüchtigkeit des FSCache können diese Informationen jederzeit verworfen werden. Nur Readonly Objekte cachen. Im FSCache sollen nur Objekte abgelegt werden, die Readonly bzw. gegen Veränderungen gesichert sind (z.B. mit Freeze()). Insbesondere in einem sitzungsübergreifenden Cache (Static, BusinessUnit, User) bestünde die Gefahr für ungewollte Seiteneffekte. Einträge müssen threadsafe sein. Wird ein Objekt in den Cache gepackt, dass veränderlich sein muss, dann muss dieses threadsafe gestaltet sein. Das gilt insbesondere bei einem sitzungsübergreifenden Cache. Weitere Scopes Weitere Scopes können mithilfe von Extension-Methods geschaffen werden, die die Scope-Methode aufrufen. Beispiel: // Eigener User-Scope public static class CacheExtensions { public static IMemoryCache User(this IFSCache cache) { // Der User-Name ist teil des Scope-Keys. string scopeKey = \"User|\" + FSGlobal.Current.AUHelper.UserName; return cache.Scope(scopeKey, entry => { // Cache wird nach einer Stunde nicht Verwendung verworfen entry.SetSlidingExpiration(TimeSpan.FromHours(1)); }); } } // Verwendung: string sValue = FSCache.Instance.User().GetOrCreate(\"UserSettings\", entry => { return LoadUserSettings(); }); Instanzen für Veränderungen sperren - Freeze() Objekte, welche im Cache verwendet werden, können mittels der Methode Freeze vor Veränderungen geschützt werden. Ein Freeze ist nur für ungeänderte und neue Objekte erlaubt. Einmal aufgerufen kann die Instanz für Änderungen nicht mehr \"geöffnet\" werden. Wird versucht eine eingefrorene Instanz zu verändern, wird eine InvalidOperationException() geworfen. Es stehen folgende Methoden/Property bereit: bool IsFrozen bool CanFreeze() void Freeze() Die Abprüfung auf IsFrozen erfolgt auf jedem internen Value Property. Zu beachten ist: Individueller Code wird dennoch durchlaufen, wenn nicht selbstständig auf die Eigenschaft IsFrozen geprüft wird. Erst wenn ein internes Value versucht wird zu ändern, wird eine Exception geworfen. Freeze ist auch für Collections implementiert. Hier wird die Collection selbst und alle internen Objekte gesperrt. Änderungen Triggern mit Change-Tokens Der FSCache bietet mithilfe von ChangeTokens die Möglichkeit, Änderungen zu triggern. Die Tokens werden Static organisiert. Das bedeutet: Ein Invalidate greift immer in allen Sessions innerhald des eigenen Broker-Prozesses. Beim Aufbau eines Caches wird dafür mithilfe eines Key ein Token bereitgestellt. Dies erfolgt mit der Methode FSCache.GetTokenFor<T>(). Der Token wird mit der Methode AddExpirationToken() am Cache-Eintrag registriert. return FSCache.Instance.Static().GetOrCreate(\"Countries\", entry => { entry.AddExpirationToken(FSCache.Instance.GetTokenFor<IcdCountry>() ); var countries = cdCountryCollFactory.Create(); countries.Load(); return countries; }); Bei Bedarf können auch mehrere Tokens für verschiedene Keys registriert werden. In diesem Fall läuft der Cache-Eintrag aus, sobald sich der erste Token meldet. Auf der anderen Seite beim Save, kann dem Cache bescheid gegeben werden. Das erfolgt mit der Methode FSCache.Invalidate<T>(). protected override void OnAfterSave() { FSCache.Instance.Invalidate<IcdCountry>() } Standardmäßig werden die beiden generischen Methoden FSCache.GetTokenFor<T>() und FSCache.Invalidate<T>() verwendet. Der generische Typ fungiert als Key. Es sollte das Interface des einzelnen Records verwendet werden. Es gibt auch allgemeine Methoden, denen als Key ein beliebiges object übergeben werden kann: IFSCache.GetTokenForKey(key), IFSCache.InvalidateKey(key). Diese sollten aber nur in Ausnahmefällen verwendet werden."
  },
  "doc/konzepte/property-changed.html": {
    "href": "doc/konzepte/property-changed.html",
    "title": "PropertyChanged",
    "keywords": "PropertyChanged Die Components und Forms implementieren das Standard-Interface INotifyPropertyChanged. Das Event konsumieren Über das Event PropetyChanged werden Änderungen an Properties gemeldet. Dieses Event transportiert als Argument PropertyChangedEventArgs mit der Eigenschaft PropertyName. oArticle.PropertyChanged += OnArticleChanged; // Der EventHandler: protected void OnArticleChanged(object sender, PropertyChangedEventArgs args) { // reagieren auf Änderungen } Prüfung des Property-Namen Um gezielt auf die Änderung bestimmter Properties zu reagieren muss die eigenschaft PropertyName ausgewertet werden. Dabei müssen auch einige Sonderfälle beachtet werden. Ist der PropertyName leer (null oder Empty) bedeutet, dass sich alle Properties geändert haben. Genauso sollte man es auch betrachten, wenn gar keine EventArgs übergeben werden. // Ausführliche Prüfung if (args == null || string.IsNullOrEmpty(args.PropertyName) || args.PropertyName == nameof(sArticleID)) ... Framework Studio bietet mit der Methode IsProperty eine praktische Erweiterung, um diese Prüfung zu vereinfachen. Man kann dieser Methode bei bedarf auch mehrere Property-Namen übergeben. // Einfache Prüfung analog zu oben if ( args.IsProperty(nameof(sArticleID)) ) ... // mit mehreren Properties: if ( args.IsProperty(nameof(decPrice1), nameof(decPrice2)) ) // ein Preis hat sich geändert ... Soll bewusst auf die Änderung exakt eines Properties gehört werden - also nicht wenn sich alles ändert - dann ist die folgende Schreibweise zu empfehlen: // Es wurde explizit die Artikel-Nummer geändert if ( args?.PropertyName == nameof(sArticleID) ) ... Generell ist es empfehlenswert, wie in den Beispielen demonstriert, mit nameof(...) zu arbeiten, damit die Namen der Properties vom Compiler geprüft werden. Das kann auf je nach Situation auf eine der folgenden Arten passieren Das Property direkt in der eigenen Klasse: nameof(this.sArticleID) Das Property an einer vorhandenen Instanz: nameof(oArticle.sArticleID) Das Property über das Interface oder die Klasse verwenden. nameof(IcdArticle.sArticleID) Aufrufen des Events Innerhalb der Component bzw. des Forms kann das Event durch Aufruf der Methode FirePropertyChanged(string propertyName) ausgelöst werden. Ach hier gilt: wird als PropertyName der Wert null oder String.Empty übergeben, bedeutet es, dass sich alles geändert hat. Davon sollte allerdings nur sehr bedacht Gebrauch gemacht werden."
  },
  "doc/maintenance/code-replace-cleanup.html": {
    "href": "doc/maintenance/code-replace-cleanup.html",
    "title": "Code Replace Cleanup",
    "keywords": "Code Replace Cleanup Code Replace Cleanup ist eine Maintenance-Routine, die mithilfe eines regulären Ausdrucks Ersetzungen in allen Methoden-Codes durchführen kann. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit Sie verfügbar ist. Sie kann in der IDE über das Menü Tools / Code Replace Cleanup aufgerufen werden. Button Copy Settings / Paste Settings Mit diesen Buttons können die Einstellungen kopiert und später wieder eingefügt werden. So können sehr kompfortabel Anleitungen zum Ersetzen von Code im Rahmen eines Updates beschrieben werden. Der kopierte Text hat das folgende Format. == FS - Code Replace Cleanup == CheckIn Comment: Move GetRound to Utils Search Regex: this\\.Global\\.oBasics\\.GetRound Replace Text: Utils.GetRound Damit das Einfügen funktioniert, muss der Text exakt diesem Format entsprechen. Checkin Comment Hier kann der CheckIn Comment angegeben werden. Dieser wird bei einer Änderung an jedes betroffene Element ergänzt. Search Regex Hier kann ein regulärer Ausdruck eingegeben werden. Eine Anleitung zu regulären Ausdrücken finden Sie in der Microsoft-Dokumentation. Replace Text Der gefundene Treffer wird durch diesen Text ersetzt. Tip Hier kann bei Bedarf mit Gruppen gearbeitet werden. Nähere informationen dazu finden Sie in der Microsoft-Dokumentation. Beispiel für Gruppen: == FS - Code Replace Cleanup == CheckIn Comment: Methoden von ocGlobal verschieben Search Regex: this\\.Global.\\ocGlobal\\.(?<name>\\w+)\\( Replace Text: NewGlobal.${name}( Button Analyze Startet eine Analyse und gibt die gefundenen Treffer in der Errors and Warnings Liste aus. Jeder Eintrag repräsentiert einen Methoden-Code. Durch einen Click auf den Link öffnet sich die entsprechende Methode. In den Details werden alle in der jeweiligen Methode gefundenen Treffer aufbereitet und die entsprechenden Ersetzungen kenntlich gemacht. Zur Orientierung steht am Anfang jeder Zeile die entsprechende Zeilennummer. Note Es werden nur Änderungen visualisiert, wenn der komplette Reguläre Ausdruck innerhalb einer Zeile gefunden wird. Erstreckt sich ein Treffer über mehrere Code-Zeilen, dann wird die Ersetzung normal durchgeführt - die Änderung wird aber nicht in den Details visualisiert. Button Cleanup Nachdem die Analyse komplett durchlaufen und die Änderungen gesichtet wurden, kann mit dem Button Cleanup die Ersetzung ausgeführt werden. Anschließend müssen alle Änderungen compiliert und die ausgecheckten Elemente wieder eingecheckt werden."
  },
  "doc/maintenance/constructor-cleanup.html": {
    "href": "doc/maintenance/constructor-cleanup.html",
    "title": "Constructor Cleanup",
    "keywords": "Constructor Cleanup Constructor Cleanup ist eine Maintenance-Routine, die ungültige Konstruktor-Deklarationen korrigiert. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit Sie verfügbar ist. Sie kann in der IDE über das Menü Tools / Checks / Constructor Cleanup aufgerufen werden. Mit dem Button Analyze wird eine Analyse gestartet ohne, dass Änderungen durchgeführt werden. Die Resultate werden in der Error-Liste ausgegeben. Der Button CleanUp führt die Änderungen aus. Dazu werden die betroffenen Components ausgecheckt, geändert und gespeichert. Nach erfolgreichen Compile müssen die Components wieder eingecheckt werden. Beschreibung Es war einige Zeit üblich, alle Methoden einschließlich der Konstruktoren als virtual zu deklarieren. Bei Konstruktoren ist das aber nicht zulässig - dieses sind im .net von Haus aus virtuell. public virtual cdCustomer(IFSGlobalObjects global, FSlong id) : this(global) { // ... } Mit Framework Studio 4.4 werden ungültige Konstruktor-Deklarationen erkannt und als Error ausgegeben. Notwendig ist das, weil Framework Studio jetzt die Methoden-Deklarationen mit offiziellen .net-Mechanismen analysiert um z.B. Tupel korrekt zu behandeln. Das führt bei ungültigen Deklarationen zu Fehlern. Die Routine scannt alle Components, findet die fehlerhaften Konstruktoren und entfernt das virtual Schlüsselwort. public cdCustomer(IFSGlobalObjects global, FSlong id) : this(global) {"
  },
  "doc/maintenance/devexpress-rft-comment-cleanup.html": {
    "href": "doc/maintenance/devexpress-rft-comment-cleanup.html",
    "title": "DevExpress Rtf Comment Cleanup",
    "keywords": "DevExpress Rtf Comment Cleanup DevExpress Rtf Comment Cleanup ist eine Maintenance-Routine, die DevExpress-Reports nach Richtext-Feldern mit Kommentaren scannt und diese korrigiert. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit Sie verfügbar ist. Sie kann in der IDE über das Menü Tools / Checks / DevExpress Rtf Comments Cleanup aufgerufen werden. Mit dem Button Analyze wird eine Analyse gestartet ohne, dass Änderungen durchgeführt werden. Die Resultate werden in der Error-Liste ausgegeben. Der Button CleanUp führt die Änderungen aus. Dazu werden die betroffenen Reports ausgecheckt, geändert und gespeichert. Nach erfolgreichen Compile müssen die Reports wieder eingecheckt werden. Beschreibung In DevExpress werden Richtext-Controls verwendet um Html-Inhalte aufzubereiten. Dabei wird die Eigenschaft Html mit einer Expression versehen. Wird am Richtext-Control zusätzlich für die Eigenschaft Rtf eine Expression in Form eines Kommentars definiert, dann führt das zu Fehlverhalten im FS Web Report Designer. Beispiel für eine Fehlerhafte Rtf-Expression: /*Projekt-Informationen*/ Der IDE-Designer zeigt diesen Kommentar im Feld an. Der Web-Designer kommt damit aber nicht klar und beim Bearbeiten hängt der Expression-Editor im Feld fest. Besser ist es, diesen \"Kommentar\" direkt per Doppelklick als Text-Inhalt im Feld zu platzieren. Die Cleanup-Routine löscht die Rtf-Expression und fügt den Kommentar in der folgenden Form in den Text-Inhalt ein: <Projekt-Informationen>"
  },
  "doc/maintenance/double-form-doc-cleanup.html": {
    "href": "doc/maintenance/double-form-doc-cleanup.html",
    "title": "Double Form Docs Cleanup",
    "keywords": "Double Form Docs Cleanup Double Form Docs Cleanup ist eine Maintenance-Routine, die in Forms doppelte Dokumentationen bereinigt. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit Sie verfügbar ist. Sie kann in der IDE über das Menü Tools / Checks / Double Form Docs Cleanup aufgerufen werden. Mit dem Button Analyze wird eine Analyse gestartet ohne, dass Änderungen durchgeführt werden. Die Resultate werden in der Error-Liste ausgegeben. Der Button CleanUp führt die Änderungen aus. Dazu werden die betroffenen Forms und Dokumentationen ausgecheckt, geändert und gespeichert. Important Nach dem CleanUp sollte Framework Studio neu gestartet werden. Durch die Bereinigung könnte es vorkommen, dass die Dokumentation im Form-Designer oder der Chapter-Tree nicht korrekt angezeigt werden. Anschließend können die ausgecheckten Elemente wieder eingecheckt werden. Beschreibung Forms können nur eine Dokumentation enthalten. In älteren Version gab es einen Fehler, dass beim Copy Paste von Forms im Hintergrund doppelte Einträge für die Form-Dokumentation erstellt wurden. Das hat zur Folge, dass der Chapter Tree das entsprechende Form mehrfach anzeigt. Dieser Fehler wurde im Mai 2023 in FS 4.4 und höher korrigiert, damit entstehen keine neuen Fehler mehr. Fehler, die vor dieser Korrektur entstanden sind, können aber noch vorhanden sein und zu unsauberen Situationen im Chapter Tree führen. Mit der Maintenance-Routine können diese Fehler bereinigt werden. Tip Es ist sinnvoll, diese Routine einmal über alle Package-Version laufen zu lassen. Mit den folgenden SQL-Statements können Sie sich einen Überblick verschaffen, welche Package-Version konkret betroffen sind. Führen Sie das entsprechende Statement auf der Repository-Datenbank aus. Nach CleanUp und Checkin sollten die korrigierten Forms nicht mehr ausgegeben werden. So lässt sich prüfen, ob der CleanUp erfolgreich war. -- SQL-Server: SELECT F_Name AS Form, P_Name AS Package, LBL_Name AS Version FROM (SELECT lblF_ObjectID, max(lblF_ObjectVersion) as lblF_ObjectVersion, lblF_LabelID, max(lblF_PackageID) as lblF_PackageID from lblRep_Form where COALESCE(lblF_IsCheckedOut, 0) = 0 group by lblF_ObjectID, lblF_LabelID) as lbl inner join tblRep_Form on F_ID = lbl.lblF_ObjectID AND F_Version = lbl.lblF_ObjectVersion AND F_PackageID = lblF_PackageID AND COALESCE(F_IsCustomization, 0) = 0 AND COALESCE(F_IsVersionDeleted, 0) = 0 inner join tblRep_Package on P_ID = lbl.lblF_PackageID AND DataLength(P_PckKey) > 1000 inner join tblRep_Label on LBL_ID = lbl.lblF_LabelID where (Select count(*) from subRep_Documentation inner join tblRep_Documentation on DOC_ID = subDOC_ID AND DOC_Version = subDOC_Version AND DOC_PackageID = subDOC_PackageID AND COALESCE(DOC_IsVersionDeleted, 0) = 0 WHERE subDOC_F_ID = lbl.lblF_ObjectID AND subDOC_F_Version = lbl.lblF_ObjectVersion AND subDOC_PackageID = lbl.lblF_PackageID) > 1 order by P_Name, lbl_Name desc -- Oracle: SELECT F_Name AS Form, P_Name AS Package, LBL_Name AS Version FROM (SELECT lblF_ObjectID, max(lblF_ObjectVersion) as lblF_ObjectVersion, lblF_LabelID, max(lblF_PackageID) as lblF_PackageID from lblRep_Form where COALESCE(lblF_IsCheckedOut, '0') = '0' group by lblF_ObjectID, lblF_LabelID) lbl inner join tblRep_Form on F_ID = lbl.lblF_ObjectID AND F_Version = lbl.lblF_ObjectVersion AND F_PackageID = lblF_PackageID AND COALESCE(F_IsCustomization, '0') = '0' AND COALESCE(F_IsVersionDeleted, '0') = '0' inner join tblRep_Package on P_ID = lbl.lblF_PackageID AND length(P_PckKey) > 1000 inner join tblRep_Label on LBL_ID = lbl.lblF_LabelID where (Select count(*) from subRep_Documentation inner join tblRep_Documentation on DOC_ID = subDOC_ID AND DOC_Version = subDOC_Version AND DOC_PackageID = subDOC_PackageID AND COALESCE(DOC_IsVersionDeleted, '0') = '0' WHERE subDOC_F_ID = lbl.lblF_ObjectID AND subDOC_F_Version = lbl.lblF_ObjectVersion AND subDOC_PackageID = lbl.lblF_PackageID) > 1 order by P_Name, lbl_Name desc;"
  },
  "doc/maintenance/msgboxshow-cleanup.html": {
    "href": "doc/maintenance/msgboxshow-cleanup.html",
    "title": "MsgBox.Show() Cleanup",
    "keywords": "MsgBox.Show() Cleanup MsgBox.Show() Cleanup ist eine Maintenance-Routine, die die obsoleten Methodenaufrufe MsgBox.Show(...) durch throw MsgBoxException(...) ersetzt. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit sie verfügbar ist. Die Routine kann in der IDE über das Menü Update / FS 4.7 / (2) MsgBox.Show() Cleanup aufgerufen werden. Mit dem Button Analyze wird eine Analyse ohne Änderungen gestartet. Die Resultate werden in der Error-Liste ausgegeben. Der Button CleanUp führt die Änderungen aus. Dazu werden die betroffenen Forms ausgecheckt, geändert und gespeichert. Beim anschließenden Compile kann es zu etlichen \"unreachable Code\" Warnings kommen. Hinter dem MessageBox-Aufruf musste früher ggf. Code geschrieben werden, damit der C#-Compiler keinen Fehler produziert. Dieser Code wurde allerdings niemals ausgeführt. protected int GetValue() { if (this.value == 0) { // FSCodeMessage: Test MsgBox.Show(MLUtil.GetMLKeyText(MLKeys.LBL_Test), \"\", MsgBoxButtons.OK, MsgBoxIcons.None, null); return 0; // <== wird niemals ausgeführt } else { return this.value; } } Nach der Umstellung auf throw... wird diese Code-Zeile korrekt als unerreichbar erkannt und vom C#-Compiler eine Warning generiert. Diese Stellen können entsprechend nachgearbeitet werden. // FSCodeMessage: Test throw MsgBox.Exception(MLUtil.GetMLKeyText(MLKeys.LBL_Test), \"\", MsgBoxButtons.OK, MsgBoxIcons.None, null); return 0; // <== unreachable Code Nach erfolgreichen Compile müssen die Forms eingecheckt werden. Beschreibung Wird in der Broker-Application wie bisher eine MessageBox ausgegeben, dann mündet der heute verwendete Aufruf MsgBox.Show(...) in einer Exception. // FSCodeMessage: Test MsgBox.Show(MLUtil.GetMLKeyText(MLKeys.LBL_Test), \"\", MsgBoxButtons.OK, MsgBoxIcons.None, null); Dies hat folgende Nachteile: Der Aufruf dieser Methode verschleiert die Exception. Es gibt keine \"Unreachable code detected\"-Warning, wenn nach diesem Aufruf weiterer Code vorhanden ist. Bei Methoden, die einen Return-Wert haben, muss ein Fake-Return programmiert werden. Mit Framework Studio 4.7 wurde dieser Mechanismus deshalb optimiert. Der durch den MessageBox-Wizard generierte Code sieht nun wie folgt aus: // FSCodeMessage: Test throw MsgBox.Exception(MLUtil.GetMLKeyText(MLKeys.LBL_Test), \"\", MsgBoxButtons.OK, MsgBoxIcons.None, null); MsgBox.Show() wird weiterhin uneingeschränkt funktionieren, falls Sie den Code nicht konvertieren."
  },
  "doc/maintenance/namespace-cleanup.html": {
    "href": "doc/maintenance/namespace-cleanup.html",
    "title": "Namespace CleanUp",
    "keywords": "Namespace CleanUp Namespace CleanUp ist eine Maintenance-Routine, die Namespace-Referenzen und Code auf die neuen Namespaces umstellt. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit sie verfügbar ist. Die Routine kann in der IDE über das Menü Update / FS 4.7 / (1) Namespace CleanUp aufgerufen werden. Durch die Umstrukturierung der Framework-Studio-Assemblies zur Version 4.7 haben sich praktisch alle FrameworkStudio-Namespaces geändert. Geänderte Namespaces Die Routine ersetzt die Namespaces in Methoden-Codes. Die Routine entfernt Namespace-Referenzen, die auf diese Namespaces zeigen. So gut wie alle diese Referenzen sind praktisch unnötig, weil Framework Studio bereits entsprechende Standard-Referenzen verwendet. Im Einzelfall kann es daher vorkommen, dass eine Referenz wieder neu angelegt werden muss. Die folgende Tabelle gibt eine grobe Übersicht, welche Namespaces sich geändert haben. Im Detail kann es davon aber auch einige Abweichungen geben und einzelne Klassen sind in andere Namespaces gewandert. Alter Namespace Neuer Namespace FrameworkSystems.FrameworkExceptions FS.Shared FrameworkSystems.FrameworkDataClient FrameworkSystems.FrameworkDataProvider FS.DataClient FrameworkSystems.FrameworkBase FrameworkSystems.FrameworkStudio.Base FS.Hosting.Shared FrameworkSystems.FrameworkBroker FS.Hosting.Broker FrameworkSystems.FrameworkControls FrameworkSystems.FrameworkStudio.DevFormBase FS.Hosting.Broker.Shared Ersatz für Windows-Forms-Enums Bisher wurden für MessageBoxen einige Enums aus dem Namespace System.Windows.Forms verwendet. Diese kommen im Bereich FS.Hosting nicht mehr zum Einsatz und werden von der Routine durch neue, eigene Enums ersetzt. Altes Enum Neues Enum DialogResult FSDialogResult MessageBoxButtons MsgBoxButtons MessageBoxIcon MsgBoxIcons"
  },
  "doc/maintenance/references-cleanup.html": {
    "href": "doc/maintenance/references-cleanup.html",
    "title": "References Cleanup",
    "keywords": "References Cleanup References Cleanup ist eine Maintenance-Routine, die ungültige Namespace-Referenzen bereinigt oder korrigiert. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit Sie verfügbar ist. Sie kann in der IDE über das Menü Tools / Checks / References Cleanup aufgerufen werden. Checkbox Invalid external references Diese Routine sucht und entfernt Referenzen auf externe Assemblies die nicht (mehr) existieren. Checkbox External $GAC references Stellt Referenzen von $GAC auf $DotNetDirectory um, wenn das möglich ist. Framework Studio bringt sein eigenes Set an .net Framework Assemblies mit, die beim Compile referenziert werden. Das stellt sicher, dass das kompilierte Programm auch auf anderen Rechnern ausgeführt werden kann, auch wenn dort eine etwas andere Version des .net Frameworks installiert ist. Referenzen auf .net Framework Assemblies werden deshalb mit einem eigenen Präfix $DotNetDirectory gekennzeichnet - z.B. $DotNetDirectory\\System.Drawing.dll. Gleichzeitig sind diese Assemblies auch über den Global Assembly Cache verfügbar. Referenzen auf den Global Assembly Cache werden mit dem Präfix $GAC gekennzeichnet - z.B. $GAC\\System.Drawing, Version=4.0.0.0. Mit dem Button Analyze wird eine Analyse gestartet ohne, dass Änderungen durchgeführt werden. Die Resultate werden in der Error-Liste ausgegeben. Der Button CleanUp führt die Änderungen aus. Dazu werden die betroffenen Namespaces ausgecheckt, die Referenzen geändert und gespeichert. Nach erfolgreichen Compile müssen die Namespaces wieder eingecheckt werden."
  },
  "doc/maintenance/remove-global-cleanup.html": {
    "href": "doc/maintenance/remove-global-cleanup.html",
    "title": "Remove Global Cleanup",
    "keywords": "Remove Global Cleanup Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit sie verfügbar ist. Die Routine kann in der IDE über das Menü Update / FS 4.7 / (3) Remove Global Cleanup aufgerufen werden. Änderungen: In den Konstruktoren und Factory.Create()-Methoden vom Components wird kein Global mehr übergeben. - cdCustomer oCustomer = new cdCustomer(this.Global); + cdCustomer oCustomer = new cdCustomer(); - IcdArticle oArticle = cdArticleFactory.Create(this.Global); + IcdArticle oArticle = cdArticleFactory.Create(); StaticCache.Get()-Methode wird kein Global mehr übergeben. - return cdArticleGroupCache.Get(this.Global).FillObject(This,sArticleGroupIDP); + return cdArticleGroupCache.Get().FillObject(This,sArticleGroupIDP); Von Framework Studio erzeugte Service-Proxies erwarten im Konstruktor kein Global mehr - MISRemoteServiceProxy proxy = new MISRemoteServiceProxy(this.Global, \"*\", sUrlP); + MISRemoteServiceProxy proxy = new MISRemoteServiceProxy(\"*\", sUrlP); TextCollFactory-Methoden erwarten kein Global mehr - FSstring sLogLevel = ctLogLevelFactory.GetText(this.Global, this.shtLevel); + FSstring sLogLevel = ctLogLevelFactory.GetText(this.shtLevel); Die Methoden GetMLText(), FormatMLText(), GetMLKeyText() und FormatMLKeyText() sind vom Global in die Klasse MLUtil gewandert - throw new FrameworkApplicationException(this.Global.GetMLText(MLKeys.MSG_93a1ea2873804fcbb771d2b2a5305f85), 0); + throw new FrameworkApplicationException(MLUtil.GetMLText(MLKeys.MSG_93a1ea2873804fcbb771d2b2a5305f85), 0); - this.Global.FormatMLKeyText(MLKeys.MSG_ddb19cf4d65b4b98a178855bdbcb9112, oOfflineScannerParameterP.sIP, sTunnelString)) + MLUtil.FormatMLKeyText(MLKeys.MSG_ddb19cf4d65b4b98a178855bdbcb9112, oOfflineScannerParameterP.sIP, sTunnelString))"
  },
  "doc/maintenance/textcollection-mlkey-replace.html": {
    "href": "doc/maintenance/textcollection-mlkey-replace.html",
    "title": "Replace TextCollection with MLKeys",
    "keywords": "Replace TextCollection with MLKeys Replace TextCollection with MLKeys ist eine Maintenance-Routine, die im Methoden-Code TextCollection-Aufrufe durch MLKeys ersetzt. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit Sie verfügbar ist. Sie kann in der IDE über das Menü Tools / Checks / Replace TextCollection with MLKeys aufgerufen werden. Im Feld TextCollection muss eine Text-Collection angegeben werden. Mit dem Button Analyze wird eine Analyse gestartet ohne, dass Änderungen durchgeführt werden. Die Resultate werden in der Error-Liste ausgegeben. Der Button Replace führt die Änderungen aus. Dazu werden die betroffenen Elemente ausgecheckt, geändert und gespeichert. Nach erfolgreichen Compile müssen die Elemente wieder eingecheckt werden. Beschreibung Bei der Einführung der MLKeys mit der Version 4.2 wurden bei Code-Messages die Aufrufe der Text-Collections mithilfe einer Routine durch MLKeys ersetzt. Nicht ersetzt wurden freie Verwendungen von Text-Collections außerhalb der Code-Messages. Neue Meldungen werden als MLKey im Wörterbuch angelegt und in den Message-Text-Collections (z.B. ctMessages) werden keine neuen Einträge mehr hinzugefügt. Damit werden diese Text-Collection immer mehr obsolet und können irgendwann vielleicht sogar komplett abgeräumt werden. Dafür muss aber sichergestellt werden, dass es keine Aufrufe mehr gibt. Das betrifft aber nur wenige Text-Collections, die als Sammlung z.B. für Meldungstexte verwendet werden. Die überwiegende Anzahl an Text-Collections, hat auch weiterhin eine Daseinsberechtigung - z.B. weil sie für Combobox-Listen verwendet werden oder Constant-Werte abbilden. Die Routine muss deshalb für die betroffenen Text-Collections explizit ausgeführt werden. Durchsucht werden alle Elemente mit Methoden-Code: Components - Methods und Property Get-/Set-Methods Forms - Methods DataContracts - Property Get-/Set-Methods Services - Methods Service-Hosts - Methods Service-Proxies - Methods Code-Transformations Im ersten Schritt wird nach der Verwendung der Text-Collection im Code gesucht - also z.B. nach ctMessagesFactory. Im zweiten Schritt wird versucht, diese Verwendung durch einen MLKey zu ersetzen. Gelingt das nicht, wird die betreffende Stelle als Warnung ausgegeben. Folgende Verwendungen werden erkannt: Namespace.ctMessagesFactory.GetText(this.Global, 5282) Namespace.ctMessagesFactory.GetText(this.Global, 5282, \"\") Namespace.ctMessagesFactory.GetText(this.Global, 5282, FSstring.Null) Namespace.ctMessagesFactory.Get(this.Global, 5282).Text Namespace.ctMessagesFactory.Get(this.Global, 5282).Value[this.Global.SelectedLanguage] Diese Aufrufe werden ersetzt durch: MLUtil.GetMLText(MLKey.MSG_b4699cd744c94d439b06a9c68f29eaf7) Der Ausdruck darf keinen Zeilen-Umbruch beinhalten. In diesem Fall schlägt die Stelle als Warnung auf. Nach manueller Korrektur der Stelle kann erneut Analyze / Replace aufgerufen werden."
  },
  "doc/mdt/format-pattern.html": {
    "href": "doc/mdt/format-pattern.html",
    "title": "Format-Pattern im Metadatentyp",
    "keywords": "Format-Pattern im Metadatentyp Je nachdem, welcher Datentyp ausgewählt wurde, ändern sich die Einstellungen für das Format-Pattern. Format Pattern für Zeichenketten Bei Zeichenketten können im Format reguläre Ausdrücke eingegeben werden. Die Zeichenketten müssen dann dem definierten regulären Ausdruck entsprechen. Im Java-Client wird bereits bei der Eingabe überprüft, ob die Zeichenkette dem Ausdruck genügt. Format-Pattern für Zahlen Bei Zahlen können gewöhnliche Zahlenformate eingegeben werden. Neben dem Feld Format-Pattern wird eine Beispiel-Zahl für das eingegebene Format dargestellt. Warning Es ist aber zu beachten, dass als Tausender-Trennzeichen das Komma und als Dezimal-Trennzeichen der Punkt dient. Gültige Formate wären z.B. #,##0.00 ergibt 1.234,56 0.00 ergibt 1.234,56 #,##0.00 ’EUR’ ergibt 1.234,56 EUR Format-Pattern für Datum Bei Datum können gewöhnliche Datum-Formate eingegeben werden. Neben dem Feld Format-Pattern wird als Beispiel das aktuelle Systemdatum entsprechend formatiert dargestellt. Der Button Default Values setzt die Werte auf die vom Framework Studio vorgegebenen Standardwerte zurück."
  },
  "doc/mdt/metadatentypen.html": {
    "href": "doc/mdt/metadatentypen.html",
    "title": "Metadatentypen",
    "keywords": "Metadatentypen Die Idee der Metadatentypen kommt daher, dass bestimmte Felder innerhalb einer Anwendung immer wieder auftauchen (z.B. Artikelnummer, Kundennummer, ...). Deshalb können solche Felder an einer zentralen Stelle definiert werden, was Fehler in der Felddefinition verhindert und Redundanzen minimiert. Dabei werden Informationen wie das Label, das Datenformat, das zugehörige Control, die mehrsprachige Bezeichnung usw. hinterlegt, so dass sich der Arbeitsaufwand bei der späteren Arbeit mit dem Metadatentypen minimiert. Sie erkennen Metadatentypen an einem - Icon vor der Bezeichnung. Metadatentypen bearbeiten Um einen Metadatatypen zu bearbeiten, doppelklicken Sie den entsprechenden Eintrag auf der Registerkarte Namespaces. Der Metadatentyp wird im Hauptfenster des Framework Designers angezeigt. Der Metadatentyp kann in verschiedenen Teilen der Anwendung zum Einsatz kommen: Er kann auf unterster Ebene der Spalte einer DBTable zugeordnet werden. Er kann in Components oder Forms als Datentyp für Properties verwendet werden. Deshalb nehmen Sie an einem Metadatentyp verschiedene Einstellungen vor: Name: Geben Sie die Bezeichnung des Metadatentyps an. Datatype Database: Benennen Sie den Datentyp der Spalte in der Datenbank. Datatype Application: Gibt den FS-Datentyp des Metadatentyps an. Dieser Datentyp wird später in den Components und Forms gezogen. Die folgende Tabelle zeigt, welche Database-Datentypen mit welchem Application-Datatype kombiniert werden können: FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring Binary X Boolean X Byte X Date X DateTime X Time X Double X Currency X X X Single X X X Decimal X X Big Int X Integer X X Smallint X X X Tiny Int X X X Ansi String X Long Varchar X String X null X X X X X X X X X X X Warning Wenn Sie die Datentypen nachträglich ändern, kann das evtl. Auswirkungen auf Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren. Die Einstellungen für Size, Precision und Scale hängen von der Auswahl des Datatype Database ab. Je nachdem, ob der Datenbank-Datentyp Zeichen, Ganzzahlen oder Gleitkommazahlen unterstützt, sind die Felder für Eingaben zugänglich. Size: Definiert die Feldlänge bei Zeichenfeldern. Precision: Anzahl der Stellen inkl. eventueller Nachkommastellen bei numerischen Feldern. Scale: Anzahl der Nachkommastellen bei Dezimal-Feldern. Format: Gibt das Anzeige-Format des Felds an. Das Format wirkt sich in der Darstellung des Felds auf einem Form aus. Format Pattern: Wird im Feld Format User Defined gewählt, ist es möglich hier selbst ein Format anzugeben. Es können Formate für Zahlen, Daten und Zeichenketten entsprechend der Standard-Definition für reguläre Ausdrücke eingegeben werden. Siehe auch Format-Pattern Besonerheiten Oracle/SQL bei Boolean DB-Datentyp Der Database-Datentyp Boolean wird in SQL und Oracle mit dem Typ Char(1) abgebildet. Wird ein Boolean-MDT beispielsweise in einem COALESCE-Statement verwendet, muss auf den Unterschied zwischen SQL und Oracle geachtet werden. SQL akzeptiert sowohl COALESCE([propName],'0') = '0' als auch COALESCE([propName],0) = '0'. Oracle hingegen akzeptiert nur COALESCE([propName],'0') = '0', also die String-Schreibweise mit Hochkomma. Note Um SQL und Oracle zu unterstützen muss daher folgende Schreibweise verwendet werden: COALESCE([propName],'0') = '0'. Bei der Verwendung des Metadatatyps CheckboxBoolean, welcher Boolean als Database-Datentyp hat, sollte darauf geachtet werden! Registerkarte Description Hier kann eine Beschreibung des Metadatentyps eingegeben werden. Registerkarte Values Für einen Metadatentypen kann definiert werden, welche Werte er annehmen darf. Wird hier nichts angegeben, sind alle Werte möglich, die der entsprechend hinterlegte Datentyp zulässt. Es können mehrere Werte oder Wertebereiche angegeben werden. From: Gibt die untere Grenze eines Wertebereichs an. Warning Ist nur dieses Feld gefüllt (und To nicht), wird dies als Wert und nicht als Wertebereich angesehen. To: Gibt die obere Grenze eines Wertebereichs an. Button Add New Range: Mit dem Button Add New Range kann ein neuer Bereich hinzugefügt werden. Button Remove Range: Mit dem Button Remove Range kann ein Bereich gelöscht werden. Registerkarte Default Label Einem Metadatentypen kann ein Label zugewiesen werden. Dieses Label wird im Form links neben dem Control des Metadatentyps angezeigt. Das Label kann mehrsprachig hinterlegt werden. Tip Es ist möglich, dieses Label in den Components und im Form zu überschreiben. Registerkarte Control Types Die Registerkarte ControlTypes zeigt an, welche Controls später im Form zur Verfügung stehen sollen. Es ist möglich, einem Metadatentypen mehrere Controls zuzuordnen. Es kann aber maximal ein Control als Default gekennzeichnet sein. Das als Default gekennzeichnete Control wird zunächst angezeigt, wenn ein Property (welches diesen Metadatentypen verwendet) in ein Form gezogen wird. Das Default-Control kann dann auf weitere, hier hinterlegte Controls geändert werden. Diese Liste von Controls kann auch im DBTable oder in der einer Component ergänzt werden. Ist kein Control als Standard-Control hinterlegt, wird ein Editfeld angenommen. Mit dem Button Add wird ein neuer Control-Type hinzugefügt. Es öffnet sich das Fenster Assign Controls. In diesem Fenster sind alle Controls aufgelistet, einschließlich der Controls, die Sie in den Control Default Styles definieren können (siehe Kapitel Control Default Styles). Wählen Sie hier ein Control aus und setzen Sie ggf. die Checkbox is Default. Mit dem Button OK wird das Control der Liste hinzugefügt. Mit dem Button Change können Sie das Control ändern. Es öffnet sich wieder wie bei Add das Fenster Assign Controls. Sie können hier ein anderes Control auswählen und dann mit OK bestätigen. Mit dem Button Delete wird das markierte Control gelöscht."
  },
  "doc/mdt/validierung.html": {
    "href": "doc/mdt/validierung.html",
    "title": "Metadatentyp-Validierung",
    "keywords": "Metadatentyp-Validierung Die Einstellungen, die am Metadatentyp zu sehen sind (z.B. Größe, Formatierung, Wertebereich, …), werden bei der Arbeit mit Properties herangezogen, um die Werte zu validieren und ggf. zu korrigieren. Auch der Client nutzt diese Informationen, um falsche Eingaben so früh wie möglich zu unterbinden. Die Zusammenhänge werden durch folgendes Schaubild erläutert: Die folgende Tabelle stellt dar, was passiert, wenn mit einem Wert gearbeitet wird, der denen am Metadatentyp definierten Kriterien nicht entspricht. Einstellung Lesen von Properties aus der Datenbank, die falsche Werte beinhalten Setzen von Properties Client Allgemein Values Value Ranges Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Strings Size Bei zu langen Strings wird auf dieser auf die Size gekürzt. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Uppercase, Lowercase Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Die Eingabe lässt nur Groß- bzw. Kleinbuchstaben zu. Format-Pattern (Regulärer Ausdruck) Es wird FSstring.Null zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Es wird zuvor noch versucht, den String mit Uppercase oder Lowercase zu korrigieren, wenn der reguläre Ausdruck selber Uppercase bzw. Lowercase ist. Wenn das funktioniert, dann wird der Wert in Uppercase bzw. Lowercase konvertiert. Numerische Werte Precision Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Scale (bei Dezimal-Zahlen) Der Wert wird „kaufmännisch“ gerundet. Der Wert wird „kaufmännisch“ gerundet. Die Eingabe wird begrenzt. Positive Integer, Negative Integer (bei Ganzzahlen) Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Das Minus-Zeichen wird bei der Eingabe unterdrückt bzw. automatisch hinzugefügt. Der Java-Client gibt bei der Eingabe eines falschen Wertes die folgenden Fehlermeldungen aus: Wenn das Format-Pattern (der reguläre Ausdruck) verletzt wird: Wenn ein Wertebereich verletzt wird:"
  },
  "doc/mdt/vererbung.html": {
    "href": "doc/mdt/vererbung.html",
    "title": "Vererbung von Metadatentypen",
    "keywords": "Vererbung von Metadatentypen Es ist möglich, Metadatentypen zu vererben. Das macht dann Sinn, wenn Metadatentypen aufeinander aufbauen und z.B. ein gemeinsames Format-Pattern verwenden. Sie können so in einem Basis-Metadatentyp mit allen Datentypen Controls und einem Default-Label definieren. Anschließend brauchen Sie diesen nur abzuleiten und die Ableitung hat die gleichen Eigenschaften wie die Basis. Dann können Sie noch z.B. das Label oder den Wertebereich ändern. In der Ableitung werden die nachträglich geänderten Werte fettgedruckt dargestellt. Eine Ableitung können Sie auf zwei Wegen erstellen: Einen Metadatentypen ableiten, indem Sie den Metadatentyp im Overview auswählen, den Button (Derive) drücken und in der Namespace-Auswahl angeben, in welchem Namespace die Ableitung angelegt werden soll. Einem vorhandenen Metadatentypen im Feld Base eine Basis (oder auch eine andere Basis) zuweisen. Warning Wird beim Ändern der Basis auch der Datentyp geändert, kann das evtl. Auswirkungen auf die Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren."
  },
  "doc/mlkey/enventa-regeln.html": {
    "href": "doc/mlkey/enventa-regeln.html",
    "title": "eNVenta Regeln für MLKeys",
    "keywords": "eNVenta Regeln für MLKeys Allgemeine Regeln Texte aus den Test-Namespaces: Diese sollen nicht ins Wörterbuch aufgenommen werden. Unübersetzbare Texte: Texte, die nicht übersetzt werden können wie z.B. Eigennamen, müssen mit dem Kommentar untranslatable versehen werden. Sind weitere Hinweise im Kommentar nötig, beginnt der Kommentar mit untranslatable gefolgt von einem Zeilenumbruch. Der Text soll in diesem Fall nur in der deutschen Sprache angegeben werden. Abkürzungen im Namen eines MLKeys: Werden im Namen eines MLKeys bewusst Großbuchstaben als Abkürzungen für Teilworte verwendet, weil z.B. der Name sonst zu lang würde, so muss die Abkürzung nach folgendem Schema im Comment erläutert werden: {Abkürzung1} = {Begriff1}, {Abkürzung2} = {Begriff2} Beispiele: LBL_CCServicePort: Comment = CC = Cross Company LBL_CCNameDebit: Comment = CC = Cost Center Bezeichnung von MLKeys Normalfall Begriffe: LBL_{englische Bezeichnung} Beispiel: LBL_Search Sätze: MSG_{GUID} Beispiel: MSG_f39ceca46b3341ee8b9862d34cfd06b6 Einheiten LBL_{englische Bezeichnung}_Unit Beispiel: LBL _mm_Unit Zeichen LBL_{englische Bezeichnung}_Sign Beispiel: LBL_Plus_Sign für den Text „+“ Ziffern LBL_{englische Bezeichnung}_Digit oder LBL_{englische Bezeichnung}_Digits (Plural) Beispiele: LBL_Nine_Digit für den Text „9“, LBL_EightOClock_Digits für den Text „08:00“ Prozentzeichen LBL_{englischer Prefix}Percent (kein Unterstrich) Beispiel: LBL_DiscountPercent (de = „Skonto %“, en = „Discount %“) Abkürzungen / Ausgeschriebene Texte Wenn für einen englischen Begriff im deutschen am häufigsten eine abgekürzte Schreibweise verwendet wird, so wird der MLKey für den Text mit Abkürzung normal mit LBL_{englische Bezeichnung} benannt. Wird parallel dazu auch der im deutschen (oder anderen Fremdsprachen) ausgeschriebene Text benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Full benannt. Wird zu einem Begriff, zu dem es schon eine ausgeschriebene Schreibweise gibt eine Abkürzung benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Abbrev bezeichnet. Beispiele: LBL_ClerkScanner (de = „SB-Scanner“), LBL_ClerkScanner_Full (de = „Sachbearbeiter Scanner“) LBL_Reminder (de = „Wiedervorlage“), LBL_Reminder_Abbrev (de = „Wiedervorl.“) Spezialfall: Ein Buchstabe als Abkürzung LBL_{englische Bezeichnung}_Char Beispiele: LBL_Order_Char (de = „B“, en= „O“) LBL_Container_Char (de = „B“, en = „C“) Beschriftung von Mini-Buttons LBL_{englische Bezeichnung}_Mini Wird ein MiniButton (Control Style = MiniEmpty) auf einer Maske mit einer Caption von 1 bis 2 Buchstaben versehen (die typischerweise eine Abkürzung darstellen), so wird der MLKey dazu mit der eigentlichen Bezeichnung, ergänzt um _Mini beschriftet. Dabei ist darauf zu achten, dass die Beschriftungen pro Sprache eindeutig sind. Beispiele: LBL_Customer_Mini (de = „K“, en = „Cu“) LBL_CrossOver_Mini (de = „C“, en = „Cr“) Zwei unterschiedliche deutsche Begriffe, die im Englischen gleich heißen Wenn zwei unterschiedliche Begriffe im englischen durch den gleichen Text beschrieben werden, so werden die Bezeichnungen der MLKeys durch Anhängen eines Zählers beginnend mit 1 im Format _{Zähler} unterschieden. Beispiel: de = „Herkunft“, en = „Source“ => MLKey = LBL_Source de = „Quelle“, en = „Source“ => MLKey = LBL_Source_1 Tooltips Wenn ein Tooltip eindeutig einem einfachen Begriff zugeordnet werden kann, so wird der MLKey mit TTT_{englische Bezeichnung} benannt. Andernfalls wird das Format TTT_{GUID} verwendet. Beispiele: TTT_Fatal (de = „Fatale Einträge anzeigen“) `TTT_584b58008ed04cd2b40b78b70e52402c' (de = „Wert für die Kreditorenvorerfassung-Pufferzeit definieren.“) Note Wenn man einen Tooltip verwenden möchte, zu dem es bereits einen exakt passenden LBL_ Eintrag gibt, so soll dazu kein TTT_ Eintrag angelegt werden! Diese Einträge wären sonst ja logisch äquivalent. Kleingeschriebene Begriffe Sollte man ein Text (z.B. wegen einer Verwendung in einer Textcollection) berechtigterweise klein geschrieben sein und es soll trotzdem ein sprechender Key generiert werden, so ist dieser ebenfalls klein zu schreiben. Beispiel: de = „eins“, en = „one“ => MLKey = LBL_one Texte Alle Texte in allen Sprachen beginnen mit einem großen Buchstaben. Ausnahmen: Abgekürzte Einheiten (z.B. mm) Einträge in Textcollections, soweit diese zwingend alle klein geschrieben werden müssen. Vor Satzzeichen werden keine Leerzeichen verwendet. Ganze Sätze werden mit einem Satzzeichen beendet. Im Englischen werden bei Texten mit bis ca. 4 Worte (Beschriftungen von Eingabefeldern, Menüs, Buttons usw.) alle Worte bis auf Füllwörter wie of, to, in, ... groß geschrieben."
  },
  "doc/mlkey/import-export.html": {
    "href": "doc/mlkey/import-export.html",
    "title": "MLKey Import / Export",
    "keywords": "MLKey Import / Export"
  },
  "doc/mlkey/mlkey-cleanup.html": {
    "href": "doc/mlkey/mlkey-cleanup.html",
    "title": "MLKeys Cleanup",
    "keywords": "MLKeys Cleanup MLKeys-Cleanup ist eine Wartungs-Routine, die Bereinigungen im Wörterbuch durchführt. Sie kann in der IDE über das Menu Tools / Checks / MLKeys Cleanup aufgerufen werden. Checkbox Reset identical overrides Es werden Texte gesucht, die im aktuellen Package denselben Inhalt haben wie im Basis-Package. Die Bereinigung entfernt diese Überschreibungen. Checkbox Find untranslatable (1) Es werden MLKeys gesucht, an denen die Texte in allen gepflegten Sprachen identisch sind. Es wird vorgeschlagen diese auf untranslatable zu setzen. Dazu kann der Button Untranslatable verwendet werden. Die Treffer werden als Information ausgegeben. (2) Es werden MLKeys gesucht, die als untranslatable gekennzeichnet sind, aber in Fremdsprachen einen Text besitzen. Die Treffer werden als Warnung ausgegeben. Note Es findet keine Bereinigung der Treffer statt. Dies muss bei Bedarf manuell erfolgen. Checkbox Find unused MLKeys Es werden MLKeys angezeigt, die nicht verwendet werden. Es wird dazu der komplette generierte Code nach Verwendungen von MLKeys durchsucht. Dieser Vorgang kann einige Zeit dauern, er kann aber bei Bedarf abgebrochen werden. Note Es findet keine Bereinigung der Treffer statt. Dies muss bei Bedarf manuell erfolgen. Checkbox Find missing MLKeys Es wird nach MLKeys im Code gesucht, die im Wörterbuch nicht existieren. Es wird dazu der komplette generierte Code nach Verwendungen von MLKeys durchsucht. Dieser Vorgang kann einige Zeit dauern, er kann aber bei Bedarf abgebrochen werden. Versehentlich gelöschte MLKeys können über die History wiederhergestellt werden. Button Analyze Dieser Button führt für die ausgewählten Operationen lediglich eine Analyse durch. Die gefundenen Treffer werden im Error-Fenster ausgegeben. Button Cleanup Nach einer Sichtung der mit dem Button Analyze gefundenen Treffer, kann mit diesem Button die Bereinigung ausgeführt werden."
  },
  "doc/mlkey/mlstring.html": {
    "href": "doc/mlkey/mlstring.html",
    "title": "MLString",
    "keywords": "MLString Framework Studio bietet eine durchgängige Unterstützung für die Mehrsprachigkeit. An allen Stellen, an denen für den Anwender sichtbare Beschriftungen, Tooltips oder Meldungstexte gepflegt werden bietet Framework Studio einen Editor zur Bearbeitung von mehrsprachigen Texten (Multi Language String / MLString) an. Der Editor wird in Form einer Tabelle angezeigt, in der die Verschiedenen Sprachen des Textes angezeigt und bei Bedarf auch bearbeitet werden. Die fett gedruckten Angaben sind an dieser Stelle überschrieben. Die normal gedruckten Angaben sind aus dem Basis-Package oder dem Basis-Record geerbt. Siehe auch Abschnitt Vererbung. An erster Stelle steht immer der MLKey. Dieser stellt einen Verweis auf das Wörterbuch dar. Es kann direkt ein MLKey eingeben werden oder mit dem Auswahl-Button ein Such-Dialog geöffnet werden. Dabei handelt es sich um den voll funktionsfähigen Multilanguage Text Editor erweitert um eine Auswahl-Funktion. In diesem Dialog können, wenn kein passender MLKey gefunden wurde, auch ein neuer Key erfasst werden. Die Texte in den einzelnen Sprachen werden im Designer und auch zur Laufzeit der Anwendung aus dem Wörterbuch ermittelt. Die angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Important Ist ein MLKey angegeben, dann ist es davon abzuraten, einzelne Texte zu überschreiben. Im Property-Grid wird der MLString in einer Zeile dargestellt, die zur Anzeige der einzelnen Sprachen erweitert werden kann. Die einzeilige Anzeige stellt einen kombinierten Text in Format @{MLKey} - {deutscher Text} dar. In diesem Text man auch direkt mit vorangestellten @-Zeichen einen anderen MLKey eintragen - z.B. @LBL_ArticleID. Ein MLKey kann auch (wie oben beschrieben) am entsprechenden MLKey-Eintrag eingetragen oder ausgewählt werden. Vererbung Mit den verschiedenen Records in Framework Studio werden auch die entsprechenden MLStrings vererbt. Dadurch werden im Idealfall die am Metadatentyp definierten Texte über die komplette Kette bis hin zu den Form-Controls durchgereicht. Ein vererbter Text kann an jeder beliebigen Stelle in der Kette überschrieben werden. Es gibt 2 Möglichkeiten: Einen anderen MLKey zuweisen Damit werden alle anderen Texte aus der Basis inkl. MLKeys und den überschriebenen Texten ausgeblendet. Auch wenn der neue MLKey z.B. keinen Text für fr definiert hat, wird ein in der Basis definierter fr Text ausgeblendet. Einen einzelnen Text überschreiben: Warning Darauf sollte möglichst verzichtet werden. Wenn lediglich die Übersetzung gepflegt wird, dann erfolgt dies besser im Wörterbuch. Wenn eine abweichende Bedeutung gewünscht ist, dann sollte ein anderer MLKey angegeben werden. Das überschreibt nur den Text der entsprechenden Sprache. Die anderen nicht überschriebenen Sprachen werden weiter aus der Basis gezogen. Caution In der eNVenta/WS Standard-Entwicklung ist das verboten. Das folgende Bild zeigt eine Vererbungs-Hierarchie. Die Pfeile stellen den Weg dar, über den der Text für das Control ermittelt wird. Dabei wird hier die Sprache fr mit den Fallback-Sprachen en und de verwendet. Der erste Text der auf diesem Weg gefunden wird, wird ausgegeben."
  },
  "doc/mlkey/programmierung.html": {
    "href": "doc/mlkey/programmierung.html",
    "title": "Programmierung mit MLKeys",
    "keywords": "Programmierung mit MLKeys Klasse MLKeys Framework Studio generiert aus dem Wörtebuch eine Klasse MLKeys, die alle MLKeys beinhaltet. Sie wird im Compile-Schritt Ressource compiliert und steht somit in der kompletten Applikation zur Verfügung. Sie erbt die MLKeys aus dem Basis-Package - so z.B. auch die SYS_-Keys aus dem System-Package. Die Klasse wird z.B. folgendermaßen verwendet: MLUtil.GetMLText(MLKeys.LBL_Amount); Alle Quellcodes, die mit MLKeys arbeiten, greifen auf diese Klasse zu - sowohl selbst geschriebener Methoden-Code als auch der von Framework Studio generierte Code. Dadurch findet der CSharp-Compiler alle Probleme, die im Zusammenhang mit MLKeys auftreten können: Compile-Error, wenn ein MLKey nicht mehr existiert. Auch wenn diese z.B. in einem Metadatentypen oder einem Form-Control verwendet werden. Eine Obsolete-Warning, wenn ein mit einer Obsolete-Message versehener MLKey verwendet wird. Die Obsolete-Message wird als Obsolete-Attribut vor den MLKey generiert. Eine Warning, wenn in einem Customizing-Package ein identischer MLKey definiert ist. Die generierte MLKeys-Klasse sieht in etwa so aus: public class MLKeys : BasisPackage_MLKeys { public static readonly MLKey LBL_Amount = new MLKey(\"LBL_Amount\"); public static readonly MLKey LBL_Article = new MLKey(\"LBL_Article\"); public static readonly MLKey TTT_Article = new MLKey(\"TTT_Article\"); public static readonly MLKey MSG_0da9815a719049ae806d3c0ba7d824ff = new MLKey(\"MSG_0da9815a719049ae806d3c0ba7d824ff\"); public static readonly MLKey MSG_0f2ad9d4385b49fc9667ed7eff2d925f = new MLKey(\"MSG_0f2ad9d4385b49fc9667ed7eff2d925f\"); [Obsolete(\"Please use LBL_Amount\")] public static readonly MLKey LBL_Amount2 = new MLKey(\"LBL_Amount2\"); } Warning Es sollten keine eigenen MLKey-Instanzen aus Strings erzeugt werden. Diese können vom Compiler nicht validiert werden. Code Editor Der Code-Editor bietet diverse Unterstützung bei der Arbeit mit der Klasse MLKeys. Im Intellisense werden alle MLKeys angeboten und im jeweiligen Tooltip wird zur besseren Orientierung der deutsche Text angezeigt. Fährt man mit der Maus über einen MLKey, dann wird ein Info-Tooltip mit dem deutschen Text angezeigt. Wird auf einem MLKey der Befehl Go To Definition ausgeführt, dann öffnet sich der Multilanguage Text Editor und es wird der entsprechende Eintrag selektiert. Methoden an der MLUtil Klasse Die MLUtil Klasse bietet mehrere Methoden an, mit denen ein MLKey in ein Text überführt werden kann. GetMLText(mlkey) GetMLText(mlkey, iso) GetMLKeyText(mlkey) FormatMLText(mlkey, args) FormatMLKeyText(mlkey, args) Für die Format-Funktionen wird die Client-Culture verwendet. Für die Verwendung einer spezifischen Culture gibt es entsprechende Überladungen: FormatMLText(culture, mlkey, args) FormatMLKeyText(culture, mlkey, args) cGlobal EntryPoint In der Klasse cGlobal gibt es einen zentralen Entry-Point GlobalGetMLText. Dieser wird JEDES MAL aufgerufen, wenn aus einem MLKey ein Text erzeugt wird."
  },
  "doc/mlkey/text-collections.html": {
    "href": "doc/mlkey/text-collections.html",
    "title": "Text-Collections",
    "keywords": "Text-Collections Text-Collections arbeiten ebenfalls mit MLKeys. Im Grunde sind sie eine Auflistung von MLKeys. Arbeitsweise Das Wörterbuch wird in xml-Dateien gespeichert. Diese liegen im Broker-Verzeichnis im Ordner lang. Die Dateien werden separat prop Package und Sprache mit dem folgenden Datei-Namen abgelegt: <package>.<iso>.lang.xml Beispiel: <broker-directory> |--lang | |--CustomPackage.de.lang.xml | |--eNVenta.de.lang.xml | |--eNVenta.en.lang.xml | |--eNVenta.fr.lang.xml | |--SystemPackage.de.lang.xml | |--SystemPackage.en.lang.xml Zur Laufzeit werden diese Dateien bei Bedarf einmalig für die benötigten Sprachen eingelesen. Dabei wird die Package-Hierarchie berücksichtigt."
  },
  "doc/mlkey/woerterbuch.html": {
    "href": "doc/mlkey/woerterbuch.html",
    "title": "Wörterbuch",
    "keywords": "Wörterbuch Alle mehrsprachigen Texte der Anwendung werden in einem zentralen Wörterbuch abgelegt. Organisiert werden die Einträge mit einem eindeutigen alphanumerischen Schüssel - dem MLKey. Die MLKeys und deren Texte können folgendermaßen genutzt werden: In den MLString-Properties überall in Framework Studio Im selbst geschriebenen Methoden-Code (siehe Programmierung) In den Code-Messages (Exceptions, Message-Boxen) Die Sprachen werden im Package-Manager an der Package-Version definiert. Multilanguage Text Editor Die Bearbeitung des Wörterbuchs erfolgt über den Multilanguage Text Editor. Dieser wird über das Menü Tools / Multilanguage Text Editor geöffnet. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Die Bearbeitung des Wörterbuchs funktioniert ohne Checkout-Mechanismus. Wenn mehrere Benutzer zur gleichen Zeit an denselben MLKeys arbeiten sollten, dann gewinnt derjenige, der zuletzt den Button Save drückt. Der Editor sammelt alle vorgenommenen Änderungen (Add, Edit, Delete) im Hintergrund. Mit dem Button Save werden diese in das Repository gespeichert. Dabei wird in einer Transaktion zuerst der aktuelle Stand frisch aus dem Repository gelesen, dann die Änderungen erneut auf diesen (evtl. durch einen anderen Benutzer veränderten) Stand angewendet und zuletzt der neue Stand wieder zurück in das Repository gespeichert. Das hat die Folge, dass nach einem Save Änderungen sichtbar sind, die zuvor von einem anderen Benutzer vorgenommen wurden. Eine Ausnahme sind die Basis-Packages. Diese werden aus einem Stand gezogen, den der FrameworkCompiler zum Zeitpunkt des Compile-Laufs in den Workspace gespeichert hat. Suchen von MLKeys Essentiell für die tägliche Arbeit ist das Auffinden von existierenden MLKeys. Dazu wird das Search Feld angeboten. Die Suche scannt alle Felder des MLKeys: MLKey, Comment, Obsolete, Texte. Die Groß-Klein-Schreibung wird nicht berücksichtigt. Es können mehrere Worte eingegeben werden. Dann müssen alle Worte oder Wortteile in irgend einem Feld auftauchen. z.B. MSG_ Artikel Save sucht nach Messages die mit Artikel und Save zu tun haben. Generell wird nach Wortteilen gesucht. Wenn man das Wort oder den Text in Anführungszeichen setzt, wird nach einem exakten Treffer und ganzen Worten gesucht. Das funktioniert auch mit mehreren Worten und in Kombination mit der normalen Suche. z.B. LBL_ \"Kunde\" Ziel des Wörterbuches ist es, Texte wiederzuverwenden und die Anzahl der Einträge auf das Nötigste zu reduzieren. Aus diesem Grund sollte man immer zuerst nach einem MLKey suchen, bevor man einen neuen erfasst. Zu einem logischen Begriff sollen keine zwei MLKeys existieren. Tip Die Suche sollte durchaus kreativ gestaltet werden - besonders bei Texten die eigentlich schon vorhanden sein müssten. Ein Beispiel dafür ist das Wort Einfügen. Möchte man dieses mit der englischen Bezeichnung Add nutzen, stellt man fest, dass es Einfügen schon mit mehreren Übersetzungen gibt, jedoch keine mit der englischen Bezeichnung Add. Sucht man dann aber direkt nach Add, so findet man den statt Einfügen zu verwendenden deutschen Text Hinzufügen. Dependencies von MLKeys suchen Mit der Betätigung des Buttons Search Dependencies, werden alle Abhängigkeiten von jedem MLKey gesucht. Nach erfolgreicher Suche wird eine neue Spalte Dependencies eingeblendet, in der die Anzahl der gefundenen Abhängigkeiten abgebildet wird. Mit einem Doppelklick auf einen Eintrag in der neu hinzugefügten Spalte wird eine detaillierte Ansicht mit den gefundenen Abhängigkeiten für den ausgewählten MLKey angezeigt. Erfassen neuer MLKeys Mit dem Button Add öffnet sich ein Dialog, in dem der neue MLKey erfasst werden kann. Textfeld MLKey Hier wird der MLKey angegeben. Im Customizing-Package wird der Package-Code automatisch vorbelegt. Note Der MLKey kann zu einem späteren Zeitpunkt nicht mehr geändert werden. Der MLKey kann frei vergeben werden, es gibt jedoch ein paar Regeln und Empfehlungen: Es handelt sich um einen C#-Identifier, der auch im Quellcode verwendet wird. Buchstaben, Zahlen, Unterstrich Groß-Klein-Schreibung ist relevant Der sprechende Name sollte sich nach Möglichkeit an den englischen Text anlehnen. z.B. LBL_Article Wenn der Text zu komplex ist - z.B. bei Messages oder Tooltips, dann kann der Name eine Guid enthalten. Diese kann mit dem Button Generate Guid angefügt werden. z.B. MSG_1c9f3024dfc340dfba0651cb92d90ad6 In Customizing-Packages erhält der MLKey einen Package-Code. Dieser wird automatisch vorbelegt. z.B. LBL_K87_SpecialArticle In der eNVenta/WS Standard-Entwicklung sind entsprechende Namensregeln einzuhalten. Wird dieser Dialog aus der MLKey-Suche heraus geöffnet, dann wird abhängig vom jeweiligen Context auch ein passender Präfix vorbelegt: LBL_ / LBL_<PackageCode>_: Der Suchdialog wurde z.B. aus einem Caption- oder Default-Label-Property aufgerufen. TTT_ / TTT_<PackageCode>_: Der Suchdialog wurde aus dem Tooltip-Property aufgerufen. MSG_ / MSG_<PackageCode>_: Der Suchdialog wurde aus dem MessageBox- bzw. Exception-Wizard aufgerufen. Feld Comment Der Kommentar beschreibt bei Bedarf den MLKey genauer. Das ist sinnvoll, wenn der Text oder auch der MLKey erklärungsbedürftige Abkürzungen beinhaltet oder wenn es ähnliche Texte mit verschiedenen Verwendungszwecken gibt. Textfeld Obsolete Ein MLKey kann durch die Eingabe einer Obsolete-Message als veraltet markiert werden. Der Compiler wird bei Verwendung dieses MLKeys diese Message als Warning ausgeben. Weil das Löschen von MLKeys vor allem im Hinblick auf Customizing-Packages Compile-Errors erzeugt, sollte davon abgesehen und stattdessen diese Obsolete-Message verwendet werden. Ein Hinweis auf einen alternativ zu verwendenden MLKey ist empfehlenswert. Textfeld German Die Eingabe eines deutschen Textes ist Pflicht, weil Deutsch immer der letzte Fallback ist, wenn eine Fremdsprache nicht gepflegt ist. Fremdsprachen Über die Radio-Buttons kann festgelegt werden, welche Sprache im 2. Textfeld angezeigt oder bearbeitet werden soll. Diese Texte sind optional. Die angebotenen Fremdsprachen und deren Reihenfolge kann in den Options mit der Einstellung Languages in designer eingestellt werden. German lässt sich in diesem Dialog aber nicht steuern - diese Sprache wird immer im separaten Feld angezeigt. In der eNVenta/WS Standard-Entwicklung muss der englische Text gepflegt werden. Button Untranslatable Es gibt Texte, die nicht übersetzt werden können wie z.B. Eigennamen oder Einheiten. Dieser Button löscht alle Fremdsprachen-Texte und Schreibt den Text untranslatable in das Comment Feld. Mit der Routine MLKeys Cleanup ist es möglich, systematisch nach Texten zu suchen, die dafür geeignet sind. Bearbeiten von MLKeys Mit dem Button Edit wird für den selektierten MLKey der Bearbeitungs-Dialog geöffnet. Durch einen Doppelklick in das Grid kann der Bearbeitungs-Dialog ebenfalls geöffnet werden. Dabei wird der Fokus automatisch in das Feld gesetzt, das der angeklickten Grid-Zelle entspricht. Das ist praktisch, wenn man z.B. gezielt eine Fremdsprache bearbeiten möchte. Außerdem können einzeilige Texte direkt im Grid bearbeitet werden. Note Die logische Bedeutung des MLKeys darf zu einem späteren Zeitpunkt nicht mehr geändert werden. Der Dialog ist gleich aufgebaut wie der Add-Dialog. Es werden zusätzlich das Create Date des MLKeys und die Edit-Informationen der Fremdsprachen-Texte (Datum und Benutzer der letzten Bearbeitung) angezeigt. Note Der Benutzer wird bei alten Texten ggf. nicht angezeigt, weil dieses Feature erst zu einem späteren Zeitpunkt implementiert wurde. Der MLKey kann nicht bearbeitet werden. Wird im Customizing-Package ein MLKey aus dem Basis-Package geöffnet, dann sind einige weitere Felder für die Bearbeitung gesperrt: Comment / Button Untranslatable, Obsolete Die Texte können bearbeitet werden. Mit dem Button View History wird ein weiteres Fenster geöffnet, in dem die Version des Eintrages vor der letzten Bearbeitung angezeigt wird. Siehe Abschnitt History. Copy Entry / Paste Entry Wenn man ein oder mehrere Einträge selektiert hat, kann man mit dem Button Copy Entry diese in die Zwischenablage kopieren. Mit dem Button Paste Entry können diese Einträge z.B. in einer anderen Version des Packages eingefügt werden. Intern benutzt diese Funktion den Import- / Export-Mechanismus. Dieser verwendet ein XML im TMX-Format. Dadurch ist es möglich, das XML vor dem Paste Entry bei Bedarf in einem Text-Editor zu manipulieren, z.B. um den PackageCode des MLKey anzupassen. Mit Paste Entry werden neue MLKeys hinzugefügt. Enthält die Zwischenablage existierende Keys, dann wird vor dem Einfügen ein Auswahl-Dialog angezeigt. Ignore: Es werden keinerlei Einträge ersetzt. Lediglich unbekannte, neue MLKeys werden hinzugefügt. Replace: Es wird der komplette existierende Eintrag ersetzt. Wenn in der Zwischenablage ein Wert nicht gesetzt ist, dann wird dieser entfernt. Merge: Die beiden Einträge werden zusammengeführt. Dabei gewinnt jeweils der Text mit dem neueren Edit-Date. Mit dem Button Cancel wird die komplette Aktion abgebrochen. Dann werden auch keine MLKeys hinzugefügt. Customizing Jedes Customizing-Package verwaltet sein eigenes Wörterbuch. Es können neue MLKeys angelegt werden. Diese müssen den Package-Code enthalten, damit es in Zukunft keine Kollisionen mit Basis-Packages gibt. Bevor ein neuer MLKey angelegt wird, sollte immer geprüft werden, ob es nicht doch einen passenden MLKey gibt. Texte aus Basis-Packages können überschrieben bzw. ergänzt werden. So können z.B. Übersetzungen für Fremdsprachen gepflegt werden. Es muss darauf geachtet werden, dass die Bedeutung des MLKeys nicht geändert wird, weil dieser ggf. an mehreren Stellen in der Anwendung verwendet wird. Wird an einer bestimmten Stelle in der Anwendung ein anderer Text benötigt (in eNVenta kann das z.B. der Text \"Code1\" sein, der ersetzt werden soll) dann muss an dieser Stelle (jedoch möglichst weit unten in der DBColumn oder Metadatentyp) ein anderer MLKey zugeordnet werden. (siehe auch MLString-Vererbung) Im Customizing-Package übersetzte Texte können exportiert und in das Basis-Package importiert werden. Zu einem späteren Zeitpunkt können die dann redundanten Übersetzung mit der MLKeys Cleanup Routine bereinigt werden. History Bei jeder Bearbeitung im Wörterbuch wird die Vorgänger-Version des MLKeys in einen separaten History-Bereich geschrieben. Aus dem Edit-Dialog heraus kann diese Information mit dem Button View History geöffnet werden. Gibt es keine Informationen, ist der Button deaktiviert. Die History arbeitet pro Sprache. Wird z.B. der englische Text bearbeitet, wird auch nur der alte englische Text mit seinem alten Änderungs-Datum in den History-Bereich übertragen. Die History-Informationen der anderen Sprachen bleiben unverändert. Eine leere Eigenschaft wird nicht historisiert - das gilt insbes. für Comment und Obsolete Message. Wird eine dieser Eigenschaften geleert, dann verbleibt der alte Text auch dann in der History, wenn später wieder ein neuer Text gesetzt wird. Wird ein MLKey gelöscht, wird der komplette Eintrag mit allen Sprachen in die History übertragen. Dieser kann jedoch zu einem späteren Zeitpunkt nicht mehr ohne weiteres gegriffen werden. Tip Wurde ein MLKey versehentlich gelöscht und es gibt einen Compile-Error mit dem entsprechenden MLKey, dann kann man diesen Eintrag wieder neu im Wörterbuch anlegen. Beim anschließenden Bearbeiten des MLKeys können dann die noch existierenden History-Informationen eingesehen werden. Gefüllt wird die History mit dem Save-Button. Framework Studio sammelt alle im Wörterbuch vorgenommenen Änderungen und speichert diese mit dem Save-Button in einem Rutsch. Dadurch kann ein Text auch mehrfach hintereinander geändert werden. Erst nach dem Save steht der alte Text in der History. Note Beim Labeln der Package-Version wird die History-Information nicht in die neue Package-Version übernommen. Die History-Informationen berücksichtigen nur das aktuelle Package. Weil für Basis-Packages das Wörterbuch aus dem letzten Framework-Compiler-Stand gelesen wird, enthält es keine History-Informationen."
  },
  "doc/modcomp/modcomp.html": {
    "href": "doc/modcomp/modcomp.html",
    "title": "Modular Components",
    "keywords": "Modular Components Mit den Modularen Components wollen wir einen Baukasten schaffen, mit dessen Hilfe wir Objekte ausschließlich mit dem benötigten Funktionsaufwand erstellen können. Unsere Motivation Aktuell gibt es für BusinessLogik und Datenobjekte nur die Möglichkeit eine Component als Objekttyp anzulegen. Dieser Objekttyp bringt viele Funktionen (New, Load, Save, NotifyChanged-Logik, etc.) mit sich, welche nicht für jeden Verwendungszweck des Objekts benötigt werden. Zum Beispiel sollte eine Component, die ausschließlich Businesslogik enthält, nicht automatisch in eine Form eingebunden werden können. Diese Funktionalität sollte bei Bedarf, wie bei einem Baukasten, ausgewählt werden können. Derzeitiger Entwicklungsstand Der Komponentenbaukasten wird iterativ erweitert. Derzeit umfasst er die folgenden Features: Modular Components Arten Die Auswahl der Modular Component-Art bestimmt Voreinstellungen der Modular Component. Bei Modular Component (Interface) kann der Type Interface nicht mehr verändert werden. Bei Modular Component (UnitTest) wird der Compile Step mit \"UnitTest\", das Attribute mit \"[TestClass]\" und die Base Class mit \"FSTestBase\" vorbelegt. Außerdem wird eine Methode MyTestMethod() mit dem Attribute \"[TestMethod]\" hinzugefügt. Type Auswahl: Class, Class with Interface oder Interface Die Auswahl des Types entscheidet, ob eine Klasse und oder ein Interface generiert wird. Die beiden Optionen Class und Interface sind selbsterklärend. Bei der Option ClassWithInterface wird sowohl eine Klasse als auch ein Interface generiert. Bei diesem Type muss zudem der Compile Step beachtet werden! Die unterschiedliche Code-Generierung kann im Kapitel Code eingesehen werden. Es kann der Compile Step, wie bei CodeFiles, definiert werden. Dies entscheidet in welche DLL die Modular Component kompiliert wird. Note Beim Typ ClassWithInterface gibt es die Besonderheit, dass bei Auswahl des Compile-Schritts Component das Interface in die Interface-Schicht, die Klasse jedoch in die Component-Schicht generiert wird. An der Klasse oder dem Interface, an Properties, und Methoden können Attribute definiert werden. Eine ausführliche Erklärung der Attribute und Verhalten im Customizing erfolgt im Kapitel Attribute. Protected Setter bei Properties Copy & Paste der Methoden und Properties über verschiedene Objekttypen hinweg ist möglich. Zwischen Forms, Components und Modular Components kann kopiert werden. Da keine 1:1 Übersetzung möglich ist, muss vor allem bei der Kopie von Modular Component Properties in Components das Ergebnis ggf. überprüft werden. BaseClass Im Feld BaseClass sind nur Klassen erlaubt, welche mit Fullname angegeben werden müssen. Dies kann für externe Klassen oder nicht Modular Component-Klassen händisch eingetragen werden. Oder es wird eine derived Modular Component über das Derive-Command im Namespace-Baum einer Basis Modular Component erstellt - ähnlich zur Form-Vererbung. Modular Components vom Typ Interface können keine BaseClass besitzen, das Feld wird deshalb nicht angezeigt. Stattdessen können im Feld Interfaces mehrere Basis-Interfaces definiert werden. Im Customizing kann die BaseClass nicht geändert werden. Das Feld BaseClass zeigt den Wert aus dem Basis-Package an. Im Property-Kontextmenü gibt es ebenfalls die neue Funktion: Property (Override). Mit welcher Properties aus der Basisklasse überschrieben werden können. Properties haben eine Checkbox Override erhalten, welche beim Überschreiben eines Properties automatisch angehakt wird. Auch bei \"Method (override)\" werden Methoden aus der Basis aufgeführt. Auf dem folgenden Screenshot wird der General Tab einer Class-Modular Component abgebildet. Interfaces Im Feld Interfaces können durch ein Komma getrennt mehrere Interfaces angegeben werden, welche die Modular Component implementieren soll. Es müssen FullNames (inkl. Namespaces) verwendet werden. Diese Interfaces werden 1:1 in den generierten Code der Klasse des entsprechenden Packages übernommen. Für eine Implementierung muss manuell gesorgt werden. Für bekannte Interfaces gibt es aber eine Unterstützung zum Erzeugen der entsprechenden Properties und Methoden. \"Bekannte\" Interfaces sind derzeit andere Modular Components. Im Customizing kann eine Modular Component weitere Interfaces implementieren - die im Basis-Package definierten Interfaces können hingegen nicht entfernt werden. Aus diesem Grund stellt das Feld Interfaces nicht den Wert aus dem Basis-Package dar. Über den Button neben dem Feld öffnet sich ein Context-Menü mit Aktionen für bekannte Interfaces. Open: öffnet die entsprechende Modular Component. Implement: sofern die angegebene Modular Component vom Typ Interface ist, werden die fehlenden Properties und Methoden automatisch erzeugt. Dabei wird nur das jeweilige Interface und nicht dessen Basis-Interface(s) betrachtet. Funktionale Einschränkungen Funktionen, welche aus Components bekannt sind, jedoch nicht für Modular Components umgesetzt wurden: Verwendung der Modular Components in DataBindings ist nicht möglich. Auch bei Textboxen mit Autovervollständigungen werden Modular Components nicht angezeit. Es muss der FullName der Modular Component angegeben werden. Properties haben derzeit nur einen External DataType. Es muss der FullName bspw. einer Component angegeben werden. MDTs stehen ebenfalls nicht zur Auswahl. Bestandteile der Modular Component Type (nicht änderbar im Customizing) Class, ClassWithInterface, Interface Compile Step (nicht änderbar im Customizing) Interface, Component, UnitTest Base Class (nicht änderbar im Customizing) Description (²) Attributes (²) Attribute werden im Customizing über die Packages hinweg summiert und im UseCode an das Interface beziehungsweise an die Klasse generiert. Beim Typ Class With Interface erhält das Interface keine Attribute. (²) wird an die Klasse (bei Type Class und ClassWithInterface) oder an das Interface (bei Type Interface) im UseCode generiert. Note Bei Type ClassWithInterface und Compile Step Component wird das Interface in die Interface-Schicht generiert. Die zugehörige Klasse kommt in die Component-Schicht. Bei Type Class und Interface wird es in den ausgewählten Compile Step generiert. Properties Properties Class Class With Interface Interface AccessLevel public | internal | protected | private public | internal | protected | private public AutoProp x x x (nur public) * Setter Type AutoProp get | get set | protected set get | get set | protected set - Field x x - * Setter Type Field - - - IndivProp x x - * Setter Type IndivProp get | get set | protected set get | get set | protected set - Attributes x x x³ Code Generierung: AutoProperties und IndivProperties werden immer mit virtual bzw. im Customizing mit override generiert. So sieht die UI im Bereich General der Properties aus: Für die Anzeige des Codes gibt es hier eine gemeinsame Ansicht des Getter und Setter-Codes. Mit gedrückter Shift-Taste und Doppelklick auf den Splitter kann die Ansicht von Vertical zu Horizontal (Get/Set Code wird dann untereinander angezeigt) und andersherum gewechselt werden. Public Properties werden automatisch virtual. AutoProperty Bei AutoProperties kann kein Get- oder Set-Code geschrieben werden. public virtual FSstring Stuff { get; set; } Individual Property public virtual FSstring Stuff { get{ // individuell definierter Code } set { // individuell definierter Code } } Fields Fields können nicht gecustomized werden. Attribute werden somit immer im Code des jeweiligen Packages definiert. Methods Methoden Class Class With Interface Interface Constructor x x - * Constructor - Attributes - - - protected Method x x - * protected Method Attributes x x - internal Method x x x * internal Method Attributes x x x Attributes x x x(1) (1) Attribute werden bei Properties und Methods beim Typ Interface an den CodeCode des jeweiligen Packages, wo sie definiert wurden, im Code geschrieben. Dies verhält sich anders bei Class und ClassWithInterface. Hier werden die Attribute im UseCode an Properties und Methods gesammelt generiert. TestMethod Beim Typen UnitTest gibt es im Bereich der Methods das spezielle TestMethod-Command. Dieses Command fügt automatisch das Attribute \"[TestMethod]\" hinzu. TestMethods sind nicht virtual. Code Class mit Attributen und Customizing [FSDemoAttribute] [FSDemoCustomizeAttribute] public class Stuff : FSDemoCustomize_Stuff { [FSDemoMethodAttribute] [FSDemoCustomizeMethodAttribute] public override void SetStuff(string stuff) => base.SetStuff(stuff); [FSDemoPropertyAttribute] [FSDemoCustomizePropertyAttribute] public override string Stuff { get => base.Stuff; set => base.Stuff = value; } } public class FSDemoCustomize_Stuff : FSDemo_Stuff { public override string Stuff { get => base.Stuff; set => base.Stuff = value; } public override void SetStuff(string stuff){ base.SetStuff(stuff + \" customizing\"); } } public class FSDemo_Stuff { public virtual string Stuff { get; set; } public virtual void SetStuff(string stuff){ Stuff = stuff; } } Generierter Code bei \"ClassWithInterface\" mit Customizing und BaseClass // UseCode public class Stuff : FSDemoCustomize_Stuff, IStuff { } public interface IStuff : FSDemoCustomize_IStuff { } // Customizing Package public class FSDemoCustomize_Stuff : FSDemo_Stuff, FSDemoCustomize_IStuff { } public interface FSDemoCustomize_IStuff: FSDemo_IStuff { } // Basis Package public class FSDemo_Stuff : BaseClass, FSDemo_IStuff { } public interface FSDemo_IStuff { }"
  },
  "doc/namespace/namespace.html": {
    "href": "doc/namespace/namespace.html",
    "title": "Namespaces",
    "keywords": "Namespaces Die Namespaces sind, wie im .NET die Klassen, systematisch zu gruppieren. In einer leeren Anwendung stehen im SystemPackage (Packages) bereits einige Namespaces zur Verfügung, die Framework Studio benötigt, um einige Dinge zu organisieren. Zum einen gibt es den System-Namespace. Hier sind bereits die einfachen Typen von .NET wie z.B. string, int und long als Komponenten angelegt. Darunter gibt es einen Namespace Framework Studio, in dem System-Klassen abgelegt sind, die Framework Studio anbietet. Zu diesen Klassen gehört z.B. DevFrameworkObject, welches die Basis-Klasse aller Components in Framework Studio darstellt oder die FS-Datentypen, die sich fast wie die .NET-Datentypen verhalten, aber zusätzlich NULL als Wert annehmen können. Im Unternamespace Metadatatypes sind die Basis-Metadatentypen für Datenbankspalten hinterlegt. Alle diese hier angebotenen Klassen können im Framework Studio nicht editiert werden – die Datentypen lassen sich nicht öffnen. Sie werden angezeigt, damit sie später in den Components oder Forms als Datentyp für Properties ausgewählt werden können. Ein weiterer besonderer Namespace ist der Namespace FSGeneral. Dieser Namespace wird von allen anderen Namespaces automatisch (durch eine using-Direktive) eingebunden und daher als erstes kompiliert. Neue Namespaces können nur im Unterordner Resources angelegt werden. Im Namespace FSGeneral befinden sich folgende Unter-Namespaces, die im DefaultPackage (und ggf. in weiteren Packages) diese Elemente enthalten: Controls In diesem Namespace werden alle Default Control Styles und alle Custom Controls angezeigt. DBTables In diesem Namespace werden alle Datasources und unterhalb der Datasouces die DBTables, die an dem jeweiligen Datasouce definiert wurden, angezeigt. GlobalObjects In diesem Namespace werden alle Global Objects angezeigt. Resources In diesem Namespace werden alle Resources angezeigt. Unternamespaces haben dabei die Bedeutung von Unterordnern im Brokerverzeichnis. Dieser Namespace ist der einzige in FSGeneral, in dem neue Namespaces angelegt werden dürfen! Namespace erstellen / löschen Erstellen eines Namespaces Elemente erstellen Löschen eines Namespaces Elemente löschen Warning Ein Namespace kann nur gelöscht werden, wenn er keine Elemente mehr enthält. Namespace umbenennen Um den Namespace zu einem späteren Zeitpunkt umbenennen zu können, bietet das Kontext-Menu des Namespaces den Eintrag Rename. Da sich Framework Studio für eingecheckte Elemente den generierten Quellcode merkt, kann ein Umbenennen eines Namespaces im laufenden Betrieb Probleme mit sich bringen. Der Name des Namespaces sollte deshalb schon beim Anlegen gut überlegt sein. Spätestens beim ersten CheckIn sollte der Name feststehen, damit andere Entwickler, die diesen Namespace bereits verwenden, keine Probleme bekommen. Caution Lässt es sich dennoch nicht vermeiden, einen Namespace umzubenennen, muss danach der gesamte zwischengespeicherte Code der Anwendung gelöscht und neu erzeugt werden. Nähere Informationen dazu gibt es im Abschnitt Code Builder und Kompilieren als FrameworkCompiler."
  },
  "doc/package-manager/administrative-mode.html": {
    "href": "doc/package-manager/administrative-mode.html",
    "title": "Administrative Mode",
    "keywords": "Administrative Mode Für einige Aktionen auf dem Repository ist es notwendig, dass alle Entwickler das Repository verlassen: Labeln einer Version und öffnen einer neuen Importieren von Packages Update des Repositories Einige Daten werden im Repository mit Triggern bearbeitet. Zudem gibt es Absicherungen durch Constraints. Bei den oben aufgeführten Aktionen werden die Trigger und Constraints zum Teil deaktiviert. Das ist aus Performance-Gründen notwendig. Dieses Deaktivieren hätte ggf. zur Folge, dass im Repository falsche Daten entstehen können. Ist der Admin-Mode aktiviert, wird der Menüeintrag rot hervorgehoben. Der Modus kann nur aktiviert werden, wenn kein Entwickler am Repository angemeldet ist. Ist dies der Fall, wird ein Dialog angezeigt mit der Information, welche Benutzer derzeit noch angemeldet sind und der Option diese Sitzungen zu beenden. Falls noch Benutzer angemeldet sind, wird dieser Dialog angezeigt. Hier gibt es die folgenden Möglichkeiten: Cancel – den Vorgang abbrechen Retry – es erneut versuchen, nachdem z.B. dem Benutzer Bescheid gegeben wurde Kill User Sessions – die Sitzungen der Benutzer zu beenden. Bei dieser Aktion wird 130 Sekunden gewartet. Das ist die Zeit, die im Extremfall benötigt wird, bis ein Benutzer zum Beenden seiner Sitzung gezwungen wurde. (60 Sekunden bis zur Hinweismeldung + 60 Sekunden bis zum endgültigen Abbruch + 10 Sekunden Reserve) Während dieser Dialog angezeigt wird, können sich keine neuen Benutzer mehr anmelden. Befindet sich ein Repository im Admin-Mode, können sich keine Benutzer mehr darauf anmelden. Diese erhalten dann folgende Meldung. Sollte man vergessen, dass der Admin-Mode aktiv ist, wird man beim Schließen des Package-Managers darauf aufmerksam gemacht."
  },
  "doc/package-manager/compile-wizard.html": {
    "href": "doc/package-manager/compile-wizard.html",
    "title": "Compile Wizard",
    "keywords": "Compile Wizard Der Compile Wizard ermöglicht das automatische Kompilieren eines Labels mit den davon abhängigen Labels. Alle Einstellungen für einen solchen Vorgang können gespeichert und wieder geladen werden. Außerdem lässt sich der Compile Wizard per Kommandozeilenparameter mit einer zuvor gespeicherten Konfiguration automatisch starten. Warning Es wird immer ohne Use saved code kompiliert. Starten des Wizards Der Compile Wizard wird über den Eintrag Compile Wizard im Kontextmenü eines Labels gestartet. Im Compile Wizard werden auf der linken Seite in einem Treeview das ausgewählte Label und alle davon abhängigen Labels angezeigt. Wurzelknoten ist das ausgewählte Label. Alle davon abhängigen Labels werden auf der ersten Ebene dargestellt. Sind von diesen Labels wiederrum weitere Labels abhängig, werden diese auf einer weiteren Ebene dargestellt. Im folgenden Screenshot ist zum Beispiel das Label CustomizingTestLevel2 1.0 abhängig vom Label CustomizingTest 1.0. Deshalb wird es (auch) als Unterknoten von CustomizingTest 1.0 angezeigt. Im Treeview kann für jedes Label über die dazugehörige Checkbox festgelegt werden, ob dieses Label kompiliert werden soll. Auf der rechten Seite werden daraus resultierend alle Labels in der Reihenfolge angezeigt, in der sie kompiliert werden. Tip Wenn man mehrere Labels (Versionen) desselben Packages hintereinander kompilieren möchte, kann man den Compile Wizard über das Kontextmenü des Labels SystemVersion vom SystemPackage öffnen. Es werden dann alle Labels angezeigt, da alle Labels von diesem Label abhängig sind. Checkbox Refresh workspace of FrameworkCompiler before each compile Wenn diese Checkbox gesetzt ist, wird der Workspace des FrameworkCompilers vor dem Kompilieren eines Labels für dieses Label aktualisiert. Button Start Compile Mit diesem Button wird der gesamte Kompiliervorgang gestartet. Tritt beim Kompilieren ein Fehler auf, wird der gesamte Kompiliervorgang unterbrochen. Button Stop after this Label Mit diesem Button kann der Kompiliervorgang zwischen den einzelnen Labels abgebrochen werden. Einstellungen exportieren Im Compile Wizard kann über den Menüpunkt File / Export Settings die aktuelle Konfiguration in eine XML-Datei exportiert werden. In dieser Datei sind die folgenden Informationen enthalten: ConnectionString für den Zugriff auf das Repository (verschlüsselt) Zu kompilierende Labels Soll der Workspace vor dem Kompilieren aktualisiert werden? Mit dieser XML-Datei ist es möglich, ein Kompiliervorgang für mehrere Packages / Labels per Kommandozeile anzustoßen Einstellungen importieren Im Compile Wizard können Sie eine gespeicherte Konfiguration über den Menüpunkt File / Import Settings importieren. Start per Kommandozeilenparameter Der folgende Aufruf startet den Package-Manager, öffnet den Compile Wizard mit den Einstellungen, die in der Datei Settings1.XML abgelegt sind und startet den Kompiliervorgang. FrameworkStudioPackageManager.exe \\compileXML \"C:\\Settings1.XML\" So ist es z.B. möglich den Package-Manager über einen geplanten Task zu starten und so das regelmäßige Kompilieren mit dem FrameworkCompiler automatisch durchzuführen. Idealerweise sollte dieser Vorgang am Abend gestartet werden, nachdem die Entwickler ihre Elemente in einem kompilierfähigen Zustand eingecheckt haben."
  },
  "doc/package-manager/export.html": {
    "href": "doc/package-manager/export.html",
    "title": "Export einer Package-Version",
    "keywords": "Export einer Package-Version Über den Button kann die im Baum ausgewählte Package-Version in eine Datei exportiert werden. Diese Datei kann anschließend in einem anderen Repository wieder importiert werden. Es wird folgender Dialog angezeigt: Package File Hier wird die Datei angegeben, in welche die Package-Version exportiert werden soll. Der Datei-Name wird automatisch mit dem Format <Datum_Package_Version> vorbelegt. Dieser sollte nach Möglichkeit nicht geändert werden. Export Code Es wird standardmäßig der Code exportiert. Der Code beinhaltet dabei sämtlichen Methoden-Code und auch den vom FrameworkCompiler generierten Code. Include Base Packages Wenn diese Checkbox gesetzt wird, dann wird ein Bereich eingeblendet, in dem angegeben werden kann, welche Basis-Packages mit in die Export-Datei gepackt werden sollen. Dies funktioniert auch bei importierten Basis-Packages. Im Vergleich zum Export der einzelnen Package-Versionen hat dieses Vorgehen den Vorteil, dass auf jeden Fall der passende Compile-Stand des Basis-Packages verwendet wird – auch wenn das Basis-Package später neu kompiliert wurde und dafür ein aktuellerer FrameworkCompiler-Stand zur Verfügung steht. Im Bereich stehen zwei Radio-Buttons zur Auswahl: Export Service Releases (standardmäßig vorbelegt) Damit werden alle Package-Versionen ausgewählt, welche als SR exportiert werden können. Darunter zählen normale SR-Packages, aber auch sealed Packages, die davor mal im SR-Modus waren (sealed SR). Außerdem werden \"Full Exporte\" für offene Package-Versionen exportiert. Diese Auswahl bedingt, dass im Ziel-Repository bereits ein aktueller Stand des Basis-Packages importiert wurde. Export Full Packages Damit wird für alle Packages ein Full Export ausgewählt. Diese Auswahl ist sinnvoll, wenn die Package-Version erstmalig zum Ziel-Repository übertragen werden soll. Bei Bedarf können auch gezielt weitere Packages ausgewählt werden. Bei Package-Versionen, die als Service-Release exportiert werden können, kann mit der Checkbox Export Full Package statt dem Service-Release-Paket die komplette Package-Version eingebunden werden. Beim Package-Import werden automatisch alle in der Export-Datei beinhalteten Packages importiert – die Auswahl kann nur beim Export getroffen werden. Bei Service-Releases erfolgt ein Import nur dann, wenn nicht bereits ein aktuellerer Service-Release-Stand vorhanden ist. Note Ein neues Repository kann mit so einer Export-Datei nicht angelegt werden. Dies ist nur mit dem Export des Default-Packages möglich."
  },
  "doc/package-manager/hotfix-branch.html": {
    "href": "doc/package-manager/hotfix-branch.html",
    "title": "Hotfix-Branch",
    "keywords": "Hotfix-Branch Mit Hilfe von Hotfix-Branches ist es möglich, parallel zum laufenden Service-Release Änderungen vorzunehmen und diese kurzfristig auszuliefern. Normalerweise werden im Laufe eines Service-Release-Zyklus mehrere Änderungen eingecheckt, die am Ende des Zyklus vor der Auslieferung getestet werden. Treten schwerwiegende Programmfehler auf, kann eine Korrektur ggf. nicht bis zur nächsten regulären Auslieferung warten. Es muss sehr zeitnah korrigiert und ausgeliefert werden. Eine Auslieferung des Entwicklungsstands birgt aber mitunter ein sehr großes Risiko, weil 1. viele weitere und 2. ungetestete Änderungen enthalten sein können. Weitere Probleme sind dann sehr wahrscheinlich. Für diesen Zweck kann im Quell-Repository für eine Package-Version ein Hotfix-Branch abgezweigt werden. Der Hotfix-Branch ist eine eigene, von der Hauptversion losgelöste, parallel existierende Version. Note Alle Änderungen im Hotfix-Branch müssen deshalb parallel in der Hauptversion nachgezogen werden. Ein \"Merge\" zurück in die Hauptversion ist nicht möglich. Der Hotfix-Branch kann zum Zeitpunkt der letzten Auslieferung abgezweigt werden. Anschließend wird die gewünschte Korrektur durchgeführt. So ist sichergestellt, dass nur der getestete Stand und ausschließlich diese Korrekturen enthalten sind. Beim Export der Package-Version gibt sich der Hotfix-Branch als Service-Release-Stand der Hauptversion aus. Nach einem Import ins Ziel-Repository müssen deshalb keine Versionen umgehängt werden und es greifen auch alle anderen beim Service-Release üblichen Optimierungen. Die Abbildung oben skizziert verschiedene Szenarien für einen Hotfix-Branch: Die Änderung wird zuerst im Hotfix-Branch (4.5.hotfix1) durchgeführt. Das muss zeitnah im Haupt-Branch (4.5) nachgezogen werden, damit die Änderung im nächsten Service-Release enthalten ist. Eine Änderung im Haupt-Branch (4.5) kann nicht bis zur Auslieferung des Service-Release warten. Sie wird im Hotfix-Branch (4.5.hotfix2) nachgezogen. Unmittelbar vor der Auslieferung findet eine Korrektur im Hotfix-Branch (4.5.hotfix2) statt. Wenn diese Korrektur einen Hotfix rechtfertigt, sollte die Auslieferung verzögert und die Korrektur sofort nachgezogen werden. Ist das absolut keine Option, dann muss die Korrektur nach der Auslieferung nachgezogen werden. In diesem Fall muss ggf. unmittelbar nach der Auslieferung ein neuer Hotfix-Branch (4.5.hotfix3) erstellt und der Zeitpunkt so gewählt werden dass die entscheidende Korrektur gerade noch so enthalten ist. ... ... Ist das nicht möglich, weil es schon andere Änderungen vor dieser Korrektur gibt, muss, wie im 1. Szenario, der Hotfix-Branch (4.5.hotfix3) regulär erstellt und die Korrektur erneut nachgezogen werden. Allgemeine Regeln Verschiedene Hotfix-Auslieferungen eines Packages sind nicht miteinander kombinierbar! Es sollten nicht mehrere Hotfix-Branches gleichzeitig parallel betrieben werden (z.B. 4.5.hotfix1 + 4.5.hotfix2). Der Hotfix sollte ausschließlich für Notfälle verwendet werden. Werden im Hotfix-Branch zu viele Korrekturen durchgeführt, gefährdet das die Möglichkeit, jederzeit kurzfristig ausliefern zu können und es erzeugt zudem signifikante Mehrarbeit. Im Entwicklungs-Repository Um einen neuen Hotfix-Branch zu eröffnen, wählen Sie im Package Manager zuerst die entsprechende Hauptversion aus. Diese Version muss sich im Service-Release-Modus befinden und es darf kein anderer Hotfix-Branch sein. Drücken Sie dann den Button (Open Hotfix Branch). Es erscheint eine Versions-Historie, in der der Zeitpunkt des Abzweigs ausgewählt werden kann. Zusätzlich zu den Check-Ins zeigt die Historie auch die Zeitpunkte für den Start des Service-Release und die letzte Service-Release-Auslieferung an. Normalerweise sollte einer dieser Zeitpunkte ausgewält werden, damit die Hotfix-Korrektur zum letzten Auslieferungs-Stand passt und keine weiteren Änderungen den Hotfix stören. Soll jedoch ein bestimmter Check-In explizit enthalten sein, dann kann auch dieser ausgewählt werden. Dabei ist jedoch zu beachten, dass damit auch alles, was davor eingecheckt wurde, im Hotfix-Branch landet. Nach dem Klick auf das gewünschte Datum wird der Hotfix-Branch angelegt. Der Version Name wird automatisch vergeben und nummeriert. Er lautet z.B. \"4.5.hotfix1\", \"4.5.hotfix2\" usw. Der Hotfix-Branch übernimmt den Service-Release-Modus. Es ist nicht möglich, den Version State auf Open zu setzen. Im Hotfix Title kann eine sprechender Titel angegeben werden. Dieser wird z.B. im Login-Dialog anzeigt. Wird kein Titel definiert, dann wird alternativ das Hotfix Start Datum verwendet. Nachdem der Hotfix-Branch erzeugt wurde muss ein Compile-Wizard ausgeführt werden. Weil der Abzweig zu einem beliebigen Zeitpunkt der Vergangenheit erfolgt, gibt es keinen Workspace, auf dem der Branch aufsetzen kann. Aus diesem Grund muss zuerst ein Compile ausgeführt werden, damit ein entsprechender Workspace frisch aufgebaut wird. Anschließend kann sich ein normaler Benutzer mit der IDE am Hotfix-Branch anmelden. Die Hotfix-Branches werden im Login-Dialog angeboten: Ab jetzt greift der ganz normale Entwicklungs- und Auslieferungs-Workflow: Änderungen durchführen Einchecken Compile-Wizard ausführen Export der Package-Version für die Auslieferung Customizing-Packages Soll im Quell-Repository ein Hotfix-Branch (z.B. eNVenta 4.5.hotfix2) in einem Customizing-Package (z.B. eNVentaWS 4.5) verwendent werden, dann muss im Customizing ebenfalls ein Hotfix-Branch (z.B. eNVentaWS 4.5.hotfix2) erstellt werden. In der Using-Hierarchy kann dann die Version des Basis-Packages auf den Hotfix-Branch geändert werden. Im Ziel-Repository Ein Hotfix beinhaltet immer ein komplettes Package (.db-Datei). Es kann, wie jedes andere komplette Package, jederzeit - auch nach einem Service-Release - importiert werden. Über einen Hotfix-Stand kann kein weiteres Service-Release-Package (.srdb-Datei) importiert werden. Um wieder zum normalen SR-Rythmus zurück zu wechseln, müssen Sie folgende Schritte druchführen: Import des ursprünglichen Release-Packages - z.B. 2023-01-02_eNVenta_4.5.db (vgl. Abb. oben) Import des gewünschten Service-Release-Packages - z.B. 2023-02-01_eNVenta_4.5.srdb"
  },
  "doc/package-manager/manage-useres.html": {
    "href": "doc/package-manager/manage-useres.html",
    "title": "Benutzer-Verwaltung",
    "keywords": "Benutzer-Verwaltung Die Benutzer-Verwaltung erreicht man im Package-Manager über das Menü Tools / Manage Users. Benutzer anlegen Mit dem Button (New) können Sie einen neuen Benutzer anlegen. Der neue Benutzer erscheint in der Liste mit den Benutzern und kann dann bearbeitet werden. Benutzer bearbeiten Sie können die Daten eines Benutzers bearbeiten, indem Sie diesen in der Liste auswählen. Die Daten werden dann in den rechten Teil des Fensters eingespielt und können bearbeitet werden. Name Name des Benutzers. Mit diesem Namen meldet sich der Entwickler beim Start von Framework Studio am Repository an. Der Benutzername kann auch noch geändert werden, wenn der Benutzer bereits Elemente bearbeitet hat. Password / Confirm Password In diesen Feldern kann das Passwort des Benutzers festgelegt oder geändert werden. Um die Änderungen zu speichern, drücken Sie den Button Save. FCUser (FrameworkCompiler Mode) Ist die Checkbox gesetzt, arbeitet der angegebene Benutzer wie der FrameworkCompiler mit dem Unterschied, dass dieser Benutzer auch auschecken darf. Das bedeutet, dass dieser Benutzer beim Kompilieren den Saved Code und die Assemblies für den FrameworkCompiler in das Repository zurückschreiben darf. Der FrameworkCompiler Mode wurde für folgende Anwendungsfälle konzipiert: Durchführen eines Kompiliervorgangs als FrameworkCompiler mit der direkten Möglichkeit, Korrekturen durchführen zu können – auch in Kombination mit dem Compile Manager (Compile Manager). Das ist z.B. bei einem Package-Update sehr vorteilhaft. Arbeiten im Ein-Benutzer-Betrieb. So können z.B. auch Korrekturen durchgeführt werden, ohne am Ende mit dem FrameworkCompiler erneut kompilieren zu müssen. Bei der Arbeit mit einem Benutzer im FrameworkCompiler Mode (FCUser) müssen einige Richtlinien beachtet werden: Es sollte nur einen FCUser geben. Mit diesem können Sie sich aber durchaus zur selben Zeit an verschiedenen Package-Versionen anmelden. Wenn mit einem FCUser an einer Package-Version gearbeitet wird, dann sollte dies der einzige Benutzer sein, der an dieser Package-Version arbeitet. Weil der FCUser generierten Code zurückschreibt, der sich ggf. auch auf von ihm ausgecheckte Elemente bezieht, kann das für andere Benutzer zu Fehlern führen. In der Zeit, in der mit einem FCUser gearbeitet wird, darf kein FrameworkCompiler laufen. Andernfalls kann es dazu führen, dass sich FCUser und FrameworkCompiler die generierten Codes und Assemblies gegenseitig zerstören. Am Ende der Arbeit sollten wieder alle Elemente eingecheckt und der FrameworkCompiler-Vorgang abgeschlossen werden. FrameworkStudio gibt beim Beenden eine entsprechende Warnmeldung aus. Beenden Sie FrameworkStudio als angemeldeter FCUser ohne \"Complete FrameworkCompiler\", wird folgende Warnung angezeigt. Diese Meldung soll darauf hinweisen, dass der FCUser entgegen unserer Anwendungsfälle verwendet wird. (Diese Warnung gibt keine Auskunft über etwaige Fehler beim Complete FrameworkCompiler.) Benutzer löschen Um einen Benutzer zu löschen, wird dieser markiert und anschließend der Button (Delete) gedrückt. Das Löschen müssen Sie jetzt noch mit dem Button (Save All) bestätigen. Warning Ein Benutzer kann nur dann gelöscht werden, wenn er noch keine Elemente bearbeitet hat. Sollten Sie versuchen einen Benutzer zu löschen, der bereits gearbeitet hat, erscheint eine Fehlermeldung."
  },
  "doc/package-manager/package-manager.html": {
    "href": "doc/package-manager/package-manager.html",
    "title": "Package Manager",
    "keywords": "Package Manager Der Package Manager von Framework Studio ist ein eigenständiges Programm. Mit diesem Tool lassen sich die folgenden Aufgaben rund um Packages erledigen: Anlegen, Löschen und Bearbeiten sowie Import und Export von Packages Exportieren einer Dokumentation im HTML-Format Definition, welche Sprachen eine Anwendung grundsätzlich unterstützen soll Fixierung eines Entwicklungsstandes (Versionierung / Labeling) Verzweigung von Entwicklungspfaden (Branching) Folgende Funktionen stehen sowohl im Package Manager als auch in Framework Studio zur Verfügung: Runtime License Manager (Laufzeitlizenzen) Publish Wizard Publish2Go Wizard Export Wizard für das HTML-Format Start des Package Managers Starten Sie den Package Manager, indem Sie im Programmverzeichnis von Framework Studio die Datei FrameworkStudioPackageManager.exe ausführen. Es erscheint der Dialog zur Auswahl eines Repositories (analog zum Start von Framework Studio). Nach der Repository-Auswahl werden Sie aufgefordert, sich als FrameworkAdministrator anzumelden. Bedienung des Package Managers Nach dem Start des Package Managers erscheint das Hauptfenster. Im Hauptfenster werden über die Toolbar folgende Funktionen angeboten: New Sie erkennen New an einem -Icon. Anlegen eines neuen Packages. Delete Sie erkennen Delete an einem -Icon. Löschen die in der Baumstruktur ausgewählten Package-Version. Package-Versionen dürfen nur mit dem Package Manager der aktuellsten Framework Studio Version gelöscht werden, die im Repository zum Einsatz kommt! Save Sie erkennen Save an einem -Icon. Speichern der Änderungen am ausgewählten Element. Save All Sie erkennen Save All an einem -Icon. Speichern aller Änderungen. Label Sie erkennen Label an einem -Icon. Erzeugt eine neue Package-Version auf gleicher Ebene und versiegelt dabei die Ursprungsversion (Status=sealed). Ausgecheckte Elemente werden dabei in die neue Version übertragen. Beispiel: Label 3.0 => 3.1 Der Status der Ursprungsversion kann anschließend bei Bedarf auf Service-Release oder wieder zurück auf Open gesetzt werden. Branch Sie erkennen Branch an einem -Icon. Erzeugt eine neue Package-Version eine Ebene tiefer und verändert den Zustand der Ursprungsversion dabei nicht. Ausgecheckte Elemente verbleiben in der Ursprungsversion. Beispiel Branch 3.0 => 3.0.2 Hotfix Branch Sie erkennen Hotfix Branch an einem -Icon. Legt für die Package-Version einen neuen Hotfix-Branch an. Beispiel 4.5 => 4.5.hotfix2 Import Package Sie erkennen Import Package an einem -Icon. Importieren einer Package-Version. Nach dem Import ist es in der Regel notwendig, abhängige Package-Versionen zu compilieren bzw. passende Stände von abhängigen Package-Versionen zu importieren. Export Package Sie erkennen Export Package an einem -Icon. Exportieren der ausgewählten Package-Version. Export Service Release Sie erkennen Export Service Release an einem -Icon. Exportiert den Service Release Stand der ausgewählten Package-Version. Dabei werden nur die Änderungen seit dem Eröffnen des Service Release Modus übernommen. Dadurch entstehen deutlich kleinere Dateien als beim normalen Package-Export. Import Service Release Sie erkennen Import Service Release an einem -Icon. Importiert einen Service Release Stand, welcher zuvor mit Export Service Release exportiert wurde. Durch den Import ändert sich der Compile-Stamp nicht, deshalb müssen die abhängigen Package-Version nicht neu compiliert werden. Export Documentation Sie erkennen Export Documentation an einem -Icon. Öffnet den Export Wizard, um die Dokumentation der ausgewählten Package-Version im HTML-Format zu exportieren. Sonstige Tools Über das Menü Tools / Publish / Wizard bzw. Tools / Publish / 2Go kann der Publish- bzw. der Publish2Go-Wizard für die ausgewählte Package-Version aufgerufen werden. Über das Menü Tools / Check Using Hierarchies des Hauptmenüs können die Abhängigkeiten der Packages überprüft werden. Über das Menü Tools / Runtime Licenses Manager kann der Runtime License Manager (Laufzeitlizenzen) für die ausgewählte Package-Version gestartet werden. Checkbox \"Show only applicable packages and versions\" Mit dieser Checkbox werden die Packages gefiltert. Es werden nur noch die zur Auswahl bereitgestellt, welche passende Versionen zur FS-Version haben, die also im geöffneten PackageManager auch bearbeitet werden können."
  },
  "doc/package-manager/package-version.html": {
    "href": "doc/package-manager/package-version.html",
    "title": "Package-Versionen",
    "keywords": "Package-Versionen In der Baumstruktur des Package Managers werden unterhalb eines Packages alle definierten Entwicklungsstände (Versionen) mit dem Symbol für Version dargestellt. Durch Doppelklick auf eine Version wird ein Fenster geöffnet, in dem alle Einstellungen zu der Version vorgenommen werden können. Package Name des Package Herstellers (nicht editierbar). Version Name Bezeichnung der Version. Es wird empfohlen, ausschließlich gültige Versionsnummern in dem Format \"Major.Minor.Build.Revision\" (z.B. 3.11 oder 3.11.1.5) zu verwenden. Es funktionieren auch andere Versions-Bezeichnungen, allerdings können diese dann nicht korrekt sortiert werden. Version ID Die interne ID der Package-Version (nicht editierbar). Product Name Der Name des Produkts. Dieser kann z.B. bei Versions-Informationen innerhalb der End-Anwendung ausgegeben werden. Assembly Prefix Kürzel, welches vor die Assemblies und den internen Elementnamen (Komponenten, Forms, Tabellen, …) gehängt werden soll. Der Assembly Prefix kann nur bearbeitet werden, wenn noch kein Compiler ausgeführt wurde bzw. es noch keinen Workspace für diese Package-Version gibt. Ist das Feld gesperrt, kann diese Sperre mit dem Button Edit aufgehoben werden. Dies hat zur Folge, dass alle Workspaces für diese Package-Version und ALLE davon abhängigen Package-Versionen gelöscht werden. Anschließend müssen alle diese Package-Versionen neu kompiliert werden. Version State: Open: Die Package-Version ist offen und befindet sich in der Entwicklung. Es gibt keinerlei Einschränkungen bei der Arbeit. Bei jedem Compile mit dem FrameworkCompiler / Compile-Wizard wird ein neuer Compile-Stempel erzeugt – das bedeutet, dass alle anhängigen Package-Version ebenfalls neu kompiliert werden müssen. Sealed: Die Package-Version ist versiegelt. Es können keine Änderungen vorgenommen werden. Es kann sich kein Entwickler mehr an dieser Package-Version anmelden. Damit eine Package-Version in den Status Sealed versetzt werden kann, darf nichts mehr ausgecheckt sein und alle Änderungen müssen mit dem FrameworkCompiler / Compile-Wizard kompiliert sein. Service Release: An der Package-Version können nur Änderungen an Methoden-Inhalten vorgenommen werden – es darf keine Schnittstellen-Änderungen mehr geben. Bei einem FrameworkCompiler / Compile-Wizard bleibt der Compile-Stempel erhalten. Dadurch brauchen abhängige Package-Versionen nicht neu kompiliert werden und es ist ein sehr schneller Update möglich. Siehe auch Service-Release-Modus. Der Version State kann jederzeit geändert werden. Dabei werden entsprechende Plausibilitäten geprüft, um eine Fehl-Bedienung zu unterbinden. Button Lock Damit kann eine Package-Version gesperrt werden, damit sich niemand mehr daran anmelden kann. Mit dem Klick erscheint ein Dialog, in dem eine Begründung eingegeben werden kann. Diese Begründung wird im Login-Dialog angezeigt. Falls noch Benutzer angemeldet sind, wird dieser Dialog angezeigt. Hier gibt es die folgenden Möglichkeiten: Cancel: den Vorgang abbrechen. Retry: es erneut versuchen, nachdem z.B. dem Benutzer Bescheid gegeben wurde. Kill User Sessions: die Sitzungen der Benutzer zu beenden. Bei dieser Aktion wird 130 Sekunden gewartet. Das ist die Zeit, die im Extremfall benötigt wird, bis ein Benutzer zum Beenden seiner Sitzung gezwungen wurde. (60 Sekunden bis zur Hinweismeldung + 60 Sekunden bis zum endgültigen Abbruch + 10 Sekunden Reserve) Während dieser Dialog angezeigt wird, können sich keine neuen Benutzer mehr anmelden. Dieser Mechanismus wird automatisch verwendet, um eine Package-Version während eines Upgrades vor einer Benutzung abzusichern. Button Status… Öffnet einen Dialog zum Festlegen einer Statusmeldung, die jedem Nutzer dieser Package Version beim Einloggen und in der Entwicklungsumgebung selbst angezeigt wird. Wird kein Informationstext angegeben, so wird der Status nicht angezeigt. Ansonsten ist er an den unten aufgeführten Positionen in der Entwicklungsumgebung sichtbar. Wird in der Combobox Name ein Status ausgewählt, dann gelten die Einstellungen, die in dem entprechenden Dialog gepflegt sind und es wird, sofern vorhanden, an allen Stellen zusätzlich der als nächstes greifende Status angezeigt. Login Dialog in der Detailbeschreibung zu einer Package Version: Status Bar im FrameworkDesigner: Im Check Out Dialog: Check In Dialog: Bei Status Rot muss im Check-In Dialog zusätzlich eine Begründung eingegeben werden, bevor der Check-In möglich ist. Diese Begründung wird mit dem Zusatz #warning State Red in den Check-In-Kommentar eingefügt. Über den Menüpunkt Tools / Package Versions States im Package Manager wird dieser Dialog geöffnet. Hier können mehrere Package Version Status gepflegt werden. Wenn mehrere Status den selben Namen haben, werden sie dem Datum entsprechend nacheinander aktiv, sofern der Name an einem Package hinterlegt ist. Last Deployment Dieses Datum markiert die letzte Auslieferung der Package-Version. Das ist entscheidend für Änderungen im Service-Release-Modus. Alle Strukturen, die vor diesem Datum angelegt wurden, werden in der IDE vor Änderungen geschützt, damit abhängige Package-Versionen nicht in breaking Changes laufen. Strukturen, die nach diesem Datum neu angelegt wurden, können noch bis zur nächsten Auslieferung geändert werden. Wird der Version State auf Service Release gesetzt, dann markiert dieses Datum automatisch den Start des Service-Release. In der Regel geht das mit der finalen Auslieferung des Releases einher. Findet eine weitere Auslieferung der Package-Version statt (z.B. am Ende eines Service-Release-Zyklus), dann muss das Datum aktualisiert werden. Mit dem Button Start new Service Release cycle wird das Datum auf den letzten erfolgreich abgeschlossenen Compile-Lauf gesetzt. Damit sind dann auch die im aktuellen Zyklus hinzugefügten Strukturen vor zukünftigen Änderungen geschützt. FS Version Framework Studio Version, mit der die Package Version bearbeitet werden kann. (nicht editierbar) Button Upgrade Note nur aktiv, wenn die FS Version der Package-Version kleiner ist als die Version, in der der Package Manager gestartet wurde Für die Package-Version wird ein Upgrade auf die aktuelle Framework Studio Version durchgeführt. Warning Der Upgrade-Vorgang lässt sich nicht rückgängig machen. Das heißt, dass dieses Label mit älteren Framework Studio Versionen nicht mehr verwendet werden kann. Compile Run In diesem Feld kann ein Name eingegeben werden, mit dem über die FSConsole.exe gesteuert werden kann, welche Package-Versionen kompiliert werden sollen. Button Source Ctrl. History … Öffnet die Source Control History für die aktuelle Package Version. Standardmäßig werden hierbei alle Elemente angezeigt. Sowohl eingecheckte als auch ausgecheckte Elemente. Button Compile Wizard Ruft für die Package-Version den Compile Wizard auf. Auf der Registerkarte Using Hierarchy werden die Package Versionen angezeigt, die von dieser Version verwendet werden. Die Versionen werden in der Verwendungsreihenfolge angezeigt. Die Using Hierarchy kann von den Requirements wie folgt abweichen: In der Using Hierarchy können zusätzlich Labels von weiteren Packages aufgeführt werden. Von einem Label in den Requirements kann ein anderes Label des gleichen Packages in der Using Hierarchy aufgeführt werden. Auf der Registerkarte Requirements werden tabellarisch die Abhängigkeiten der Version von anderen Packages bzw. Package Versionen dargestellt, also auf welchen Packages in welcher Version das aktuelle Package aufbaut. Diese Information wird beim Import im Repository abgelegt und ist nicht veränderbar. Die Registerkarte Info stellt interne Informationen zum Kompilierstatus dar. Auf allen Registerkarten befindet sich ein Button Refresh zum Aktualisieren der dargestellten Informationen. Warnings Es besteht die Möglichkeit Warnings, welche der Compiler ausgibt, zu ignorieren. Geben Sie hierfür die entsprechende Warning-Nummer oder Nummern in das Textfeld, getrennt mit einem Komma, ein. Zudem kann auch das Level der Warnings (Level 0 - Level 4) definiert werden. Wird kein Level angegeben, ist es standardmäßig Level 3. Die verschiedenen Warnings können Sie hier einsehen. Die Einstellung wird an die Customizing-Packages vererbt. Sie kann ausschließlich durch Nissen & Velten am eNVenta Package (bzw. einem anderen Default-Package) geändert werden. Base Workspaces freezed since Gibt das Datum an, seit wann die Workspace-Stände der Basis-Packages fixiert sind. Mit dem Button Freeze wird das Datum gesetzt und der aktuelle Zustand fixiert. Wird jetzt für diese Package-Version ein neuer Compile-Wizard ausgeführt, dann werden bei diesem Compile-Lauf exakt dieselben Workspaces der Basis-Package-Version verwendet wie beim letzten erfolgreich abgeschlossenen Compile-Lauf - auch wenn es neuere Stände geben sollte. Dadurch greifen keine neuen Änderungen aus den Basis-Packages. Das Datum kann jederzeit mit dem Button Reset entfernt werden. Dann funktioniert der Compile wieder ganz normal. Dieses Datum greift nur im eigenen Repository. Diese Information wird nicht mit der Package-Version exportiert. Beim Export einer solchen Package-Version ist es ratsam, diese inkl. ihrer Basis-Packages zu exportieren. So ist gewährleistet, dass nach dem Import im Ziel-Repository alle Versions-Stände zusammenpassen. Beim Export wird die Checkbox Include Base Packages automatisch gesetzt. Register Languages Auf dieser Registerkarte können die Sprachen für die Package-Version definiert werden. Eine Sprache besteht aus den folgenden Informationen: Iso-Code: Der ISO 639-1 Code der Sprache. Dieser besteht aus 2 kleinen Buchstaben - z.B. de, en. Name: Der Name der Sprache. Dieser wird in der IDE angezeigt. An einer Package-Version können beliebig viele Sprachen definiert werden. Diese werden automatisch in die abhängigen Package-Versionen vererbt. Warning Auf der Application Startseite werden nur Sprachen angeboten, für die im Wörterbuch mindestens ein MLKey übersetzt ist. Languages from Base Diese Liste zeigt die Sprachen aus den Basis-Packages an. Languages from current Package In dieser Liste können die Sprachen für die Package-Version gepflegt werden. Es können zusätzliche Sprachen definiert werden Wird eine Sprache mit einem identischen Iso-Code wie im Basis-Package angelegt, dann überschreibt der Eintrag das Basis-Package. In der IDE wird dann die überschriebene Bezeichnung der Sprache angezeigt. Note Wird eine Sprache gelöscht, dann bleiben die Übersetzungen an den Records und im Wörterbuch trotzdem erhalten."
  },
  "doc/package-manager/package.html": {
    "href": "doc/package-manager/package.html",
    "title": "Package",
    "keywords": "Package In der Baumstruktur des Package Managers werden alle Packages des Repositories in alphabetischer Reihenfolge auf der ersten Ebene dargestellt. Durch Doppelklick auf ein Package wird ein Fenster geöffnet, in dem grundlegende Eigenschaften des Packages bearbeitet werden können. Package Eigenschaften: Name Name des Packages. Manufacturer Name des Package Herstellers. Owner Ist in der Checkbox ein Haken gesetzt, wird dadurch angezeigt, dass Sie der Eigentümer des Packages sind. Wenn Sie ein neues Package erstellen, sind Sie automatisch der Eigentümer. Warning Der Eigentümer eines Packages ist der einzige, der Lizenzen für ein Package erstellen kann. Diese Eigenschaft kann nicht geändert werden! Wenn man Eigentümer eines Packages ist und dieses zunächst exportiert, um es anschließend wieder zu importieren, ist man nicht mehr Eigentümer des importierten Packages! Package prefix Hier kann ein Präfix angegeben werden, das einheitlich bei allen neu erstellten Elementen in diesem Package dem normalen Namen voran gestellt wird. Dadurch werden Namenskonflikte zwischen verschiedenen Packages vermieden. Beispiel (Package prefix = NV1): Neues Form wird mit dem Namen NV1_frm initialisiert. Damit das Präfix verwendet wird, muss außerdem die im Folgenden beschriebene Checkbox gesetzt sein."
  },
  "doc/package-manager/packages.html": {
    "href": "doc/package-manager/packages.html",
    "title": "Packages",
    "keywords": "Packages Ein Package kapselt funktionale Erweiterungen und Veränderungen der Anwendung. Eine mit Framework Studio erstellte Anwendung setzt sich immer aus mehreren Packages zusammen. Aus welchen Packages letztendlich eine Anwendung zusammengesetzt ist, steht zur Entwicklungszeit eines Packages nicht fest. Klar definiert ist nur, welche Packages vorausgesetzt werden. Einzelne Packages einer Anwendung können von unterschiedlichen Herstellern entwickelt werden und mit Packages anderer Hersteller kombiniert werden. Hauptvorteil des Package-Konzepts von Framework Studio sind die Customizing Möglichkeiten. Kunden und Partnerunternehmen können durch das Hinzufügen eines zusätzlichen Packages die Anwendung nahezu ohne Einschränkungen funktional erweitern und verändern. Dabei sind sogar Erweiterungen an zentralen Datenstrukturen, Datenbanktabellen und Prozessabläufen möglich. SystemPackage Wenn Sie ein leeres Repository anlegen, enthält dieses Repository immer automatisch ein Package mit dem Namen SystemPackage. An diesem Package können Sie sich beim Start von Framework Studio nicht anmelden, da am SystemPackage keine Veränderungen vorgenommen werden können. Das SystemPackage enthält einige grundlegende Namespaces und Elemente, die von jeder Anwendung benötigt werden. Default Package Mit Default Package wird das Package bezeichnet, welches in der Verwendungsreihenfolge der Packages direkt oberhalb des SystemPackages angeordnet ist. Dieses Package hat einige Besonderheiten: Am Default Package werden die Sprachen definiert, die grundsätzlich von der Anwendung unterstützt werden sollen. Verschiedene Default Packages lassen sich mit der aktuellen Framework Studio Version nicht zusammen führen. Im Default Package werden alle Standard Controls (Default Control Styles) angezeigt. Ein Default Package muss mit dem Package Manager (Package Manager) angelegt werden, bevor es genutzt werden kann. Weitere Packages Mit Hilfe des Package Managers (Package Manager) können weitere Packages zu einem Repository hinzugefügt werden. Dort wird auch definiert, in welcher Reihenfolge die Packages benutzt werden sollen und welche anderen Packages Voraussetzung für die Verwendung eines Packages sind. Aktives Package Mit aktivem Package wird das Package bezeichnet, an dem sich der Benutzer beim Start von Framework Studio angemeldet hat. Nur an diesem Package kann der Benutzer Veränderungen durchführen. Synonym dazu wird auch der Begriff Top Package verwendet. Customizing Mit Customizing wird der Vorgang bezeichnet, bei dem man Änderungen an einem Element aus einem Package vornimmt, das nicht das aktive Package ist. Da Änderungen immer nur im aktiven Package durchgeführt werden können, wird dazu von dem gewünschten Element eine Customization im aktiven Package angelegt. An dieser Customization können die gewünschten Änderungen dann vorgenommen werden. Technisch gesehen ist eine Customization eine Ableitung vom originalen Element. Diese Ableitung wird dann in der gesamten Anwendung statt des Originalen Elements verwendet. Das Anlegen einer Customization erfolgt über den Button Customize (Buttons). Warning Wenn ein Element über das Kontextmenü mit der Funktion Change Namespace… in einem anderen Package in einen anderen Namespace verschoben wurde, so muss das Element, wenn eine Customization im aktiven Package existiert, über das Kontextmenü seines Namespaces mit der Funktion Adjust moved customizations … auch im aktiven Package in den neuen Namespace verschoben werden."
  },
  "doc/pbe/aktionen.html": {
    "href": "doc/pbe/aktionen.html",
    "title": "PBE-Aktionen",
    "keywords": "PBE-Aktionen Allgemein Aktionen Die eigentliche Arbeit wird in den Aktionen ausgeführt. Neben der FSConsole.exe können auch allgemeine Aktionen definiert werden. So können z.B. entsprechende Ordner oder Dienste vorbereitet werden. Konten <Batch> Damit kann eine beliebige Batch-Routine ausgeführt werden. Attribute: Name: optional Cmd: erforderlich - gibt den Pfad für eine Exe oder eine Batch-Datei an. Die Angabe sollte mit komplettem Pfad erfolgen. Args: optional - hier können Kommandozeilen-Argumente übergeben werden. Args können auch als XML-Knoten angegeben werden. Diese werden hinter die im Attribut definierten Args gepackt. Das ist praktisch bei komplexeren Listen von Kommandozeilen-Argumenten. PBE kümmert sich dabei um die korrekte Behandlung von Leerzeichen und Anführungszeichen. Liefert die aufgerufene Routine einen Exit-Code != 0, dann wird der Vorgang als Fehlerhaft beendet. Wird als Cmd=\"robocopy\" aufgrufen, dann führen die Exit-Codes 1-7 nicht zu einem Fehler (vergleiche auch https://learn.microsoft.com/troubleshoot/windows-server/backup-and-storage/return-codes-used-robocopy-utility) Beispiele: <Batch Name=\"IIS neu starten\" Cmd=\"iisreset\"/> <Batch Name=\"IIS beenden\" Cmd=\"NET\" Args=\"STOP W3SVC\"/> <Batch Name=\"IIS starten\" Cmd=\"NET\" Args=\"START W3SVC\"/> <!-- MyProgram.exe Param1 \"Param2 mit Leerzeichen\" C:\\temp\\export --> <Batch Name=\"Individuelle Aktion\" Cmd=\"MyProgram.exe\" Args=\"Param1\"> <Args> <Arg>Param2 mit Leerzeichen</Arg> <Arg>{ExportDir}</Arg> </Args> </Batch> Knoten <MD> Legt ein neues Verzeichnis an. Attribute: Name: optional Dir: erforderlich - Der anzulegende Ordner Beispiel <MD Dir=\"{ExportDir}\"/> Knoten <RD> Löscht ein Verzeichnis samt ihrem Inhalt. Attribute: Name: optional Dir: erforderlich - Der zu löschende Ordner Beispiel <RD Dir=\"{ExportDir}\"/> FSConsole-Aktionen Kern dieser Routine ist die Arbeit mit der FSConsole.exe. Dazu werden folgende Aktionen angeboten. Knoten <FSConsole> Startet eine FSConsole.exe Attribute Name: optional FS: erforderlich - gibt die Version von Framework-Studio an. \"3.8.0.0\", \"3.7.0.0\", ... Rep: erforderlich - gibt das Repository an, mit dem gearbeitet werden soll Args: erforderlich - gibt die weiteren Kommandozeilen-Parameter an. Wie beim Konten <Batch> können auch Args in Form eines XML-Knoten angegeben werden. Knoten <CompileRun> Führt mithilfe der FSConsole.exe einen Compile-Run durch Attribute: Name: optional FS: erforderlich (siehe oben) Rep: erforderlich (siehe oben) Run: erforderlich - Gibt den Compile-Run an. Dieser kann im Package-Manager an der Package-Version gepflegt werden. MaxParallel: optional - (ab FS 3.6) gibt an, wie viele Compiler innerhalb des CompileRuns parallel laufen dürfen. Beispiel: <!--Führt den CompileRun \"1\" für Framework-Studio 3.8 aus.--> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep1}\" Run=\"1\"/> Knoten <Export> Exportiert ein Package. Dieses wird in dem Ordner abgelegt, der im Parameter ExportDir angegeben wird. Der Name der Datei setzt sich aus dem Namen des Packages und der Version zusammen. Attribute: Name: optional FS: erforderlich (siehe oben) Rep: erforderlich (siehe oben) Package: erforderlich - gibt den Namen des zu exportierenden Packages an Version: erforderlich - gibt den Namen der zu exportierenden Package-Version an Mode: optional - wenn ein Bugfix / ServiceRelease exportiert werden soll, muss Mode=\"Bugfix\" angegeben werden Queue: optional - Der Name der Import-Queue, mit der dieser Export wieder importiert werden soll. Siehe auch Knoten <ImportQueue> Dir: optional - der Ordner, in dem die Export-Dateien abgelegt werden sollen, falls dieser vom Parameter {ExportDir} abweicht. ExportFileName: optional - der Dateiname ohne Dateiendung, der für die Export-Datei verwendet werden soll. Wird dieses Attribut nicht angegeben, dann wird ein Dateiname nach folgendem Schema erzeugt: {ExportFilePrefix}<Package>_<Version> (FS <fs-version>). Der Dateiname kann Parameter beinhalten. IncludeBasePackages: optional - gibt an ob Basis-Package in den Export eingeschlossen werden sollen. Mögliche Werte: ServiceRelease - analog zum Package-Manager Unsealed - analog zum Package-Manager All - alle kompletten Base-Packages Konten <Import> Importiert ein Package. Ordner und Dateinamen werden wie beim Export verwendet. Die Attribute müssen zum Knoten <Export> passen. Bei der Verwendung der <ImportQueue> wird diese Aktion automatisch von der PBE.exe erzeugt. Attribute: Name: optional FS: erforderlich (siehe oben) Rep: erforderlich (siehe oben) Package: erforderlich - gibt den Namen des zu exportierenden Packages an Version: erforderlich - gibt den Namen der zu exportierenden Package-Version an Mode: optional - wenn ein Bugfix / ServiceRelease exportiert werden soll, muss Mode=\"Bugfix\" angegeben werden Dir: optional - der Ordner, aus dem die Export-Dateien gelesen werden sollen, falls dieser vom Parameter {ExportDir} abweicht. Knoten <ApprovedExport> Arbeitet wie der Konten <Export> mit folgenden Unterschieden: Wenn nicht über das Attribut Dir anders definiert, dann wird für den Export-Ordner der Parameter {ApprovedExportDir} verwendet. Das Attribut Queue steht nicht zur Verfügung. Konten <ApprovedImport> Importiert alle im Ordner enthaltenen Dateien in das angegebene Repository. Nach erfolgreichem Import werden die Dateien in das {HistoryDir} verschoben. Wenn dieser Ordner nicht angegeben ist – weder als Parameter noch als Attribut – dann werden die Dateien nach dem Import gelöscht, damit sie beim nächsten Lauf nicht noch einmal importiert werden. Bei der Verarbeitung wird für jeden Import ein separater Import-Vorgang protokolliert. Die FS-Version wird aus dem Dateinamen ermittelt. Dieser muss z.B. so aussehen: 2014-11-10_FSDemo_3.9 (FS 3.9).db. Beim Export wird bereits ein passender Dateiname erzeugt. Dieser sollte nicht verändert werden. Attribute: Name: optional Rep: erforderlich (siehe oben) Dir: optional - der Ordner, aus dem die zu importierenden Dateien gelesen werden sollen, falls dieser vom Parameter {ApprovedImportDir} abweicht. HistoryDir: optional - der Ordner, in den die Dateien nach erfolgreichen Import verschoben werden sollen, falls dieser vom Parameter {ApprovedHistoryDir} abweicht. Knoten <Publish> Führt einen Publish-Vorgang aus. Attribute: Name: optional FS: erforderlich (siehe oben) Rep: erforderlich (siehe oben) Package: erforderlich - gibt den Namen des zu exportierenden Packages an Version: erforderlich - gibt den Namen der zu exportierenden Package-Version an Setting: erforderlich - Name des Settings. Dieses muss im Publish-Wizard vorbereitet und abgespeichert werden. Knoten <Publish2Go> Führt einen Publish2Go-Vorgang aus. Attribute: Name: optional FS: erforderlich (siehe oben) (ab FS 3.11.8) Rep: erforderlich (siehe oben) Package: erforderlich - gibt den Namen des zu exportierenden Packages an Version: erforderlich - gibt den Namen der zu exportierenden Package-Version an Setting: erforderlich - Name des Settings. Dieses muss im Publish-Wizard vorbereitet und abgespeichert werden. Im Setting muss der Folder angegeben sein Dieser darf für den Publish2Go keinen Inhalt haben. Knoten <ExportDoc> Exportiert die komplette Dokumentation der Package-Version im HTML-Format. Attribute: Name: optional FS: erforderlich (siehe oben) (ab FS 3.11.8) Rep: erforderlich (siehe oben) Package: erforderlich - gibt den Namen des zu exportierenden Packages an Version: erforderlich - gibt den Namen der zu exportierenden Package-Version an Iso: erforderlich - der Iso-Code der zu exportierenden Sprache – z.B. „de“ oder „en“ Dir: optional - der Ordner, in dem die Dokumentation abgelegt werden soll, falls dieser vom Parameter {ExportDir} abweicht. Für den Export wird ein Unter-Ordner mit dem folgenden Format erzeugt: {ExportFilePrefix}_<Package>_<Version>_Help_<Iso> Beispiel: ExportDir\\2016-09-17_eNVenta_3.7_Help_de\\... ExportDBTables: optional - sollen die Tabellen-Beschreibungen exportiert werden, dann muss ExportDBTables=\"1\" angegeben werden. UseLicense: optional - wenn dieser Parameter(UseLicense=\"1\") gesetzt ist, wird die Runtime-Lizenz aus dem Setting verwendet, welches via Setting=\"SETTING_NAME\" übergeben wird. In der Folge wird nur der Teil der Dokumentation exportiert, der mit der Runtime-Lizenz sichtbar ist. Setting: erforderlich, wenn UseLicense=\"1\" gesetzt ist - Name des Settings. Dieses muss im Run-Wizard vorbereitet und abgespeichert werden. Args: optional - Weitere Kommandozeilen-Argumente, die zusätzlich übergeben werden sollen. So können zukünftige Features integriert werden. Wie beim Konten <Batch> können auch Args in Form eines XML-Knoten angegeben werden."
  },
  "doc/pbe/beispiel.html": {
    "href": "doc/pbe/beispiel.html",
    "title": "Beispiel PBE.xml",
    "keywords": "Beispiel PBE.xml Die folgende Konfiguration stellt beispielhaft einen etwas komplexeren Ablauf mit mehreren FS-Versionen und Repositories dar. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <!DOCTYPE PBE SYSTEM \"PBE.dtd\"> <PBE Logfile=\"C:\\temp\\Log.html\" Logarchive=\"C:\\temp\\Archive\\Log_{DateTime}.html\"> <FSVersions> <FSVersion FS=\"3.7.0.0\" Dir=\"C:\\Programme\\Framework Systems\\FrameworkStudio 3.7.3\"/> </FSVersions> <Params> <Param Name=\"ExportDir\" Value=\"E:\\temp\\export\\\"/> <Param Name=\"rep1\" Value=\"\\ConnectionType SqlServer \\Server NV261 \\Database FSDemo37\"/> <Param Name=\"rep2\" Value=\"\\ConnectionType SqlServer \\Server NV261 \\Database FSDemo37Imp\"/> </Params> <Sequence> <RD Name=\"letztes Export-Dir löschen\" Dir=\"{ExportDir}\"/> <MD Name=\"Export-Dir neu anlegen\" Dir=\"{ExportDir}\"/> <Parallel Name=\"Compile Repository 1\"> <ImportQueue QueueName=\"ImportQueue\" Rep=\"{rep2}\"/> <Sequence Name=\"Compile-Lauf FS 3.7\"> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep1}\" Run=\"1\"/> <Export FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.2\" Queue=\"ImportQueue\"/> <Export FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.2\" Queue=\"ImportQueue\"/> </Sequence> <Sequence Name=\"Compile-Lauf FS 3.8\"> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep1}\" Run=\"1\"/> <Export FS=\"3.8.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.3\" Queue=\"ImportQueue\"/> <Export FS=\"3.8.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.3\" Queue=\"ImportQueue\"/> </Sequence> </Parallel> <Parallel Name=\"Compile Repository 2\"> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep2}\" Run=\"1\"/> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep2}\" Run=\"1\"/> <Condition Name=\"Sonntags-Compile\" Value=\"{Weekday}\" Equals=\"So\"> <Parallel> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep2}\" Run=\"Sonntag\"/> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep2}\" Run=\"Sonntag\"/> </Parallel> </Condition> </Parallel> <Sequence Name=\"Publish\"> <Batch Name=\"IIS beenden\" Cmd=\"NET\" Args=\"STOP W3SVC\"/> <Parallel Name=\"Publish\" MaxTasks=\"2\"> <Publish FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.2\" Setting=\"Cust1_Setting1\"/> <Publish FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.2\" Setting=\"Cust1_Setting2\"/> <Publish FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.2\" Setting=\"Cust2_Demo\"/> </Parallel> <Batch Name=\"IIS wieder starten\" Cmd=\"NET\" Args=\"Start W3SVC\"/> </Sequence> </Sequence> </PBE>"
  },
  "doc/pbe/commandline-parameter.html": {
    "href": "doc/pbe/commandline-parameter.html",
    "title": "PBE - Kommandozeilen-Parameter",
    "keywords": "PBE - Kommandozeilen-Parameter -a / --auto Automatischer Mode. Zur Absicherung gegen versehentliches Ausführen verlangt die PBE.exe beim Start eine Bestätigung durch den Benutzer. Wird dieser Parameter angegeben, erfolgt die Ausführung ohne Rückfrage. Bei einer automatisierten Ausführung (z.B. über einen geplanten Task) muss dieser Parmater angegeben werden. Beispiel: PBE.exe -a PBE.exe --auto -c / --config Definiert die Konfigurations-Datei. Der Paramter is optional. Wird der nicht angegeben, wird die Datei PBE.xml im Programm-Verzeichnis verwendet. Beispiel: PBE.exe -c C:\\temp\\MyPBE.xml PBE.exe --config C:\\temp\\MyPBE.xml -p / --param Definiert Parameter-Werte, die in die Routine übergeben werden. Diese werden in der Konfiguration bei den Parametern berücksichtigt. Die hier angegebenen Parameter-Werte haben eine höhere Priorität als die Konfigurations-Datei. Sie Überschreiben auch die Standard-Parameter wie z.B. Weekday oder Title. Important Es können nur Parameter \"überschrieben\" werden, die in der Konfiguration definiert sind oder als Standard-Parameter exisiteren. Frei definierte Parameter werden NICHT berücksichtigt. Die Paramater werden in folgendem Format übergeben: Parameter und Wert werden mit = getrennt: --param Param1=Wert1 Mehrere Parameter werden mit einem Semikolon (;) getrennt: --param Param1=Wert1;Param2=Wert2 Enthält ein Parameter-Wert ein Semikolon, dann muss dieses doppelt geschrieben werden: --param MyValue=Ein;;Semikolon Beispiel (einen Wochenend-Lauf simulieren): PBE.exe -p Weekday=Sa;ExportDir=C:\\temp\\TestExport PBE.exe --param Weekday=Sa;ExportDir=C:\\temp\\TestExport -l / --logDir Gibt das Verzeichnis an, in dem die Log-Dateien geschrieben werden sollen. Beispiel: PBE.exe -c C:\\temp\\MyPBE.xml -l C:\\temp\\LogFiles PBE.exe --config C:\\temp\\MyPBE.xml --logDir C:\\temp\\LogFiles -f / --filter Es werden die Namen der Tasks angegeben, die ausgeführt werden sollen. Es können auch Tasks in einer tieferen Ebene angegeben werden. Die Umschließenden Tasks werden automatisch mit in die Ausführung eingeschlossen. Mehrere Filter werden mit einem Doppelpunkt (:) getrennt. Beispiel: PBE.exe -f Task1:Task2 PBE.exe --filter Task1:Task2"
  },
  "doc/pbe/config.html": {
    "href": "doc/pbe/config.html",
    "title": "Konfiguration der PBE",
    "keywords": "Konfiguration der PBE Die Konfiguration erfolgt mithilfe der Datei PBE.xml. Diese wird am besten mit Visual Studio bearbeitet, weil es dort eine IntelliSense-Unterstützung und eine Validierung der Eingaben gibt. Programm-Verzeichnisse Für die unterschiedlichen FS-Versionen werden die Programm-Verzeichnisse ermittelt. Dabei geht die Routine für jede FS-Version mit den folgenden Prioritäten vor und verwendet das Verzeichnis, welches zuerst gefunden wird: Konfiguration in der XML-Datei Beispiel: <FSVersions> <FSVersion FS=\"4.7.0.0\" Dir=\"C:\\Programme\\enventa Group\\Framework Studio\\4.7\"/> <FSVersion FS=\"4.8.0.0\" Dir=\"C:\\Programme\\enventa Group\\Framework Studio\\4.8\"/> </FSVersions> Order C:\\FS\\Framework Studio X.Y.0.0\\ - das ist der Standard im Haus von Nissen & Velten. Standard Installations-Verzeichnis %ProgramFiles%\\enventa Group\\Framework Studio\\X.Y Altes Standard Installations-Verzeichnis (bis zur Version 4.6) %ProgramFiles%\\Framework Systems\\Framework Studio X.Y Dabei werden auch ServiceRelease- und Beta-Versionen erkannt. Parameter Für eine einfachere Konfiguration wird mit Parametern gearbeitet. Diese werden am Anfang der Datei angegeben. Unterhalb des XML-Knoten <Params> werden die Parameter mit <Param>-Knoten aufgelistet. Diese Parameter können bei den Aktionen verwendet werden. Dazu müssen sie in geschweiften Klammern geschrieben werden: {parameter} Beispiel: <Params> <Param Name=\"ExportDir\" Value=\"E:\\temp\\export123\\\"/> <Param Name=\"rep\" Value=\"\\ConnectionType SqlServer \\Server NV261 \\Database FSDemo37 \\DBUser sa \\DBPassword sql2005\"/> </Params> <Sequence> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep}\" Run=\"1\"/> </Sequence> Die im Folgenden aufgelisteten Parameter sind immer gefüllt: ExportDir Beinhaltet einen Ordner, in dem die Dateien der Package-Exporte abgelegt werden. Die Package-Importe werden ebenfalls in diesen Ordner gesucht. Dieser Parameter wird bei den Aktionen <Export> und <Import> automatisch verwendet. ApprovedExportDir Beinhaltet einen Ordner, in dem die Dateien der Approved Package-Exporte abgelegt werden. Dieser Parameter wird bei der Aktion <ApprovedExport> automatisch verwendet. ApprovedImportDir Beinhaltet einen Ordner, in dem die Dateien abgelegt werden, die mit der Aktion <ApprovedImport> verbarbeitet werden sollen. ApprovedHistoryDir Beinhaltet einen Ordner, in den die Dateien verschoben werden, nachdem sie mit der Aktion verbarbeitet wurden. Date Start-Datum im Format \"yyyyMMdd\" z.B. 20140526 DateTime Start-Zeit im Format \"yyyyMMdd-HHmmss\" z.B. 20140526-142457 DateTimeText Start-Zeit im Format \"yyyy-MM-dd HH:mm (dddd)\" z.B. 2014-05-26 14:24 (Montag) ExportFilePrefix Start-Datum mit dem Format \"yyyy-MM-dd_\" z.B. 2014-05-26_ Dieses Präfix wird vor den Dateinamen der Export-Dateien gestellt. So haben die Dateinamen dasselbe Format wie es auch der Package-Manager beim Export vorschlägt. z.B. 2014-05-26_eNVenta_3.4.db Weekday Aktueller Wochentag in Deutsch: Mo, Di, Mi, Do, Fr, Sa, So Kann z.B. in einer <Condition> verwendet werden um wöchentliche Aktionen zu definieren. Title Hat standardmäßig den Wert \"Nachtlauf {DateTimeText}\". Dieser Parameter kann bei Bedarf überdefiniert werden. Machine Name des Rechners (Environment.MachineName) Darüber hinaus können auch eigene Parameter definiert werden. So können z.B. die verwendeten Repository-Connections an zentraler Stelle definiert werden. Bei Parametern kann auch auf vorher definierte Parameter verwiesen werden – wie z.B. bei dem vordefinierten Parameter Title. Tip Alle bekannten Parameter können der PBE.exe mit dem Kommandozeilen-Parameter -p / --param übergeben und so \"überschrieben\" werden. Organisation Die Aktionen werden in der XML-Datei als Sequenzen oder Parallel-Verarbeitungen organisiert. Die unterschiedlichen Knoten können beliebig ineinander verschachtelt werden. Einzige Ausnahme ist der oberste Knoten – dieser muss immer <Sequence> sein. Jeder Knoten kann Optional ein Attribut \"Name\" erhalten. Dieser Name wird in der Protokoll-Datei ausgegeben. Konten <Sequence> Alle darunter aufgeführten Aktionen werden nacheinander verarbeitet. In der Protokoll-Datei werden die Einträge untereinander ausgegeben. Attribute: Name: optional Knoten <Parallel> Alle darunter definierten Aktionen werden parallel verarbeitet. In der Protokoll-Datei werden die Einträge nebeneinander ausgegeben. Attribute: Name: optional MaxTasks: optional - gibt die Anzahl der maximal parallel ausgeführten Aktionen an. Bei einer sehr langen Liste an Aktionen macht es Sinn, die Parallelität z.B. auf 4 zu begrenzen. Important Wenn dieses Attribut nicht angegeben ist, erfolgt die Verarbeitung komplett parallel – egal wie viele Aktionen definiert wurden. Konten <Condition> Arbeitet wie eine <Sequence> - die darunter aufgeführten Aktionen werden nacheinander ausgeführt. Die Ausführung erfolgt aber nur dann, wenn die beiden Attribute \"Value\" und \"Equals\" denselben Wert haben. Attribute: Name: optional Value: erforderlich – gibt den linken Wert für den Vergleich an. Üblicherweise wird hier ein Parameter angegeben - z.B. \"{Weekday}\" Equals: erforderlich – gibt den Wert an, mit dem verglichen werden soll – z.B. \"So\". Im Value können verschiedene Funktionen verwendet werden: \"#EXISTS(<dateipfad>)\" Prüft, ob eine Datei oder ein Ordner existiert. Diese Funktion liefert den Wert \"True\" oder \"False\". Der Dateipfad kann auch Parameter beinhalten. Beispiel: <Condition Name=\"Prüfen ob Publish2Go existiert\" Value=\"#Exists({InputDir}\\sqlitedb.p2go)\" Equals=\"True\"> \"#CONTAINS_FILES(<verzeichnispfad>)\" Prüft, ob das Verzeichnis einen Inhalt hat. Diese Funktion liefert \"True\", wenn das Verzeichnis einen Inhalt (Datei / Verzeichnis) hat und \"False\" wenn es leer ist. Der Verzeichnispfad kann auch Parameter beinhalten. Beispiel: <Condition Name=\"Prüfen ob das Export-Verzeichnis leer ist\" Value=\"#CONTAINS_FILES({ExportDir}\\Package2)\" Equals=\"False\"> Knoten <ImportQueue> Damit können die Package-Importe so organisiert werden, dass diese parallel zu anderen Aktionen durchgeführt werden können. Die Export-Aktionen packen, wenn sie fertig sind, entsprechende Import-Aktionen in diese Queue. Diese wird dann sofort mit der Abarbeitung beginnen. Dabei werden aber alle Importe nacheinander verarbeitet, weil parallele Importe auf einem Repository nicht möglich sind. Attribute: Name: optional QueueName: erforderlich – gibt den Namen der Queue an. Diese kann bei einer <Export>-Aktion verwendet werden. Rep: erforderlich – gibt das Repository an, in dem die Packages importiert werden sollen. Beispiel Es laufen parallel 2 Compile-Läufe und Exporte auf Repository1. Daneben werden zeitgleich die Exporte in Repository2 importiert. Beispiel: <Parallel> <ImportQueue QueueName=\"ImportQueue\" Rep=\"{rep2}\"/> <Sequence Name=\"Compile-Lauf FS 3.7\"> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep1}\" Run=\"1\"/> <Export FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.2\" Queue=\"ImportQueue\"/> <Export FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.2\" Queue=\"ImportQueue\"/> </Sequence> <Sequence Name=\"Compile-Lauf FS 3.8\"> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep1}\" Run=\"1\"/> <Export FS=\"3.8.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.3\" Queue=\"ImportQueue\"/> <Export FS=\"3.8.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.3\" Queue=\"ImportQueue\"/> </Sequence> </Parallel>"
  },
  "doc/pbe/pbe.html": {
    "href": "doc/pbe/pbe.html",
    "title": "Parallel Batch Engine (PBE)",
    "keywords": "Parallel Batch Engine (PBE) Die Parallel Batch Engine ist eine Routine, die es ermöglicht eine Batch-Verarbeitung zu automatisieren. Neben der Ausführung normaler Batch-Verarbeitung ist sie dafür optimiert, die FSConsole.exe von Framework Studio zu steuern und so Compile-Läufe, Package-Exporte, Package-Exporte und Publish-Aktionen auszuführen. Weitere Kern-Funktionen sind die parallele Verarbeitung und das erzeugen und Archivieren einer Log-Datei. Arbeitsweise Ausgeliefert wird diese Routine zusammen mit Framework Studio. Sie ist im Programm-Verzeichnis von Framework Studio im Unterordner PBE abgelegt. Das Programm besteht aus folgenden Dateien: PBE.exe - Das eigentliche Programm PBE.xml - hier wird die Konfiguration vorgenommen PBE.dtd - beinhaltet die Schema-Definition für die PBE.xml LogTemplate.htm - Vorlage für die Protokoll-Datei Wenn die Konfiguration in der Datei PBE.xml vorgenommen wurde, dann kann die Routine durch ausführen der Datei PBE.exe gestartet werden. Es wird die XML-Datei ausgewertet und die darin konfigurierten Schritte werden alle abgearbeitet. Dabei wird ein Protokoll in Form einer HTML-Datei erzeugt. Dieses beinhaltet neben den Informationen, wann welche Aktion gestartet wurde und wie lange sie gedauert hat, auch das während der jeweiligen Aktion erzeugte Protokoll. Das Protokoll wird während der Ausführung regelmäßig aktualisiert. So kann man sich auch ein Bild vom Fortschritt der Aktion machen. PBE ist dafür konzipiert in einem Lauf mit mehreren Versionen von Framework Studio parallel zu arbeiten. Unterstützt werden alle Versionen ab Framework Studio 3.2. Protokoll Die Routine erzeugt ein Protokoll. In dem Haupt-Knoten <PBE> kann eingestellt werden, wohin das Protokoll geschrieben werden soll. In jeder Protokoll-Datei wird ein Link Previous Logfile erzeugt, in dem jeweils auf das vorherige \"archivierte\" Protokoll verwiesen wird. So kann man sich einfach durch die Protokolle klicken. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <!DOCTYPE PBE SYSTEM \"PBE.dtd\"> <PBE Logfile=\"U:\\eNVenta\\Nacht\\Compile\\Log.html\" Logarchive=\"U:\\eNVenta\\Nacht\\Compile\\Archiv\\{DateTime}.html\"> <Params> <Param Name=\"ExportDir\" Value=\"C:\\PackageExport\\\"/> Logfile: gibt den Pfad der Protokoll-Datei an. In Netzwerk-Umgebungen macht es Sinn, das Protokoll auf einem Netzlaufwerk abzulegen, so kann sie z.B. einfach über eine interne Web-Seite verlinkt werden. Logarchive: gibt an, wo die Historischen Protokolle gespeichert werden sollen. Dabei ist es sinnvoll den Parameter {DateTime} in den Dateinamen einzubauen, um einen eindeutigen Namen zu erhalten."
  },
  "doc/print-server/config.html": {
    "href": "doc/print-server/config.html",
    "title": "Konfiguration Print-Server",
    "keywords": "Konfiguration Print-Server Registerkarte Printers Mit dem Link Add new Printer wird ein neuer Drucker angelegt. Es erscheint eine Drucker-Auswahl der auf dem Rechner installierten Drucker. Wählen Sie den gewünschten Drucker aus. Feld ID Hier wird die ID des Druckers angegeben. Diese wird automatisch erzeugt. Dabei handelt es sich um eine eindeutige Guid. Mit dem Link Generate ID kann eine neue ID generiert werden. Note Wird die ID nachträglich geändert, verlieren andere Programme die Zuordnung zu diesem Drucker. Feld Name Dieser Name wird in Framework-Studio-Anwendungen ausgegeben. Dieser Name ist frei wählbar und muss nicht mit dem physikalischen Namen des Druckers in Verbindung stehen. Der Name kann auch nachträglich geändert werden, weil die Zuordnung des Druckers über die ID erfolgt. Feld Path Bei Path wird der physikalische Name des Druckers angegeben. Mit dem Link Choose Printer können Sie diesen neu definieren. Mit dem Link Choose Folder kann ein Datei-Ordner ausgewählt werden. In diesen werden dann die Dokumente abgelegt. Dadurch wird der Typ des Druckers zu [Folder] geändert. Im Feld Path wird dann der Datei-Pfad angezeigt. Weitere Informationen dazu finden Sie im Feature Druck in einen Ordner. Feld Paper Source Hier können Sie den Schacht angeben, der zum Druck verwendet werden soll. Paper Source 1st Page(s) Hier können Sie bei Bedarf für die ersten Seiten eine abweichende Papier-Quelle angeben. Standardmäßig zieht diese Einstellung für die erste Seite. Wenn der Drucker z.B. für Duplex-Druck konfiguriert ist, dann kann die Anzahl der Seiten auf 2 gesetzt werden, damit das erste Blatt beidseitig bedruckt wird. Wenn hier ein Wert definiert ist, der von Paper Source abweicht, dann wird der Druck in 2 Schritten ausgeführt. Das kann die Verarbeitungsgeschwindigkeit verringern. Beim Ausdruck von mehreren Kopien wird der Druck in mehreren Schritten durchgeführt, damit die Reihenfolge der Seiten gewährleistet ist: ersten Seiten mit Schacht 1, Folgeseiten mit Schacht 2, ersten Seiten mit Schacht 1, Folgeseiten mit Schacht 2, usw. Wir dem Ausdruck als Start die Seite 2 oder höher übergeben, dann erfolgt der komplette Ausdruck auf dem Standard-Schacht. Note Der Schacht (Paper Source und Paper Source 1st Page) wird nur beim Ausdruck mit DevExpress® Reports berücksichtigt. Registerkarte Database Connection Geben Sie hier die gewünschte Verbindung zu der Datenbank an, in der die Druckdaten abgelegt werden. Standardmäßig wird dazu das Runtime Repository Ihrer Anwendung verwendet. Bei Query Interval geben Sie den Rhythmus an, mit dem der Print-Service auf der Datenbank nach neuen Druckaufträgen schaut. Die Angabe hat das Format hh:mm:ss.millisekunden - Beispiel: 00:00:01.5000000 sind 1,5 Sekunden. Registerkarte Service Feld Name Dieser Name wird in Framework-Studio-Anwendungen ausgegeben. Feld ID Die eindeutige ID des Print-Service. Bei der Installation können Sie mit dem Link Generate ID eine neue ID erzeugen. Feld URL Die URL können Sie mit dem Link Set Default auf den eigenen Rechnernamen setzen. Dort ist auch z.B. eine IP-Adresse möglich. Es kann auch ein anderer Port als 20002 verwendet werden. Dann müssen auch die Konfigurationen der Clients, die mit dem Service kommunizieren sollen, auf den geänderten Port angepasst werden. Falls Sie auf einem Server mehrere Print-Services installieren, muss jeder Print-Service einen anderen Port erhalten. Feld Private Key, Public Key Für Private Key und Public Key müssen Sie mit dem Link Generate Keypair ein neues Schlüsselpaar generieren. Feld Culture gibt an, mit welchen Ländereinstellungen der Print-Service arbeiten soll. Diese Einstellung zieht beim Verarbeiten von Crystal Reports. Wenn hier nichts angegeben ist, dann ziehen die Standard-Einstellungen des Rechners. Beispiele: de-DE de-CH en-US Feld Log File Hier kann eine Datei angegeben werden, in der detaillierte Informationen protokolliert werden sollen. Das sind dieselben Informationen, die bei Start mit /Console in das Konsolen-Fenster ausgegeben werden. Zusätzlich werden die einzelnen Protokoll-Einträge mit einem Zeit-Stempel versehen. Der Benutzer, mit welchem der Service gestartet wird, muss Schreibrechte für diese Datei besitzen. Checkbox Delete Printjobs after Processing Wenn diese Checkbox gesetzt ist, dann löscht der Printserver die Druckjobs nach der Verarbeitung. Diese Aktion ist Bestandteil der Verarbeitung eines Jobs. Es wird also nur der aktuelle Printjob gelöscht. Der Druckjob muss die folgenden Bedingungen erfüllen: Es wurden keine PDF-Dateien für die Archivierung generiert (in diesem Fall kümmert sich eNVenta ERP im Archiv-Pool um das Löschen). Der Druckjob war erfolgreich (Status = 3). Das Löschen wird in das detaillierte Protokoll ausgegeben. Nach einem Update muss der Schalter explizit gesetzt werden. Feld Export Folder Wenn definiert, dann werden alle Druck-Jobs, die über den Print-Service verarbeitet werden, zusätzlich in diesen Ordner gespeichert. Dies kann bei der Analyse von Problemen helfen. Feld Trace Folder Wenn angegeben, dann werden in diesen Ordner Trace-Informationen des Print-Servers gespeichert. Diese Dateien können mit dem Session Trace Analyzer gelesen werden. Registerkarte Windows-Service Hier können nur Änderungen vorgenommen werden, solange der Service nicht installiert worden ist. Warning Ändern Sie diese Einstellungen auch niemals manuell in der Datei PrintService.exe.config. Ansonsten kann der Print-Service dem Windows-Dienst nicht mehr zugeordnet werden. Wenn Sie diese Einstellung nachträglich ändern möchten, dann müssen Sie: den Dienst mit dem Link stop beenden, den Dienst mit dem Link uninstall Service deinstallieren, die Änderungen vornehmen und speichern und den Dienst mit dem Link install Service wieder installieren. Dabei sollte der Benutzer-Account des Dienstes wieder der von vorher sein – ggf. vor der ganzen Aktion merken. Siehe auch Installation. Feld Service Name Unter diesem Namen wird der Service in den Windows-Diensten registriert. In dem Feld können Sie einen Namenszusatz angeben. Das ist vor allem dann notwendig, wenn Sie mehrere Print-Services auf einem Rechner installieren, da der Name in den Windows-Diensten eindeutig sein muss. Feld Description Diese wird als Description in den Windows-Diensten gespeichert. Registerkarte Print Adapter Hier können die vom Print-Service unterstützen Print-Adapter aktiviert und konfiguriert werden. Details dazu sind auf der Seite Print-Adapter ausgeführt. Registerkarte Runtime Supervisor Hier kann angegeben werden, an welchem Runtime Supervisor sich der Print-Service registrieren soll. Nähere Informationen dazu sind in der Dokumentation des Runtime Supervisor zu finden. Checkbox Enable Diese Checkbox muss gesetzt werden, damit der Runtime Supervisor aktiviert wird. Feld Runtime Supervisor Url Hier können der Server und der Port angeben werden. Die vollständige URL wird automatisch aufgebaut. Mit dem Button Test kann versucht werden, ob eine Verbindung zum Runtime Supervisor aufgebaut werden kann."
  },
  "doc/print-server/features.html": {
    "href": "doc/print-server/features.html",
    "title": "Features im Print-Server",
    "keywords": "Features im Print-Server Konsole Sie können den Print-Service auch als Konsole-Anwendung starten. Dazu kann einfach die Datei PrintService.exe gestartet werden. Ein PrintService darf generell nur einmal gestartet sein. Also entweder als Dienst oder mit der Konsole. Bevor Sie die Konsole-Anwendung starten, stellen Sie sicher, dass der Dienst gestoppt oder deaktiviert ist. Anmerkung: Es ist aber durchaus möglich VERSCHIEDENE PrintServices auf einem Rechner parallel zu betreiben. Jeder dieser Services darf aber nur einmal laufen. Beim Start mit der Konsole werden detaillierte Informationen zum Status und zu den Print-Jobs ausgegeben. Das kann sehr hilfreich sein, um z.B. das Verhalten des PrintServices oder auch Fehler zu analysieren. Die Ausgaben auf der Konsole haben denselben Inhalt wie die Protokoll-Datei. Wenn der Service als Konsole-Anwendung gestartet wird, werden die Informationen sowohl in der Konsole als auch, wenn konfiguriert, in der Protokoll-Datei ausgegeben. Prüfungen beim Start Der PrintService führt beim Start Überprüfungen durch. Sind Drucker verfügbar? Es wird geprüft, ob die angegebenen Drucker auch als Windows-Drucker verfügbar sind. Der Print-Server registriert ja alle Drucker im Repository. Diese werden dann von der Applikation (z.B. eNVenta) verwendet. Wenn ein Drucker nicht verfügbar ist, wird eine Warnung in das Ereignis-Protokoll geschrieben, Es wird eine Information in die Protokoll-Datei geschrieben und der Drucker wird mit dem Präfix ##ERROR## in das Repository geschrieben. So können Sie auch in der Anwendung sehen, wenn der Print-Service einen Drucker nicht ansprechen kann. Wenn der Drucker aufgrund technischer Probleme nicht korrekt arbeitet, kann der PrintService keinen Fehler erzeugen. Das schlägt dann ggf. erst bei der Verarbeitung des Druckjobs auf. Sind die Print-Adapter richtig konfiguriert? Word, Excel Adapter: Es wird geprüft, ob Word oder Excel verfügbar ist. Bei der Prüfung wird die Version in die Protokoll-Datei geschrieben. Im Fehlerfall wird in die Protokoll-Datei geschrieben und es wird eine Warnung in das Ereignis-Protokoll geschrieben. Wenn Sie kein Word oder Excel verwenden, dann können die entsprechenden Adapter auch aus der Config-Datei entfernt werden. Entsprechende Print-Jobs werden in diesem Fall ignoriert. PDF-Adapter: Es wird geprüft, ob die in der Config definierte Programm-Datei existiert. Wenn nicht, wird die Protokoll-Datei geschrieben und eine Warnung in das Ereignis-Protokoll. Wenn Sie keine PDF-Dateien verarbeiten, dann können Sie diesen Adapter auch aus der Config-Datei entfernen. Entsprechende Print-Jobs werden in diesem Fall ignoriert. Druck in einen Ordner Wenn man mit dem Link Choose Folder den Drucker in einen [Folder] geändert hat, können Sie im Anschluss den Pfad manuell bearbeiten. Tip Bei der Angabe des Ordners können auch UNC-Pfade (z.B. \\\\Server\\Freigabe\\) verwendet werden. Es ist zwingend darauf zu achten, dass der Dienst mit einem Benutzer läuft, der entsprechende Schreib-Rechte für diese Freigabe hat. Note Netzlaufwerke sind hingegen NICHT zu empfehlen, weil diese – wenn der Print-Service als Dienst gestartet wird – evtl. nicht zur Verfügung stehen. Durch die Verwendung von Platzhaltern kann der Pfad dynamisch aufgebaut werden. Folgende Platzhalter können verwendet werden: Platzhalter Beschreibung {date} Datum des Drucks mit dem Format yyyy-MM-dd z.B. 2012-05-30 {time} Zeit des Drucks im Format HHmmss z.B. 121037 (für 12:10:37) {owner} Benutzer, der den Druck durchgeführt hat. Der Dateiname wird folgendermaßen generiert: Crystal Report Adapter Dateiname: <ReportName>_<PrintJob-ID>.PDF Beispiel: Invoice_61b7ad1bb4304b40a7758f02f888e614.PDF Wenn nicht bereits im Ordner verwendet, werden dem Dateinamen noch die Platzhalter in der folgenden Reihenfolge vorangestellt: {date}_{time}_{owner}_<dateiname> Beispiel-Konfiguration Es soll pro Tag ein neuer Ordner angelegt werden und darunter pro Mitarbeiter ein weiterer eigener Ordner. Konfigurierter Ordner (Folder): \\\\Fileserver1\\Ausdrucke\\{date}\\Server1\\{owner}\\ Es werden z.B. folgende Ordner generiert: \\\\Fileserver1\\Ausdrucke\\2012-05-30\\Server1\\User1\\ \\\\Fileserver1\\Ausdrucke\\2012-05-30\\Server1\\User2\\ Es werden die Dateien im folgenden Format angelegt: {time}_<ReportName>_<PrintJob-ID>.PDF ({date} und {owner} werden schon im Ordner verwendet und deshalb nicht in den Dateinamen gepackt) Beispiele für Dateien 121037_Invoice_61b7ad1bb4304b40a7758f02f888e614.PDF 182026_CallList_2a0af0b92b7f418483b5ab0801727453.PDF"
  },
  "doc/print-server/installation.html": {
    "href": "doc/print-server/installation.html",
    "title": "Installation Print-Server",
    "keywords": "Installation Print-Server Requirements Die Requirements für den Print-Server sind in der Liste der Requirements enthalten. Update Wenn ein bestehender Print-Service mit einer neuen Version aktualisiert werden soll, dann befolgen Sie bitte die folgenden Schritte. Die Installation eines neuen Print-Service ist weiter unten beschrieben. Bitte prüfen Sie vor dem Update, ob alle Requirements in der korrekten Version installiert sind. Sichern Sie das aktuelle Programm-Verzeichnis. Jetzt müssen Sie den Dienst deinstallieren. Note Sehen Sie ggf. nach, mit welchem Benutzer der Dienst im Moment läuft (unter Systemsteuerung, Verwaltung, Dienste). Dieser Benutzer muss später bei der Installation der neuen Version wieder angegeben werden. Starten sie das Programm PrintServiceConfigEditor.exe und drücken sie nacheinander die beiden Links stop und uninstall Service und beenden Sie dann den Config-Editor. Wenn noch eine ältere Version im Einsatz ist, welche keinen PrintServiceConfigEditor besitzt, dann führen Sie die Datei Service_uninstall.bat aus. Kopieren Sie den Inhalt des Ordners bin\\ in den Zielordner. Ersetzen Sie alle vorhandenen Dateien. Note Mit dieser Kopier-Aktion wird eine Datei Template_PrintService.exe.config in den Programm-Ordner kopiert. Unbedingt die Datei PrintService.exe.config aus dem alten (gesicherten) Programmverzeichnis weiterverwenden. Starten Sie das Programm PrintServiceConfigEditor.exe und prüfen Sie, ob alle Einstellungen korrekt sind. Es kann durch den Update Änderungen in der config-Datei geben, die dazu führen, dass Änderungen gespeichert werden müssen. Mit Klick auf den Link install Service wird das Programm wieder als Dienst im Betriebssystem registriert. Die darauffolgenden Schritte sind identisch mit der Installation (siehe unten). Installation Bitte prüfen Sie vor der Installation, ob alle Requirements installiert sind. Erstellen Sie den Zielordner für den Service Empfehlung: C:\\Programme\\Framework Systems\\PrintService\\ Kopieren Sie den Inhalt des Ordners bin\\ in den Zielordner. Jetzt müssen Sie die Konfiguration des Services festlegen. Führen Sie dazu im Zielordner das Programm PrintServiceConfigEditor.exe aus. Dieses Programm bearbeitet den Inhalt der Konfigurations-Datei PrintService.exe.config. Beim ersten Aufruf des Configuration-Editors wird die Datei Template_PrintService.exe.config automatisch in PrintService.exe.config umbenannt. Informationen zur Konfiguration von Datenbankverbindung und Drucker finden Sie auf der separaten Seite Konfiguration. Bitte führen sie diese wie gewünscht durch. Jetzt müssen Sie das Programm als Dienst im Betriebssystem registrieren. Klicken Sie dazu den Link install Service. Es öffnet sich ein Fenster, welches den Fortschritt der Installation anzeigt. Fehler, die bei der Installation auftreten, werden in diesem Fenster ausgegeben. Während der Installation des Services wird folgendes Fenster angezeigt: Geben Sie hier den Benutzer an, mit welchem der Dienst ausgeführt werden soll. Es wird empfohlen nach Möglichkeit einen Domain-User anzugeben, der Zugriff auf die Drucker des Rechners hat. Im Idealfall dürfte dies der angemeldete Benutzer sein. Wählen Sie dazu User aus und geben sie in User credentials die Benutzerdaten an. Der User muss im Format Domain\\User angegeben werden. Je nach Konfiguration des Systems kann ggf. auch eines der Systemkonten verwendet werden. Diese Routine erzeugt einige Protokoll-Dateien über den Installationsverlauf im Zielordner. Diese sind kein Problem. Schließen Sie das Installations-Fenster mit dem Button Close. Wenn die Installation erfolgreich verlaufen ist, dann wird im Anschluss angezeigt, dass der Dienst läuft. Im oberen Teil des Fensters sollten Sie folgendes Bild sehen: Mögliche Gründe für das Fehlschlagen der Installation: Die Konfiguration ist fehlerhaft. Starten Sie ggf. die PrintServiceConfigEditor.exe erneut und prüfen Sie die Angaben. Der angegebene Benutzer hat nicht die notwendigen Rechte. Prüfen Sie ggf. das Ereignisprotokoll. Deinstallation Starten Sie das Programm PrintServiceConfigEditor.exe Stoppen Sie den Dienst mit dem Link stop Mit dem Link uninstall Service wird der Windows Dienst deinstalliert. Nach einer Rückfrage startet die Deinstallation und es wird wie bei der Installation ein Dialog mit dem Fortschritt angezeigt. Auch hier werden bei Problemen Fehlermeldungen ausgegeben. Wenn die Deinstallation abgeschlossen ist, kann dieser Dialog mit dem Button Close beendet werden. Anschließend wird angezeigt, dass der Service nicht installiert ist. Beenden Sie den Configuration-Editor und löschen Sie den Zielordner. Warning Dabei gehen die Einstellungen aus der Konfigurations-Datei PrintService.exe.config verloren. Sichern Sie diese Datei ggf. für eine spätere Verwendung. David Fax für Faxversand Installieren Sie auf dem PrintService-Rechner ein Tobit Infocenter. Setzen Sie den neu angelegten Tobit Faxware Drucker als Standarddrucker ein. Falls noch nicht vorhanden, installieren Sie ein Microsoft Word in der Version 2003, 2007, 2010 oder 2013 auf dem PrintService-Rechner. Legen Sie im Abschnitt Printers den neuen Fax-Drucker an. a. Legen Sie mit Add new Printer einen neuen Fax-Drucker an. b. Es erscheint eine Drucker-Auswahl der auf dem Rechner installierten Drucker. Wählen Sie den Drucker Tobit Faxware aus. c. Für den Faxware Drucker wird eine Registerkarte angelegt. d. Markieren Sie die Checkbox Use Word (for Fax Printers). Bei Name geben Sie den Namen des neuen Fax-Druckers an. Dieser Name wird in Framework-Studio-Anwendungen ausgegeben. Dieser Name ist frei wählbar und muss nicht mit dem physikalischen Namen des Druckers in Verbindung stehen. Hier im Beispiel haben wir den Namen Tobit Fax gewählt. Bei Path wird der physikalische Name des Fax-Druckers angegeben, hier Tobit Faxware. Bei Paper Source können Sie den Schacht angeben, der zum Druck verwendet werden soll. Diese Einstellung ist hier erst einmal nicht von Interesse. Der Schacht wird nur beim Ausdruck mit CrystalReports berücksichtigt. Speichern Sie die neuen Einstellungen über Save Changes. Starten Sie anschließend den PrintService-Dienst einmal mit dem Link restart durch. Der Fax-Drucker steht nun in eNVenta ERP zur Verfügung und kann benutzt werden."
  },
  "doc/print-server/print-adapter.html": {
    "href": "doc/print-server/print-adapter.html",
    "title": "Print-Adapter",
    "keywords": "Print-Adapter Auf der Register-Karte Print-Adapter können diese bearbeitet und konfiguriert werden. Es folgt eine Aufstellung der standardmäßig zur Verfügung stehenden Print-Adapter. DEVEXPRESS Mit diesem Adapter können DevExpress® Reports (.repx) gedruckt werden. Assembly: DevExpressPrintAdapter Class: PrintServer.DevExpressPrintAdapter In der Drucker-Warteschlange erhalten die Ausdrucke einen Namen mit dem im folgenden Format: DevExpress - <owner> - <JobID> - <Report-Name> <owner> entspricht der Spalte PRTR_Owner in der Tabelle rptRun_PrintTransaction <Report-Name> entspricht der Spalte RPQRPT_NAME in der Tabelle rptRun_RPQReportFile Settings ExportFolder: Diese Einstellung kann optional zu Test- oder Debug-Zwecken angegeben werden. Es werden alle Reports nach dem Druck als PRNX-Datei (Report-Datei inkl. Daten) in diesem Ordner abgelegt. Beispiel: ExportFolder = C:\\temp\\PRNX-Files IMAGE Der IMAGE-Adapter dient zum Drucken von Bildern. Assembly: ImagePrintAdapter Class: PrintServer.ImagePrintAdapter Settings: -keine- PDF Mit diesem Adapter können PDF-Dateien an den Drucker gesendet werden. Der Adapter verwendet ein externes PDF-Programm zur Verarbeitung der PDF-Dateien. In diesem Adapter kann ein beliebiges Kommandozeilen-Programm verwendet werden. Für den Einsatz von Sumatra PDF, Foxit Reader oder Acrobat Reader sollte bei Class auf entsprechend optimierten Adapter umgestellt werden (siehe unten). Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter Settings ReaderPath: Dateipfad des PDF-Programms. Diese Einstellung muss angegeben werden. Beispiel: ReaderPath = C:\\Programme\\Adobe\\Reader 9.0\\Reader\\AcroRd32.exe ReaderArgs: Die Kommandozeilen-Argumente zur Ansteuerung des PDF-Programms. Darin können die Platzhalter {file} und {printer} benutzt werden. PDF - Sumatra PDF Dieser PDF-Adapter ist speziell für den Sumatra PDF Reader optimiert. Um diesen einzusetzen, muss beim PDF-Adapter die Class PrintServer.PdfPrintAdapter_SumatraPDF angegeben werden. Sumatra PDF ist ein einfacher, schlanker PDF-Viewer für Windows. Er kann von der Home-Page des Herstellers http://www.sumatrapdfreader.org heruntergeladen werden. Es gibt eine Installations-Routine und eine portable Version, welche lediglich aus der SumatraPDF.exe besteht. Im Normalfall kann die 32-Bit Version verwendet werden. Die 32-Bit Version hat eine etwas bessere Performance als die 64-Bit Version. Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter_SumatraPDF Settings ReaderPath: Die SumatraPDF.exe der portablen Version kann direkt in das Print-Service-Verzeichnis gepackt werden. In diesem Fall braucht kein Reader-Path angegeben werden. Wird die installierte Version von Sumatra PDF verwendet, muss der Pfad angegeben werden. Beispiel: ReaderPath = C:\\Program Files\\SumatraPDF\\SumatraPDF.exe ReaderArgs: Wenn nicht angegeben, dann wird die folgende Standard-Einstellung verwendet: ReaderArgs = -print-to \"{printer}\" \"{file}\" -exit-on-print PDF - Foxit Reader Dieser Adapter ist speziell für den Foxit Reader optimiert. Um diesen einzusetzen, muss beim PDF-Adapter die Class PrintServer.PdfPrintAdapter_FoxitReader angegeben werden. Der Foxit-Reader kann über die Homepage des Herstellers heruntergeladen werden: https://www.foxitsoftware.com/de/products/pdf-reader/ Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter_FoxitReader Settings ReaderPath: Dateipfad des Foxit Reader. Diese Einstellung muss angegeben werden. Beispiel: ReaderPath = C:\\Program Files (x86)\\Foxit Software\\Foxit Reader\\FoxitReader.exe ReaderArgs: Wenn nicht angegeben, dann wird die folgende Standard-Einstellung verwendet: ReaderArgs = /t \"{file}\" \"{printer}\" Timeout: Zeitdauer in ms, die angibt, wie lange gewartet werden soll, bis der FoxitReader-Prozess beendet wird. Der Standard-Wert ist 2000 ms. Wird der PrintService als Dienst ausgeführt, dann kann es sein, dass die FoxitReader.exe nach dem Druck nicht automatisch schließt. Nach Ablauf dieses Timeouts wird ein alternativer Versuch unternommen, den Reader zu schließen. Wenn der Timeout zu kurz bemessen ist, denn wird die FoxitReader.exe zu früh geschlossen und es wird kein Ausdruck erzeugt. Für die Ermittlung eines passenden Wertes ist es sinnvoll, sich durch mehrere Tests an einen Minimal-Wert heranzutasten. Dieser sollte dann mit genug Reserve als Einstellung verwendet werden. Z.B. minimal 300 ms – Einstellung 500 ms. Beispiel: Timeout = 2000 PDF - Acrobat Reader Dieser Adapter ist für den Adobe Acrobat Reader DC optimiert. Um diesen einzusetzen, muss beim PDF-Adapter die Class „PrintServer.PdfPrintAdapter_AcrobatReader“ angegeben werden. Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter_AcrobatReader Settings ReaderPath: Dateipfad des Acrobat Reader. Diese Einstellung muss angegeben werden. Beispiel: ReaderPath = C:\\Program Files (x86)\\Adobe\\Acrobat Reader DC\\Reader\\AcroRd32.exe ReaderArgs: Wenn nicht angegeben, dann wird die folgende Standard-Einstellung verwendet: ReaderArgs = /t /n /h \"{file}\" \"{printer}\" WORD Mit diesem Adapter können Word-Dateien (.doc / .docx) an den Drucker gesendet werden. Assembly: MsOfficePrintAdapter Class: PrintServer.WordPrintAdapter Warning Word hat die Einschränkung, dass es nicht von einem Dienst-Programm gesteuert werden kann / darf. Aus diesem Grund ist der WORD-Adapter standardmäßig deaktiviert. Wird der Word-Adapter aktiviert, dann sollte der Print-Service nur im Console-Modus ausgeführt werden. Settings StaticApp: Optional - mögliche Werte 0 oder 1 Beispiel: StaticApp = 1 Standardmäßig wird für jeden Druck eine eigene Instanz von Word geöffnet. Wenn der Wert mit 1 angegeben ist, dann wird beim ersten Druck eine Word-Instanz geöffnet, die auch für alle folgenden Drucke verwendet wird. Diese Einstellung kann die Performance verbessern, sie kann aber auch die Stabilität des Print-Service verringern. EXCEL Mit diesem Adapter können Excel-Dateien (.xls / .xlsx) an den Drucker gesendet werden. Assembly: MsOfficePrintAdapter Class: PrintServer.ExcelPrintAdapter Warning Der EXCEL-Adapter ist standardmäßig deaktiviert. Wird der EXCEL-Adapter aktiviert, dann sollte der Print-Service nur im Console-Modus ausgeführt werden. Settings -keine-"
  },
  "doc/publish-wizards/auto-publish.html": {
    "href": "doc/publish-wizards/auto-publish.html",
    "title": "AutoPublish",
    "keywords": "AutoPublish Framework Studio bietet eine Möglichkeit, Anwendungen vollständig automatisiert über die Kommandozeile zu publishen. So können Publish- / Publish2Go-Vorgänge z.B. per Batch in der Nacht angestoßen werden. Dabei gibt es die Möglichkeit, ein bestimmtes Setting direkt aus dem Repository heraus zu publishen oder einen automatisierten Publish-Vorgang von einem Publish2Go-Paket anzustoßen. Beide Möglichkeiten werden im Folgenden beschrieben. AutoPublish mit FSConsole Um mit FSConsole.exe ein Setting publishen zu können, muss dieses in Framework Studio als öffentliches Setting gespeichert werden. Auf dem Panel „End“ befindet sich der Button „Save Setting“. Im Dialog einen entsprechenden Namen eingeben und das Setting speichern. „Save as personal“ darf nicht aktiviert sein, da sonst das Setting vom FrameworkCompiler (welcher den AutoPublish durchführt) nicht gefunden wird. Ist das Setting gespeichert, kann der Konsolenbefehl für den AutoPublish vorbereitet werden. Folgende Parameter müssen übergeben werden: \\Publish Initiiert den AutoPublish-Vorgang \\ConnectionType „SqlServer“ oder „Oracle“ \\Server Name oder IP des Datenbankservers \\Database Name der Datenbank \\DBUser Datenbank-User (z.B. „sa“) \\DBPassword Passwort des Users \\Package Name des zu publishenden Packages \\Version Package Version, die gepublished werden soll \\Setting Öffentliches Setting, welches gepublished werden soll \\Logfile (optional) Pfad mit Dateiname des Logfiles Beispiel FSConsole.exe \\Publish \\ConnectionType SqlServer \\Server NVDBServer \\Database eNVenta \\DBUser dbadmin \\DBPassword dbadminpw123 \\Package Themes \\Version 1.0 \\Setting “AutoPublishSetting” \\Logfile “C:\\AutoPublish.log” Note Bei einer Oracle-Verbindung werden DBUser und DBPassword nicht benötigt (TNSNAMES). Warning Wird vom AutoPublish-Vorgang erkannt, dass das ausgewählte Setting schon gepublished ist, wird automatisch ein Revoke durchgeführt und die Installation gelöscht bevor der AutoPublish-Vorgang angestoßen wird. AutoPublish mit Publish2Go Da beim Publish2Go kein Repository verfügbar ist, sieht die Vorbereitung etwas anders aus. Hier wird ein exportiertes Setting benötigt. Ein Setting kann entweder über den Publish Wizard in Framework Studio oder direkt mit dem Publish2Go Wizard des Pakets erstellt werden. Im Panel „End“ kann über den Button „Save Setting“ das aktive Setting als *.p2gosetting Datei auf die Festplatte exportiert werden. Runtime-Lizenzen, die vom AutoPublish-Vorgang mit installiert werden sollen, müssen sich im Root-Ordner des Publish2Go-Pakets befinden (auf Höhe der Datei „sqlitedb.p2go“). Das Setting wird als Parameter an die Publish2Go.exe übergeben und muss somit nicht zwingend im Root-Ordner liegen. Folgende Parameter müssen übergeben werden: | | | |:-------------|:------------------| | \\Publish | Initiiert den AutoPublish-Vorgang| | \\Setting | Pfad zum Setting, welches gepublished werden soll| | \\Logfile (optional) | Pfad mit Dateiname des Logfiles | Beispiel Publish2Go.exe \\Publish \\Setting “C:\\Publish2Go\\AutoPublishSetting.p2gosetting” \\Logfile “C:\\AutoPublish.log” Note Wird vom AutoPublish-Vorgang erkannt, dass das ausgewählte Setting schon gepublished ist, wird automatisch ein Revoke durchgeführt und die Installation gelöscht bevor der AutoPublish-Vorgang angestoßen wird."
  },
  "doc/publish-wizards/load-balancing.html": {
    "href": "doc/publish-wizards/load-balancing.html",
    "title": "Load Balancing",
    "keywords": "Load Balancing Framework Studio bietet die Möglichkeit, eine Lastenverteilung über mehrere Broker hinweg zu definieren. Im Beispiel werden 3 Applications veröffentlicht. In der Application „ThemesApplication“ sind die anderen zwei Broker als Load Balancing Broker hinterlegt. Diese können auf demselben oder auf einem ganz anderen Server laufen. Startet ein User die Application „ThemesApplication“ wird er von diesem Broker auf einen der anderen verwiesen und kommuniziert von nun an mit dem zugewiesenen Broker. User 1 startet die Anwendung „ThemesApplication“. Der Client sendet einen ersten Request. Der Broker (Verteiler) erkennt, dass zwei andere Broker als Load Balancing Broker hinterlegt sind und wird dem Client im ersten Response im Round Robin Verfahren eine der beiden Broker-Adressen übergeben. Ab diesem Zeitpunkt wird der Client von User 1 seine Requests nur noch an den vom Verteiler zugewiesenen Broker senden. Auf welchem Broker der jeweilige Client gerade arbeitet, ist in der Titelleiste des JavaClients ersichtlich. Note Bei einem Update der Applikationen sollte darauf geachtet werden, dass auch der Verteiler Broker aktualisiert wird, da der JavaClient einige Daten vom Broker erhält. Warning Wenn mehrere Broker auf demselben Server veröffentlicht werden, sollte darauf geachtet werden, dass diese in unterschiedlichen Application Pools laufen, da ein Pool ab ca. 4GB Speicherauslastung spürbar langsamer werden kann Load Balancing hat keinen Effekt mehr."
  },
  "doc/publish-wizards/publish-wizard.html": {
    "href": "doc/publish-wizards/publish-wizard.html",
    "title": "Publish Wizard",
    "keywords": "Publish Wizard Der Publish-Wizard wird verwendet, wenn mit Framework Studio entwickelte Applikationen und Dienste (Service Hosts) lokal veröffentlicht (installiert) werden sollen. Gestartet wird der Publish-Wizard über den Menüeintrag Tools / Publish Wizard. Der Publish-Wizard arbeitet grundsätzlich wie bei Wizards üblich. Man kann sich mit den Buttons Back und Next durch die verschiedenen Einstellungen navigieren. Um gezielt eine bestimmte Einstellung zu ändern kann man diese auch direkt über den Baum anwählen. Button Restore Default Settings: Sämtliche Einstellungen, die im Publish-Wizard definiert wurden, werden verworfen. Damit wird alles auf die Default-Einstellungen zurückgestellt. Die Default-Einstellungen werden aus der FSDomain gelesen. Button Back, Next: Zur vorherigen bzw. nächsten Einstellung navigieren. Button Publish: Installiert die Umgebung. Es werden die Applications und Services auf dem Rechner installiert. Siehe auch Registerkarte End Button Close: Schließt den Publish-Wizard. Die geänderten Einstellungen werden in dem aktuellen User-Setting gespeichert. Start Installation Name Hier muss ein eindeutiger Name für die Installation angegeben werden. Das ist vor allem dann wichtig, wenn man mehrere verschiedene Umgebungen installieren möchte. Framework Studio merkt sich unter diesen Namen alle erzeugten Verzeichnisse und Dienste. Wird eine Umgebung erneut gepublished, dann wird erst alles, was unter diesem Namen installiert wurde entfernt, bevor die neuen Dateien rausgeschrieben werden. Standardmäßig wird der Name des aktuellen Packages vorbelegt. Windows Service Prefix Wenn Services als Windows Dienst installiert werden, dann muss Framework Studio diesen Diensten einen eindeutigen Namen geben. Als Dienst-Name wird der Name des Services verwendet. Damit bei mehreren unterschiedlichen Installationen auf einem Rechner die Dienst-Namen eindeutig bleiben, kann man hier einen Prefix angeben, der dem Dienst-Namen vorangestellt werden soll. Standardmäßig wird der Name des aktuellen Packages vorbelegt. Server-Culture Hier kann eine Culture definiert werden (z.B: de-DE, de-CH oder en-US) mit der die Anwendung ausgeführt werden soll. Dies wirkt sich auf Culture-spezifische Aktionen wie z.B. Zahlen- und Datums-Formate aus. Erfolgt keine Angabe, dann wird die Culture des Betriebssystems verwendet. Client-Timeout Der Java-Client meldet sich in der Regel alle 2 Minuten beim Server - auch wenn der Benutzer keine Aktionen ausführt. Bleiben diese Meldungen aus beendet der Broker die entsprechende Session nach dem definierten Timeout. Dadurch werden Lizenzen und Ressourcen freigegeben, wenn ein Benutzer z.B. seinen Rechner ausschaltet ohne den Client zuvor zu beenden. Der Standard-Wert ist 5 Minuten. Logging / Tracing Hier kann definiert werden, ob und in welche Ordner protokolliert werden soll. Warning Beide Protokollierung erzeugen große Daten-Mengen. Die Protokolle sollten nur gezielt in konkreten Situationen aktiviert werden. Checkbox Session Trace: Diese Checkbox aktiviert das Session Trace. Dazu muss ein entsprechender Folder angegeben werden, in dem die Daten protokolliert werden sollen. Ist die Checkbox nicht gesetzt, dann hat ein ggf. definierter Ordner keine Funktion. Checkbox Broker XML: Ist diese Checkbox gesetzt, dann werden alle Broker-Requests und Responses als XML-Datei gespeichert. Das kann hilfreich sein um ganz konkrete Probleme im Detail zu analysieren. Dazu muss ein entsprechender Folder angegeben werden, in dem die Daten protokolliert werden sollen. Ist die Checkbox nicht gesetzt, dann hat ein ggf. definierter Ordner keine Funktion. Warning In den XML-Dateien sind ALLE Daten enthalten, die ein Benutzer am Client eingibt und angezeigt bekommt. Das kann auch benutzerbezogene und sensible umfassen - insbesondere in produktiven Umgebungen. Button Revoke Release Mit diesem Button wird die komplette Umgebung deinstalliert. Dabei wird alles das deinstalliert, was unter dem angegebenen Installations-Namen installiert wurde. Button Configure Servernames Mit diesem Button wird ein Dialog geöffnet, mit dem Server, welche einen vom internen Namen abweichenden externen Namen haben, konfiguriert werden können. Mit dem Button New wird in der linken Listbox ein neuer Eintrag angelegt. Dort werden alle Server mit ihrem internen Namen aufgeführt. Mit dem Button Delete wird der Eintrag, den Sie in der linken Listbox ausgewählt haben, gelöscht. Im Eingabefeld Internal server name kann der interne Name bzw. die IP-Adresse für den Eintrag angegeben werden, den Sie in der linken Listbox ausgewählt haben. Im Eingabefeld Existing external server names werden zu einem Eintrag, den Sie in der linken Listbox ausgewählt haben, alle externen Servernamen angegeben. Gibt es mehrere externe Namen für einen Server, so müssen die Namen dort getrennt durch Zeilenumbrüche eingegeben werden. Mit dem Button OK werden alle Änderungen bestätigt und der Dialog geschlossen. Mit dem Button Cancel werden alle Änderungen verworfen. Button Session Logging Analyzer Dieser Button öffnen den Session Logging Analyzer und meldet ihn automatisch am Runtime-Repository an. Connection Groups Hier können die Verbindungseinstellungen für die verschiedenen Connection Groups definiert werden. Die RuntimeConnection ist die Verbindung zum Repository. Combobox Registerkarte Database: Hier kann eine Registerkarte Database ausgewählt werden. Die Angaben aus der Registerkarte Database werden entsprechend angezeigt. Diese Angaben werden dynamisch aus den Registered Databases gelesen. Wenn sich also dort die Angaben ändern, werden diese auch hier verwendet. Button Individual: Mit diesem Button kann man eine individuelle Verbindung definieren. Die Felder für die Verbindungsdaten werden freigeschaltet und können entsprechend definiert werden. Note Diese Daten gehen verloren, wenn aus der Combobox eine Datenbank ausgewählt wird. Wenn eine Verbindung häufiger verwendet wird, dann ist es empfehlenswert, dafür eine Registerkarte Database anzulegen und diese dann hier auszuwählen. Authentication Hier können die Grundeinstellungen für die Authentication definiert werden. Im Eingabefeld Default User wird der Name des Benutzers angegeben, der bei eingeschalteter Authentifizierung von der mit Framework Studio erstellten Applikation automatisch verwendet wird, solange noch gar kein Benutzer authentifiziert wurde. Im Eingabefeld Default Password wird das Password des Default Benutzers angegeben. Im Eingabefeld Public Key (Auth. Service) wird der öffentliche Schlüssel des Authentifizierungsdienstes angegeben, der von den Applikationen und Service Hosts verwendet werden soll. Wenn der Authentifizierungsdienst läuft, kann der öffentliche Schlüssel des Authentifizierungsdienstes mit dem Button Get key from Auth. Service vom Dienst erfragt werden und wird automatisch in das Eingabefeld übernommen. Im nicht editierbaren Eingabefeld Auth. Service Address wird die Adresse angezeigt, unter der alle Applikationen und Service Hosts, die mit Authentifizierung arbeiten, den Authentifizierungsdienst ansprechen. Diese Einstellung kann am AuthService Proxy geändert werden. Um zum AuthService Proxy zu wechseln, kann der Link Button Configure Auth. Service Proxy verwendet werden. Runtime Licenses Hier werden die zu verwendenden Laufzeitlizenzen konfiguriert. Die Lizenzkonfiguration kann mit dem Button Change configuration geändert werden. Siehe Laufzeitlizenzen Applications Hier können alle Applikationen konfiguriert werden. Application properties Title: Name der Applikation. Dieser wird später im Anwendungsfenster und in der Task Leiste des Betriebssystems als Bezeichnung der Applikation angezeigt. Service Name: Name der Applikation. Unter diesem Namen wird im IIS ein Verzeichnis für die Applikation registriert. Der Name darf nur alphanumerische Zeichen und den Unterstrich enthalten. Service Address: Ist die Checkbox nicht gesetzt, wird die Serviceadresse, unter der das Applikationsverzeichnis erreichbar ist, automatisch vorbelegt. Ist die Checkbox gesetzt, kann die Service Adresse manuell angegeben werden. Insbesondere, wenn die externe Adresse des Servers von dem eigenen Namen des Servers abweicht, muss hier eine manuelle Eingabe durchgeführt werden. Bei abweichender externer Adresse muss diese hier eingetragen werden, gefolgt von einem Schrägstrich „/“ und dem Service Name. Die interne Adresse wird dann automatisch aus den Einstellungen unter Start ermittelt. Directory: Verzeichnis, in dem die Applikationsdateien abgelegt werden sollen. Der IIS muss mindestens lesend auf dieses Verzeichnis zugreifen dürfen. Mit dem Button … wird ein Ordner-Auswahldialog geöffnet. Server Culture: Kultureinstellung, die im Server verwendet werden soll. Diese hat beispielsweise Auswirkungen auf „ToString()“ Methoden im Applikationscode. Configuration: Hier können in einer Xml Struktur Parameterwerte angegeben werden, die der Applikation beim Start mit übergegeben werden und in der Programmlogik über das GlobalObject ausgewertet werden können. Enable Java Web Start: Damit kann auf der Client Start Page die Client-Option Java Web Start ein- oder ausgeblendet werden. Note Benutzerdefiniertes XML wird weder von FS, noch während der Laufzeit geparst oder auf Validität/Wohlgeformtheit geprüft. Registerkarte Authentication Enabled: Nur dann, wenn in dieser Checkbox ein Häkchen gesetzt ist, wird die Applikation mit Authentifizierung gestartet. Nur dann sind auch die weiteren Einstellungen zur Authentifizierung zugänglich. Name: Name der Applikation, mit der sich die Applikation am Authentifizierungsdienst anmelden soll. Description: Beschreibung der Applikation. ID: Eindeutige Identifikationsnummer der Applikation. Diese wird mit dem Button Generate New Identity zufällig erzeugt. Public Key, Private Key: Öffentlicher und privater Schlüssel der Applikation. Die Schlüssel werden vom Authentifizierungsdienst verwendet, um diese Applikation zweifelsfrei zu identifizieren. Die Schlüssel werden mit dem Button Generate New Identity zufällig initialisiert. Generate New Identity: Für die Applikation wird eine neue Identität generiert. Durch diesen Vorgang werden ID, Public Key und Private Key mit zufälligen Werten gefüllt. Registerkarte Images Auf der Registerkarte Images können Hintergrundbild (Background Image), Startbild (Start Image) und das Icon der Applikation angepasst werden. Dafür stehen die Buttons und Reset zur Verfügung. Mit dem Button wird ein Dateiauswahldialog geöffnet. Mit dem Button Reset wird das jeweilige Bild auf die Standardeinstellung zurückgesetzt. Registerkarte Load Balancing Auf der Registerkarte Load Balancing können zusätzliche Broker für die Lastenverteilung definiert werden siehe Load Balancing Service Hosts Für jeden mit Framework Studio erstellten Service Host (Dienst), der publiziert werden soll, werden hier alle Einstellungen vorgenommen. Service Host - General Hier werden allgemeine Einstellungen zu einem Service Host vorgenommen. Servername: Name des Servers, auf dem der Dienst/Service Host installiert werden soll. Port: Port, unter dem der Dienst bereitgestellt werden soll. Hostname: Wenn das Häkchen gesetzt ist, kann der Name des ServiveHosts überschrieben werden. Dies hat Einfluss auf den Platzhalter %HOSTNAME% in der Base Address des Service Hosts und dessen Endpoints. CORS Origin: Wenn ein Service gehostet wird, der direkt über JavaScript aus dem Browser angesprochen wird, kann hier der CORS Origin gesetzt werden, welcher per HTTP-Header an den Client geschickt wird. Bei jedem Response des Services wird der Header „Access-Control-Allow-Origin“ mit dem angegebenen Wert mitgeschickt. Username: Gibt den Benutzer an, mit dem der Windows-Dienst für den Service Host installiert werden soll. Eine Domäne kann mit der Schreibweise „Domäne\\Username“ angegeben werden. Es stehen auch die drei Systemkonten „Local Service“, „Local System“ und „Network Service“ zur Auswahl. Ist eines dieser Konten ausgewählt, ist kein Passwort erforderlich. Password: Das Passwort zum ausgewählten Benutzer. Configuration: Hier können in einer Xml-Struktur Parameterwerte angegeben werden, die der Applikation beim Start mit übergegeben werden und in der Programmlogik über das GlobalObject ausgewertet werden können. Note Benutzerdefiniertes XML wird weder von FS, noch während der Laufzeit geparst oder auf Validität/Wohlgeformtheit geprüft. Trace: Einstellungen zur Protokollierung (Tracing) Activate: Nur wenn diese Checkbox gesetzt ist, wird Protokollierung verwendet und es können weitere Einstellungen vorgenommen werden. Output File: Datei, in die die Trace-Informationen geschrieben werden sollen. Mit dem Button wird ein Dateiauswahl-Dialog geöffnet. Trace Level: Über die Auswahlbuttons wird das Trace Level festgelegt. Activity Tracing: Activity Tracing ein- oder ausschalten Service Host - Authentication Hier werden die Authentifizierungseinstellungen zu einem Service Host vorgenommen. Enabled: Nur dann, wenn in dieser Checkbox ein Häkchen gesetzt ist, wird die Applikation mit Authentifizierung gestartet. Nur dann sind auch die weiteren Einstellungen zur Authentifizierung zugänglich. Name: Name der Applikation, mit der sich die Applikation am Authentifizierungsdienst anmelden soll. Description: Beschreibung der Applikation. ID: Eindeutige Identifikationsnummer der Applikation. Diese wird mit dem Button Generate New Identity zufällig erzeugt. Public Key, Private Key: Öffentlicher und privater Schlüssel der Applikation. Die Schlüssel werden vom Authentifizierungsdienst verwendet, um diese Applikation zweifelsfrei zu identifizieren. Die Schlüssel werden mit dem Button Generate New Identity zufällig initialisiert. Generate New Identity: Für die Applikation wird eine neue generiert. Durch diesen Vorgang werden ID, Public Key und Private Key mit zufälligen Werten gefüllt. Service Directories Für alle Server wird hier jeweils im Eingabefeld hinter dem Servernamen das Verzeichnis angegeben, in das alle Service Dateien gespeichert werden sollen. Mit dem Button wird ein Ordnerauswahl-Dialog geöffnet. Service Proxies Hier kann die Serviceadresse von externen Diensten geändert werden. End Hier werden alle Applikationen und Dienste (Service Hosts) aufgelistet, die zur Installation zur Verfügung stehen. Wenn einzelne Einträge ausgegraut dargestellt werden, sind nicht alle nötigen Konfigurationseinstellungen vorgenommen worden. In diesem Fall steht in Klammern hinter dem Namen der Applikation bzw. des Dienstes ein Hinweis, warum die Installation nicht möglich ist. Benutzen Sie den Button Publish um die Veröffentlichung zu starten. Save Setting: Mit diesem Button öffnen Sie den Dialog zum Speichern der aktuellen Einstellungen in der Datenbank. Auflistung blockierender Prozesse und Netzwerksitzungen Beim Publish sowie beim Revoke wird überprüft, ob das Zielverzeichnis von einem Prozess oder einer Netzwerksitzung blockiert wird. Im GUI Modus werden diese Blockaden aufgelistet. Über das Kontextmenü lassen sich einzelne davon abräumen. Der Button Terminate all löst alle aufgelisteten Blockaden. Über den Button Retry kann erneut das Löschen des Verzeichnisses angestoßen werden. Geschieht der Publish aus der Konsole, so wird ein Terminate all forciert. D.h. alle Prozesse und Netzwerksitzungen, die das Löschen des Zielverzeichnisses unterbinden, werden unmittelbar beendet."
  },
  "doc/publish-wizards/publish2go-export-wizard.html": {
    "href": "doc/publish-wizards/publish2go-export-wizard.html",
    "title": "Publish2Go Export-Wizard",
    "keywords": "Publish2Go Export-Wizard Der Publish2Go Export-Wizard wird verwendet, wenn mit Framework Studio entwickelte Applikationen und Dienste (Service Hosts) auf einem Rechner (oder auch auf mehreren Rechnern) installiert werden sollen, auf denen kein Framework Studio installiert ist (siehe Publish2Go Prinzip). Gestartet wird der Publish2Go Export-Wizard über den Menüeintrag Tools / Publish2Go Export. Der Publish2Go Export-Wizard arbeitet grundsätzlich wie bei Wizards üblich. Man kann sich mit den Buttons Back und Next durch die verschiedenen Einstellungen navigieren. Um gezielt eine bestimmte Einstellung zu ändern, können Sie diese auch direkt über den Baum anwählen. Button Restore Default Settings: Sämtliche Einstellungen, die im Publish2Go Export-Wizard definiert wurden, werden verworfen. Damit wird alles auf die Default-Einstellungen zurückgestellt. Die Default-Einstellungen werden aus der FSDomain gelesen. Button Back, Next: Zur vorherigen bzw. nächsten Einstellung navigieren. Button Run: Die ausgewählte Applikation und die ausgewählten Service Hosts werden gestartet. Siehe auch Registerkarte End Button Close: Schließt den Publish2Go Export-Wizard. Die geänderten Einstellungen werden in dem aktuellen User-Setting gespeichert. Start Folder Name: In diesem Eingabefeld wird der Name des zu erstellenden Publish2Go-Verzeichnisses angegeben. Das Verzeichnis muss leer sein. Button Load Setting: Hier kann ein gespeichertes Setting aus dem Repository geladen werden. Alle nicht gespeicherten Angaben gehen dabei verloren. Runtime License Beim Erstellen eines Publish2Go-Pakets ist es möglich, die zugehörigen Runtime Lizenzen gleich mit zu exportieren. Dazu steht im Publish2Go Wizard der aus dem normalen Publish Wizard bekannte Runtime License Manager zur Verfügung. Nachdem das Paket erfolgreich erstellt wurde, befinden sich die Runtime Lizenzen im angegebenen Ordner. Beim Starten des Publish2Go werden alle im Ordner befindlichen Lizenzen automatisch eingelesen. Service Proxies Hier kann die Serviceadresse von externen Diensten geändert werden. End Save Setting: Mit diesem Button öffnen Sie den Dialog zum Speichern der aktuellen Einstellungen in der Datenbank. Im Bereich Choose Applications and Service Hosts you want to publish wählen Sie alle Applikationen und Service Hosts aus, die zur Verfügung gestellt werden sollen. Benutzen Sie den Button Create um den Publish2GO-Ordner mit den ausgewählten Applikationen und Service Hosts zu erstellen."
  },
  "doc/publish-wizards/publish2go-wizard.html": {
    "href": "doc/publish-wizards/publish2go-wizard.html",
    "title": "Publish2Go-Wizard",
    "keywords": "Publish2Go-Wizard Allgemeine Informationen zum Publish2Go finden Sie unter Publish2Go Prinzip. Gestartet wird der Publish-Vorgang mit der Datei Publish2Go.exe im entsprechenden Unterordner 32bit oder 64bit des erstellten Publish2Go-Verzeichnisses. Der Publish2Go Wizard entspricht im Wesentlichen dem normalen Publish Wizard und weicht nur in den folgenden Punkten davon ab: Unter dem Navigationspunkt Start kann über den Button Load Setting ein zuvor vorbereitetes Setting aus einer Datei geladen werden. Unter dem Navigationspunkt End kann analog dazu ein Setting für die erneute Verwendung in eine Datei gespeichert werden. Unter dem Navigationspunkt Runtime License wird wie gewohnt die aktuelle Lizenzkonfiguration (Laufzeitlizenzen für alle Packages) verwaltet. Diese Lizenzen werden im Publish2Go-Verzeichnis gespeichert. Mit dem Button Select License File kann eine andere Lizenzdatei zur Verwendung ausgewählt werden. Liegt diese Datei nicht im oben genannten Verzeichnis, wird sie automatisch dorthin kopiert. Note Wenn für jedes Package genau eine Laufzeitlizenz im Publish2Go-Verzeichnis liegt werden diese Lizenzen automatisch als gültige Lizenzkonfiguration verwendet. Mit dem Button Publish wird wie gewohnt der Publish-Vorgang gestartet."
  },
  "doc/publish-wizards/run-wizard.html": {
    "href": "doc/publish-wizards/run-wizard.html",
    "title": "Run Wizard",
    "keywords": "Run Wizard Der Run-Wizard wird verwendet, wenn mit Framework Studio entwickelte Applikationen und Dienste (Service Hosts) getestet werden sollen. Gestartet wird der Run-Wizard über den Menüeintrag Compile / Run… oder über die Tastenkombination Umschalt+F5. Der Run-Wizard arbeitet grundsätzlich wie bei Wizards üblich. Man kann sich mit den Buttons Back und Next durch die verschiedenen Einstellungen navigieren. Um gezielt eine bestimmte Einstellung zu ändern kann man diese auch direkt über den Baum anwählen. Button Restore Default Settings: Sämtliche Einstellungen, die im Run-Wizard definiert wurden, werden verworfen. Damit wird alles auf die Default-Einstellungen zurückgestellt. Die Default-Einstellungen werden aus der FSDomain gelesen. Button Back, Next: Zur vorherigen bzw. nächsten Einstellung navigieren. Button Run: Die ausgewählte Applikation und ausgewählten Service Hosts werden gestartet. Siehe auch Registerkarte End Button Close: Schließt den Run-Wizard. Die geänderten Einstellungen werden in dem aktuellen User-Setting gespeichert. Start Active Languages In dieser Liste kann die Sprach-Hierarchie definiert werden. Start Mode Mit der Combobox wird der zu startende Client ausgewählt. Client Launcher: Die Anwendung wird als Java-Client über den FS Client Launcher gestartet. Java Client: Die Anwendung wird als Java-Client über Java WebStart gestartet. Das setzt die Installation einer Java Runtime voraus. Html Client: Es wird der HTML-Client im Browser geöffnet. Diese Option steht nur zur Verfügung, wenn der HTML-Client in der Application aktiviert ist. Client Start Page: Es wird die Client Start-Page im Browser angezeigt. Diese Aktion kann man auch direkt mit dem Befehl Open Client Start Page (F6) aufrufen. Server-Culture Hier kann eine Culture definiert werden (z.B: de-DE, de-CH oder en-US) mit der die Anwendung ausgeführt werden soll. Dies wirkt sich auf Culture-spezifische Aktionen wie z.B. Zahlen- und Datums-Formate aus. Erfolgt keine Angabe, dann wird die Culture des Betriebssystems verwendet. Logging / Tracing Hier kann definiert werden, ob und in welche Ordner protokolliert werden soll. Warning Beide Protokollierung erzeugen große Daten-Mengen. Die Protokolle sollten nur gezielt in konkreten Situationen aktiviert werden. Checkbox Session Trace: Diese Checkbox aktiviert das Session Trace. Dazu muss ein entsprechender Folder angegeben werden, in dem die Daten protokolliert werden sollen. Ist die Checkbox nicht gesetzt, dann hat ein ggf. definierter Ordner keine Funktion. Checkbox Broker XML: Ist diese Checkbox gesetzt, dann werden alle Broker-Requests und Responses als XML-Datei gespeichert. Das kann hilfreich sein um ganz konkrete Probleme im Detail zu analysieren. Dazu muss ein entsprechender Folder angegeben werden, in dem die Daten protokolliert werden sollen. Ist die Checkbox nicht gesetzt, dann hat ein ggf. definierter Ordner keine Funktion. Button Session Logging Analyzer Dieser Button öffnen den Session Logging Analyzer und meldet ihn automatisch am Runtime-Repository an. Connection Groups Hier können die Verbindungseinstellungen für die verschiedenen Connection Groups definiert werden. Die RuntimeConnection ist die Verbindung zum Repository. Combobox Registerkarte Database: Hier kann eine Registerkarte Database ausgewählt werden. Die Angaben aus der Registerkarte Database werden entsprechend angezeigt. Diese Angaben werden dynamisch aus den Registerkarte Databases gelesen. Wenn sich also dort die Angaben ändern, werden diese auch hier verwendet. Button Individual: Mit diesem Button können Sie eine individuelle Verbindung definieren. Die Felder für die Verbindungsdaten werden freigeschaltet und können entsprechend definiert werden. Diese Daten gehen verloren, wenn aus der Combobox eine Datenbank ausgewählt wird. Wenn eine Verbindung häufiger verwendet wird, dann ist es empfehlenswert, dafür eine Registerkarte Database anzulegen und diese dann hier auszuwählen. Authentication Hier können die Grundeinstellungen für die Authentication definiert werden. Im Eingabefeld Default User wird der Name des Benutzers angegeben. Dieser Name wird von der mit Framework Studio erstellten Applikation automatisch verwendet, wenn die Authentifizierung eingeschaltet ist. Dies gilt nur solange noch gar kein Benutzer authentifiziert wurde. Im Eingabefeld Default Password wird das Password des Default Benutzers angegeben. Im Eingabefeld Public Key (Auth. Service) wird der öffentliche Schlüssel des Authentifizierungsdienstes angegeben, der von den Applikationen und Service Hosts verwendet werden soll. Wenn der Authentifizierungsdienst läuft, kann der öffentliche Schlüssel des Authentifizierungsdienstes mit dem Button Get key from Auth. Service vom Dienst erfragt werden und wird automatisch in das Eingabefeld übernommen. Im nicht editierbaren Eingabefeld Auth. Service Address wird die Adresse angezeigt, unter der alle Applikationen und Service Hosts, die mit Authentifizierung arbeiten, den Authentifizierungsdienst ansprechen. Diese Einstellung kann am AuthService Proxy geändert werden. Um zum AuthService Proxy zu wechseln, kann der Link Button Configure Auth. Service Proxy verwendet werden. Runtime Licenses Hier werden die zu verwendenden Laufzeitlizenzen konfiguriert. Die Lizenzkonfiguration kann mit dem Button Change configuration geändert werden. Siehe Laufzeitlizenzen Applications Hier können alle Applikationen konfiguriert werden. Mit der Combobox Choose application wird die zu startende Applikation festgelegt. Application properties Title: Name der Applikation. Dieser wird später im Anwendungsfenster und in der Task-Leiste des Betriebssystems als Bezeichnung der Applikation angezeigt. Server Culture: Kultureinstellung, die im Server verwendet werden soll. Diese hat beispielsweise Auswirkungen auf „ToString()“ Methoden im Applikationscode. Configuration: Hier können in einer Xml Struktur Parameterwerte angegeben werden, die der Applikation beim Start mit gegeben werden und in der Programmlogik ausgewertet werden können. Enable Java Web Start: Damit kann auf der Client Start Page die Client-Option Java Web Start ein- oder ausgeblendet werden. Registerkarte Authentication Enabled: Nur dann, wenn in dieser Checkbox ein Häkchen gesetzt ist, wird die Applikation mit Authentifizierung gestartet. Nur dann sind auch die weiteren Einstellungen zur Authentifizierung zugänglich. Name: Name der Applikation, mit der sich die Applikation am Authentifizierungsdienst anmelden soll. Description: Beschreibung der Applikation. ID: Eindeutige Identifikationsnummer der Applikation. Diese wird mit dem Button Generate New Identity zufällig erzeugt. Public Key, Private Key: Öffentlicher und privater Schlüssel der Applikation. Die Schlüssel werden vom Authentifizierungsdienst verwendet, um diese Applikation zweifelsfrei zu identifizieren. Die Schlüssel werden mit dem Button Generate New Identity zufällig initialisiert. Generate New Identity: Eine neue Identität für die Applikation wird generiert. Durch diesen Vorgang werden ID, Public Key und Private Key mit zufälligen Werten gefüllt. Registerkarte Images Auf der Registerkarte Images können Hintergrundbild (Background Image), Startbild (Start Image) und das Icon der Applikation angepasst werden. Dafür stehen die Buttons und Reset zur Verfügung. Mit dem Button wird ein Dateiauswahldialog geöffnet. Es dürfen nur Bilder aus dem Brokerverzeichnis angegeben werden. Mit dem Button Reset wird das jeweilige Bild auf die Standardeinstellung zurückgesetzt. Service Hosts Für jeden mit Framework Studio erstellten Service Host, der gestartet werden soll, werden hier alle Einstellungen vorgenommen. Service Host – General Hier werden allgemeine Einstellungen zu einem Service Host vorgenommen. Active (Start Development Service Host): Wenn diese Checkbox gesetzt ist, wird dieser Service Host zum Starten via F5 markiert, andernfalls nicht. Servername: Name des Servers, auf dem der Dienst/Service Host installiert werden soll. Port: Port, unter dem der Dienst bereitgestellt werden soll. CORS Origin: Wenn ein Service gehostet wird, der direkt über JavaScript aus dem Browser angesprochen wird, kann hier der CORS Origin gesetzt werden, welcher per HTTP-Header an den Client geschickt wird. Bei jedem Response des Services wird der Header „Access-Control-Allow-Origin“ mit dem angegebenen Wert mitgeschickt. Configuration: Hier können in einer Xml-Struktur Parameterwerte angegeben werden, die der Applikation beim Start mit übergeben werden und in der Programmlogik über das GlobalObject ausgewertet werden können. Note Benutzerdefiniertes XML wird weder von FS, noch während der Laufzeit geparst oder auf Validität/Wohlgeformtheit geprüft. Bereich Trace Activate: Nur wenn diese Checkbox gesetzt ist, wird Protokollierung verwendet und es können weitere Einstellungen vorgenommen werden. Output File: Datei, in die die Trace-Informationen geschrieben werden sollen. Mit dem Button wird ein Dateiauswahl-Dialog geöffnet. Trace Level: Über die Auswahlbuttons wird das Trace Level festgelegt. Activity Tracing: Activity Tracing ein- oder ausschalten. Service Host – Authentication Hier werden die Authentifizierungseinstellungen zu einem Service Host vorgenommen. Enabled: Nur dann, wenn in dieser Checkbox ein Häkchen gesetzt ist, wird die Applikation mit Authentifizierung gestartet. Nur dann sind auch die weiteren Einstellungen zur Authentifizierung zugänglich. Name: Name der Applikation, mit der sich die Applikation am Authentifizierungsdienst anmelden soll. Description: Beschreibung der Applikation. ID: Eindeutige Identifikationsnummer der Applikation. Diese wird mit dem Button Generate New Identity zufällig erzeugt. Public Key, Private Key: Öffentlicher und privater Schlüssel der Applikation. Die Schlüssel werden vom Authentifizierungsdienst verwendet, um diese Applikation zweifelsfrei zu identifizieren. Die Schlüssel werden mit dem Button Generate New Identity zufällig initialisiert. Generate New Identity: Eine neue Identität für die Applikation wird generiert. Durch diesen Vorgang werden ID, Public Key und Private Key mit zufälligen Werten gefüllt. Service Proxies Hier kann die Serviceadresse von externen Diensten geändert werden. End Save Setting: Mit diesem Button öffnen Sie den Dialog zum Speichern der aktuellen Einstellungen in der Datenbank. Benutzen Sie den Button Run um die ausgewählte Applikation und alle zum Starten markierten Service Hosts Service Host – General zu starten. Update config files on start: Das Flag bestimmt, ob bei einem Anwendungsstart über den RunWizard oder F5 die im Development Broker Verzeichnis liegenden Config-Dateien überschrieben werden oder nicht. Standardmäßig ist das Flag aktiviert. Wird das Flag deaktiviert, hat der Entwickler die Möglichkeit, sämtliche Konfigurationsdateien im Development Broker Verzeichnis abzuändern und seine Anwendung mit diesen zu testen, ohne dass bei jedem neuen Start der Anwendung die Konfigurationsdateien von Framework Studio wieder überschrieben werden. So können z.B. in der Web.config des Development Brokers für Testzwecke zusätzlich Trace Listener o.ä. konfiguriert werden oder manuell ein Control Style einer Application vorübergehend abgeändert werden. Betroffene Konfigurationsdateien *.FrameworkBroker.config von Applications *.FrameworkBroker.config von Service Hosts Web.config des Development Brokers Note Nach einem Neustart von Framework Studio ist das Flag grundsätzlich aktiviert (Konfigurationsdateien werden überschrieben)."
  },
  "doc/publish-wizards/wizards.html": {
    "href": "doc/publish-wizards/wizards.html",
    "title": "Wizards zum Starten und Konfigurieren von Anwendungen und Diensten",
    "keywords": "Wizards zum Starten und Konfigurieren von Anwendungen und Diensten Szenarien Framework Studio bietet unterschiedliche Möglichkeiten zum Starten und Installieren von Anwendungen und Diensten. Zum Testen bietet sich die Verwendung des Run-Wizards) an. Dieser hat insbesondere den Vorteil, dass der Startvorgang sehr schnell geht (Siehe auch Anwendung Starten / Fehlersuche] Zum Publizieren von Anwendungen und Diensten auf einem Rechner mit Framework Studio kann der Publish-Wizard verwendet werden. Sollen Anwendungen und Dienste auf einem oder mehreren Rechnern publiziert/installiert werden, auf denen kein Framework Studio zur Verfügung steht, so bietet sich die Verwendung des Publish2Go Export-Wizards an. Weitere Details zum Publish2Go Prinzip folgen im nächsten Kapitel. Publish2Go Prinzip Applikationen können grundsätzlich auch auf einem Rechner publiziert/installiert werden, ohne dass dort Framework Studio benötigt wird. Das Vorgehen ist wie folgt Mit Framework Studio wird ein Publish2Go-Verzeichnis (Dateiordner) erstellt. Darin befindet sich in erster Linie eine SQL-Lite Datei, in der alle für den Publish-Vorgang benötigten Informationen (inkl. aller Dlls) abgelegt sind und (für 32 und 64 bit) die Datei Publish2Go.exe. Dieser Ordner wird zusammen mit geeigneten Laufzeitlizenzen zu den Rechnern übertragen, an denen Installationen durchgeführt werden sollen. Die Installation selbst wird dann mit der Datei Publish2Go.exe durchgeführt. In einem Setting werden alle Einstellungen für den Publish-Vorgang abgespeichert. Dazu zählen beispielsweise Datenbankverbindungen, Applikationsnamen, welche Applikation auf welchem Rechner publiziert werden soll, Installationsverzeichnisse, Laufzeitlizenzen und so weiter. Diese Settings können in eine Datei gespeichert werden und für weitere Publish-Vorgänge (z.B. Updates) wiederverwendet werden. Das Erstellen des Publish2Go-Verzeichnisses wird mit dem Publish2Go Export-Wizard durchgeführt; die Installation vor Ort durch starten der Datei Publish2Go.exe mit dem Publish2Go-Wizard."
  },
  "doc/reporting/devexpress-carry-forward-control.html": {
    "href": "doc/reporting/devexpress-carry-forward-control.html",
    "title": "Carry Forward",
    "keywords": "Carry Forward Eine nicht nativ abgedeckte Funktionalität ist die des Übertrags. Um diese abzubilden, wurde das Custom Control CarryForward geschaffen. Es ist dazu designed, den Textwert eines anderen Controls der vorigen Seite zu übernehmen. Sollte diese Aktion fehlschlagen oder unmöglich sein, kann es sich wie ein normales Label verhalten. Note Der Übertrag ist ausschließlich für ein Kopieren über Seiten hinweg ausgelegt. Übertragen von Werten z.B. zwischen Gruppen wird explizit nicht unterstützt. Eigenschaften Die Control spezifischen Einstellungen werden im Folgenden dokumentiert. Target Control Ein Verweis auf das Control, dessen Text kopiert werden soll. Im Editor ist eine Bearbeitung der Eigenschaften des Target Controls vom CarryForward-Control aus möglich. Hier sollte spezifisch das Summen-Feld selektiert werden, dessen Ergebnis auf die nächste Seite übertragen werden soll. Print on first page Bestimmt, ob das Control auf der ersten Seite des Reports angezeigt werden darf. Falls ja, fungiert es auf der ersten Seite als normales Label (da kein zu kopierender Text einer vorigen Seite existiert.) Print on last page Bestimmt, ob das Control auf der letzten Seite des Reports angezeigt werden darf."
  },
  "doc/reporting/devexpress-fold-marks-control.html": {
    "href": "doc/reporting/devexpress-fold-marks-control.html",
    "title": "Fold Marks",
    "keywords": "Fold Marks Belege in Briefform benötigen oft Falzmarken am Rand der Seite, um das Falten zu erleichtern. Um Falzlinien darstellen zu können, wurde das FoldMarks-Control geschaffen. Dieses ist unter dem Namen \"Fold Mark Settings\" in der Toolbox zu erreichen. Auf der Report-Oberfläche nimmt das Control die Form einer grauen Box an: Note Hierbei handelt es sich lediglich um einen Placeholder, um das Control leichter greifbar zu machen. Die Box wird beim Druck nicht erscheinen. Das Foldmark-Control kann auch in einem Sub-Report platziert werden. Die Falzmarken werden dabei auf allen Seiten des Haupt-Reports gedruckt - unabhängig davon, an welcher Position der Sub-Report platziert ist. Important Werden Foldmark-Controls in mehreren Sub-Reports platziert, dann ziehen diese alle gleichzeitig. Einstellungen Das Control bringt einige Properties mit, welche die Eigenschaften der Falzmarken bestimmen. DIN Norm Bestimmt, welche Art Falzmarken angedruckt werden. Zur Verfügung stehen Falzmarken nach Formen A und B der DIN-Norm für Briefe. HalfHeightMark Bestimmt, ob eine zusätzliche Marke an der Randmitte des Blattes angedruckt werden soll. Visible Definiert, ob die Falzmarken angedruckt werden. Das im Report Designer angezeigte Settings-Control wird nie gedruckt. Mark Size Bestimmt die Größe der Falzmarken. Diese werden als Rechteck gedruckt; definiert werden also erst Breite und dann Höhe. Orientation Bestimmt, ob die Marken links oder rechts gedruckt werden sollen. Padding Bestimmt den Abstand der Marken vom Rand. ForeColor / BackColor Bestimmt die Farbe der Marken. HalfHeightMarkForeColor / HalfHeightMarkBackColor Bestimmt die Farbe der zusätzlichen Marke. HalfHeightMarkSize Bestimmt die Größe der zusätzlichen Marke. Verwendung des Controls Um die Funktionalität nachzustellen, wurde das Custom Control „Fold Mark Settings“ erstellt, welches im Designer zu finden ist: Das Platzieren des Controls auf dem Report erstellt ein Dummy-Control zur Selektion. Dieses wird beim späteren Druck nicht zu sehen sein. Im neuen Control lässt sich jetzt die DIN-Norm selektieren, welche bestimmt, welche Form der Falzmarken angezeigt wird: „A“ und „B“ beziehen sich hierbei auf die beiden DIN-Standards für Briefpapier. A beschreibt einen üblichen Briefkopf, während B mehr Platz oben auf dem Papier für Adresszeile etc. vorsieht. Nach der Konfiguration werden die Falzmarken nicht im Designer angezeigt – die genaue Position ist erst nach Erstellung des Report-Documents (unmittelbar vor dem physischen Druck) bekannt, da zu diesem Zeitpunkt die Platzberechnung durchgeführt wird. Im Preview sind sie allerdings schon sichtbar: Änderungen an den Einstellungen werden hier reflektiert. Wenn wir z.B. jetzt die ForeColor & BackColor auf ein subtileres DarkGrey umstellen, ändert sich das Preview wie folgt:"
  },
  "doc/reporting/devexpress-label-control.html": {
    "href": "doc/reporting/devexpress-label-control.html",
    "title": "Labels",
    "keywords": "Labels Wichtige Einstellungen für Labels und Text-Shrinking Labels (und Tabellenzellen) bieten viele verschiedenen Kontrollschrauben für das Verhalten von Text und der Größe des Labels selbst auf Basis dessen an. Die wichtigsten Grundregeln werden hier beschrieben. CanShrink CanShrink ist eines der zentralen Properties im control resizing. Wenn es aktiviert ist, passt sich die Größe des Controls beim Druck der Größe des Textes innerhalb des Controls an. Wenn alle Controls über und unter dem schrumpfenden Control ebenfalls CanShrink aktiviert haben, kann ein gesamtes Band drastisch verkleinert werden: Design: Preview: Das funktioniert allerdings nur, solange auch alle betroffenen Controls in die Platzberechnungen des Drucks miteinbezogen werden. Visible = false entfernt ein Control aber aus dieser Berechnung! Der im Designer beanspruchte Platz des unsichtbaren Controls wird somit als leerer Platz gewertet und kann Lücken zur Folge haben: Design: Preview: (Die blauen Tabellenzellen schrumpfen immer noch ordnungsgemäß, weshalb nur der Designer-Platz der grauen Zellen mit Visible = false übrig bleibt) Sobald der Platz wieder in Berechnungen einfließt, wird er auch wieder geschrumpft – zum Beispiel, wenn nur eine Zelle in der Zeile unsichtbar ist: Design: Preview: Aus diesem Grund ist es empfehlenswert, bei Feldern, die unter bestimmten Bedingungen nicht angezeigt werden sollen, per Expression den Text zu leeren, statt das Visible-Property zu steuern. CanGrow CanGrow funktioniert, wie zu erwarten, als Gegenstück zu CanShrink. Wenn ein Text nicht vollständig ins Control passt, aus Gründen der Textlänge oder Schriftgröße, wächst es vertikal. Controls unter dem Label werden weiter nach unten geschoben. ProcessNullValues ProcessNullValues bestimmt, wie ein Label mit null als Textwert umgeht. Standardmäßig steht dies auf „Leave“, was das Control einfach leer stehen lässt, welches dann als Lücke auf dem Report erscheint. Wenn man leere Labels verstecken möchte, muss ProcessNullValues.SuppressAndShrink eingestellt sein, oder über CanShrink und expression-abhängiges Text-Leeren gearbeitet werden. Multiline Bestimmt, ob Zeilenumbrüche im Text auch als Zeilenumbrüche interpretiert und angezeigt werden. Bestimmt außerdem, ob WordWrap überhaupt umbrechen darf. WordWrap WordWrap setzt automatische Zeilenumbrüche, sobald Text den Rand des Controls erreicht. Es garantiert nicht, dass auch der gesamte Text dargestellt wird – dafür muss die Höhe des Controls zur Darstellung ausreichen. AutoWidth Analog zu CanGrow, allerdings für die Breite des Controls. Wenn Text den Rand des Controls erreicht, wird der Text über den Seitenrand des Controls hinaus weitergeschrieben. Andere Controls werden ignoriert und übermalt. Falls AutoWidth und WordWrap gleichzeitig aktiviert sind, gewinnt WordWrap. Ein aktiviertes WordWrap verhindert seitliches Wachsen des Controls."
  },
  "doc/reporting/devexpress-scripting.html": {
    "href": "doc/reporting/devexpress-scripting.html",
    "title": "Scripting in DevExpress-Reports",
    "keywords": "Scripting in DevExpress-Reports Scripte in DevExpress-Reports beinhalten C#-Code, welcher im Context der Anwendung zur Laufzeit kompiliert und ausgeführt wird. Dabei steht der komplette Funktionsumfang des .NET Frameworks und ggf. Funktionalitäten weiterer auf dem Anwendungsserver installierter Software zur Verfügung. Einschränkungen Das Scripting ist somit ein mächtiges, aber aus Sicherheitsaspekten sehr gefährliches Werkzeug. Im besten Fall können nicht versierte Benutzer Fehler verursachen, die die Stabilität der kompletten Anwendung beeinträchtigen. Im schlimmsten Fall bietet dieses Werkzeug aber auch ein potentielles Einfallstor für Angreifer. Caution Aus Sicherheitsgründen ist deshalb das Scripting in Reports, die vom Endbenutzer in der Anwendung bearbeitet werden, nicht gestattet. Ausschließlich mit der Framework Studio IDE vom Entwickler erstellte und mit dem Publish ausgerollte Reports dürfen Scripts enthalten. Warning Werden im Report-Designer Scripte verwendet, dann können diese Reports nicht über das Client Report Customizing mit dem Web Report Designer bearbeitet werden. Die Scripts führen zu Exceptions. Das Scripting eignet sich somit hauptsächlich für spezielle Situationen im Kunden-Package. Als Hersteller in einem Standard-Package sollte auf Scripting verzichtet werden, weil so dem Endanwender die Möglichkeit des Client Report Customzings genommen wird. Dies kann natürlich im Einzelfall eine bewusste Entscheidung sein."
  },
  "doc/reporting/devexpress-subreport-control.html": {
    "href": "doc/reporting/devexpress-subreport-control.html",
    "title": "Subreport Control",
    "keywords": "Subreport Control DevExpress® bietet von Haus aus SubReports. Diese bilden einen Hybrid unserer Use cases, aber erfüllen keinen dieser vollständig. Aus diesem Grund bietet der FS Report Designer zwei spezielle Varianten von Subreports: Embedded Subreport - wird vollständig in den Haupt-Report eingebettet Linked Subreport - wird beim Druck voll dynamisch gezogen. Funktional handelt es sich dabei jeweils um das Control von DevExpress®. Hier werden lediglich die Besonderheiten im FS Report Designer erklärt. Embedded Subreport Es handelt sich um einen Subreport, der vollständig in den Hauptreport eingebettet ist und zusammen mit diesem in einer Datei gespeichert wird. Beim Druck werden die Reports als ein gemeinsamer, größerer Report behandelt. Ein Embedded Subreport sollte genutzt werden, wenn ein DetailReportBand keine Option ist (z.B. für eine Iteration über eine separate Datenquelle im Reportkopf). Im WinForms-Designer lässt er sich über einen Doppelklick auf das Control neu anlegen oder editieren. Da alle Subreports in derselben Datei gespeichert sind, werden beim Auslösen eines Speichervorgangs alle Subreports zusammen mit dem Hauptreport gespeichert. Als Datenquelle wird die des Hauptreports genutzt. Um diese zu filtern sollten Report-Parameter eingesetzt werden. Note Wenn möglich, sollte statt eines embedded Subreports ein DetailReportBand eingesetzt werden (insbesondere für verschachtelte Positionen). Beim initialen Hinzufügen eines Embedded Subreports wird der DataMember aus der DataMember-Eigenschaft des Haupt-Reports übernommen. Ist ein anderer DataMember im Embedded Report gewünscht, kann dieser geändert werden. Änderungen speichern Embedded Subreports sind Status-synchronisiert mit ihrem Quellreport. Das bedeutet konkret, dass jede Änderung an einem Embedded Subreport im Status des Hauptreports widergespiegelt wird. Haupt- und Subreport werden immer gemeinsam gespeichert, unabhängig von der Anzahl der geöffneten Subreports. Ein Save auf einem der Tabs führt immer automatisch einen Save auf den Hauptreport aus. Linked Subreport Es handelt sich um einen Subreport, der als Link in den Hauptreport eingefügt wird. In der Hauptreport-Datei wird lediglich die URL auf die Subreport-Datei gespeichert. Beim JEDEM Druck wird die URL des Subreports neu aufgelöst und dessen Inhalt frisch in den Haupt-Report eingebettet. Dadurch wird eine echte Modularität erzielt. Hauptreport und Subreport können unabhängig voneinander bearbeitet / customized werden. Um sie zu nutzen, muss über den Smart Tag des Reports ein bestehender Report ausgewählt werden. Nach der Auswahl wird die Url des selektierten Reports automatisch auf Höhe des Report-Verzeichnisses relativiert. Dies garantiert, dass der Subreport zum Druckzeitpunkt auf Basis des aktuellen Verzeichnisses seinen Ziel-Report selektiert und auswählt. Im Designer öffnet ein Doppelklick auf einen Linked Subreport diesen im Readonly-Modus. Um einen Subreport editieren zu können, muss dieser über den entsprechenden Report Document Type aus Framework Studio heraus geöffnet werden. Generate Own Pages Diese Option ändert das Verhalten des Subreports: Statt in das Subreport-Control gedruckt zu werden, generiert sich der Subreport als vollwertiger Report. Der generierte Subreport wird nicht auf die Seite des Hauptreports gedruckt, es werden stattdessen seine Seiten zu oder zwischen die des Hauptreports gelegt. Use Cases Je nach Use Case empfiehlt sich entweder die Verwendung von Linked Subreports, Embedded Subreports oder Detail-Bands. Unter welchen Anforderungen/Voraussetzungen, welches Element verwendet werden sollte, wird im Folgenden erörtert. Werden dem RootReport zwei Collections mittels Datasource übergeben und es sollen beide Collections angezeigt werden, muss für die zweite Collection ein Subreport verwendet werden. Ein Embedded Subreport sollte genutzt werden, wenn ein DetailReportBand keine Option ist. Zum Beispiel für eine Iteration über eine separate Datenquelle im ReportHeader oder PageHeader. Auch bei einer Ansicht von zwei Collections nebeneinander müssen Subreports verwendet werden. Parameter DevExpress® erlaubt es, an einen Report beim Druck sogenannte Report-Parameter zu übergeben. Parameter ermöglichen es Report Daten dynamisch zu filtern. Diese enthalten arbiträre Werte und lassen sich in der Field List pflegen. In der Field List können Sie über das Kontextmenü der Parameters diese editieren oder einen neuen Parameter hinzufügen: Parameter finden insbesondere bei verlinkten Subreports Einsatz, wenn z.B. auf Basis einer ID nur über einen begrenzten Teil des Datensatzes iteriert werden soll. Um dies zu erreichen sollten Parameter Bindings am Subreport in Verbindung mit Filter Strings eingesetzt werden. Innerhalb einer Expression ist ein Report-Parameter mit der Syntax „?ParameterName“ abrufbar und verhält sich wie ein Calculated Field."
  },
  "doc/reporting/report-designer.html": {
    "href": "doc/reporting/report-designer.html",
    "title": "FS Report Designer",
    "keywords": "FS Report Designer Der FS Report Designer ist für den Einsatz mit Framework Studio konzipiert. Es handelt sich um den DevExpress® Report Designer, welcher für diesen Zweck entsprechend optimiert und angepasst wurde. Standardmäßige Funktionalitäten sind in dieser Doku nicht eingeschlossen - hierzu sollte die offizielle Dokumentation von DevExpress® beansprucht werden. Diese ist äußerst umfangreich, ist jedoch auf Englisch geschrieben. Für eine deutsche Übesetzung können Sie Google Translator verwenden. Dieser funktioniert (leider) am besten mit Google Chrome. Dieser kann auch komplette Websites übersetzen. Der FS Report Designer kann über \"Edit Report\" im Report Document Type geöffnet werden. Durch die Integration in FS sind keine weiteren Einstellungen notwendig. Die Daten, welche im FS Report Designer verwendet werden können, werden durch die DataSource definiert. Hier müssen keine Haken gesetzt werden, da DevExpress® auf alle Daten zugreift und selbst nur die verwendeten Daten zieht. Note Falls sich die Datenquellen oder die Komponenten ändern, die als Datenquelle genutzt werden, muss das Report Document und die betroffenen Interfaces der Datenquellen neu kompiliert werden. Dies zeigt Framework Studio an. Allgemeine Verhaltensweisen des FSReportDesigners Regulär wird eine Report-Datei aus Framework-Studio heraus bearbeitet. Dabei startet Framework-Studio den Report-Designer für die entsprechende Datei und stellt sicher, dass die im Report DocumentType definierten Datasources korrekt und vollständig angeboten werden. Wird der Report-Designer nach der Bearbeitung geschlossen, überträgt Framework Studio diese eine geänderte .repx-Datei (inklusive der darin enthaltenen Embedded Subreports) wieder zurück in den Report Document Type und in das Repository. Dadurch ergeben sich einige Besonderheiten beim Umgang mit Dateien. Die Registerkarte des initial durch Framework Studio geöffneten Haupt-Reports kann nicht geschlossen werden. Es muss der komplette Report Designer beendet werden. Werden zusätzlich Dateien aus dem Datei-System geöffnet, dann werden diese als Readonly angezeigt. Gleiches gilt beim Öffnen eines Linked Subreports. Werden Dateien als Readonly geöffnet, dann wird dies in der Registerkarte durch ein kleines Schloss gekennzeichnet und eine Meldung mit einem Hinweis angezeigt. Um möglichst viel Bedienkomfort zu gewährleisten ist die Bearbeitung nicht eingeschränkt. Bei Bedarf müssen vorgenommene Änderungen mit Save As... in eine neue Datei gespeichert werden. Mit Save As... kann ein Embedded Subreport aus dem Haupt-Report \"herausgelöst\" und eine Kopie als eigenständige Datei gespeichert werden. Das Embedded Subreport Control des Haupt-Reports und der darin gespeicherte Subreport bleiben davon unberührt. Eine New File Operation steht nicht zur Verfügung. Neue Dateien müssen aus Framework Studio heraus erzeugt werden. Standalone-Ausführung der FSReportDesigner.exe Die FS-Customizations werden via eines Launchers (FSReportDesigner.exe) auf den standardmäßigen Report-Designer angewandt. Aus diesem Grund müssen DevExpress® Reports über diesen Launcher editiert werden. Die entsprechende .exe ist auf oberster Ebene im Installationsverzeichnis zu finden, also \"\\Framework Studio X.Y.0.0\\FSReportDesigner.exe\". Diese .exe lässt sich auf beliebige Weise öffnen (unten genauer erläutert). Wenn die geöffnete Datei sich nicht in einem Report-Verzeichnis befindet und der Pfad zu diesem nicht als Argument angegeben wurde, erscheint folgende Meldung: \"Yes\" öffnet einen Verzeichnis-Auswahldialog, in dem sich ein Report-Verzeichnis auswählen lässt. Falls es sich um eine valide Auswahl handelt, wird der Report so gehandhabt, als ob er sich in diesem Verzeichnis befinden würde. Alle vom Report-Verzeichnis abhängigen Features stehen dann zur Verfügung. \"No\" oder ein Abbruch der Auswahl startet den Designer völlig standalone. Custom Controls stehen noch zur Verfügung, aber Features, die von Interoperabilität mit anderen Report-Dateien abhängen sind nicht nutzbar. Direkter Aufruf Bei einem direkten Aufruf der FSReportDesigner.exe, z.B. per Doppelklick, oder beim Aufruf mit einer ungültigen .repx-Datei, wird ein Auswahldialog für eine .repx geöffnet. Ein Öffnen einer .repx-Datei per Windows file association oder durch drag & drop einer .repx-Datei auf die .exe öffnet die besagte Datei und verhält sich ansonsten identisch. Important Bei einem Standalone-Aufruf des Report-Designers steht normalerweise keine Datenquelle zur Verfügung. Um sie trotzdem nutzen zu können, müssen die Argumente \"--type\", \"--assembly\" und \"--folder\" angegeben sein. Kommandozeilen-Argumente Der FSReportDesigner ist von der Kommandozeile aus granularer aufrufbar. Die folgenden Argumente stehen zur Verfügung: --report: Muss in der Kommandozeile angegeben werden. Definiert den voll qualifizierten Pfad zu der zu editierenden .repx-Datei. --type: Der voll qualifizierte type name der Datenquelle, z.B. 'NV.ERP.MM.Sales.rptSalesDocument_Rptx' --assembly: Der Name der assembly-Datei, die den bereits angegebenen Typen beinhaltet, in diesem Beispiel also 'NV.ERP.MM.Sales_RDT.dll'. --folder: Das Verzeichnis, welches die benötigten Assembly-Dateien beinhaltet - üblicherweise '\\bin\\' im Compile-Verzeichnis. -l/--locked (optional): Setzt den Report in einen readonly-modus, welcher Änderungen und das Speichern verhindert. Einstellungen im Winforms-Designer Beim Öffnen eines Reports werden folgende Standardeinstellungen angewandt: Grid Snapping Einheit (tenths of a millimeter) A4 Seitenränder Schriftart: Arial Schriftgröße: 8pt Weitere Details finden sich im Folgenden: Grid Der Designer nutzt ein Raster (Grid), an welchem sich Controls per Snapping ausrichten, d.h. Objekte rasten an den Grid-Linien ein. Einstellungen des Grids, wie dessen Größe, Snapping Mode und bei welchen Kästchen Snapping angewandt wird, werden von FS aus festgesetzt und an den Designer übergeben. Note Änderungen der Grid-Einstellungen gehen beim erneuten Öffnen verloren und könnten zu Verschiebungen von Controls führen – wird deshalb nicht empfohlen. Maße Die Maßeinheit ist gleichermaßen auf Zehntelmillimeter festgesetzt, obwohl auch Pixel und Hunderstel-Inches unterstützt werden. Vererbung Der Designer folgt einer hierarchischen Vererbung übergeordneter Controls an untergeordnete Controls. Solange eine Eigenschaft nicht überschrieben ist (sichtbar durch das gefüllte Kästchen neben der Eigenschaft in den Properties), wird es von den übergeordneten Controls übernommen. Dies erlaubt es, bspw. Schriftarten über den gesamten Report hinweg zu ändern. Um eine Überschreibung zu löschen, muss auf das Kästchen geklickt werden. Anschließend öffnet sich ein entsprechendes Kontextmenü, wo das Property mit ‚Reset‘ zurückgezusetzt werden kann. Read-only Beim Öffnen eines Reports, ohne diesen vorher auszuchecken, wird dieser im Read-only-Modus geöffnet. Dies garantiert, dass keine Änderungen möglich sind. Lediglich das Layout des Reports ist sichtbar. Fenster im Designer In den folgenden Unterkapitel werden die einzelnene Oberflächenelemente des Designers aufgeführt. Field List Report Designer Analyzer Group and Sourt Properties Field List Fenster Hier werden alle Felder der Datenquelle angezeigt. Um diese zu nutzen, reicht es, sie auf den Report zu ziehen. Weiterhin lassen sich mit Rechtsklick Calculated Fields anlegen/bearbeiten und Report-Parameter pflegen. Die Field List verfügt über eine Volltextsuche, um benötigte Felder schnell zu finden. Zieht man von der Field List aus mit Rechts- statt Linksklick, werden nur die Namen der Felder auf den Report gelegt. Diese Funktion ist nützlich, um schnell eine Grundstruktur für Tabellenüberschriften erstellen zu können. Report Design Analyzer Fenster Hier werden Fehler und Warnungen im Report angezeigt. Fehler führen zu einem Fehlschlag des Drucks, weshalb dieses Fenster vor dem Speichern immer überprüft werden sollte. Group and Sort Fenster Dieses Fenster bietet eine Übersicht über alle Gruppierungen und Sortierungen, die aktuell im Einsatz sind, sowie deren Hierarchie. Properties Fenster Das Property-Fenster listet alle Eigenschaften eines ausgewählten Controls auf. Ist kein Control ausgewählt, finden sich hier die Einstellungen des Reports selbst, da diese als Eigenschaften des Reports realisiert sind. Report mit Bands strukturieren Ein Report Layout besteht aus Bändern, die Report-Controls enthalten und deren Position auf den Dokumentseiten festlegen. Sie bilden die Struktur eines Reports. Verschiedene Bands haben verschiedene Funktionen und demnach auch verschiedene Eigenschaften, welche im folgenden Kapitel erörtert werden. Dies ist eine Übersicht über die verschiedenen Bands, welche zur Verfügung stehen: Ein leerer Report enthält die folgenden Bereiche: Das Detail Band wird für jeden Datensatz in einer Datenquelle gedruckt, es sei denn, Sie haben die Daten gefiltert. Jeder Bericht sollte einen Detail Band enthalten, diesen können Sie nicht löschen. Die Bands TopMargin und BottomMargin. Diese Bänder werden auf jeder Dokumentseite einmal wiederholt. TopMargin/ BottomMargin Noch über/unter dem Footer und Header sind diese Bands als Platzhalter gedacht, können aber trotzdem Controls beinhalten. Sie haben keine besonderen Eigenschaften. ReportHeader/ ReportHeaderFooter Der ReportHeader und der ReportFooter werden nur jeweils ein einziges Mal am Anfang bzw. Ende des Reports gedruckt. Sie verfügen über eine Eigenschaft Keep Together, sodass sie jeweils nur gedruckt werden, wenn sie auf eine Seite passen. Des Weiteren haben sie die Eigenschaft Page Break, um eine neue zusätzliche Seite vor bzw. nach ihnen zu veranlassen. PageHeader/ PageHeaderFooter Wie ReportHeader/ -Footer, nur einmal pro Seite. Sie verfügen über die Eigenschaft Print On, die es erlaubt beispielsweise nur zu drucken, falls kein Report Header auf derselben Seite ist. Detail Das Detail Band hat besondere Eigenschaften. In ihm wird automatisch über eine Collection iteriert, falls diese als Data Member am Report selbst eingestellt ist. Der Data Member bezeichnet die primäre Collection, über die iteriert werden soll. Alle Bänder unter dem Detail Band müssen auch in der Datenquelle dem Data Member untergeordnet sein oder müssen ihre Felder mit vollem Namen qualifizieren. Als Beispiel: In diesem Report ist oSalesDocument.oSalesOrderColl als Data Member definiert. Um auf das direkt am oSalesDocument (also über dem Data Member) hängende decTaxRa-te1 zuzugreifen, muss voll über oSalesDocument.decTaxRate1 qualifiziert werden. Das Gleiche gilt für Calculated Fields. Falls über eine dem Detail band untergeordnete Collection iteriert werden soll, muss ein Detail Report Band oder ein Subreport eingesetzt werden. FillEmptySpace in Kombination mit GroupFooter.PrintAtBottom erlaubt es, Platzhalter zwischen Gruppen zu drucken, auch, wenn Gruppen auf einer neuen Seite anfangen sollen. Detail Report Band Ein Detail Report Band erlaubt es, ein weiteres Detail unter einem bestehenden Detail band zu iterieren. Da DevExpress® Reports dazu konzipiert sind, nur ein Detail band zu haben, fungiert es quasi als aufgelöster Subreport, der nur in einem Report zum Einsatz kommt. Subreports sollten hingegen eingesetzt werden, falls er in mehreren Reports zum Einsatz kommen soll. Dem Detail Report Band muss ein Data Member zugewiesen werden: Die Limitation eines Detail Report Bands ist es, dass die Data Source dessen immer unter der des Detail Reports liegt. Falls über eine separate Collection außerhalb dessen iteriert werden muss, sollte ein Embedded Subreport eingesetzt werden. GroupHeader/ GroupHeaderFooter Die GroupHeader/Footer Bands stellen die Gruppierungs- und Sortierungsfunktionalität bereit. Sie müssen nicht immer in Paaren erstellt werden – alleinstehende Header und Footer sind möglich. Beide Bands stehen in Relation zu ihrem Detail Band. Die Distanz (in Bändern) zum Detail Band sind im „Level“-Property festgesetzt. In der Gruppierung lassen sich mehrere Felder und Sortierungen kombinieren. Über den Smart Tag des Bands lässt sich unter „Group Fields“ ein Editor hierfür öffnen. Gleichzeitig unterstützen Group Bands automatisches Sortieren auf Basis von Summierungen über ausgewählte Felder der Objekte in der Gruppierung. Auch für diese gibt es einen dedizierten Editor, welcher sich über „Sorting Summary“ öffnen lässt. Das Ergebnis der jeweiligen Summe bestimmt daraufhin, in welcher Reihenfolge die einzelnen Gruppen gedruckt werden. Es wird empfohlen, die Positionen des Reports mit einer Gruppe zu umschließen. Gruppen bieten Features explizit für dieses Szenario an, z.B. „Repeat Every Page“. Diese Checkbox erlaubt Überschriften in dem Group Header zu platzieren und sie auf jeder Seite erneut zu drucken, unabhängig des Page Headers. Tip Nur die Detail- und Group Bands können zur Anzeige dynamischer Datenquelleninhalte verwendet werden. Andere Bands zeigen Titel, Zusammenfassungen und andere zusätzliche Informationen an. Sorting Summary in Group Bands Group Bands bieten ein sog. Sorting Summary an. Das Sorting Summary wird nicht genutzt, um z.B. eine Gesamtsumme darzustellen, sondern dient zur Bestimmung der Sortierreihenfolge innerhalb der Gruppe. Die folgende Konfiguration, beispielsweise, sortiert die Datensätze der Gruppe nach der jeweiligen Anzahl der ClientAddressLine-Datensätze: Controls und Custom Controls Wichtige Eigenschaften zu Labels finden sich hier Zusätzlich zum sehr umfangreichen Angebot von DevExpress® werden im FS Report Designer zusätzliche der Embedded Subreport und der Linked Subreport angeboten. Nähere Informationen hierzu finden Sie hier. Das Control Fold Mark Settings ermöglicht das Drucken von Falzmarken für Briefe am Rand der Seite. Für den Übertrag von Daten auf die vorherige Seite kann das Carry Forward genutzt werden. Expressions, Calculated Fields und FilterStrings DevExpress® Expressions sind das Formel-Äquivalent von DevExpress®. Sie werden allerdings nicht zentral verwaltet, sondern sind immer Teil eines Properties. Expressions bestimmen entweder ein Property eines Calculated Fields, oder direkt den Wert eines Properties an einem Control. Für die spezielle Expression Language hat DevExpress® eine ausführliche Dokumentation. Expressions bei Properties Ausgewählte Properties können ihren Wert direkt durch Expressions berechnet bekommen. Durch diese Funktionalität lassen sich bspw. dynamisch Schriftgrößen ändern oder die Unterdrückungsformeln von Crystal nachbilden. Um eine Expression zu editieren, kann der f-Button in dem entsprechenden Feld betätigt werden. Dieser öffnet eine Übersicht über alle Properties des Controls, welche eine Expression besitzen können, und erlaubt es, sie zu editieren. Calculated Fields Calculated Fields sind \"künstliche Felder\" mit einem Expression-Property, welches es erlaubt, einen Wert per Expression zu erhalten. Künstliches Feld bedeutet, dass kein Datenbankfelder (z.B. sName) diesem zugrunde liegt. Sie werden wie normale Datenbankfelder behandelt und lassen sich in allen Situationen verwenden, in welchen auch Datenbankfelder zum Einsatz kommen. Im Fenster Field List lassen sie sich erstellen und einer Datenquelle unterordnen. Über das Kontextmenü in der Field List kann man eine Übersicht über alle Calculated Fields öffnen. Diese beinhaltet alle Calculated Fields und erlaubt es, diese zu verwalten. Filter Strings FilterStrings erlauben es, die Datenquelle auf Basis einer Expression einzuschränken, wenn man einzelne Daten nicht nutzen möchte (z.B. um nur einen bestimmten Kunden unter Betracht zu ziehen). Da Detail Report Bands die Funktionalität von Subreports für Positionsdrucke ersetzen sollen und eine eigene Datenquelle besitzen, haben auch sie einen eigenen Filter String. Die genaue Syntax von Filter Strings findet sich, wie die Syntax von Criteria, auf der offiziellen DevExpress®-Website. Summen DevExpress® bietet eine ausführliche Doku zu Summen. Im Folgenden wird auf die einzelnen Möglichkeiten kurz eingegangen. Innerhalb Groups kann summiert werden. Eine kurze Zusammenfassung hierzu findet sich hier Zwischensummen Besonders Zwischensummen aus mehreren verschiedenen Feldern setzen in Crystal viele Umstände voraus – es werden Funktionen für die Zwischenstände benötigt, welche am Ende manuell aufaddiert werden müssen. Diese Möglichkeit besteht auch in DevExpress® (Ansatz mit Hilfe eines Calculated Fields), aber es bestehen weitere und bessere Optionen. Statt ein separates Calculated Field zu erstellen, kann man stattdessen ein eigenes Label erstellen, dessen Expression eines der nativen Summen-Expressions nutzt. Diese akzeptieren mehrere Datenbankfelder und Calculated Fields, was eine laufende Summe über mehrere Felder über eine Formel ermöglicht. Calculated Field-Summen Die Berechnung von Summen über Calculated Fields ist nicht mehr die offiziell empfohlene Variante, aber immer noch nutzbar. Hierfür muss einfach ein neues Calculated Field angelegt werden, in wessen Expression die gewünschte Summe manuell berechnet wird. Dieses Calculated Field kann dann beliebig genutzt werden, um die errechnete Summe anzuzeigen. Tipps und Tricks In diesem Kapitel sind Tipps und Tricks aufgeführt, die den Umgang mit Reports in DevExpress® erleichtern können. Methode GlobalOnBeforePrintSubreport Am Global wurde die Methode GlobalOnBeforePrintSubreport hinzugefügt. Diese Methode ermöglicht das Umlenken eines Subreports auf eine eigene Customization. Ausrichtung vieler Labels Werden mehrere Labels hinzugefügt, kann die Ausrichtung der Elemente aufwändig sein. DevExpress® bietet die Funktion \"Convert to Table\" an, welche für eine Anordnung verwendet werden kann. Markieren Sie die entsprechenden Labels. Diese dürfen sich horizontal nicht überschneiden. Über das Kontextmenü (Rechtsklick) können Sie die Funktion \"Convert to Table\" ausführen. Nun sind alle Labels auf einer Höhe ausgerichtet. Sollten Sie keine Tabelle benötigen, kann auf gleichem Weg die Tabelle wieder in einzelne Labels umgewandelt werden. Die Anordnung und Ausrichtung bleiben bestehen. Vorgehensweise für die Konvertierung einer Tabelle in einzelne Labels: Markieren Sie die Tabelle über das \"Vier-Pfeile\"-Icon am oberen linken Rand der Tabelle. Über das Kontextmenü (Rechtsklick) können Sie die Funktion \"Convert to Labels\" ausführen. Minimale Höhe in einer Band Ziehen Sie den unteren Rand eines Bands über die darin enthaltenen Controls. DevExpress® verkleinert das Band auf die minimale Höhe, welche die Felder im Band benötigen. Größe des Bands über das letzte Control ziehen: Die Höhe des Detail Bands ist nun direkt unter dem letzten Label \"sColor\". How to use: Detail Band Reports - Embedded Subreports In diesem Kapitel werden detaillierte Anwendungsfälle der Detail Reports und Subreports vorgestellt und ausführlich beschrieben. Die Beispiele basieren auf dem Repository FSDemo und können mithilfe dessen nachgestellt werden. Vorbereitung Das Beispiel basiert auf FSDemo, weshalb zunächst ein neues FSDemo-Repository angelegt werden muss. Anschließend muss dieses FSDemo mit dem User \"user1\" gestartet werden. Es genügt die Anmeldung am Default-Package. An der Form frmCompany ein Event zum Print-Button \"OnClick\"-Event hinzufügen und folgenden Code in die Methode einfügen. protected virtual void FE_btnPrint_OnClick(FrameworkButtonClickEventArgs e) { var rpt = new rptCompanyList(this.Global, rptCompanyList.Reports.SideBySide, ExportFormat.PDF); rpt.oCompanyColl = this.oCompanyColl; var articleColl = FS.Demo.Article.cdArticleCollFactory.Create(this.Global); articleColl.Load(); rpt.oArticleColl = articleColl; rpt.Print(); } Das Property Visibility des Print-Buttons auf Visible setzen. Einen Report rptCompanyList im Namespace Company anlegen. Dem Report in der Registerkarte DataSource die DataSources oArticleColl und oCompanyColl zuweisen. Anschließend in der Registerkarte Report Files einen neuen DevExpress® Report anlegen. Im Beispiel wurde dieser \"SideBySide\" genannt. Möchten Sie den Report anders benennen, müssen Sie im Methoden Code der FE_btnPrint_OnClick den Namen entsprechend anpassen. Anzeige des Reports: Starten Sie die Applikation mit F5. Navigieren Sie in der gestarteten FSDemo-Applikation zum Kunden. Klicken Sie auf die Lupe, um entsprechende Datensätze zu laden. Über das Print-Icon können Sie sich nun den fertigen Report ansehen. Detail Report anlegen Dieses Tutorial soll veranschaulichen, wie hierarchische Daten in einem Report mit verschachtelten Detail Report Bands angezeigt werden können. Einen Report mit Hilfe des FSReportDesigners öffnen. Im Fenster Report Explorer den report auswählen und das Property Data Member auf oCompanyColl setzen. Anschließend, falls kein Detail Band vorhanden ist, dies mit Rechtsklick auf dem Report über \"Insert Band\" - \"Detail\" hinzufügen. Im nächsten Schritt Rechtsklick auf das Detail Band im Report. Im daraufhin geöffneten Kontextmenü kann über \"Insert Detail Report\" eine Datenquelle ausgewählt werden (siehe Abbildung). Die angebotenen Datenquellen im Kontextmenü beim letzten Schritt befinden sich eine Ebene unter dem Data Member des Haupt-Reports. Über das Fenster Report Explorer kann der Haupt-Report (hier report) ausgewählt werden und anschließend in den Properties der Data Member eingesehen werden (siehe folgenden Screenshot). Sobald eine Datenquelle ausgewählt wurde, wird im Report im oberen Teil des Detail Reports der komplette Datenpfad angezeigt. Warning Falls dem Report über die DataSource zwei Collections übergeben wurden, kann im Haupt-Report der Data Member auf eine andere Collection geändert werden. Dies wird jedoch nicht empfohlen, da hierdurch bestehende DetailReports auf falsche Datenfelder verweisen können. Sind die Datenfelder in der neu zugewiesenen Collection nicht vorhanden, führt dies zu Fehlern. Detail Report strukturieren und Felder hinzufügen Klickt man auf ein Detail Report wird automatisch im Fenster Field List die zugehörige Datenquelle ausgewählt. Dies ist im folgenden Screenshot dargestellt. Im Baum der Field List kann nun der Eintrag oContactColl aufgeklappt und einzelne Felder auf das Detail Report Band gezogen werden. Wie im Bild ebenfalls zu sehen, wurde mit einem ReportHeader und einem ReportFooter gearbeitet. Diese können über Rechtsklick auf dem DetailReport hinzugefügt werden. Sie werden einmalig am Anfang bzw. am Ende des Detail Reports gedruckt. Im Beispiel dient dies zur besseren Übersicht im gedruckten Report. Im folgenden Screenshot sehen Sie, welche weiteren Auswahlmöglichkeiten zur Verfügung stehen. Der fertige Report sieht wie folgt aus: Iterieren über Collections außerhalb des Detail Bands Ist das Ziel über Daten zu iterieren, welche im ReportHeader, PageHeader, ReportFooter, oder PageFooter angezeigt werden sollen, muss dies über einen Subreport realisiert werden. Als Beispiel sollen die ID, der Name und die Farbe aller Artikel ausgegeben werden. Auf dem nachfolgenden Screenshot sehen Sie das fertige Ergebnis des Reports im FSReportDesigner. Auf der linken Seite befindet sich der Haupt-Report \"SideBySide\". Auf der rechten Seite ist der Embedded Subreport mit den Daten zu den einzelnen Artikeln. Die Vorgehensweise ist wie folgt: Zunächst muss ein Embedded Subreport Control auf den Report gezogen werden. Im Beispiel wird dies auf den ReportHeader gezogen. Ggf. kann zunächst der Namen des Controls geändert werden. Anschließend muss der Embedded Subreport mit Doppelklick geöffnet werden. Dieser befindet sich im Bild auf der rechten Seite. Die Fenster auf der rechten Seite zeigen die Details des Embedded Subreports an. Nach dem Öffnen des Subreports müssen Sie in das Fenster Report Explorer wechseln und dort, wie bei Schritt 2 im Bild, den Subreport auswählen. Anschließend kann im Properties Fenster der Data Member ausgewählt werden (Schritt 3 im Bild). Im Beispiel wurde hier die zweite Collection oArticleColl ausgewählt, welche per DataSource dem Haupt-Report zugewiesen wurde. Als letzten Schritt können Sie nun über das Fenster Field List verschiedene Datenfelder auf den Report ziehen. Im Bild sind sID, sName und sColor hinzugefügt worden. Speichern und fertig. Ergebnis: Einmalig auf der ersten Seite im Report wird nun die Liste der Artikel mit den Daten ID, Name und Farbe ausgegeben. Kombination der verschiedenen Möglichkeiten Auf dem nachfolgenden Screenshot sehen Sie die Zusammenfassung der bereits erklärten Beispiele, welche zusätzlich farblich aufbereitet wurden. Dies dient einer besseren Übersichtlichkeit. Des Weiteren wurde ein DetailReport hinzugefügt, welcher über die Bestellungen der Firma iteriert. Die zugehörige Überschrift lautet \"Bestellungen\" und ist gelb. Diesen DetailReport können Sie als Übung selbst hinzufügen und sich am bereits erstellten Ansprechpartner-DetailReport orientieren. Auf dem Report werden folgende Informationen angezeigt: Embedded Subreport im ReportHeader: Iteration über die verschiedenen Artikel DetailReport oCompanyColl.oContactColl: Iteration über die Ansprechpartner DetailReport oCompanyColl.oSalesOrderMasterColl: Iteration über die verschiedenen Bestellungen Report im FSReportDesigner: Ergebnis: Datenanzeige direkt im Detail Band Auch im Detail können Daten bspw. der Firma ausgegeben werden. Diese wurden nachträglich zum Detail Band, welches über die Bestellungen iteriert, hinzugefügt. Die Firmendaten haben einen grauen Hintergrund. Report im FSReportDesigner: Ergebnis: Daten in mehreren Spalten anzeigen Innerhalb des DetailReports mit dem Data Member \"oCompanyColl.oSalesOrderMasterColl\", in welcher bereits die Bestellungen durchlaufen werden, legen wir nun einen weiteren DetailReport an. Über das Detail Band der \"Bestellungen\" kann über das Contextmenü \"Insert Detail Report\" - \"oSalesOrderDetailColl\" ausgewählt werden. Nachdem man einen ReportHeader und das Label \"Positionen\" hinzugefügt hat, sieht der Report wie im folgenden Screenshot aus. Rot umrandet ist der neu angelegte Detail Report. In diesem Screenshot kann man des Weiteren sehen, wie ein Report in Spalten aufgeteilt werden kann. Im Fenster Properties ist dies markiert. Zusätzlich sollte die Einstellung Layout bei den Multi-Column-Options auf \"First Accross, then down\" gesetzt werden. Ansonsten werden die Positionen nur nebeneinander angezeigt, wenn beispielsweise am Ende der Seite kein Platz mehr für alle Positionen untereinander vorhanden ist. Anschließend das Control \"Panel\" auf das Detail ziehen und die gewünschten Datenfelder zum Panel per Drag&Drop hinzufügen. Der fertige Report mit Panel und Multi Column im FSReportDesigner: Ergebnis: Ansprechpartner im Embedded Subreport Es gibt die Möglichkeiten die Anzeige der Bestellungen und Ansprechpartner nicht über Detail Reports, sondern mittels Embedded Subreports zu lösen. Ziel ist, dass die Ansprechpartner neben den Bestellungen und Positionen angezeigt werden. Note Die nachfolgende Vorgehensweise ist auf Basis des obigen Reports. Die Überschriften sind im Embedded Subreport mit grünem Hintergrund versehen. Im Detail Band unterhalb der Firmen Infos (grauer Hintergrund) zwei Embedded Subreports hinzufügen. Diese nebeneinander anordnen. Den linken Report in embeddedSubreportControl_Contact umbenennen. Den rechten Report umbenennen in embeddedSubreportControl_Orders. Den linken Report öffnen, ein Detail Report über das Kontextmenü \"Insert Detail Report\" - \"oContactColl\" hinzufügen und wie im Screenshot mit Daten aus der \"oCompanyColl.oContactColl\" füllen: Anschließend im Fenster Field List die \"Parameters\" auswählen und über Rechtsklick einen neuen Parameter hinzufügen. Diesen wie im folgenden Screenshot anlegen (Type: Guid; Name \"Company_ROWID\"). Als letzten Schritt muss im Embedded Subreport im Fenster Report Explorer der oberste Report ausgewählt werden. Im Bild heißt dieser \"Report2\". Im Fenster Properties in der Registerkarte data beim Property \"Filter Strings\" folgende Formel angeben: [ROWID] = ?Company_ROWID Anschließend den Embedded Report speichern und schließen. Am embeddedSubreportControl_Contact im Haupt-Report auf das Zahnrad-Icon klicken und anschließend Edit Parameter Bindings... auswählen (siehe Screenshot). Im nun geöffneten Parameter Binding Collection Editor auf den Button Sync klicken. Hiermit wird der im Subreport angelegte Parameter automatisch hinzugefügt. Im rechten PropertyGrid muss nun bei Binding auf die ROWID der oCompanyColl verwiesen werden. Das Fenster mit Ok schließen. Note Nur wenn sie zusätzlich zum Parameter auch den Filter String anlegen, wird nach der ROWID gefiltert. Ansonsten werden bspw. für alle Firmen alle Ansprechpartner untereinander angezeigt. Auf diesem Screenshot ist zu sehen, wie nun der embedded Subreport auf dem finalen Report aussieht: Bestellungen und Positionen im Embedded Subreport Um auch die Bestellungen und die Positionen ebenfalls mit Embedded Subreports abbilden zu können, ist keine neue Funktion notwendig. Mit den bisherigen Beispielen können Sie sich nun selbst ausprobieren oder der Anleitung weiter folgen. Die Vorgehensweise ist wie folgt: Falls noch kein entsprechender Embedded Subreport unterhalb der Firmeninfos hinzugefügt wurde, muss dies nun getan werden. Der Embedded Subreport sollte in keinem Detail Report, sondern direkt im Detail Band eingebunden werden. Den Subreport in embeddedSubreportControl_Orders umbenennen. Subreport embeddedSubreportControl_Orders öffnen. Anschließend den Report mit folgenden Controls befüllen: Zusätzlich muss noch ein Parameter Company_ROWID hinzugefügt werden. Nennen Sie den hier hinzugefügten Embedded Subreport bitte ebenfalls embeddedSubreportControl_OrderPos, da dieser im Folgenden so genannt wird. Anschließend müssen im Report embeddedSubreportControl_Orders auf das oberste Report Element im Report Explorer klicken und den Filter String auf [ROWID] = ?Company_ROWID setzen. Als letzten Schritt müssen Sie zurück in den Haupt-Report und beim Control embeddedSubreportControl_Orders auf das Zahnrad-Icon klicken und Edit Parameter Bindings auswählen. Im nun geöffneten Fenster können Sie wieder über den Button Sync den Parameter aus dem Embedded Report ziehen und müssen nur das Binding auf \"oCompanyColl.ROWID\" setzen. Die erste Ebene ist nun vollständig. Als nächstes wird erklärt, wie Sie die Positionen anzeigen können. Navigieren Sie in den embeddedSubreportControl_Orders Report und von dort in den embeddedSubreportControl_OrderPos Subreport. In diesem müssen Sie zwei Detail Reports hinzufügen. Diese müssen wie im folgenden Bild angeordnet sein: Des Weiteren müssen diesmal zwei Parameter angelegt werden. Diese sind beide wieder vom Type: GUID und lauten: Company_ROWID und Order_ROWID Als nächstes muss erneut ein Filter String zum obersten Report Element hinzugefügt werden. Dieser lautet wie folgt: [ROWID] = ?Company_ROWID Nun navigieren Sie zum embeddedSubreportControl_Orders und legen am embeddedSubreportControl_OrderPos Control die beiden Parameter Bindings an. Das Binding der Company_ROWID ist identisch zu den Beispiele zuvor. Das Binding der Order_ROWID lautet: oCompanyColl.oSalesOrderMasterColl.ROWID Der finale Report sieht nun wie folgt aus:"
  },
  "doc/reporting/report-document-type.html": {
    "href": "doc/reporting/report-document-type.html",
    "title": "Report Document Type",
    "keywords": "Report Document Type Report Document Types stellen die Verbindung zwischen den Components und den Reports dar. Sie definieren, was für Daten in welchem Report ausgegeben werden. Ein Report Document Type enthält eine Angabe, welche Components ausgedruckt werden sollen und welche Reports dafür zur Verfügung stehen. Diese Report Document Types können später in Forms verwendet werden. Report Document Types sind an dem – Icon zu erkennen. Erstellen, bearbeiten und löschen von Report Document Types Sie erstellen einen neuen Report Document Type, indem Sie in der Registerkarte Namespaces den Namespace auswählen, in welchem der Report Document Type abgelegt werden soll. Mit dem Button (New) und dem Eintrag ReportDocumentType aus dem Menü wird im markierten Namespace ein neuer Report Document Type angelegt. Dieser wird auch gleichzeitig geöffnet. Direkt nach dem Anlegen des Report Document Types steht der Cursor in dem sich öffnenden Designer auf dem Feld Name, wo Sie den Namen eingeben können. Es wird empfohlen den Namen mit rpt zu beginnen. Löschen können Sie einen Report Document Type mit dem Button (Delete). Sie müssen dazu den gewünschten Report Document Type im Namespace-Baum markiert haben. Es gibt auch im Kontext-Menü den Eintrag Delete. Registerkarte Data Sources Unter Data Sources werden die Components angegeben, die in einem Report ausgegeben werden sollen. Es können mehrere Components (Collections) aus unterschiedlichen Namespaces eingebunden werden. Jede Component wiederum kann für mehrere Reports als Data-Source angegeben werden. Über das Menü File / New / Data Source bzw. über das Kontextmenü der Tabelle wird ein neuer Data-Source erstellt. Bei Datatype können Sie durch Eingabe eines Types die Component / Collection auswählen, die verwendet werden soll. Im Feld Name können Sie dem Data-Source einen Namen geben. Dieser wird anhand des ausgewählten Datentyps mit einem Standardnamen vorbelegt. Die Data-Sources sind sozusagen die \"Properties\" des Reports. Diese Properties müssen später beim Druck mit Werten gefüllt werden. Registerkarte Report Files Auf der Registerkarte Report Files können dem Report Document Type die eigentlichen Reports zugewiesen werden. Hinzufügen und Öffnen eines neuen Reports Über das Menü File / New / Report File oder über das Kontextmenü der Tabelle wird eine neue Report-Datei erstellt. In einem abgeleiteten Report bzw. im Customizing-Package kann auch ein Report aus der Basis bearbeitet werden. Markieren Sie dazu den entsprechenden grau hinterlegten Report und drücken Sie dann den Button Edit Report. Dadurch wird eine \"Überschreibung\" des Inhalts des Basis-Reports erzeugt. Include Base Reports Mit der Checkbox Include Base Reports legen Sie fest, ob vererbte, nicht geänderte Basisreports später in der Applikation zur Auswahl stehen sollen. Sie hat Einfluss darauf, was die Methode ReportDocument.GetReportEnums() zurückgibt. Bei gesetzter Checkbox werden die Reports aus der direkten Basis ebenfalls zurückgegeben. Auf jeder weiteren Basis-Ebene (sowohl Vererbung als auch Customizing) wird die Checkbox erneut ausgewertet. Ist die Checkbox nicht gesetzt, dann werden in der Anwendung nur die neu hinzugefügten und die in dieser Ableitungsebene überschriebenen Reports zurückgegeben. Überschriebene Reports sind am grauen Hintergrund und dem blauen Text zu erkennen. Note Um eine Überschreibung zu löschen muss diese über das Kontext-Menü der Tabelle mit Delete gelöscht werden. Dadurch wird der Text wieder Schwarz. Reset File alleine reicht nicht aus. Allgemeine Einstellungen Die folgenden Einstellungen beziehen sich auf den in der Tabelle ausgewählten Report: Im Feld Name kann dem Report ein Name gegeben werden. Warning Dieser Name darf keine Leer- und Sonderzeichen enthalten, weil dieser später im Code zum Einsatz kommt. Mit dem Button Edit Report wird der Report über ein externes Tool bearbeitet. Für weitere Erklärungen bezüglich der Bearbeitung von DevExpress® Reports siehe FS Report Designer Der Button Choose File öffnet einen Dateiauswahl-Dialog, in dem Sie eine bestehende Report-Datei zuweisen können. Mit dem Button New Report wird ein neuer, leerer Report erstellt und zugewiesen. Mit dem Button Reset File wird der Inhalt eine einzelnen Report-Datei gelöscht. Handelt es sich um eine aus der Basis geerbeten Report-Datei, zieht danach wieder der Inhalt aus der Basis. Crystal Report (Deprecated) Diese Box wird angezeigt, wenn das Report-File eine Crystal-Report-Datei besitzt. Note Seit der Version 4.8 wird Crystal Reports nicht mehr unterstütz. Die hinterlegte Datei steht in der Anwendung nicht mehr zur Verfügung. Mit dem Button View Report können Sie den Crystal Report im Designer anzeigen. So können Sie weiterhin eine Konvertierung zum DevExpress®-Report durchführen. Ein Ändern dieser Report-Datei ist nicht mehr möglich. Mit dem Button Delete File wird die Crystal Report Datei endgültig gelöscht. Dadurch wird die Crytal Report Box ausgeblendet. Caption Im Report Document Type können Sie für Report Files lokalisierte Bezeichnungen (Captions) hinterlegen, also die Bezeichnung mehrsprachig pflegen. Diese Captions können zur Laufzeit ausgewertet werden, um z.B. im Druck-Dialog bei der Auswahl der unterschiedlichen Report-Varianten einen sprechenden Text auszugeben. Report-Verzeichnis Auf dem Dateisystem werden die Report-Dateien vom Compile-Verzeichnis ausgehend im Ordner /Report/ gespeichert. DevExpress® Reports erhalten einen weiteren Unterordner, nach dem übergeordneten Report Document Type benannt. Der Report CustomerList aus rptCustomerList wäre also unter /Report/NV.ERP.Base.Customer.rptCustomerList/CustomerList.repx zu finden. Bei jedem Compile-Vorgang werden die DevExpress® Report-Dateien aus dem Repository in das Dateisystem herausgeschrieben, nach folgenden Regeln: DevExpress® Alle DevExpress® Reports eines Report Document Types im aktuellen Package werden in den entsprechenden Unterordner unter /Report/ herausgeschrieben. Basis-Reports werden nur aus der Basis gesucht und ins Verzeichnis geschrieben, solange am Report Document Type die Checkbox \"Include Base Reports\" gesetzt ist. Für den Druck relevante Klassen ReportDocument ReportEnum PrintServer PrintQueue Browserbasierter Report-Designer zur Laufzeit Zur Laufzeit steht ein Report Designer dem Benutzer zur Verfügung. Dieser muss vorher in das System integriert und aufgerufen werden. Weitere Details zum Designer finden Sie unter FS Web Report Designer. Im folgenden Beispiel wird ein Report Designer geöffnet, auf eine Bestätigung des Benutzers gewartet und anschließend der geänderte Report ausgedruckt. // Eigenschaft, um sich die Design Session zu merken private FS.Hosting.Core.Reporting.ReportDesignSession oDesignSession { get; set; } // Einstiegspunkt; hier bspw. über einen Button Click protected virtual void btnGrdReportDesigner_OnClick(FrameworkButtonClickEventArgs e) { rptArticles report = new rptArticles(this.Global, rptArticles.Reports.XArticleReport, ExportFormat.PDF); this.oDesignSession = report.CreateDesigner(); this.oDesignSession.ShowDesigner(); // Öffnet den Report Designer in einem Browser-Fenster throw MsgBox.Exception(FSGeneral.ctMessagesFactory.GetText(this.Global, 10), \"\", MsgBoxButtons.OK, MsgBoxIcons.None, new MsgBoxEventHandler(OnMsgBoxReportDesignSessionClick)); } // Ein Klick auf den MessageBox-Button signalisiert, dass die Bearbeitung abgeschlossen ist protected virtual void OnMsgBoxReportDesignSessionClick(object sender, MsgBoxEventArgs e) { byte[] reportDesign = null; if (this.oDesignSession != null && this.oDesignSession.IsModified()) { // Veränderten Report aus der Session herunterladen reportDesign = this.oDesignSession.GetBytes(); } this.oDesignSession.Dispose(); // Verwerfen der Design Session nicht vergessen this.oDesignSession = null; if (reportDesign == null) { throw new Exception(\"Kein neuer Report vorhanden.\"); } // Drucken des geänderten Reports rptArticles report = new rptArticles(this.Global, rptArticles.Reports.XArticleReport, ExportFormat.PDF); report.SelectedReport.ReportBytes = reportDesign; report.oArticle = oArticleColl; // Beim Drucken wird die Datenquelle benötigt report.Print(); } Weitere Information zum Web-Designer finden Sie unter ReportDesignSession."
  },
  "doc/reporting/web-report-designer.html": {
    "href": "doc/reporting/web-report-designer.html",
    "title": "FS Web Report Designer",
    "keywords": "FS Web Report Designer Der Report Designer im Web umfasst bis auf einzelne Ausnahmen den gleichen Funktionsumfang, wie der FS Report Designer. Die genauen Einschränkungen finden Sie im nachfolgenden Kapitel Einschränkungen. Die offizielle Doku von DevExpress® finden Sie hier. Sollten Sie den WebDesigner schließen und Änderungen nicht gespeichert haben, fragt der Browser ab, ob Sie diese Änderungen verwerfen möchten. Es gibt demnach kein automatisches Speichern. Einschränkungen Im WebDesigner ist, aufgrund von Sicherheitsaspekten, kein Scripting möglich. Eine weitere Einschränkung ist, dass Sie keine Linked Subreports anlegen oder bestehende Linked Subreports öffnen können. Die ReportSourceUrl wird im Control des Linked Subreports angezeigt. Verhaltensunterschied zum FS Report Designer Wird ein nicht gespeicherter Embedded Subreport im Hauptreport gelöscht, gehen die Änderungen im Embedded Subreport verloren."
  },
  "doc/resources/reference-check.html": {
    "href": "doc/resources/reference-check.html",
    "title": "Referenz-Prüfung für Ressourcen",
    "keywords": "Referenz-Prüfung für Ressourcen Framework Studio bringt schon eine ganze Menge eigener Referenzen mit: FrameworkStudio - Assemblies die Framework Studio \"out of the box\" schon mitbringt. ReferencedAssemblies - dotnet-Framework Assemblies, die beim Compile verwendet werden. GlobalAssemblyCache Weitere Referenzen können als DLL-Datei mittels Ressource im bin-Ordner eingebunden werden. Diese Ressourcen können Konflikte verursachen, wenn sie z.B. FrameworkStudio - Referenzen überschreiben. Deshalb wird beim Compile der Ressources eine Referenz-Prüfung durchgeführt und gefundene Konflikte und Unstimmigkeiten als #error oder #warning ausgegeben. // Reference Check Results: Resource #warning Resource 'My.Assembly.Ressource' with lower version 1.0.1.2 overrides FrameworkStudio Reference with higher version 2.0.0.0 (see ...) Sobald Ressourcen mit einer spezifischen Architektur (32-Bit oder 64-Bit) vorhanden sind, wird pro Architektur eine vollständige Prüfung durchgeführt. Das ist erforderlich, weil sich die Versionen und Referenzen dieser Assemblies unterscheiden könnten. Dadurch werden Errors und Warnungen ggf. mehrmals ausgegeben: // Reference Check Results: Resource (64 Bit) #warning Resource (64 Bit) | Resource 'My.Assembly.Ressource' with lower version 1.0.1.2 overrides FrameworkStudio Reference with higher version 2.0.0.0 (see ...) ... // Reference Check Results: Resource (32 Bit) #warning Resource (32 Bit) | Resource 'My.Assembly.Ressource' with lower version 1.0.1.2 overrides FrameworkStudio Reference with higher version 2.0.0.0 (see ...) Neben den Konflikten werden die Details der Referenz-Prüfung als Kommentar in den Code generiert. Wenn Probleme auftreten, lässt sich so auf einfache Weise recherchieren, wie diese zustande kommen. Treten keine Warnings oder Errors auf, kann man sich diesen Code auch manuell anzeigen lassen. Dazu muss im Namespace FSGeneral.DBTables der generierte Code für Resources angezeigt werden. // Reference Details: Resources (64 Bit) // // - Accessibility 4.0.0.0 (ReferencedAssemblies) // -> mscorlib 4.0.0.0 // // - AESInterface 1.0.5.9 (Resource) // -> mscorlib 2.0.0.0 // -> System 2.0.0.0 // -> System.Web.Services 2.0.0.0 // -> System.Xml 2.0.0.0 ... Aufgelistet werden die gefundenen Assemblies mit ihrer tatsächlichen Version. In Klammern ist zu erkennen, woher diese Referenz kommt: (NotFound) - Die Assembly wird von einer anderen referenziert, wurde jedoch nicht gefunden. (GlobalAssemblyCache) - Assemblies die aus dem Global Assembly Cache gezogen werden. Dabei handelt es sich in der Regel um installierte Drittsoftware. (ReferencedAssemblies) - dotnet-Framework Assemblies, die beim Compile verwendet werden. Diese befinden sich im Programm-Verzeichnis im Unter-Ordner ReferencedAssemblies (FrameworkStudio) - Assemblies die Framework Studio \"out of the box\" schon mitbringt. Dabei handelt es sich um eigene Assemblies und von Framework Studio verwendete Nuget-Pakete. (Resource64Bit) - eine vom Entwickler eingebundene Ressource für 64-Bit Architektur (Resource32Bit) - ... für 32-Bit Architektur (Resource) - ... ohne spezifische Architektur Unterhalb der Assembly werden jeweils die erwarteten Referenzen mit der jeweils erwarteten Version aufgelistet. Diese Versionen dienen als Basis für die Prüfung der Versionen der tatsächlich verfügbaren Assemblies. Errors Der folgende Error kann beim Compile ausgegeben werden: #error Resource | Resource 'My.Assembly.Ressource' with lower version 1.0.1.2 overrides FrameworkStudio Reference with higher version 2.0.0.0 (see ...) Die eingebundene Ressource überschreibt eine bereits von Framework Studio bereitgestellt Assembly mit einer kleineren Version. Dadurch funktionieren Binding-Redirects nicht mehr korrekt und es kann zur Laufzeit zu Exceptions kommen. #error Resource | Resource 'My.Assembly.Ressource' with version 1.0.1.2 is too low. References from other assemblies requires Version up to 2.0.0.0 (see ...) Die gefundene Assembly hat eine zu kleine Version. Es gibt in anderen Assemblies Referenzen, die eine höhere Version erwarten. Wenn es sich dabei um eine Ressource handelt, dann muss diese aktualisiert werden. Dieser Error kann auch dann auftreten, wenn z.B. eine FrameworkStudio-Referenz eine zu alte Version hat. Das kann sein, wenn eine Ressource mit einem zu aktuellen Version-Stand eingebunden wird. In diesem Fall kann für die Ressource ggf. eine ältere Version dieser Assembly verwendet werden, deren Version zu den anderen Assemblies passt. Alternativ können auch aktuellere Versionen der Referenzen als Ressource eingebunden werden. Warnings Die folgenden Warnungen können beim Compile ausgegeben werden: #warning Resource | Resource 'My.Assembly.Ressource' with version 2.0.0.0 is already referenced via FrameworkStudio. The Resource may be deleted. (see ...) Die eingebundene Ressource wird mit derselben Version bereits eingebunden - z.B. durch FrameworkStudio oder ReferencedAssemblies. Die Ressource sollte deshalb gelöscht werden. Aktuell ist das kein Problem. Wenn aber zu einem späteren Zeitpunkt FrameworkStudio eine neuere Version einbindet, dann wird es einen Error geben, weil die Ressource dann eine zu kleine Version hätte. #warning Resource | Referenced Assembly 'My.Assembly.Ressource' not found! References from other assemblies requires Version up to 2.0.0.0. (see ...) Eine Assembly, welche als Referenz von anderen Assemblies erwartet wird, wurde nicht gefunden. Ggf. muss diese Assembly als Ressource eingebunden werden, oder es muss eine Drittsoftware installiert werden, die diese Assembly im Global Assembly Cache registriert."
  },
  "doc/resources/resources.html": {
    "href": "doc/resources/resources.html",
    "title": "Resources",
    "keywords": "Resources Ressourcen ermöglichen dem Entwickler, der Anwendung beliebige Dateien zur Verfügung zu stellen. Typische Beispiele für Ressourcen sind: von der Anwendung benötigte Bilder Custom Control Erweiterungen auf der Seite der Clients externe Bibliotheken (dlls), die von der Anwendung benutzt werden (siehe auch Referenz-Prüfung für Ressourcen) Bedeutung von Namespaces für Ressourcen Ressourcen können im Objekt-Baum (Registerkarte Namespaces) im Namespace FSGeneral / Resources angelegt werden. Beim Kompilieren von Ressourcen werden diese dann direkt in das Brokerverzeichnis kopiert. Außerdem können im Namespace FSGeneral / Resources weitere Namespaces angelegt werden. Diese Namespaces werden beim Kompilieren von Ressourcen automatisch als Unterverzeichnisse im Brokerverzeichnis angelegt, sobald sie eine Ressource enthalten. Die Ressourcen eines Unter-Namespaces werden dann in das entsprechende Unterverzeichnis des Brokers kopiert. Erstellen und Löschen von Ressourcen Für das Erstellen und Löschen ist zu beachten, in welchem Namespace die Ressource angelegt werden muss (Bedeutung von Namespaces für Ressourcen). Ansonsten werden Ressourcen wie alle anderen Elemente angelegt. Erstellen einer Ressource Löschen einer Ressource Bearbeiten von Ressourcen Durch einen Doppelklick auf eine Ressource im Objekt-Baum wird das Designer-Fenster geöffnet. Resource Dort können Sie mit dem Button Import File einen Dateiauswahldialog öffnen. Dort wählen Sie die Datei aus, die in das Brokerverzeichnis kopiert werden soll. Nach dem Import wird der Name der Ressource mit dem Namen der ausgewählten Datei initialisiert. Sie können diesen Namen im Textfeld Name ändern. Im nicht editierbaren Textfeld Relative Path wird der Pfad relativ zum Brokerverzeichnis angezeigt, unter dem die Datei letztendlich angelegt wird. Der Pfad ergibt sich aus dem Namespace, in dem die Ressource angelegt wurde (Bedeutung von Namespaces für Ressourcen) und dem Namen der Ressource. Erläuterungen zu den Standardfunktionen, die im Designer-Fenster für Ressourcen angeboten werden, finden Sie unter Allgemeine Funktionalitäten. Encoding Text-Resourcen können mit einem Encoding versehen werden. Folgende Encodings stehen zur Auswahl bereit: UTF8 UTF8 BOM UTF16 BE BOM UTF16 LE BOM Windows (ISO-8859-1) \"Leer\" Das Standard-Encoding für neue leere Text-Resourcen ist UTF8. Das \"leere\" Encoding bedeutet, dass das Encoding zurückgesetzt und neu ermittelt wird. Die bereits bestehenden Text-Resourcen bleiben in Framework Studio unberührt. Sobald Sie Änderungen vornehmen, wird das Encoding abgespeichert. Am Fettdruck des Encodings kann erkennt werden, dass der Wert neu gesetzt wurde. Wir empfeheln Ihnen keine Änderungen in Framework Studio an Resourcen vorzunehmen, bei welchen bspw. Sonderzeichen oder äöü nicht korrekt angezeigt werden. Sollte Sie eine neue Resource mit einem nicht unterstützten Encoding hinzufügen und anschließend in Framework Studio bearbeiten wollen, empfehlen wir Ihnen die Datei in einem entsprechenden Editor zu konvertieren und erst danach in Framework Studio zu importieren. Erkennung des Encodings und Konvertierung Beim Öffnen einer Text-Resource wird das Encoding ermittelt. Mit diesem Encoding wird die Datei angezeigt, bearbeitet und anschließend auch in der Datenbank gespeichert. Mit der Encoding-Combobox können Sie das Encoding ändern. Die Datei wird dann automatisch in das ausgewählte Encoding konvertiert. Byte order mark Als Byte Order Mark wird eine charakteristische Bytefolge am Anfang eines Datenstroms bezeichnet, die ein spezielles Unicode-Zeichen kodiert. Diese Bytefolge dient als Kennung zur Definition der Byte-Reihenfolge und Kodierungsform in Textdateien. Note Die UTF-8-Kodierung des BOM besteht bspw. aus der Bytesequenz EF BB BF, die in nicht UTF-8-fähigen Texteditoren und Browsern meist als ISO-8859-1-Zeichen ï»¿ erscheinen. Sollten Sie ein solches oder ein anderes invalides (z.B. �) Zeichen in einer Textdatei sehen, deutet dies auf eine Bearbeitung mit falschem Encoding hin. Wir empfehlen in einem solchen Fall Dateien nicht in FS zu bearbeiten, sondern in einem speziellen Hex-Editor. Werden unbekannte Zeichen angezeigt, kann es ggf. helfen das byte order mark in einem Hex-Editor zu entfernen und die Datei anschließend wieder in Framework Studio zu importieren."
  },
  "doc/runtime-administration/runtime-administration-common.html": {
    "href": "doc/runtime-administration/runtime-administration-common.html",
    "title": "Runtime Administration",
    "keywords": "Runtime Administration Mit dem Administrations-Werkzeug Runtime Administration können Sie zentral alle Einstellungen an der Benutzerverwaltung, die zur Laufzeit definiert werden können, bearbeiten. Das Werkzeug enthält zwei verschiedene Module: Zum einen das Role Management Tool, mit dem Sie beispielsweise die Möglichkeit haben, Rollen zu erstellen und zu importieren. Zum anderen das Authentication and Authorisation Tool, mit dem Benutzer verwaltet werden. Dazu gehört insbesondere das Zuweisen von Rollen und Gruppen. Technischer Hintergrund Zentraler Punkt der Benutzerverwaltung ist der Authentication Service. Dieser Dienst wird von der Endanwendung genutzt, um einen Benutzer (z.B. durch Benutzername und Passwort) zu authentifizieren. Vom Authentication Service erhält die Endanwendung auf diese Weise einen Token, der zum einen beweist, dass der Benutzer tatsächlich der ist, der er vorgibt zu sein und der zum anderen die Information enthält, welche Rollen dem Benutzer an einzelnen Anwendungen oder Diensten zugeteilt wurden. Der Authentication Service wird mit dem Authentication and Authorisation Tool konfiguriert. Mit Framework Studio erstellte Endanwendungen sind durch so genannte Access Units in einzelne Bereiche aufgeteilt. Mit dem Role Management Tool werden Rollen definiert. Das heißt, dass für eine Rolle der Endanwendung festgelegt wird, welche Access Units und damit welche Programmteile durch diese Rolle freigeschaltet und welche gesperrt werden. Diese Informationen werden ebenfalls im Authentication Service abgelegt und können dort abgefragt werden. Beim Start der Endanwendung wird der Authentication Service genutzt, um den Benutzer zu authentifizieren. Mit dem Token des Benutzers können dann ggf. weitere Dienste, die eine Authentifizierung benötigen, benutzt werden, ohne dass eine neue Authentifizierung nötig ist. Nach der Authentifizierung werden am Authentication Service die Details zu den Rollen des Benutzers abgefragt, also die Rechte für die einzelnen Access Units."
  },
  "doc/runtime-administration/runtime-administration-config.html": {
    "href": "doc/runtime-administration/runtime-administration-config.html",
    "title": "Konfiguration und Start",
    "keywords": "Konfiguration und Start Um das Werkzeug Runtime Administration starten zu können, muss ein Authentifizierungsdienst zur Verfügung stehen. Note Wie Sie einen Authentifizierungsdienst in Betrieb nehmen, entnehmen Sie bitte der Installationsbeschreibung zum Authentication Service. Starten Sie die Datei RuntimeAdministration.exe. Sie sehen nun das Login Fenster. Geben sie den Namen des Servers ein, auf dem der Authentifizierungsdienst installiert ist. Wenn der Dienst einen anderen Port als der Standard-Port „20001“ verwendet, dann muss dieser auch angegeben werden – z.B. „Server:12345“. Geben Sie Benutzername und Passwort eines Benutzers an, der im Authentifizierungsdienst angelegt wurde. Diesem Benutzer muss im Service „AuthenticationService“ mind. ein der beiden Rollen „ManageUsers“ oder „ManageRoles“ zugewiesen sein. Nach der Installation des Authentifizierungsdienst existiert bereits der Standard-Benutzer „Admin“ mit dem Kennwort „change_on_install“. Note Bei jedem Start des Authentifizierungsdienstes wird überprüft, ob bereits ein Benutzer mit dem Namen Admin existiert. Wenn dieser nicht existiert, wird er automatisch mit dem Passwort change_on_install angelegt. Caution bei Oracle MUSS der User mit Groß- / Kleinschreibung also als „Admin“ eingegeben werden!!! Die letzten Anmeldungen (Server + User) werden im Windows Benutzer-Profil gespeichert und können beim nächsten Login über die Server-Combobox ausgewählt werden. Diese Anmeldungen bleiben bei einem Update erhalten. Sollte beim Login eine Fehlermeldung erscheinen, die daraufhin deutet, dass im Authentication Service ein Fehler aufgetreten ist, so schauen Sie Details zum aufgetretenen Fehler im EventLog des Rechners nach, auf dem der Authentifizierungsdienst läuft. Nach dem Login öffnet sich das Hauptfenster."
  },
  "doc/runtime-administration/runtime-administration-roles.html": {
    "href": "doc/runtime-administration/runtime-administration-roles.html",
    "title": "Rollen verwalten / Role Management Tool",
    "keywords": "Rollen verwalten / Role Management Tool Allgemeines Die Rollen, die Sie mit dem Role Management Tool verwalten, werden im Authentication Service gespeichert. Wenn eine Endanwendung gestartet wird, erhält diese vom Authentication Service nicht nur Informationen über den authentifizierten Benutzer, sondern auch die aktuellen Rollendefinitionen. Note Role Management Tool und Authentication and Authorisation Tool sind zwei unabhängige Softwarekomponenten. Das hat zur Folge, dass das Authentication and Authorisation Tool nicht automatisch erkennt, dass über das Role Management Tool eine neue Rolle angelegt wurde. In diesem Fall müssen im Authentication and Authorisation Tool alle Daten mit der Funktion Reload All neu eingelesen werden. Role Management Tool starten Wenn Sie das Role Management Tool starten, erscheint folgendes Fenster. In diesem Fenster wählen Sie aus, für welchen Service Sie Rollen bearbeiten wollen. Anmerkung: In diesem Zusammenhang werden unter Service alle Programme verstanden, die sich am Authentication Service registrieren und diesen zur Authentifizierung verwenden. Insbesondere sind das auch die mit Framework Studio erstellten Endanwendungen (Applications). In der Tabelle werden alle Services aufgelistet, die sich am Authentication Service registriert haben. In der Spalte Name wird der Name des Services angezeigt. In der Spalte Roles managed by sind folgende Werte möglich: Service: Dieser Service verwaltet seine Rollen selbstständig. Die Rollen können also nicht durch einen Administrator definiert werden. In diesem Fall kennt der Authentication Service keine Access Unit Hierarchy. Anmerkung: Alle Applications, die mit einer Framework Studio Version älter als 3.0 erstellt wurden, gehören zu dieser Kategorie. Rollen dieser Applications müssen weiterhin mit der alten Runtime Administration verwaltet werden. User: Die Rollen dieses Services können durch einen Administrator bearbeitet werden. Dieser muss dazu die Rolle Manage Roles am Authentication Service besitzen. In der Spalte Description wird die für den Service hinterlegte Beschreibung angezeigt. In der Spalte ID wird der Schlüssel angezeigt, durch den ein Service eindeutig identifiziert wird. Mit dem Button OK bestätigen Sie, dass Sie Rollen für den ausgewählten Service bearbeiten möchten. Mit dem Button Cancel brechen Sie die Anmeldung am Role Management Tool ab, Elemente im Hauptfenster Das Hauptfenster sieht folgendermaßen aus: Unter der Taskleiste befindet sich links die Combobox Role. In dieser Combobox wählen Sie aus, welche Rolle Sie bearbeiten möchten. Im Textfeld darunter wird die Beschreibung zu der ausgewählten Rolle angezeigt. In der Gruppierung Identity werden alle Informationen zu der Identität des Services angegeben, für den die Rollen konfiguriert werden. Name ist der Name, der im Authentication and Authorisation Toolfür den Service angezeigt wird. Die Description enthält die Beschreibung des Services, die im Authentication and Authorisation Tool im Tooltip des Dienstes angezeigt wird. Mit der ID identifiziert sich der Service eindeutig. Unter diesen Elementen befindet sich der Access Unit Tree in tabellarischer Form. Dieser stellt die Rechte der ausgewählten Rolle dar. In der ersten Spalte werden alle Access Units mit einem Symbol in ihrer hierarchischen Baumstruktur dargestellt. Das Symbol für Access Units ist der Schlüssel das Symbol für Form Access Units der Schlüssel auf einem Form . Die weiteren Spalten stellen die einzelnen Zugriffsartendar, für die Rechte vergeben werden können. Die einzelnen Zugriffsarten sind: ACC (Access): Daten lesen bzw. Form öffnen ACD(Access derived): Betrifft nur Access Units von Forms: Diese Zugriffsart regelt, ob Ableitungen des Forms dieser Access Unit geöffnet werden dürfen UPD (Update): Vorhandene Daten aktualisieren INS (Insert): Neue Daten einfügen DEL (Delete): Daten löschen Rechte für die einzelnen Zugriffsarten werden durch besondere Checkboxen dargestellt. Die Checkboxen können folgende Werte annehmen: Explizit erlaubt: Diese Zugriffsart wird explizit erlaubt. Hierarchisch erlaubt: Diese Zugriffsart wird automatisch erlaubt, weil diese Access Unit ein Unterelement einer anderen Access Unit ist, für die das Recht für diese Zugriffsart erteilt wurde. Explizit verboten: Diese Zugriffsart wird explizit verboten. Hierarchisch verboten: Diese Zugriffsart wird automatisch verboten, weil diese Access Unit ein Unterelement einer anderen Access Unit ist, für die das Recht für diese Zugriffsart verboten wurde. Explizit keine Angabe: Zu dieser Zugriffsart wird explizit keine Angabe gemacht. Keine Angabe: Zu dieser Zugriffsart wird keine Angabe gemacht, es wurde auch kein Recht durch die Hierarchie geerbt. Sie können den Wert der Checkbox durch Anklicken mit der linken Maustaste oder über das Kontextmenü ändern. Wenn ein Benutzer durch verschiedene Rollen unterschiedliche Angaben zu einer Zugriffsart bekommt, wirkt das Recht mit der höchsten Priorität. Die höchste Priorität hat Explizit verboten, danach folgen Hierarchisch verboten, Explizit erlaubt, Hierarchisch erlaubt und mit niedrigster Priorität Keine Angabe und Explizit keine Angabe. Note Access Units können an mehreren Stellen im Hierarchiebaum eingehängt sein. In einem solchen Fall hat innerhalb der Rolle Hierarchisch erlaubt höhere Priorität als Hierarchisch verboten. Im Kontextmenü einer Access Unit werden unter dem Menüpunkt Parents alle Access Units aufgelistet, an denen diese Access Unit im Hierarchiebaum eingehängt ist. Durch Anklicken wird die entsprechende Access Unit ausgewählt. Im Access Unit Tree wird mit der Multiplikationstaste * der komplette Teilbaum der ausgewählten Access Unit aufgeklappt, mit der Subtraktionstaste - wird der Teilbaum wieder kollabiert. Mit der Tastenkombination <Strg+F> wird die Suche nach Access Units geöffnet. Im Tool Tipp einer Access Unit im Access Unit Tree werden der technische Name der Access Unit, ihre ID und ggf. die hinterlegte Beschreibung angezeigt. Rollen verwalten Mit dem Button New legen Sie eine neue Rolle an. Name und Beschreibung der Rolle können angegeben werden. Außerdem haben Sie beim Anlegen einer neuen Rolle einmalig die Möglichkeit, den zufällig generierten Schlüssel, mit dem die Rolle eindeutig identifiziert wird (Internal identifier), zu ändern. Dies ist nur dann sinnvoll, wenn die Rolle von Framework Studio Applikationen älter als 3.4 verwendet werden soll. Dort wird als Rollenname der Internal identifier benutzt. Mit dem Button Edit können Sie Name und Beschreibung der ausgewählten Rolle ändern. Mit dem Button Copy legen Sie eine neue Rolle an, bei der alle Einstellungen im Access Unit Tree von der zuvor ausgewählten Rolle kopiert werden. Mit dem Button Delete löschen Sie die ausgewählte Rolle. Mit dem Button Save speichern Sie die aktuellen Einstellungen der ausgewählten Rolle am Authentication Service. Mit dem Button Undo machen Sie alle Änderungen an der ausgewählten Rolle seit dem letzten Speichern oder Laden rückgängig. Mit dem Button Refresh all aktualisieren Sie alle Rollendefinitionen am Authentication Service. Der Fortschritt der Aktualisierung wird in der Progressbar in der linken unteren Ecke des Hauptfensters angezeigt. Note Der Authentication Service hält die Rollendefinitionen selbstständig aktuell. Daher besteht keine Notwendigkeit, diese Funktion manuell aufzurufen. Mit dem Button Import importieren Sie eine Rolle aus einer XML-Datei. Im Auswahldialog können Sie auch mehrere Dateien auswählen und somit mehrere Rollen in einem Schritt importieren. Mit dem Button Export exportieren Sie eine Rolle in eine XML-Datei. Mit dem Button Export all exportieren Sie alle Rollen in einen auszuwählenden Ordner. Mit dem Button Copy from service kopieren Sie Rollen von einem anderen Service in den aktuellen Service. Im Dialog Role Management Tool – Service Selector wählen Sie (analog zur Anmeldung am Role Management Tool) den Service aus, von dem die Rollen kopiert werden sollen. Note In diesem Dialog werden nur Services aufgelistet, bei denen die Rollen nicht vom Service selbst verwaltet werden, also nur Role managed by User. Das bedeutet, dass Sie diese Funktion nicht verwenden können, um Rollen von Applikationen zu kopieren, die mit einer Framework Studio Version alter als 3.0 erstellt wurden. Wollen Sie Rollen von einer älteren Applikation übernehmen, müssen Sie diese zunächst mit dem alten Role Management Tool an der alten Applikation in Dateien exportieren und anschließend mit der aktuellen Version des Role Management Tools wieder importieren. Mit dem Button Search Access Unit suchen Sie im Access Unit Tree nach Access Units. Im Textfeld Search for geben Sie den Suchtext an. Im Bereich Search in geben Sie an, wo nach diesem Text gesucht werden soll: Name: Technischer Name der Access Unit, z.B. aufrmArticle Label: Bezeichnung, die im Access Unit Tree angezeigt wird Description: Beschreibung, die für die Access Unit hinterlegt wurde ID: ID, die die Access Unit eindeutig identifiziert Mit der Checkbox Search Up legen Sie fest, ob von der aktuellen Position im Access Unit Tree aus aufwärts gesucht werden soll. Im Bereich Permissions kann nach bestimmten Zugriffsrechten gesucht werden. Durch setzen der Checkboxen Access, Access Derived, Update, Insert oder Delete werden Vergleiche für die jeweilige Zugriffsart aktiviert. Für jede Zugriffsart kann der Wert mit einem der folgenden verglichen werden: In der folgenden Übersicht wird für jede Option angegeben, auf welche Werte die Option einschränkt: None: None und Explicit None Allowed: Hierarchic Allowed und Explicit Allowed Denied: Hierarchic Denied und Explicit Denied Explicit None: Explicit None Explicit Allowed: Explicit Allowed Explicit Denied: Explicit Denied Grey: Alle Rechte, jedoch nur die, die durch eine verwendete Lizenz verboten sind. Das entspricht allen Checkboxen, die mit grauem Hintergrund dargestellt werden. Ändern Sie das Recht durch Anklicken oder über das Kontextmenü der Rechte-Checkbox. Mit dem Button Find Next wird die Suche gestartet, mit dem Button Done beenden Sie die Suche und schließen das Suchfenster Die Suchergebnisse werden im Access Unit Tree blau und unterstrichen dargestellt. Mit dem Button Show List werden alle Access Units, die den Suchkriterien entsprechen in einer Liste angezeigt. In diesem Dialog kann mit dem Button Copy to clipboard (Tastenkombination <Strg + C>) die gesamte Liste mit Suchkriterien in die Zwischenablage kopiert werden. Mit dem Button Copy selected to clipboard werden alle ausgewählten Einträge in die Zwischenablage kopiert. Durch Doppelklick auf einen Eintrag wird dieser im Access Unit Tree ausgewählt. Mit dem Button Search Roles im Role Management Tool suchen Sie für die aktuell ausgewählte Access Unit nach allen Rollen, in denen für diese Access Unit die angegebenen Rechte gesetzt sind. In der Gruppierung Access Unit werden alle Informationen zur ausgewählten Access Unit angezeigt. In der Gruppierung Permissions können für alle Zugriffsarten (Access, Access Derived, Update, Insert und Delete) Rechte (explizit oder implizit erlaubt oder verboten), angegeben werden (siehe auch Access Unit Search). Mit dem Button Search Roles werden alle Rollen angezeigt, in denen die angegebenen Rechte für die Access Unit gesetzt sind. Dazu muss mindestens ein Recht gesetzt sein. In diesem Dialog kann mit dem Button Copy to clipboard (Tastenkombination <Strg + C>) die gesamte Liste mit Suchkriterien in die Zwischenablage kopiert werden. Mit dem Button Copy selected to clipboard werden alle ausgewählten Einträge in die Zwischenablage kopiert. Durch Doppelklick auf eine Rolle wird diese im Hauptfenster ausgewählt. Mit der Combobox Language wird die Sprache festgelegt, in der die Access Units im Access Unit Tree dargestellt werden. Neben allen Sprachen des Defaultpackages steht dort der Eintrag zur Auswahl, mit dem Sie einstellen können, dass der technische Name der Access Units zur Anzeige verwendet werden soll."
  },
  "doc/runtime-administration/runtime-administration-user.html": {
    "href": "doc/runtime-administration/runtime-administration-user.html",
    "title": "Benutzer verwalten / Authentication and Authorisation Tool",
    "keywords": "Benutzer verwalten / Authentication and Authorisation Tool Allgemeines Benutzer können in Gruppen organisiert werden. Jeder Benutzer kann in mehreren Gruppen enthalten sein. Jeder Gruppe können mehrere Rollen zugeordnet sein. Ein Benutzer kann mit einem Windows Domänenbenutzer verknüpft werden. Gruppen haben einen eindeutigen Schlüssel, der vor dem Anwender versteckt wird. Auch Rollen haben einen eindeutigen Schlüssel, der aus Gründen der Abwärtskompatibilität beim Anlegen einer neuen Rolle einmalig manuell angegeben werden kann. Ansonsten wird auch der Schlüssel der Rollen vor dem Anwender versteckt. Durch die Verwendung von eindeutigen Schlüsseln für Gruppen und Rollen können diese umbenannt werden, ohne dass Zuordnungen verloren gehen. Wenn eine Endanwendung dem Authentication Service mehrere Geschäftseinheiten (Units) mitteilt, so können Benutzerrechte für jede Geschäftseinheit individuell vergeben werden. Wenn Sie das Authentication and Authorisation Tool starten, sehen Sie folgendes Fenster. Bedienkonzept: Es gibt drei Hauptregisterkarten Users, Groups und Roles (siehe 1 in obigem Screenshot), die alle nach dem gleichen System aufgebaut sind: Im linken Bereich (siehe 2 im Screenshot) wird das Element ausgewählt, welches konfiguriert werden soll (hier: Benutzer „Admin“). Im mittleren Bereich (siehe 3) befinden sich zwei weitere Registerkarten, auf denen jeweils die Verknüpfungen des links ausgewählten Elements mit den anderen Elementen definiert werden (hier Gruppen und Rollen). Im rechten Bereich (4) werden Eigenschaften des links ausgewählten Elements angezeigt. Im Screenshot können durch Setzen der Checkboxen im Bereich 3 dem links ausgewählten Benutzer „Admin“ Rollen zugeordnet werden. Durch Wechseln der Registerkarte im mittleren Bereich können Sie definieren, welchen Gruppen der Benutzer „Admin“ zugeordnet sein soll. In allen Listendarstellungen gibt es einen Tooltip, der Details zu dem Element anzeigt, sowie die Maus für mehr als 5 Sekunden darüber still gehalten wird. Außerdem kann durch Doppelklick auf ein Element in einer Listendarstellung in Bereich 3 die Sichtweise gewechselt werden: Das geklickte Element wird im Auswahlbereich (2) geöffnet. Über jeder Listenansicht gibt es ein Eingabefeld mit der Bezeichnung Filter. In der Listenansicht werden nur die Elemente angezeigt, die den als Filter eingegebenen Text enthalten. Ob ein Buchstabe groß oder klein geschrieben wird, ist dabei unerheblich. So ist ein schnelles Finden von Elementen möglich. Folgende Sonderzeichen können in Filter-Eingabefeldern allein oder vor dem eigentlichen Filtertext angegeben werden: + Nur neu angelegte Elemente anzeigen - Nur gelöschte Elemente anzeigen (diese werden sonst ausgeblendet) * Nur geänderte Elemente anzeigen ! Nur zugeordnete Elemente anzeigen (dieses Sonderzeichen macht nur bei Listenansichten mit Checkbox Sinn) Die Filter-Eingabefelder zeigen die jeweils gültigen Sonderzeichen im Tooltip an. Beispiel: Filter „!Lo“ bedeutet, alle Elemente, deren Checkbox gesetzt ist und welche die Zeichen „Lo“ enthalten. Wenn Änderungen an einem Benutzer durchgeführt werden und diese Änderungen noch nicht gespeichert wurden, wird der Benutzer mit einem Sternchen in Klammern (*) gekennzeichnet. Neu hinzugefügte Benutzer, die noch nicht gespeichert wurden, werden mit einem Plus in Klammern (+) gekennzeichnet. Mit dem Button Save All werden alle Änderungen gespeichert. Mit dem Button Reload All werden alle aktuellen Änderungen verworfen und alle Daten neu vom Authentifizierungsdienst geladen. Note Das neue Einlesen der Daten mit dem Button Reload All ist auch dann notwendig, wenn Sie im Role Management Tool relevante Änderungen an Rollen durchgeführt haben, also beispielsweise neue Rollen angelegt oder die Bezeichnung geändert haben. Allgemeine Hinweise: Note Der Authentifizierungsdienst selbst wird unter der Bezeichnung AuthenticationService mit den Rollen ManageUsers und ManageRoles aufgeführt. Jedem Benutzer, der das Authentication and Authorisation Tool starten will, muss die Rolle ManageUsers zugeordnet sein, jedem Benutzer, der das Role Management Tool starten will, muss die Rolle ManageRoles zugeordnet sein! Note Dem Benutzer Admin werden beim Start des Authentifizierungsdienstes automatisch die Rollen ManageUsers und ManageRoles zugeordnet. Benutzer verwalten (Registerkarte Users) Mit dem Button New auf der Hauptregisterkarte Users wird ein neuer Benutzer angelegt. Wenn Sie Advanced Security aktiviert haben (siehe Installationsanleitung Authentication Service), sind weitere Eingabefelder sichtbar. Wenn Sie Domain und Domain Controller angegeben haben (ebenfalls beschrieben in der Installationsanleitung Authentication Service), ist zusätzlich ein Eingabefeld für den Domänenbenutzer (Domain user) sichtbar **User:**Name des Benutzers. Password: Passwort des Benutzers **Confirm:**Passwortwiederholung. Dieses Feld muss nur angegeben werden, wenn das Passwort neu festgelegt oder geändert wurde. Domain user: Nur wenn der Authentication Service mit Domain und Domain Controller konfiguriert wurde, wird dieses Eingabefeld angezeigt. Darin kann der Benutzer mit einem Domänenbenutzer verknüpft werden. Das zu verwendende Format ist Domäne\\Benutzer. Wird eine Applikation auf einem Windows System gestartet, an dem der Domänenbenutzer angemeldet ist, so wird automatisch der zugeordnete Benutzer angemeldet. Ein Domänenbenutzer kann nur einem Benutzer zugeordnet werden. Enable: Wenn die Checkbox gesetzt ist, ist der Benutzerzugang freigeschaltet. Valid from: Wenn die Checkbox gesetzt ist, kann ein Datum angegeben werden, ab dem der Benutzerzugang gültig ist. Valid to: Wenn die Checkbox gesetzt ist, kann ein Datum angegeben werden, bis zu dem der Benutzerzugang gültig ist. Change password required: Wenn die Checkbox gesetzt ist, muss der Benutzer bei der ersten Anmeldung sein Passwort ändern. Enable Advanced Security: Ist diese Checkbox gesetzt, gelten die erweiterten Sicherheitsanforderungen, wie sie am Authentication Service definiert sind. Note Die erweiterten Sicherheitseinstellungen dürfen typischer Weise nicht für den Benutzer aktiviert werden, der als Standardbenutzer für den Login an Applikationen vorgesehen ist (Standardbezeichnung anonymous), da dessen Passwort zeitlich unbegrenzt gültig sein muss. Mit dem Button Delete wird der aktuell ausgewählte Benutzer gelöscht. Mit dem Button Edit werden die Eigenschaften des aktuell ausgewählten Benutzers geändert. Wenn Sie Advanced Security aktiviert haben (siehe Installationsanleitung Authentication Service), sind weitere Eingabefelder sichtbar. Wenn Sie Domain und Domain Controller angegeben haben (ebenfalls beschrieben in der Installationsanleitung Authentication Service), ist zusätzlich ein Eingabefeld für den Domänenbenutzer (Domain user) sichtbar. Bis auf den Benutzernamen können hier alle Angaben, wie bei der Funktion New beschrieben, angegeben werden. Mit dem Button Copy kann ein neuer Benutzer angelegt werden, der bis auf den Namen und das Passwort die gleichen Eigenschaften wie der aktuell ausgewählte Benutzer erhält. Gruppen Verwalten (Registerkarte Groups) Mit dem Button New auf der Registerkarte Groups wird eine neue Gruppe angelegt, mit dem Button Edit kann die ausgewählte Gruppe bearbeitet werden. Mit beiden Buttons öffnet sich ein Dialog, in dem der Name der Gruppe und eine Beschreibung eingegeben werden kann. Mit dem Button Delete wird die aktuell ausgewählte Gruppe gelöscht. Rollen Verwalten (Registerkarte Roles) In der Combobox Service wird der Service ausgewählt, dessen Rollen verwaltet werden sollen. Auf dieser Registerkarte können nur die Zuordnungen zu Gruppen und Benutzern verwaltet werden (siehe 3.1). Zum Anlegen, Umbenennen und Löschen von Rollen wird das Role Management Tool (siehe 4) verwendet. Services Verwalten (Registerkarte Services) Die Registerkarte Services ist in vier Spalten organisiert. Analog zu den anderen Registerkarten wird in der ersten Spalte das Element ausgewählt, welches konfiguriert werden soll. In diesem Fall der gewünschte Service. In der zweiten Spalte werden die Eigenschaften des ausgewählten Services angezeigt. Die Spalten drei und vier sind nicht von Interesse, wenn der ausgewählte Service keine Geschäftseinheiten (Units) besitzt. In diesem Fall enthalten die Spalten keinerlei Daten. Wenn der ausgewählte Service bei der Registrierung am Authentifizierungsdienst Geschäftseinheiten mitgeteilt hat, so werden in der dritten Spalte alle Geschäftseinheiten aufgelistet. In diesem Fall wird zu der in der dritten Spalte ausgewählten Geschäftseinheit deren Eigenschaften in der vierten Spalte angezeigt. Dort kann außerdem eine Geschäftseinheit, die als veraltet (obsolete) markiert ist (siehe 0), mit dem Button Delete Obsolete Unit gelöscht werden. Note Wenn für diese Unit Rollen zu Benutzern oder Gruppen zugeordnet waren, gehen diese Zuordnungen dabei unwiderruflich verloren! Mit dem Button Delete Service wird der aktuell ausgewählte Service am Authentifizierungsdienst vollständig entfernt. Note Wenn Rollen von diesem Service Benutzern oder Gruppen zugeordnet waren, gehen diese Zuordnungen unwiderruflich verloren! Mit dem Button Copy mappings from… können für den ausgewählten Service Rollen-Zuordnungen von einem anderen Service übernommen werden. Bestehende Zuordnungen werden dabei überschrieben. Dazu muss der Service ausgewählt werden, von dem die Rollen-Zuordnungen kopiert werden sollen. Hat der ausgewählte Service mehrere Geschäftseinheiten, so können auch aus diesem Service selbst Rollen-Zuordnungen von einer Geschäftseinheit in eine andere kopiert werden. Nach der Auswahl des Services, aus dem kopiert werden soll, erscheint der Dialog Copy role mappings from…, in dem die genauen Optionen für den Kopiervorgang festgelegt werden. Mit den Checkboxen User-Role mappings und Group-Role mappings wird festgelegt, ob Benutzer-Rollen Zuordnungen und Gruppen-Rollen Zuordnungen kopiert werden sollen. Der Bereich Units ist komplett deaktiviert, falls weder der als Quelle noch der als Ziel ausgewählte Service über mehrere Geschäftseinheiten verfügt. Andernfalls gibt es zwei Kopiermodi zur Auswahl: All Units: In diesem Modus werden für alle Units, die in beiden Versionen existieren, die Zuordnungen eins zu eins übertragen. Achtung: Alle Zuordnungen (egal für welche Unit), die vorher im Ziel existiert haben, werden dabei gelöscht. Dieser Modus steht nur zur Auswahl, wenn sowohl der als Quelle, als auch der als Ziel ausgewählte Service mehrere Mandanten enthält. One Unit: In diesem Modus werden Zuordnungen aus der Geschäftseinheit Source Unit in die Geschäftseinheit Target Unit kopiert. Alle zuvor existierenden Zuordnungen zur Target Unit werden dabei gelöscht. Alle anderen Geschäftseinheiten im Ziel Service werden dabei nicht verändert. Die Geschäftseinheiten Source Unit und Target Unit müssen ggf. über die entsprechenden Buttons Select ausgewählt werden. Erst dann wird der Button Start aktiviert. Mit dem Button Start wird der Vorgang gestartet. Gegebenenfalls erhalten Sie Hinweismeldungen, wenn Rollen oder Geschäftseinheiten aus dem als Quelle ausgewählten Service im Ziel Service nicht existieren. Mit dem Button Cancel wird die Konfiguration der Kopieroptionen und damit auch der Kopiervorgang abgebrochen. Arbeiten mit mehreren Geschäftseinheiten (Units) Seit Framework Studio 3.7 kann eine Framework Studio Endanwendung dem Authentifizierungsdienst Geschäftseinheiten (Units) mitteilen. Diese werden im Authentication and Authorization Tool auf der Registerkarte Services für den ausgewählten Service angezeigt (siehe 3.5). Wird eine Unit beim Start eines Services dem Authentifizierungsdienst nicht mehr mitgeteilt, so wird diese als veraltet (obsolete) markiert. Erst dann kann eine Unit endgültig (mit den Button Delete Obsolete Unit, siehe 3.5) aus dem Authentifizierungsdienst gelöscht werden. Bis dahin bleiben alle Zuordnungen zu dieser Unit erhalten. Note Im Broker werden die Geschäftseinheiten nicht bei jedem Anwendungsstart geprüft und an den Authentifizierungsdienst übermittelt, sondern nur beim ersten Start der Anwendung. Sollen diese erneut geprüft und der Authentifizierungsdienst über Änderungen informiert werden, muss daher ggf. der genutzte Application Pool im IIS neu gestartet werden. Note Als veraltet gekennzeichnete Units werden in der Vorbelegung der Unit Filter für die Rollenzuordnung ausgeblendet. Über den Button Filter Units ist ein Einblenden jederzeit möglich. In diesem Fall wird der Name der Unit in Spaltenüberschriften in Klammern gesetzt. Wenn ein Service mehrere Units hat, werden in allen Ansichten, in denen Rollen mit Benutzern oder Rollen mit Gruppen verknüpft werden, aus den Listenansichten mit Checkboxen Tabellen mit Checkboxen. In der ersten Spalte wird immer der Name des zu verknüpfenden Elements (im obigen Screenshot der Name der Rolle) angezeigt. Darauf folgen Spalten für alle Units, die im Dialog Select Units ausgewählt wurden. Voreingestellt werden alle Units angezeigt, die nicht als veraltet (obsolete) gekennzeichnet sind. Der Dialog wird mit dem Button Filter Units geöffnet. Eine Sonderstellung hat die (immer als erste Unit dargestellt) vom System automatisch generierte Unit mit der Bezeichnung General. Ist für einen Benutzer oder ein Gruppenmitglied bei dieser Unit für eine Rolle ein Haken gesetzt, so bedeutet dies, dass ihm an allen Units diese Rolle zugewiesen ist, an denen ihm irgend eine Rolle explizit zugeordnet ist. Beispiel: Rollen O.General 1. Unit A 2. Unit B 3. Unit C 4. Unit D General Usage x x Buyer x Administrator x Der Benutzer kann sich an Unit 1, Unit 3 und Unit 4 anmelden, da er für diese Units explizit einer Rolle zugewiesen ist. An diesen Units ist ihm durch die Zuordnung der General Unit auch die Rolle Buyer zugeordnet. Die Rechte bei der Anmeldung sind also: Unit 1: General Usage, Buyer Unit 2: Keine Rechte Unit 3: General Usage, Buyer Unit 4: Buyer, Administrator In den Tabellenansichten werden die Units von 0. bis 9. durchnummeriert dargestellt. Diese Nummer stellt die Ziffer dar, mit der Sie, in der aktuell ausgewählten Zeile, den Wert der Checkbox in der durch die Nummer identifizierten Unit wechseln können. Mit der Taste Leertaste werden alle angezeigten Units, außer der General Unit, geschaltet. Beispiel: Rollen O.General 1. Unit A 2. Unit B 3. Unit C 4. Unit D General Usage x x Buyer x Administrator x Zeile „General Usage“: Taste 4 wird gedrückt => Unit D ist zusätzlich ausgewählt Zeile „Buyer“: Taste 0 wird gedrückt => General ist nicht mehr ausgewählt Zeile „Administrator“: Leertaste wird gedrückt => Alle Units (außer General) sind ausgewählt Note Diese Shortcuts ermöglichen es im Zusammenspiel mit der Unit-Filterfunktion, für ausgewählte Units die gleichen Einstellungen zu vorzunehmen. Beispiel: Ein Benutzer hat grundsätzlich Rechte an den Units A, B, C und D. Ihm sollen viele Rollen zugeordnet werden. Diese Rollen sollen genau gleich an den Units A, B und D gesetzt werden, also nicht an Unit C. Nun können Sie mit dem Button Filter Units die Units A, B, und D zur Darstellung auswählen. Nun selektieren Sie nach und nach die gewünschten Rollen und drücken die Leertaste. Auf diese Weise werden jeweils die Checkboxen für die Units A, B, und D gesetzt. Unit C bleibt unberührt, da diese nicht angezeigt wird."
  },
  "doc/runtimesupervisor/runtimesupervisor-common.html": {
    "href": "doc/runtimesupervisor/runtimesupervisor-common.html",
    "title": "Runtime Supervisor",
    "keywords": "Runtime Supervisor Was ist der Runtime Supervisor? Der Runtime Supervisor ist ein Software Bundle mit dem die gesamte Framework Studio Runtime an zentraler Stelle überwacht, analysiert und ausgewertet werden kann. Die Framework Studio Runtime stellt dabei die mit Framework Studio entwickelte Anwendung und deren zur Ausführung benötigte Zusatzprogramme dar. Dies sind: Framework Studio Broker Framework Studio Service Host Authentication Service Print Service Document Service Diese Programme werden im Normalfall auf unterschiedlichen Servern im Netzwerk ausgeführt. Das folgende Bild zeigt einen typischen Aufbau einer Framework Studio Runtime mit Runtime Supervisor für die Überwachung. Jedes Programm, welches durch den Runtime Supervisor überwacht wird, wird als “Observable” bezeichnet. Alle Observables stehen immer in direktem Kontakt zum Runtime Supervisor. Dies erlaubt es dem Runtime Supervisor “live” Informationen zu sammeln, auszuwerten und auf Events der Observables zu reagieren. Features Echtzeitüberwachung Am Runtime Supervisor registrierte Observables werden in Echtzeit überwacht. Durch ein sehr leichtgewichtiges Kommunikationsinterface auf Basis von ASP.NET SignalR wird der Online-Status sowie die Netzwerkverbindung zwischen Observable und Runtime Supervisor stetig überwacht. Es muss nicht immer ein Totalausfall sein. Auch alte Netzwerkinfrastruktur oder Netzwerkkabel können z.B. zu instabiler Kommunikation und Fehlern in verteilten Systemen führen. Der Runtime Supervisor informiert Sie über instabile Netzwerkverbindungen zu den Observables. So kann im besten Fall reagiert werden, noch bevor der erste Mitarbeiter einen Fehler auf dem Bildschirm hat. Event Logs Jedes Observable in der Framework Studio Runtime führt bisher sein eigenes Event Log, sei es in der Windows Ereignisanzeige, in einer Datenbank oder in einem Logfile. Gibt es Probleme, muss zuerst einmal die richtige Stelle gefunden werden, wo potenzielle Fehler erfasst wurden. Es heißt erst einmal “finde den Server” anstatt “finde den Fehler”. Jedes am Runtime Supervisor registrierte Observable leitet jedes Event Log, welches protokolliert werden soll, an den Runtime Supervisor weiter. Somit werden alle Event Logs eines jeden Observables kategorisiert, an zentraler Stelle gesammelt und können mit wenigen Klicks ausgewertet werden. Alerting Jedes Event Log, welches an den Runtime Supervisor geschickt wird, ist nutzlos, wenn es nicht beachtet wird. Deswegen gibt es ein Alerting-System, welches in der Lage ist, abhängig vom Loglevel (Information, Warning, Error, Critical) eMails an registrierte Empfänger zu schicken. So lässt sich die gesamte Framework Studio Runtime z.B. überall mit dem Smartphone beobachten, ohne sich manuell am Runtime Supervisor anmelden zu müssen. Statusinformationen Nicht alle am Runtime Supervisor registrierten Observables müssen auch zur gleichen Zeit online sein. Um den Überblick zu behalten, werden Statusinformationen zu allen Observables angeboten. Auszug: Onlinestatus Wann wurde das Observable gestartet? Läuft das Observable als Konsolenprogramm, im IIS oder als Windows Service? Wann wurde das Observable beendet? Wurde es regulär oder auf Grund eines Fehlers beendet? … Informationen über die Hardware Die am Runtime Supervisor registrierten Observables laufen im Normalfall auf verschiedenen Servern im Netzwerk. Um einen besseren Überblick über die von der Framework Studio Runtime genutzten Rechner zu bekommen, werden Informationen über die Hardware an den Runtime Supervisor geschickt. Auszug: Prozessor Wie viele CPU-Kerne? Prozessorgeschwindigkeit Arbeitsspeicher Speicherbelegung lokaler Laufwerke Ist der Prozessor 64 Bit? … Informationen über die Software Die vom Runtime Supervisor angebotenen Softwareinformationen enthalten nicht nur Daten zum Observable selbst, sondern auch zum Betriebssystem, auf dem es läuft. Oft wird vergessen, ob auf einem Server ein Service Pack installiert ist oder nicht und wenn ja, welches. Diese Informationen werden alle am Runtime Supervisor zusammengefasst. Auszug: Betriebssystem Service Pack Ist das Betriebssystem 64 Bit? Installationsverzeichnis des Observables Mit welchem User wird das Observable ausgeführt? … Runtime Supervisor Komponenten Der Runtime Supervisor besteht insgesamt aus drei Komponenten, einer Datenbank, einem Windows Service und einer Web Application. Diese müssen nicht zwingend auf demselben Server installiert sein (mehr in Kapitel). Datenbank Der Runtime Supervisor benötigt für die Datenhaltung eine relationale Datenbank. Hierfür kann entweder Microsoft SQL Server oder Oracle eingesetzt werden. Die Datenbank bleibt bei einem Update oder einer Neuinstallation des Runtime Supervisor erhalten, sodass der Windows Service und die Web Application anschließend nicht neu konfiguriert werden müssen. Alle Einstellungen bis hinauf zur Benutzeroberfläche der Web Application werden in der Datenbank persistiert. Windows Service Der Windows Service ist der Mittelpunkt des Runtime Supervisor. Alle automatisierten Prozesse werden hier verwaltet. Er hat direkten Zugriff auf die Datenbank und ist verantwortlich für die Kommunikation mit den zu überwachenden Observables. Features: Kommunikationsschnittstelle zu den Observables Überwachung der Observables Versenden von eMails Periodisches Löschen alter Event Logs … Web Application Die Web Application ist die Benutzeroberfläche des Runtime Supervisor und wird als Website im IIS (Internet Information Service) gehostet. Sie bereitet alle vom Windows Service gesammelten Informationen über die Observables und deren Systeme grafisch auf und stellt Masken zur Konfiguration des Runtime Supervisor bereit. Features: Benutzeroberfläche in Form einer Website Responsive Design Übersicht über registrierte Observables (Dashboard) Anzeige der Event Logs inkl. Filteroptionen Konfiguration des Runtime Supervisor …"
  },
  "doc/runtimesupervisor/runtimesupervisor-features.html": {
    "href": "doc/runtimesupervisor/runtimesupervisor-features.html",
    "title": "Funktionsweise",
    "keywords": "Funktionsweise In den nachfolgenden Kapiteln wird ein Einblick in die Funktionsweise des Runtime Supervisor gegeben. Viele Prozesse laufen vollständig automatisiert ab, wie z.B. das Senden von Event Logs von einem Observable an den Runtime Supervisor, das Versenden von eMails beim Eingang eines bestimmten Event Logs oder die Verbindungsüberwachung in Echtzeit. Um diese Prozesse besser verstehen zu können, werden nachfolgend die wichtigsten Prozesse auf technischer Ebene erläutert. Identifikation von Observables Der Runtime Supervisor muss Observables eindeutig zuordnen können. Ein Print Service hat z.B. eine ID in Form einer Guid. Diese ist jedoch für den Runtime Supervisor nicht eindeutig. Wird dieser Print Service z.B. mit derselben Konfiguration auf einem anderen Server gestartet (zum Test), sollte dieser vom Runtime Supervisor auch als eigenständiger Print Service erkannt werden, da der Print Service auf dem anderen Server gleichzeitig gestartet werden könnte. Abhilfe schafft die sogenannte „Client ID“, mit der sich ein Observable am Runtime Supervisor registriert. Diese ist ein 32 Bit langer MD5-Hashwert, der sich je nach Observable-Typ aus unterschiedlichen Bausteinen zusammensetzt. Nachfolgende Liste gibt Aufschluss darüber: Broker: Domain + Server + Install Name + Application Name + Application Pool Name Service Host: Domain + Server + Install Name + Service Host Name Authentication Service: Domain + Server + Authentication Service ID Print Service: Domain + Server + Print Service ID Document Service: Domain + Server + Document Service ID Der „Install Name“ ist der Name der Installation, der beim Publish in Framework Studio angegeben wird. Der „Application Name“ ist der Name der Framework Studio Application, die gepublisht wird. Sollte der Rechner, auf dem ein Observable läuft, nicht in einer Domäne registriert sein, wird diese nicht in den Hashwert mit aufgenommen. Registrierung von Observables Wie in Kapitel 5 erläutert wurde, benötigt ein Observable ausschließlich die URL des Runtime Supervisor Windows Service, um sich erfolgreich am Runtime Supervisor registrieren zu können und die Überwachung durch diesen zu initiieren. Wenn ein Observable konfiguriert wurde, sich mit dem Runtime Supervisor in Verbindung zu setzen, startet dieses beim Programmstart einen Prozess, der versucht, den Runtime Supervisor zu erreichen und sich an diesem zu registrieren. Hierfür wird die URL verwendet, die zuvor konfiguriert wurde. Das Observable startet nun den ersten Versuch, mit dem Runtime Supervisor Kontakt aufzunehmen. Bei diesem Request werden alle Daten übertragen, die nötig sind, um das Observable am Runtime Supervisor anzulegen. Diese Daten beinhalten hauptsächlich alle statischen Werte, die sich zur Laufzeit des Observables nicht ändern können (z.B. das Betriebssystem). Ist dem Runtime Supervisor das Observable mit der übertragenen Client ID schon bekannt, werden alle Daten entsprechend aktualisiert. Wurde der Registrierungsvorgang vom Runtime Supervisor erfolgreich bearbeitet, bekommt das Observable eine entsprechende Antwort. Erhält das Observable die Antwort, dass alles fehlerfrei bearbeitet wurde, wird der Registrierungsprozess auch an diesem abgeschlossen. Die Verbindung für die Überwachung seitens des Runtime Supervisor ist somit aufgebaut. Erhält das Observable die Antwort, dass ein Fehler aufgetreten ist oder erhält es nach einem Timeout sogar gar keine Antwort (Runtime Supervisor nicht erreichbar), dann wird in einem Intervall von 30 Sekunden immer wieder versucht, den Runtime Supervisor zu erreichen. Beim ersten Fehlversuch wird zudem ein entsprechender Eintrag in das Windows Event Log geschrieben. Verbindet sich ein Observable also nicht mit dem Runtime Supervisor, kann das Windows Event Log über den Grund Aufschluss geben. Parallelität Observables wie z.B. ein Authentication Service müssen neben der Kommunikation mit dem Runtime Supervisor auch “ihren eigenen Job machen”. Es kann natürlich sein, dass während des Abarbeitens eines Prozesses, der in Verbindung mit dem Runtime Supervisor steht, auch kritische Fehler auftreten. Diese potenziellen Fehler dürfen allerdings keinen Einfluss auf die eigentliche Aufgabe des Observables haben. Scheitert z.B. ein Authentication Service auf Grund eines Fehlers dabei, sich am Runtime Supervisor zu registrieren, darf dieser Fehler nicht zur Folge haben, dass der Authentication Service abstürzt und seinen eigentlichen Job nicht mehr machen kann. Deswegen laufen alle Prozesse, die in Zusammenhang mit dem Runtime Supervisor stehen, völlig losgelöst von den Hautprozessen der Observables. Überwachung der Verbindung Nachdem ein Observable erfolgreich am Runtime Supervisor registriert wurde, besteht ab diesem Zeitpunkt eine dauerhafte Verbindung. Diese Verbindung basiert auf ASP.NET SignalR. Eine SignalR-Verbindung wird automatisch auf drei Ebenen überwacht und generiert Events, die vom Runtime Supervisor und dem Observable verarbeitet werden können (z.B. ein Verbindungsabbruch). Die drei Ebenen der Verbindung sind die folgenden: Physisch: Die physikalische Verbindung ist das Kabel selbst. Wird der Netzwerkstecker gezogen, bricht die physische Verbindung ab. Transport: Die Transport-Verbindung ist in den meisten Fällen die TCP-Verbindung. Sie kann auch erhalten bleiben, wenn die darunter liegende physische Verbindung kurz unterbrochen wird (Packet Loss). Logisch: Die logische Verbindung wird von SignalR selbst aufrechterhalten. Sie wird mit einer ID versehen und kann auch längere Unterbrechungen der physischen Verbindung oder auch der Transport-Verbindung überstehen. So kann ein Observable z.B. innerhalb von 30 Sekunden nach dem Ziehen des Netzwerksteckers mit dem Runtime Supervisor „reconnected“ werden, ohne die logische Verbindung zu unterbrechen. Eine ausführliche Beschreibung der Funktionsweise einer SignalR-Verbindung würde den Rahmen dieser Dokumentation sprengen. Eine sehr gute Erklärung auf technischer Ebene bietet die ASP.Net SignalR Dokumentation von Microsoft. Diese finden Sie unter folgendem Link: http://www.asp.net/signalr Verarbeiten von Event Logs Wenn an einem Observable ein Event auftritt, resultiert dies meist aus einem unbehandelten Fehler bei der Ausführung des Programms. Diese Events wurden bisher dezentral in die vom Observable-Typ abhängigen Logs geschrieben (meist das Windows Event Log). Ist der Runtime Supervisor für ein Observable konfiguriert, wird dieses nach erfolgreicher Registrierung versuchen, Event Logs ausschließlich an den Runtime Supervisor zu schicken. Für den Fall, dass der Runtime Supervisor nicht verfügbar ist, oder beim Verarbeiten des Event Logs ein Fehler auftritt, gibt es Fallbacks, die garantieren, dass keine Event Logs „verloren gehen“. Log Store Tritt ein Event am Observable auf, wird diesem eine ID in Form einer Guid gegeben (hier im Text und in Abbildung 41 vereinfacht dargestellt). Das Event bekommt im Beispiel die ID 1. Es wird sofort vom Obvservable versucht, dieses Event über die bestehende SignalR-Verbindung an den Runtime Supervisor zu schicken. Dieser könnte zu diesem Zeitpunkt im schlechtesten Fall nicht erreichbar sein oder einen Fehler bei der Verarbeitung des Events produzieren. Im ersten Fall bekommt das Observable keine Antwort (Timeout). Im zweiten Fall bekommt das Observable die Antwort, dass sein Event nicht ordnungsgemäß verarbeitet wurde. In beiden Fällen wird das Event (ID 1) in den sogenannten “Log Store” geschrieben. Dieser beinhaltet alle Event Logs, die am Observable aufgetreten sind, jedoch noch nicht vom Runtime Supervisor verarbeitet wurden. Note Der Timestamp, der zu jedem Event Log im Runtime Supervisor gespeichert wird, ist der Zeitpunkt, zu dem das Event am Observable aufgetreten ist. Nun tritt kurz darauf (innerhalb von 30 Sekunden) ein zweites Event ein (ID 2). Es wird wieder versucht, dieses sofort an den Runtime Supervisor zu schicken. Zuvor wird jedoch überprüft, ob sich noch nicht verarbeitete Events im Log Store befinden. Ist dies der Fall (ID 1), so werden alle Events aus dem Log Store mit dem neu aufgetretenen Event an den Runtime Supervisor geschickt. Im Beispiel also Event 1 (aus dem Log Store) und Event 2. Nun kann der Fall eintreten, dass nur eines der beiden Events erfolgreich am Runtime Supervisor verarbeitet wird. Beim Versuch, Event 2 in die Datenbank zu schreiben könnte z.B. ein Fehler auftreten. In diesem Fall sendet der Runtime Supervisor in seiner Antwort an das Observable alle ID’s mit, die erfolgreich verarbeitet wurden. Das Observable stellt also fest, dass Event 1 nun erfolgreich verarbeitet wurde, Event 2 jedoch nicht. Die Folge ist, dass Event 2 nun in den Log Store geschrieben wird. Event 1 wurde erfolgreich verarbeitet und wird aus dem Log Store entfernt. Tritt nun erst einmal kein weiteres Event am Observable auf, wird alle 30 Sekunden überprüft, ob sich Events im Log Store befinden. Ist dies der Fall, wird alle 30s versucht, diese an den Runtime Supervisor zu schicken. Im Beispiel wird Event 2 nach 30s nochmals zum Runtime Supervisor geschickt und erfolgreich verarbeitet. Danach ist der Log Store am Observable leer. Fallback Event Logs dürfen nicht einfach verloren gehen, nur weil der Runtime Supervisor vielleicht nicht erreichbar ist oder selbst beim Verarbeiten auf einen Fehler stößt. Eine logische Folge aus dieser Situation wäre, dass der Log Store am Observable immer größer und niemals abgearbeitet wird. Im schlechtesten Fall läuft der Arbeitsspeicher des Rechners langsam mit Event Logs voll. Beenden des Observables Das Observable kann jederzeit beendet werden. Z.B. beim Update eines Authentication Service muss z.B. der Windows Service neu installiert werden. Zu diesem Zeitpunkt könnten sich jedoch noch nicht verarbeitete Event Logs im Log Store befinden. Das Observable bekommt aber mit, wenn es heruntergefahren wird. Es wird dann noch einmal versucht, die Events aus dem Log Store an den Runtime Supervisor zu senden. Schlägt dies fehl, werden alle nicht verarbeiteten Events in das bisherige Log des Observables geschrieben (meist das Windows Event Log). Sendeintervall Normalerweise werden die Events aus dem Log Store auch dann noch einmal zum Runtime Supervisor geschickt, wenn ein neues Event auftritt. Ist letzteres nicht der Fall, wird alle 30s überprüft, ob sich nicht verarbeitete Events im Log Store befinden und diese nochmals an den Runtime Supervisor geschickt. Kann ein Event innerhalb von 10 Minuten, aus welchem Grund auch immer, nicht am Runtime Supervisor verarbeitet werden, so wird dieses automatisch aus dem Log Store entfernt und in das Standard-Log des Observables geschrieben (Windows Event Log). Die Überprüfung, ob sich Events, die älter als 10 Minuten sind, im Log Store befinden, erfolgt jede Minute einmal. Versenden von eMails Das Versenden von eMails durch den Runtime Supervisor erfolgt über den .NET SMTP Client. Beim Eingang eines Event Logs am Runtime Supervisor wird überprüft, ob SMTP für den Runtime Supervisor aktiviert wurde (siehe Kapitel SMTP). Ist dies der Fall, dann werden alle Empfänger überprüft, die für den Event Log Level (Error, Warning, etc.) des eingegangenen Events eine Nachricht erhalten sollen (siehe Kapitel SMTP). Anschließend wird die eMail generiert und an jeden Empfänger versendet. Generierung der eMails Der Betreff der eMail beinhaltet Typ und Name des Observables. Im Text erscheint an erster Stelle das Event Log mit seinem Event Log Level und der Uhrzeit, zu der das Event am Observable aufgetreten ist. Danach kommt der eigentliche Text des Event Logs. An jede eMail vom Runtime Supervisor wird eine Zusammenfassung des Observables angehängt, zu dem das Event Log gehört. Der Link zur Seite des Observables in dieser Zusammenfassung wird nur generiert, wenn in den “Web Application Settings” des Runtime Supervisor die URL für “Web Application Root” definiert wurde (Siehe Kapitel Web Application). Aktualisierung dynamischer Daten Jedes Observable sendet Daten an den Runtime Supervisor, die sich zur Laufzeit ändern können. So kann sich z.B. der verfügbare Speicherplatz der lokalen Partitionen ändern. Diese dynamischen Daten werden periodisch an den Runtime Supervisor übertragen. Das Sendeintervall beträgt 5 Minuten. Statische Daten, wie z.B. Informationen über die Hardware des Rechners, sind von diesem Vorgang ausgeschlossen. Aktualisierung der Settings In der Web Application des Runtime Supervisor können im Bereich Settings (siehe Kapitel Settings) Einstellungen vorgenommen werden. Es kann während der Laufzeit des Runtime Supervisor Windows Service z.B. ein neuer Empfänger für eMails eingetragen werden. Einstellungen für die Web Application werden sofort übernommen und angewendet. Wenn z.B. die Einstellung „Number of records per page in events grid“ geändert wird und danach in die Event-Tabelle gewechselt wird, ist die neue Anzahl der Einträge auf einer Seite der Tabelle zu sehen. Für den Windows Service gilt dies nicht! Der Windows Service arbeitet mit sehr vielen parallelen Prozessen und kann deshalb nicht einfach auf Knopfdruck sämtliche Einstellungen übernehmen, ungeachtet dessen, was die Prozesse gerade verarbeiten. Der Windows Service kümmert sich deswegen im Intervall von 5 Minuten selbst darum, die in der Datenbank gespeicherten Settings zu aktualisieren. D.h., wird in der Web Application eine Einstellung geändert, die den Windows Service betrifft (z.B. die SMTP-Einstellungen) und werden diese gespeichert, heißt das erst einmal, dass sie korrekt in die Datenbank geschrieben werden. Ab diesem Zeitpunkt können also maximal 5 Minuten vergehen, bis der Windows Service die gespeicherten Einstellungen auch übernimmt. Im konkreten Fall kann es also sein, dass nach dem Speichern der SMTP-Einstellungen der Windows Service trotzdem noch für maximal 5 Minuten eMails über den zuvor aktiven SMTP-Server verschickt."
  },
  "doc/runtimesupervisor/runtimesupervisor-installation.html": {
    "href": "doc/runtimesupervisor/runtimesupervisor-installation.html",
    "title": "Installation",
    "keywords": "Installation Die Systemvoraussetzung für den Runtime Supervisor befinden sich hier. Vorbereiten einer Datenbank Microsoft SQL Server Wenn Microsoft SQL Server verwendet wird, muss nicht zwingend eine Datenbank vor der eigentlichen Installation durch den Setup Wizard erstellt werden. Der Setup Wizard überprüft selbst, ob die angegebene Datenbank schon existiert und ob der angegebene Benutzer die nötigen Rechte besitzt, die Datenbank und das Datenbankschema zu erstellen. Oracle Wenn Oracle verwendet werden soll, muss auf dem Datenbankserver ein entsprechender User angelegt sein, der dann im Setup Wizard angegeben werden kann. Setup Wizard Die Installation des Runtime Supervisor erfolgt über einen Setup Wizard, in dem alle für die Einrichtung nötigen Daten vom Benutzer abgefragt werden. Nachfolgend werden alle Schritte des Wizards beschrieben. Start Nach dem Start wird eine Übersicht über die vom Runtime Supervisor benötigten Programme angezeigt. Die Installation kann nur dann durchgeführt werden, wenn alle Voraussetzungen erfüllt sind. Wenn ein Programm aus der Liste noch nicht installiert sein sollte, wird “Not Installed” in rot angezeigt. Die Installation des Oracle ODP.NET Client ist optional. Ist dieser nicht installiert, wird “Not Installed” in orange angezeigt. Über den Button „Refresh“ kann die Anzeige aktualisiert werden, falls eines der fehlenden Programme installiert wurde, während der Setup Wizard schon geöffnet war. Lizenzvereinbarung Die allgemeinen Lizenzbedingungen müssen vor der Installation akzeptiert werden. Dazu muss die Checkbox aktiviert werden. Danach kann der Wizard fortgesetzt werden. Auswahl der Features Über die Baumstruktur kann definiert werden, welche Komponenten des Runtime Supervisor installiert werden sollen. Note Es muss mindestens eine Komponente ausgewählt werden, damit der Wizard fortgesetzt werden kann! Das Installationsverzeichnis kann über den Button „Browse“ oder durch manuelle Eingabe geändert werden. Auswahl des Datenbank-Providers In diesem Schritt wird festgelegt, mit welchem Datenbank-Anbieter der Runtime Supervisor arbeiten soll. Es besteht die Auswahl zwischen Microsoft SQL Server und Oracle. Sollte der optionale Oracle ODP.NET Client nicht installiert sein, kann nur “SQL Server” ausgewählt werden. Note Die Auswahl des Datenbank-Anbieters ist dauerhaft und kann nicht bei einem Update auf zukünftige Versionen des Runtime Supervisor geändert werden! SQL Server Datenbankverbindung Dieser Schritt wird nur angezeigt, wenn im vorherigen Schritt als Datenbank-Anbieter “SQL Server” ausgewählt wurde. Über diesen Dialog wird die Datenbankverbindung definiert, mit der der Runtime Supervisor arbeiten soll. Server: Servername oder IP des Zielservers. Database: Name der SQL-Datenbank, die der Runtime Supervisor verwenden/anlegen soll. Username: SQL-Benutzer, der verwendet werden soll (Windows Authentifizierung wird derzeit nicht unterstützt). Der User muss ausreichend Rechte besitzen, um das Datenbankschema ändern zu können (Tabellen anlagen etc.) und ggf. Rechte besitzen, um eine Datenbank anlegen zu können, sollte sie noch nicht existieren. Password: Das Passwort des angegebenen SQL-Benutzers. Über den Button “Test Connection” können die Angaben überprüft werden. Ist die Verbindung zum Server erfolgreich, wird zusätzlich angezeigt, ob die angegebene Datenbank schon existiert oder nicht. Note Es muss keine existierende Datenbank angegeben werden. Wird eine Datenbank angegeben, die noch nicht existiert, wird diese während der Installation automatisch erstellt. Oracle Datenbankverbindung Dieser Schritt wird nur angezeigt, wenn im vorherigen Schritt als Datenbank-Anbieter “Oracle” ausgewählt wurde. Über diesen Dialog wird die Datenbankverbindung definiert, mit der der Runtime Supervisor arbeiten soll. Server: Servername oder IP des Zielservers. Database: Name der Oracle-Datenbank-Instanz auf dem Zielserver, die der Runtime Supervisor verwenden soll. Username: Oracle-Benutzer, der verwendet werden soll. Der User muss ausreichend Rechte besitzen, um das Datenbankschema ändern zu können (Tabellen anlegen etc.). Password: Das Passwort des angegebenen Oracle-Benutzers. Über den Button “Test Connection” können die Angaben überprüft werden. Ist die Verbindung zum Server erfolgreich, wird zusätzlich angezeigt, ob die angegebene Datenbank schon existiert oder nicht. Einstellungen des Windows Service Der Windows Service kommuniziert mit den Observables über den Port, der in diesem Schritt definiert wird. Der Standard-Port ist 10000. Es muss ein Port zwischen 1024 und 65535 definiert werden. Über den Button “Test Port” kann geprüft werden, ob der definierte Port noch frei ist und nicht von einer anderen Anwendung bereits genutzt wird. Einstellungen der Web Application Die Web Application wird als Anwendung im IIS ausgeführt. In diesem Schritt wird festgelegt, wo die Anwendung im IIS platziert werden soll. Name: Name der Web Application im IIS. Web Site: Die IIS Website, unter der die Anwendung installiert werden soll. Port: Sollten der ausgewählten IIS Website mehrere Ports zugewiesen sein, kann über die Combobox der gewünschte ausgewählt werden, unter dem die Web Application ausgeführt werden soll. Application Pool: Der IIS Application Pool, in dem die Anwendung ausgeführt werden soll. Note Es werden nur Application Pools angezeigt, die mit der .NET Runtime Version 4 laufen und vom Typ “Integriert” sind. Wird während der Installation eine Website oder ein Application Pool angelegt, muss der Setup Wizard neu gestartet werden, um die Anzeige zu aktualisieren (Einschränkung des MSI-Installers). Refresh: Über den Button „Refresh“ kann die Anzeige aktualisiert werden, sollte z.B. ein Application Pool angelegt worden sein während der Setup Wizard geöffnet ist. Festlegen des Web Application Logins In diesem Schritt wird der User für die Anmeldung an der Web Application im Browser festgelegt. Username: Name des Benutzers Password: Passwort des Benutzers Das Passwort muss zwischen 8 und 30 Zeichen lang sein. Es kann später in der Web Application bei Bedarf geändert werden. Bereit zur Installation Sind alle Daten in den vorherigen Schritten definiert worden, kann über den Button “Install” die eigentliche Installation des Runtime Supervisor gestartet werden. Wird der Setup Wizard an dieser Stelle abgebrochen, bleibt das System unverändert. Installationsvorgang Während der Installation wird der gerade ausgeführte Schritt über der Progressbar angezeigt. Die Installation kann jederzeit über den Button “Cancel” abgebrochen werden. Note Wurde vor dem Zeitpunkt des Abbruchs der Installation schon eine Datenbank vom Setup Wizard angelegt, wird diese bei einem Abbruch nicht gelöscht! Abschluss Nachdem alle Komponenten des Runtime Supervisor installiert wurden, erscheint der oben gezeigte Dialog. Der Runtime Supervisor ist nun betriebsbereit. Der Setup Wizard kann über den Button “Finish” beendet werden. Überprüfung der Installation Diese Überprüfungen sind optional. Um zu überprüfen, ob alle Komponenten des Runtime Supervisor korrekt arbeiten, können nachfolgende Schritte unternommen werden: Startmenü Nach einer erfolgreichen Installation werden im Startmenü (ab Windows 8/8.1 und Windows Server 2012 in der App-Ansicht) zwei Einträge erstellt. Einer für den Windows Service und einer für die Web Application. Windows Service Über den Task-Manager kann festgestellt werden, ob der Runtime Supervisor Windows Service korrekt ausgeführt wird. Der Windows Service trägt den Namen “RSService” und sollte den Status “Wird ausgeführt” haben. Wird im Windows Startmenü auf den Eintrag “Windows Service” geklickt, sollte sich der Standard-Browser öffnen und folgendes Bild anzeigen: Dies bedeutet, dass der OWIN Web Service innerhalb des Windows Service korrekt hochgefahren wurde und nun bereit zur Kommunikation mit den Observables ist. Web Application Um zu überprüfen, ob die Web Application im IIS korrekt installiert wurde, kann im Startmenü auf den Eintrag “Web Application” geklickt werden. Danach öffnet sich der Standard-Browser und die Login-Seite der Runtime Supervisor Web Application sollte angezeigt werden. Sie können sich hier mit dem im Setup Wizard definierten Web Application Benutzer anmelden. Ändern der Installation Ist der Runtime Supervisor erfolgreich auf einem Rechner installiert, kann diese Installation durch erneutes Starten des Installers geändert werden. Ist bei einer Installation z.B. nur der Windows Service installiert worden und soll nun nachgelagert noch die Web Application auf demselben Rechner installiert werden, können Sie dies jederzeit tun. Nach dem erneuten Start des Setup Wizard wird der oben dargestellte Dialog angezeigt. Change Installation: Wenn Komponenten einer Runtime Supervisor Installation hinzugefügt oder deinstalliert werden sollen, klicken Sie auf den Button “Change”. Anschließend wird der Setup Wizard wie bei einer Neuinstallation fortgeführt und es kann neu definiert werden, was auf dem Rechner installiert sein soll. Uninstall: Der Runtime Supervisor wird mit all seinen Komponenten und Einstellungen vom Rechner entfernt. Note Bei einer Deinstallation des Runtime Supervisor werden unter keinen Umständen Datenbanken gelöscht oder geändert! Diese müssen durch den Benutzer manuell entfernt werden! Troubleshooting Es kann durch verschiedenste Bedingungen (Zugriffsrechte, Inkompatibilitäten, Systemauslastung, usw.) dazu kommen, dass der Setup Wizard mit einem Fehler abbricht. In so einem Fall kann der Installer in einem erweiterten Modus gestartet werden, um während der Installation eine Logdatei zu erzeugen. Diese ist essenziell, wenn Sie sich auf Grund des Fehlers im Installer mit unserem Support in Verbindung setzen. Um die Aktionen des Installers in einer Logdatei zu dokumentieren, muss dieser wie folgt per Windows-Eingabeaufforderung gestartet werden: RS_Install_x64.exe -l „[Pfad und Dateiname der Logdatei]“ Beispiel: RS_Install_x64.exe -l „C:\\Windows\\Temp\\RS_Installer_Log.txt“ Führen Sie den Installer ganz normal aus und lassen Sie ihn wieder auf den Fehler laufen. Dieser wird dann mit in die Logdatei aufgenommen und kann von unserer Entwicklungsabteilung analysiert werden."
  },
  "doc/runtimesupervisor/runtimesupervisor-setup.html": {
    "href": "doc/runtimesupervisor/runtimesupervisor-setup.html",
    "title": "Einrichtung der Clients",
    "keywords": "Einrichtung der Clients Um eine Verbindung mit dem Runtime Supervisor aufbauen zu können, muss jedes Observable wissen, wo dieser zu erreichen ist. Die Kommunikation erfolgt über ASP.NET SignalR. Um eine bidirektionale Kommunikation zu initiieren bedarf es hierzu nur der URL des Zielservers. Broker und Service Hosts Um einem Broker oder Service Host in Framework Studio die URL des Runtime Supervisor mitzuteilen, gibt es im Publish Wizard ein entsprechendes Textfeld. Im Textfeld “Runtime Supervisor URL” auf der Startseite des Publish Wizard müssen der Server und Port, auf dem der Runtime Supervisor läuft, im Format [Server]:[Port] angegeben werden. Im darunter liegenden Textfeld wird die URL automatisch aufbereitet angezeigt. Diese URL gilt nun für alle Broker und Service Hosts der Framework Studio Runtime bzw. für dieses Setting gleichermaßen. Über den Button “Test”, kann die Kommunikation getestet werden. Um festzulegen, ob für einen bestimmten Broker oder Service Host der Runtime Supervisor aktiviert sein soll oder nicht, kann über die entsprechende Seite im Publish Wizard eingestellt werden. Für jede Framework Studio Application (Broker) kann über die Checkbox “Enable” der Runtime Supervisor aktiviert oder deaktiviert werden. Dasselbe gilt auch für die Service Hosts. Wird ein Broker oder ein Service Host gepublisht, registriert er sich automatisch am Runtime Supervisor und wird von da an von diesem überwacht. Authentication Service Für den Authentication Service gibt es im dazugehörigen Konfigurationsassistenten den Reiter “Runtime Supervisor”. Über die Checkbox “Enable” kann der Runtime Supervisor aktiviert oder deaktiviert werden. Im Textfeld “Runtime Supervisor URL” müssen der Server und der Port, auf dem der Runtime Supervisor läuft, im Format [Server]:[Port] angegeben werden. Im Textfeld daneben wird die URL automatisch aufbereitet angezeigt. Über den Button “Test”, kann die Kommunikation getestet werden. Print Service Für den Print Service gibt es im dazugehörigen Konfigurationsassistenten den Reiter “Runtime Supervisor”. Über die Checkbox “Enable” kann der Runtime Supervisor aktiviert oder deaktiviert werden. Im Textfeld “Runtime Supervisor URL” müssen der Server und der Port, auf dem der Runtime Supervisor läuft, im Format [Server]:[Port] angegeben werden. Im Textfeld daneben wird die URL automatisch aufbereitet angezeigt. Über den Button “Test”, kann die Kommunikation getestet werden. Document Service Im Gegensatz zum Authentication Service oder Print Service bietet der Document Service keinen Konfigurationsassistenten an. Die Aktivierung des Runtime Supervisor muss hier über die XML-Konfigurationsdatei angepasst werden. Dem Document Service liegt eine Template-Datei bei, in der die zwei nötigen Einträge schon vorhanden sind und nur noch konfiguriert werden müssen. Wird eine ältere Konfigurationsdatei verwendet, muss überprüft werden, ob die nachfolgenden Einträge existieren. Ist dies nicht der Fall, müssen sie ggf. ergänzt werden. Im Element / müssen folgende Elemente existieren: True http://[Server]:[Port]/RuntimeSupervisorService Das Element „RuntimeSupervisorEnabled“ definiert, ob der Runtime Supervisor für den Document Service aktiviert („True“) werden soll oder nicht („False“). Das Element „RuntimeSupervisorUri“ definiert die URL, unter der der Runtime Supervisor zu finden ist. Die URL muss im Format http://[Server]:[Port]/RuntimeSupervisorService angegeben werden."
  },
  "doc/runtimesupervisor/runtimesupervisor-ui.html": {
    "href": "doc/runtimesupervisor/runtimesupervisor-ui.html",
    "title": "Benutzeroberfläche",
    "keywords": "Benutzeroberfläche Layout Nach dem Login wird das Runtime Supervisor Dashboard angezeigt, in dem die wichtigsten Daten der Framework Studio Runtime zusammengefasst sind. Sind noch keine Observables registriert, wird einzig der Runtime Supervisor Windows Service angezeigt. Hauptmenü Dashboard: Unterhalb des Menüpunktes “Dashboard” werden Unteransichten für die verschiedenen Observable-Typen angezeigt. Diese werden auch nur dann angezeigt, wenn sich tatsächlich auch Observables am Runtime Supervisor registriert haben. Existiert in der Framework Studio Runtime z.B. kein Document Service (wie in Abbildung 19), wird dieser auch nicht angezeigt. Nach einer Neuinstallation wird also - wie auch im Dashboard - erst einmal nur der Runtime Supervisor Service angezeigt. Je Observable-Typ wird rechts neben der Bezeichnung die Anzahl der am Runtime Supervisor registrierten Observables dieses Typs angezeigt. Diese Zahl beinhaltet alle Observables, unabhängig davon, ob sie gerade online oder offline sind. Events: Über den Menüpunkt “Events” kann die globale Event-Ansicht des Runtime Supervisor erreicht werden. Siehe Kapitel Events. Settings: Über den Menüpunkt “Settings” können alle Einstellungen für den Runtime Supervisor vorgenommen werden. Siehe Kapitel Settings. Toolbar Die Toolbar ist ein kontextabhängiges Menü, bestehend aus ein oder mehreren Dropdown-Controls. Das in Abbildung 19 gezeigt Dropdown-Control ist statisch und steht jederzeit zur Verfügung. Es beinhaltet folgende Menüpunkte: Change Password: Ruft den Dialog zum Ändern des Passworts des angemeldeten Benutzers auf (siehe Kapitel Passwort ändern). Logout: Meldet den derzeit angemeldeten Benutzer ab und leitet auf die Login-Seite weiter. Responsive Design Um den Runtime Supervisor auch auf kleineren Endgeräten wie Smartphones oder Tablets gut bedienbar zu machen, wurde die Web Application mit einem Responsive Design versehen. Ab einer Bildschirmauflösung von unter 768 Pixeln in der Breite, wird die Seite “zusammengeklappt” und das Hauptmenü ist über einen Button rechts oben auf der Seite (siehe Abbildung) zu erreichen. Die Toolbar wird dann linksbündig angezeigt. Passwort ändern Über die Toolbar ist der Menüpunkt “Change Password” erreichbar. Dieser ruft folgenden Dialog zum Ändern des Passworts des aktuell angemeldeten Benutzers auf: Um das Passwort zu ändern, müssen das derzeitige Passwort sowie das neue Passwort und dessen Wiederholung eingegeben werden. Nach einem Klick auf den Button “Ok” wird eine Bestätigung der Änderung angezeigt. Dashboard Das Dashboard besteht aus einer Übersicht über alle am Runtime Supervisor registrierten Observables. Diese sind gruppiert nach Typ. Name: Der Name des Observables wird als Link angezeigt. Durch einen Klick kann die Detail-Ansicht des jeweiligen Observables aufgerufen werden (siehe Kapitel Detailansicht). Server: Der Server auf dem das Observable läuft. Version: Die Version des Observables. Status: Online-Status des Observables. Tooltip: Zeitpunkt der Registrierung am Runtime Supervisor. Run As: Information darüber, wie das Observable ausgeführt wird. Die Optionen sind: Als Windows Service (Windows-Symbol) Als IIS Application (Wolken-Symbol) Als Konsolenapplikation (Konsolenfenster-Symbol) Tooltip: Beschreibung der Ausführungsart. User: Benutzer, mit dem das Observable auf dem System ausgeführt wird. New Events: Zeigt an, wie viele unbestätigte Events es zu einem Observable gibt, gruppiert nach Event-Art. Gibt es für eine Event-Art keine neuen Einträge, wird das Symbol ausgegraut angezeigt. Tooltip für jedes Symbol: Beschreibung der Event-Art. Gruppierte Ansicht Die gruppierte Ansicht beinhaltet im oberen Teil der Seite den Ausschnitt des Dashboards für den im Hauptmenü ausgewählten Observable-Typ. Im unteren Teil wird eine Event-Tabelle angezeigt, die alle Events für alle Observables des ausgewählten Typs beinhaltet. Somit können Sie sich z.B. schnell ein Überblick über alle laufenden Framework Studio Broker verschaffen. Mehr Informationen zum Umgang mit der Event-Tabelle und deren Filterfunktion erfahren Sie im Kapitel Events. Detailansicht Diese Ansicht kann erreicht werden, indem im Dashboard, in einer gruppierten Ansicht oder in einer Event-Tabelle auf den Namen eines Observables geklickt wird. Erweiterte Toolbar Über das erweiterte Dropdown-Control (Stift) kann das Observable vom Runtime Supervisor gelöscht werden. Das Observable kann sich danach jederzeit wieder am Runtime Supervisor registrieren. Note Wird ein Observable gelöscht, werden auch alle zugehörigen Events aus der Datenbank entfernt! Tab „Status“ Dieser Tab Listet allgemeine Informationen über das Observable auf. Diese sind für alle Observable-Typen identisch. Panel “Information” Dieses Panel enthält die wichtigsten Daten zur Identifikation des Observables. Database ID: Registriert sich ein Observable am Runtime Supervisor, wird für dieses eine einmalige ID generiert, mit der es in der Datenbank identifiziert werden kann. Das Observable selbst hat keine Kenntnis und keinen Einfluss auf diese Guid. Client ID: Diese ID wird auf dem Rechner des Observables generiert. Sie ist u.a. auch abhängig von der Domain und dem Rechnernamen, auf dem das Observable läuft. Dies hat zur Folge, dass z.B. zwei Authentication Services, die zwar die gleiche ID haben, jedoch auf unterschiedlichen Rechnern laufen, vom Runtime Supervisor unterschieden werden können. Name: Der Anzeigename des Observables. Version: Die Version des Observables wird aus der ausführenden Assembly gelesen (z.B. PrintService.exe). API Version: Dies ist die Version der Schnittstelle zwischen dem Observable und dem Runtime Supervisor. Ist die API-Version eines Observables größer als die des Runtime Supervisors, kann dieser nicht mit dem Observable kommunizieren und sollte upgedatet werden. Ältere Observables können hingegen problemlos auch mit einem neueren Runtime Supervisor kommunizieren. Type: Der Typ des Observables (Authentication Service, Print Service, etc.) Server: Der Server, auf dem das Observable ausgeführt wird. Domain: Die Domain, in der das Observable ausgeführt wird. Panel “Status” Dieses Panel gibt Auskunft über den Status des Observables und dessen Verbindung zum Runtime Supervisor. Status: Zeigt den Online-Status an. Dieser wird vom Runtime Supervisor in Echtzeit überwacht. Connection ID: Die ASP.NET SignalR Connection ID. Diese kann bei der Fehlersuche hilfreich sein und wird in diversen Events angegeben. Console: Gibt an, ob das Observable als Konsolenanwendung ausgeführt wird oder nicht. Das kann dann hilfreich sein, wenn z.B. ein Print Service auf einem Server in der Konsole läuft und der Benutzer aus Versehen abgemeldet wird, was ein Beenden des Print Service zur Folge hat. Registered: Der Zeitpunkt, an dem sich das Observable beim Runtime Supervisor registriert hat. Ein Observable registriert sich bei jedem Neustart erneut am Runtime Supervisor. Shutdown: Der Zeitpunkt, an dem das Observable beendet wurde. Shutdown Reason: Der Grund des Beendens des Observables. Kann die Werte “Regular Shutdown” und “Unexpected Disconnect” annehmen. Panel “System” Dieses Panel gibt Auskunft über die Hardware des Rechners, auf dem das Observable läuft. CPU: Gibt Auskunft über den Prozessor des Rechners. CPU Architecture: Gibt Auskunft über die Architektur des Prozessors. CPU Speed: Geschwindigkeit des Prozessors. Physical Cores: Anzahl der Rechenkerne des Prozessors. Logical Cores: Anzahl der logischen Prozessoren des Rechners. Gibt an, ob Hyperthreading unterstützt wird oder nicht. Installed Memory: Menge des Arbeitsspeichers des Rechners in MB. Panel “Software” Dieses Panel gibt Auskunft über das Betriebssystem des Rechners, auf dem das Observable läuft. Auch Informationen zum Programm selbst sind hier aufgelistet. OS: Gibt an, welches Betriebssystem auf dem Rechner installiert ist. OS Service Pack: Gibt an, welches Service Pack auf dem Rechner installiert ist. OS 64 Bit: Gibt an, ob das Betriebssystem 64 Bit-fähig ist. User: Der Name des Users, mit dem das Observable ausgeführt wird. Application Path: Das Ausführungsverzeichnis des Observables. Application Exe: Die ausführende Assembly des Observables (z.B. PrintService.exe). Panel “Volumes” In diesem Panel werden alle lokalen Partitionen des Rechners angezeigt, auf dem das Observable läuft. Entfernbare Geräte wie USB-Sticks, CD-Laufwerke und auch Netzlaufwerke werden nicht angezeigt. Drive: Der Laufwerksbuchstabe der Partition. Label: Der Name der Partition (kann undefiniert sein). Size: Die Größe der Partition in GB. Free: Der freie Speicherplatz der Partition in GB. Used: Der belegte Speicherplatz der Partition in GB. Status: Die Statusleiste zeigt den belegten Speicherplatz der Partition in Prozent an. Überschreitet der Wert 90%, wird der Balken in rot angezeigt. Tab “Events” Dieser Tab enthält, wie auch die gruppierte Ansicht, eine Event-Tabelle. In dieser werden ausschließlich die Events des ausgewählten Observables angezeigt. Mehr Informationen zum Umgang mit der Event-Tabelle und deren Filterfunktion erfahren Sie in Kapitel Events. Tab “Runtime & Configuration” Dieser Tab beinhaltet alle Informationen zur Laufzeit und Konfiguration eines Observables. Diese Informationen sind speziell auf den einzelnen Observable-Typ zugeschnitten, können sich also zwischen unterschiedlichen Observable-Typen unterscheiden. Während der Authentication Service beispielsweise seine Einstellungen zur Sicherheit bekannt gibt, listet der Print Service seine konfigurierten Drucker und Adapter auf. Der Broker hingegen zeigt an, in welchem IIS Application Pool er gerade läuft usw. Auch Informationen zum laufenden Prozess, belegten Ports oder genutzten Datenbankverbindungen werden hier aufgelistet, falls verfügbar. Events Auf dieser Seite werden alle Events von allen am Runtime Supervisor registrierten Observables zusammengefasst angezeigt. Damit ist sie die zentrale Anlaufstelle, wenn es darum geht, herauszufinden, ob es Fehler in der Framework Studio Runtime gegeben hat. Event Tabelle Combobox “records per page”: Über diese Combobox kann ausgewählt werden, wie viele Events je Seite in der Tabelle angezeigt werden sollen. Der Standardwert kann über die Settings (siehe Kapitel Web Application) eingestellt werden. Navigation: Mit den Buttons in der Mitte über der Tabelle kann durch diese navigiert werden. Es kann zu einer bestimmten Seite gesprungen werden, oder mit den Buttons “Previous” und “Next” durch die Tabelle geblättert werden. Button “Page”: Mit diesem Button können alle als “Neu” markierten Events auf der derzeit angezeigten Seite bestätigt werden. Button “All”: Mit diesem Button können alle als “Neu” markierten Events in der gesamten Tabelle (also absolut alle Events des Runtime Supervisor!) bestätigt werden. Plus “+” Symbol: Über diesen Button kann ein Event aufgeklappt werden, um den gesamten Mitteilungstext einsehen zu können. Level: Zeigt den Error Level des Events. Timestamp: Zeigt an, wann das Event eingetreten ist. Name: Der Name des Observables, an dem das Event eingetreten ist. Server: Der Server, auf dem das betroffene Observable läuft. Message: Eine auf 100 Zeichen beschränkte Vorschau des Mitteilungstextes. New: Zeigt an, ob das Event bestätigt wurde (grau) oder nicht (grün). Event Filter Über den Button “Show Filter” über der Event-Tabelle kann ein Filter-Formular eingeblendet werden, mit dem nach Events gesucht werden kann (siehe Abbildung). Error Level: Gibt an, nach welchen Event-Arten gesucht werden soll. From: Das Datum und die Uhrzeit ab dem nach Events gesucht werden soll. To: Das Datum und die Uhrzeit bis zu dem nach Events gesucht werden soll. Name: Der Name des Observables, zu dem nach Events gesucht werden soll. Server: Es wird nach allen Events zu Observables gesucht, die auf diesem Server laufen. Message: Es wird nach Events gesucht, die im Mitteilungstext die angegebene Zeichenfolge enthalten. Events: Gibt an, ob nach bestätigten, unbestätigten oder beiden Events gesucht werden soll. Button “Apply”: Startet die Suche und aktualisiert die Event-Tabelle. Button “Clear”: Leert das Filter-Formular und stellt den Standardzustand der Event-Tabelle wieder her. Settings Die Einstellungen des Runtime Supervisor sollten direkt nach der Installation überprüft werden. Für weitergehende Informationen zum Thema Settings siehe Kapitel Aktualisierung der Settings. Windows Service Delete confirmed events after: In verschiedenen Framework Studio Runtimes können unterschiedlich viele Events auftreten. Der Informationsgehalt dieser ist jedoch meist nur für kurze Zeit aktuell, sodass die Events normalerweise nach einiger Zeit gelöscht werden können, um die Datenbank des Runtime Supervisor nicht unnötig aufzublähen. Im Textfeld kann die Anzahl Tage angegeben werden, nach denen ein Event-Eintrag verfällt und aus der Datenbank gelöscht werden kann. Um das automatische Löschen zu deaktivieren (nicht empfohlen), kann der Wert “0” angegeben werden. Standard: 30 Tage Mindestwert: 3 Tage Run the delete task at: Gibt an, um wieviel Uhr die nicht mehr benötigten Events tatsächlich aus der Datenbank gelöscht werden. Dieser Task läuft täglich. Standard: 02:00 Uhr Confirm incoming events of type: Nicht jedes Event, welches an den Runtime Supervisor gemeldet wird, ist von so hohem Informationsgehalt, dass eine manuelle Bestätigung seitens des IT-Verantwortlichen notwendig ist. Meist sind das Events vom Typ “Information”. Über die Button kann eingestellt werden, für welche Event-Typen der Runtime Supervisor beim Erfassen eines Events dieses von vornherein schon auf “bestätigt” setzen soll (das Event wird dann in der Event-Tabelle nicht grün angezeigt). Standard: “Information” Web Application Web Application Root: Diese Einstellung ist wichtig, wenn das Alerting-System verwendet wird. Die eingegebene URL muss auf die Web Application des Runtime Supervisor zeigen. Wird ein Event per eMail versendet, beinhaltet diese einen Link zum betroffenen Observable. Dadurch kann aus dem eMail-Programm heraus direkt zur Runtime Supervisor Web Application gesprungen werden. Die Adresse, die für diese Links verwendet wird, ist die im Textfeld eingegebene. Ist der Web Server, auf dem die Web Application läuft, von extern über die gleiche URL erreichbar, wie auf dem Server selbst (das ist meistens der Fall, wenn sich der Web Server in der gleichen Domain befindet, wie die Client-Rechner), kann die URL über den Button “Current” eingestellt werden. Number of records per page in events grid: Gibt die Anzahl der Events an, die in der Event-Tabelle standardmäßig angezeigt werden soll. Standard: 25 Number of records per page in observable types grid: Gibt die Anzahl der Events an, die in der Event-Tabelle in der Observable-Typ-Übersicht standardmäßig angezeigt werden soll. Standard: 10 Number of records per page in observable details grid: Gibt die Anzahl der Events an, die in der Event-Tabelle in der Detailansicht eines Observables angezeigt werden soll. Standard: 10 SMTP Soll das automatische Alerting-System des Runtime Supervisor genutzt werden, muss dies über die SMTP-Einstellungen aktiviert werden. Sind die SMTP-Daten korrekt angegeben und sind im Reiter “Alerting” aktive Empfänger eingetragen, versendet der Runtime Supervisor beim Eingang eines Events eine eMail an jeden Empfänger, der für den Event-Typ des Events freigeschaltet ist. Enabled: Aktiviert oder deaktiviert das Versenden von eMails beim Eingang von Events. Server or IP: Der Name oder die IP des zu verwendenden Mailservers. Security: Die Verschlüsselung, die zum Versenden der eMails genutzt werden soll. Wird die Auswahl geändert, wird im Feld „Port“ der zur Verschlüsselungsart zugehörige Standardport eingetragen Verschlüsselung Port None 25 STARTTLS 587 SSL/TLS 465 Port: Der Port, der zum Versenden der eMails genutzt werden soll. User: Der Benutzer, mit dem die eMail vom Mailserver aus versendet werden soll. Password: Das zum User zugehörige Passwort. Domain: Die Domain, in der sich der angegebene Benutzer befindet. Sender Mail Address: Die eMail-Adresse, die zum Versenden der eMails genutzt werden soll. Sender Name: Der Anzeigename des Versenders der eMail (wird nicht von allen eMail Clients unterstützt). Send mail as HTML: Die eMails werden im HTML-Format optisch etwas aufgewertet versendet (wird nicht von allen eMail Clients unterstützt). Alerting In diesem Reiter sind alle Empfänger aufgelistet, die beim Eingang eines Events am Runtime Supervisor per eMail benachrichtigt werden. Active: Zeigt an, ob der Empfänger aktiviert ist. Nur aktivierte Empfänger bekommen eMails vom Runtime Supervisor. Mail: Die eMail-Adresse, an die Benachrichtigungen versendet werden. Name: Der Name des Empfängers Configuration: Zeigt an, für welche Event-Typen der Empfänger benachrichtigt wird. Im Beispiel in Abbildung 33 bekommt der Empfänger für alle Event-Typen außer “Information” eine eMail. Button “Edit”: Über diesen Button können die Einstellungen des Empfängers geändert werden. Button “Delete”: Löscht den Empfänger aus der Liste. Button “Add Receiver”: Öffnet einen modalen Dialog zum Anlegen eines neuen Empfängers."
  },
  "doc/session-logging/logging.html": {
    "href": "doc/session-logging/logging.html",
    "title": "Application Logging",
    "keywords": "Application Logging Framework Studio stellt mehrere Möglichkeiten bereit, Applications zu protokollieren. Session-Logging Jede Application speichert automatisch Informationen in der Tabelle tblRep_SessionLogging im Runtime-Repository. Es werden pro Session aggregierte Daten über die Anzahl und Dauer der ausgeführten Broker-Anfragen und die Datenbank-Befehle gespeichert. Diese Daten können mit dem Session Logging Analyzer ausgewertet werden. Session-Trace Das Session Trace protokolliert einzelne Requests und Datenbank-Befehle in Protokoll-Dateien auf dem Broker-Server. Das Session-Trace muss bei Bedarf explizit im Publish-Wizard bzw. Publish2Go-Wizard aktiviert werden. Diese Daten können mit dem Session Trace Analyzer ausgewertet werden."
  },
  "doc/session-logging/manuelle-requests-im-sessionanalyzer.html": {
    "href": "doc/session-logging/manuelle-requests-im-sessionanalyzer.html",
    "title": "Manuelle Requests im Session Analyzer",
    "keywords": "Manuelle Requests im Session Analyzer Der Broker protokolliert automatisch jeden Request im SessionLogging. Bei Services gibt es keine Requests, die generell von einer FS-Logik überwacht und sicher einer \"Session\" zugeordnet werden können. Um jedoch auch Services in die Protokollierung einfließen zu lassen, kann man gezielt eigene Requests protokollieren. Die eigentliche Session hängt am Global. Jede Instanz eines GlobalObject ist gleichzeitig auch eine eigene Session und erzeugt somit auch einen eigenen Datensatz in der SessionLogging-Tabelle. Bei Services kann das verschiedene Auswirkungen haben: Wenn in einer Service-Methode ein neues Global erzeugt wird (Property GenerateGlobalObjects an der Service-Methode), dann bedeutet das JEDES mal eine neue Session. In Umgebungen mit mehreren Globals (z.B. Job-Server) baut auch dort jedes Global eine eigene Session auf. Somit erzeugt ein laufender Service mehrere Einträge im SessionLogging. Die Session \"läuft\", solange das Global existiert. Dadurch können sich Sessions über einen sehr langen Zeitraum - ggf. mehrere Tage oder Wochen - erstrecken. Zeitliche Zusammenhänge lassen sich dadurch sehr bedingt erfassen. Die DB-Commands werden über die Connection automatisch am Global gesammelt - und zwar über die komplette Session und nicht nur während der protokollieren Requests. Nur dann, wenn mindestens 1 Request protokolliert wurde, landet die Session im Runtime-Repository. Requests protokollieren Das Session-Logging ist ursprünglich für Broker-Requests ausgelegt und betrachtet deshalb die Folgenden Informationen: FormName (der FullName des Forms) ControlName EventName Es wird die Anzahl und die Gesamt-Zeit der Requests gespeichert. Dabei wird nach allen 3 Informationen gruppiert. Auch die manuellen Requests müssen aus diesen Informationen bestehen. Es muss selbst entschieden werden, wie man diese 3 Felder mit eigenen Informationen bestückt. Beispiel Job-Server: FormName = \"JobServer\" ControlName = FullName der Component (also Art des Jobs) EventName = ID des Jobs (so lassen sich verschiedene Job-Konfigurationen unterscheiden) Über this.Global.SessionLogging werden verschiedene Varianten für die Protokollierung angeboten: Variante 1 RequestDisposable(string formName, string controlName, string eventName) Es wird ein Disposable zurückgegeben. Ein using-Block übernimmt automatisch die Zeit-Messung. Beispiel: using(this.Global.SessionLogging.RequestDisposable(\"MyForm\", \"MyControl\", \"MyEvent\")) { // Code ... } Variante 2 RequestDisposable() Es wird ein Objekt mit dem Typ SessionRequestDisposable zurückgegeben. Wenn die Request-Informationen erst im Laufe der Verarbeitung bekannt sind, können sie an diesem Objekt gesetzt werden. Der Request wird am Ende nur protokolliert, wenn am SessionRequestDisposable-Objekt mindestens 1 Information gesetzt ist. Der Using-Block übernimmt automatisch die Zeit-Messung. using(SessionRequestDisposable request = this.Global.SessionLogging.RequestDisposable()) { // Code ... request.FormName = \"MyForm\"; request.ControlName = \"MyControl\"; request.EventName = \"MyEvent\"; // Code ... } Variante 3 AddRequest(string formName, string controlName, string eventName, TimeSpan duration) Die Zeit-Messung erfolgt manuell - z.B. über eine Stopwatch. System.Diagnostics.Stopwatch stopwatch = System.Diagnostics.Stopwatch.StartNew(); try { // Code ... } finally { this.Global.SessionLogging.AddRequest(\"MyForm\", \"MyControl\", \"MyEvent\", stopwatch.Elapsed); }"
  },
  "doc/session-logging/session-logging-analyzer.html": {
    "href": "doc/session-logging/session-logging-analyzer.html",
    "title": "Session Logging Analyzer",
    "keywords": "Session Logging Analyzer Jede Application speichert automatisch Informationen in der Tabelle tblRep_SessionLogging im Runtime-Repository. Es werden pro Session aggregierte Daten über die Anzahl und Dauer der ausgeführten Broker-Anfragen und die Datenbank-Befehle gespeichert. Mit dem Session Logging Analyzer können diese Daten ausgewertet werden. Im Session-Logging werden die Daten aggregiert. So lassen sich sehr gut statistische Aussagen auch über viele Sessions und lange Zeiträume treffen. Die Aussagen können maximal auf Session-Ebene heruntergebrochen werden. Einzelne Requests und auch exakte Zeitpunkte (z.B. von auftretenden Blockaden) sind nicht zu greifen. Dafür muss das deutlich detailliertere Session Trace verwendet werden. Einlesen der Daten Mit dem Button Login kann man sich an einem Runtime-Repository anmelden. Wird der Session Logging Analyzer über den Run Wizard, Publish Wizard oder Publish2Go-Wizard gestartet, dann wird die Verbindung zum im Setting definierten Runtime-Repository automatisch hergestellt. Anschließend kann man mit dem Button Load from DB die Daten einlesen. Über die Datums-Felder kann vor dem Einlesen der Zeitraum eingeschränkt werden. Standardmäßig sind die letzten 30 Tage voreingestellt. Mit dem Button Load from Files können exportierte Daten eingelesen werden. Dabei können aus einem Ordner auch mehrere Dateien gleichzeitig ausgewählt werden. Dafür ist kein Login notwendig. Mit jedem Einlese-Vorgang werden die aktuellen Daten verworfen. Export der Daten Mit dem Button Export to File können die Daten aus dem Repository in eine Datei exportiert werden. Es ist sinnvoll, die Daten auf diese weise zu archivieren, bevor sie dauerhaft aus der Tabelle tblRep_SessionLogging gelöscht werden. Auf diese Weise lassen sich die Daten auch ganz einfach transportieren. Über die Datums-Felder muss vor dem Export der Zeitraum eingeschränkt werden. Standardmäßig sind die letzten 30 Tage voreingestellt. Der Export erfolgt immer direkt aus der Datenbank in die Datei. Die aktuell eingelesenen Daten landen nicht im Export. Tip Es ist sinnvoll, monatsweise Exports zu erstellen und diese z.B. im Format yyyy-mm-KundenName.sessionlogging zu speichern. Die Export-Dateien lassen sich sehr gut zippen. Um den Datenschutz zu gewährleisten ist die Checkbox Anonymous Export standardmäßig gesetzt. Sie bewirkt, dass alle Daten, die auf den Benutzer schließen können anonymisiert werden. In der Export-Datei werden nur noch Hash-Codes angezeigt. Das betrifft z.B. Name des Benutzers (UserName, ClientUser) Name und IP des Client-Rechners (ClientMachine) Löschen der Daten Im Laufe der Zeit sammeln sich in der Tabelle tblRep_SessionLogging sehr viele Datensätze an. Tip Grundsätzlich können auch ältere Daten interessante Informationen enthalten, wenn z.B. beurteilt werden soll, wie sich die Performance des Systems im Laufe der Zeit entwickelt hat. Vor dem endgültigen Löschen aus der Datenbank sollte daher ein Export vorgenommen werden (siehe oben). Alte Datensätze müssen direkt per SQL auf der Datenbank gelöscht werden. Das folgende SQL-Statement löscht Sätze, die älter sind als 6 Monate. Es werden auf einen Schlag nur 1.000 Zeilen gelöscht, weil ansonsten die Transaktion zu groß und die Tabelle zu lange für laufende Sessions blockiert werden könnte. Das Statement muss so oft ausgeführt werden, bis keine Sätze mehr gelöscht wurden. Die Anzahl der Monate und die Anzahl der zu löschenden Zeilen kann bei Bedarf angepasst werden. -- SQL-Server: DELETE TOP (1000) FROM tblRep_SessionLogging WHERE SL_SessionStart < DATEADD(month, DATEDIFF(month, 0, getdate()) - 6, 0); -- Oracle: DELETE FROM tblRep_SessionLogging WHERE SL_SessionStart < ADD_MONTHS(TRUNC(SYSDATE,'MM'), -6) AND ROWNUM <= 1000;"
  },
  "doc/session-logging/session-trace-analyzer.html": {
    "href": "doc/session-logging/session-trace-analyzer.html",
    "title": "Session Trace Analyzer",
    "keywords": "Session Trace Analyzer Das Session-Trace protokolliert detailliert Sessions, einzelne Requests und lang dauernde Sql-Statements in Form von SessionTrace-Dateien. Aktiviert werden kann der Session-Trace im Run Wizard, Publish Wizard oder Publish2Go-Wizard. Mit dem Session Trace Analyzer können diese Daten visualisiert und ausgewertet werden. Im Gegensatz zum Session Logging, welches die Daten aggregiert, speichert das Session-Trace exakte Start- und Ende-Zeiten für jede einzelne Aktion. Darüber hinaus werden CPU-Auslastung und RAM-Verbrauch protokolliert. Mit dieser Aufbereitung ist es möglich potentielle Probleme wie z.B. Transaktions-Blockaden oder hohen Ressource-Verbrauch auf einzelne Sessions und sogar Requests einzuschränken."
  },
  "doc/sql/aggr-funktionen.html": {
    "href": "doc/sql/aggr-funktionen.html",
    "title": "Aggregat-Funktionen",
    "keywords": "Aggregat-Funktionen COUNT COUNT ( <Expression> ) Liefert die Anzahl. MIN MIN ( <Expression> ) Liefert das Minimum. MAX MAX ( <Expression> ) Liefert das Maximum. SUM SUM ( <Number Expression> ) Liefert den Summe. AVG AVG ( <Number Expression> ) Liefert den Durchschnitt. VAR VAR ( <Number Expression> ) Liefert die Varianz. STDEV STDEV ( <Number Expression> ) Liefert die Standardabweichung."
  },
  "doc/sql/alpha-funktionen.html": {
    "href": "doc/sql/alpha-funktionen.html",
    "title": "Alphanumerische Funktionen",
    "keywords": "Alphanumerische Funktionen LENGTH LENGTH ( <text> ) Liefert die Länge des Ausdrucks LOWER LOWER ( <text> ) Text in Kleinbuchstaben. UPPER UPPER ( <text> ) Text in Großbuchstaben. LTRIM LTRIM ( <text> ) Schneidet die linken Leerzeichen der Zeichenkette ab. RTRIM RTRIM ( <text> ) Schneidet die rechten Leerzeichen der Zeichenkette ab. REPLACE REPLACE ( <text>, <search text>, <replace text> ) Ersetzt im übergebenen Text den Search-Text durch Replace-Text. SUBSTRING SUBSTRING ( <text>, <number start>, <number length> ) Gibt den Teil einer Zeichenkette zurück."
  },
  "doc/sql/cast-funktionen.html": {
    "href": "doc/sql/cast-funktionen.html",
    "title": "Umwandlungsfunktionen",
    "keywords": "Umwandlungsfunktionen CHAR_TO_DATE CHAR_TO_DATE ( <Expression>, <format-Number>) Wandelt eine Zeichen-Kette in ein Datum um. Dabei wird das angegebene Format verwendet. Die Format-Nummer muss als konstante Zahl übergeben werden. Sie kann folgende Werte haben: Number Format YY Format YYYY 1 / 101 MM/DD/YY MM/DD/YYYY 2 / 102 YY/MM/DD YYYY/MM/DD 3 / 103 DD/MM/YY DD/MM/YYYY 4 / 104 DD.MM.YY DD.MM.YYYY 5 / 105 DD-MM-YY DD-MM-YYYY 6 / 106 DD MM YYY DD MM YYYY 7 / 107 Mon DD, YY Mon DD, YYYY 8 / 108 hh:mm:ss (24h) 10 / 110 MM-DD-YY MM-DD-YYYY 11 / 111 YY/MM/DD YYYY/MM/DD 12 / 112 YYMMDD YYYYMMDD 20 / 120 YYYY-MM-DD hh:mm:ss (24h) DATE_TO_CHAR DATE_TO_CHAR ( <date Expression>, <format-Number> ) Wandelt ein Datum in eine Zeichenkette um. Die Format-Nummer arbeitet wie bei der Funktion CHAR_TO_DATE. NUMBER_TO_CHAR NUMBER_TO_CHAR ( <Number Expression>, <Decimals>) Wandelt eine Dezimal-Zahl in einen Text um. Dabei wird die Zahl auf die übergebene Anzahl von Dezimal-Stellen gerundet bzw. abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, <Decimals> ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999.9999' ) ) Die Anzahl der Nachkommastellen ist gleich <Decimals> INT_TO_CHAR INT_TO_CHAR ( <Number Expression>) Wandelt eine Ganzzahl in einen Text um. Bei einer Dezimal-Zahl wird gerundet bzw. es werden die Dezimal-Stellen abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, 0 ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999' ) ) CHAR_TO_DECIMAL CHAR_TO_DECIMAL ( <Expression> ) Wandelt eine Zeichenkette in eine Dezimal-Zahl um. LOB_COMPARABLE LOB_COMPARABLE ( <Expression> ) Wandelt eine Langtext-Spalte so um, dass sie in einer Where-Condition bzw. in einem Order By verwendet werden kann. Das ist notwendig unter Oracle bei Spalten mit dem Typ CLOB und unter SQL-Server bei Spalten mit dem Typ text. Beispiel: SELECT memo FROM Tabelle WHERE LOB_COMPARABLE(memo) != 'text' ORDER BY LOB_COMPARABLE(memo) Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CONVERT ( VARCHAR(max), <Expression> ) Oracle CAST ( SUBSTR ( <Expression>, 1, 4000) AS VARCHAR2(4000) ) NLOB_COMPARABLE NLOB_COMPARABLE ( <Expression> ) Wandelt eine Unicode Langtext-Spalte so um, dass sie in einer Where-Condition bzw. in einem Order By verwendet werden kann. Das ist notwendig unter Oracle bei Spalten mit dem Typ NCLOB und unter SQL-Server bei Spalten mit dem Typ ntext. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CONVERT ( NVARCHAR(max), <Expression> ) Oracle CAST ( SUBSTR ( <Expression>, 1, 2000 ) AS NVARCHAR2(2000) )"
  },
  "doc/sql/datum-funktionen.html": {
    "href": "doc/sql/datum-funktionen.html",
    "title": "Datums-Funktionen",
    "keywords": "Datums-Funktionen GETDATE GETDATE ( ) Liefert das aktuelle Datum auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETDATE ( ) Oracle SYSDATE GETUTCDATE GETUTCDATE ( ) Liefert die aktuelle Weltzeit (UTC) auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETUTCDATE ( ) Oracle CAST(sys_extract_utc(systimestamp) AS TIMESTAMP) ADD_DAYS ADD_DAYS ( <Date Expression>, <Days> ) Addiert die übergebenen Tage zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( DAY, <Days>, <Date Expression> ) Oracle <Date Expression> + <Days> ADD_MINUTES ADD_MINUTES ( <Date Expression>, <Minutes> ) Addiert die übergebenen Minuten zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MINUTE, <Minutes>, <Date Expression> ) Oracle <Date Expression> + ( <Minutes> / 1440 ) ADD_MONTHS ADD_MONTHS ( <Date Expression>, <Months> ) Addiert die übergebenen Monate zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MONTH, <Months>, <Date Expression> ) Oracle ADD_MONTHS ( <Date Expression>, <Months> ) DAYS_BETWEEN DAYS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Tage zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF ( DAY, <Start-Date>, <End-Date> ) Oracle TRUNC ( <End-Date> - <Start-Date> ) MONTHS_BETWEEN MONTHS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Monate zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF (MONTH, <Start-Date>, <End-Date>) Oracle MONTHS_BETWEEN (<End-Date>, <Start-Date>) YEAR YEAR ( <Date Expression> ) Liefert eine 4-stellige Zahl, die dem Jahr des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server YEAR ( <Date Expression> ) Oracle EXTRACT ( YEAR FROM <Date Expression> ) MONTH MONTH ( <Date Expression> ) Liefert eine Zahl, die dem Monat des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server MONTH ( <Date Expression> ) Oracle EXTRACT ( MONTH FROM <Date Expression> ) DAY DAY ( <Date Expression> ) Liefert eine Zahl, die dem Tag (Tag des Monats) des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DAY ( <Date Expression> ) Oracle EXTRACT ( DAY FROM <Date Expression> ) HOUR HOUR ( <Date Expression> ) Liefert eine Zahl, die der Stunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( HOUR, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'HH24' ) ) MINUTE MINUTE ( <Date Expression> ) Liefert eine Zahl, die der Minute des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( MINUTE, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>,'MI' ) ) SECOND SECOND ( <Date Expression> ) Liefert eine Zahl, die der Sekunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( SECOND, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'SS' ) )"
  },
  "doc/sql/funktionen.html": {
    "href": "doc/sql/funktionen.html",
    "title": "SQL-Funktionen",
    "keywords": "SQL-Funktionen GETGUID GETGUID ( ) Liefert eine neue Guid mit folgendem Format: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server LOWER( REPLACE ( NEWID ( ), '-', '' ) ) Oracle LOWER( SYS_GUID ( ) ) MODULO MOD ( <Numeric Expression> , <Numeric Expression>) Gibt den Rest der Division einer Zahl durch eine andere zur�ck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server <Numeric Expression> % <Numeric Expression> Oracle MOD( <Numeric Expression>, <Numeric Expression> )"
  },
  "doc/sql/grammatik.html": {
    "href": "doc/sql/grammatik.html",
    "title": "SQL-Grammatik",
    "keywords": "SQL-Grammatik Im Folgenden ist die Grammatik beschrieben, die vom Framework Studio SQL-Parser verstanden wird. Alle an die Datenbank geschickten Befehle müssen dieser Grammatik genügen, ansonsten kommt es zu SqlParser-Exceptions. Grammatik für SQL-Kommandos <select> SELECT [DISTINCT] { * | <resultColumn>[,…n] } FROM { <singleSource> | <joinSource> } [ WHERE <condition> ] [ GROUP BY <value>[,…n] [HAVING <condition>]] [ {UNION [ALL] | INTERSECT | EXCEPT} <select(ohne orderby)> ] [ ORDER BY <orderColumn>[,…n] ] [ OFFSET <integerValue> ] [ LIMIT <integerValue> ] <insert> INSERT INTO <identifierChain> ( <identifier>[,…n] ) { VALUES ( <value>[,…n] ) | <select> } <update> UPDATE <identifierChain> SET {<identifierChain> = <value> } [,…n] [ WHERE <condition> ] <delete> DELETE [FROM] <identifierChain> [ WHERE <condition> ] <withQuery> WITH <identifier> AS ( <select(ohne orderby)> ) [,…n] <select> Grammatik für die Bestandteile der Kommandos <resultColumn> <identifierChain>.* | <value> [AS <identifier>] <singleSource> ( <singleSource> ) | <identifierChain> [ [AS] <identifier> ] <joinSource> ( <joinSource> ) | { <singleSource> | <joinSource> } { INNER | {LEFT | RIGHT | FULL} [OUTER] } JOIN { <singleSource> | <joinSource> } ON <condition> <condition> ( <condition> ) | NOT <condition> | <condition> {{ AND | OR } <condition>}[,…n] | <value> <predicate2> | EXISTS ( <select> ) <predicate2> { = | != | < | <= | > | >= } <value> | IS [NOT] NULL | BETWEEN <value> AND <value> | IN ( <select> | <value> [,…n] ) | LIKE <value> | LIKEESCAPE <value> <value> NULL | ( <value> ) | { - | + } <value> | <value> { + | - | * | / | “||” } <value> | <identifierChain> | [<identifierChain>.] <FunktionsName> ( [ <value> [,…n] ] ) | <searchedCaseWhen> | <simpleCaseWhen> | \"[[\" <natives sql fragment> \"]]\" | <stringLiteral> | <integerValue> | <decimalValue> <searchedCaseWhen> CASE {WHEN <condition> THEN <value>}[,…n] [ ELSE <value> ] END <simpleCaseWhen> CASE <value> {WHEN {<predicate2> | <value>} THEN <value>}[,…n] [ ELSE <value> ] END <orderColumn> <value> [ASC | DESC] <identifierChain> <identifier>[.<identifier>][,…n] <identifier> \"[\" <beliebige Zeichenfolge> \"]\" | <Wort, mit einem Buchstaben beginnend>"
  },
  "doc/sql/num-funktionen.html": {
    "href": "doc/sql/num-funktionen.html",
    "title": "Numerische Funktionen",
    "keywords": "Numerische Funktionen ABS ABS ( <Numeric Expression> ) Liefert den absoluten Betrag einer Zahl TRUNC TRUNC ( <Numeric Expression>, <Decimals> ) Schneidet eine Dezimal-Zahl auf die angegebene Anzahl Stellen ab. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server ROUND ( <Numeric Expression>, <Decimals>, 1 ) Oracle TRUNC ( <Numeric Expression>, <Decimals> ) ROUND ROUND ( <Numeric Expression>, <Decimals> ) Rundet eine Dezimal-Zahl auf die angegebene Anzahl Stellen. POWER POWER ( <Numeric Expression>, <y> ) Potenziert eine Zahl mit y SQUARE SQUARE ( <Numeric Expression> ) Quadrat eine Zahl. SQRT SQRT ( <Numeric Expression> ) Quadratwurzel einer Zahl CEILING CEILING ( <Numeric Expression> ) Rundet eine Zahl auf. FLOOR FLOOR ( <Numeric Expression> ) Rundet eine Zahl ab. LOG LOG (<Float Expression> ) Natürlicher Logarithmus einer Fließkommazahl. LOG10 LOG10 ( <Float Expression> ) Logarithmus mit der Basis 10. EXP EXP ( <float Expression> ) Gibt den exponentiellen Wert des angegebenen float-Ausdrucks zurück. (ex) SIN SIN ( <float Expression> ) Sinus einer Fließkommazahl. TAN TAN (<Float Expression> ) Tangens einer Fließkommazahl. SIGN SIGN ( <Number> ) Gibt das Vorzeichen der Zahl zurück. Negativ -> -1, 0 -> 0, positiv -> +1."
  },
  "doc/sql/operatoren.html": {
    "href": "doc/sql/operatoren.html",
    "title": "Operatoren",
    "keywords": "Operatoren || Verbindet 2 Zeichenketten. Beispiel: SELECT column1 || ' - ' || colum2 FROM tabelle Bei Zeichen-Ketten muss dieser Operator verwendet werden. Der + - Operator ist nicht zulässig. Wenn dennoch der + - Operator verwendet wird, versucht der Parser dies zu korrigieren. Das ist möglich, wenn bei der Operation Zeichen-Ketten oder bestimmte Zeichenketten-Funktionen beteiligt sind. Nicht erkannt wird z.B. das Verbinden von 2 Spalten. In diesem Fall kann es zu Fehlern auf der Ziel-Datenbank kommen. + - * / Addiert, subtrahiert, multipliziert bzw. dividiert 2 Zahlenwerte. Der Framework Studio SQL-Parser versteht die im Folgenden beschriebenen Operatoren und Funktionen. Diese werden Datenbank-spezifisch umgesetzt und können bedenkenlos in selbst formuliertem Sql verwendet werden. Funktionen, die der Parser nicht kennt, werden direkt ohne Konvertierung an die Datenbank weitergegeben. Das bedingt, dass diese Funktionen von der Datenbank verstanden werden. Ggf. Ist es in solchen Fällen nötig, selbst dafür zu sorgen, dass das Sql datenbankspezifisch formuliert wird. % Für die Modulo-Operation gibt es eine MOD()-Funktion, siehe hier. Note Die alleinige Verwendung des % Operators wird in der Syntax nicht akzeptiert."
  },
  "doc/sql/syntax.html": {
    "href": "doc/sql/syntax.html",
    "title": "SQL-Syntax",
    "keywords": "SQL-Syntax Framework Studio übersetzt alle SQL-Statements in die Syntax der verwendeten Ziel-Datenbank. Dazu werden alle Statements geparsed und für die Ziel-Datenbank wieder neu zusammengesetzt."
  },
  "doc/tables/dbrun_config.html": {
    "href": "doc/tables/dbrun_config.html",
    "title": "dbRun_Config (Business-Datenbank)",
    "keywords": "dbRun_Config (Business-Datenbank) Diese Tabelle beinhaltet die Konfigurationen für den automatischen Datenbank-Update und die MLColumn-Logik. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Die Einstellungen müssen manuell per SQL vorgenommen werden. Wenn keine Einstellung existiert, dann zieht automatisch die Default-Einstellung. Spalte Beschreibung ConfigKey Schlüssel (siehe unten) ConfigValue Wert (siehe unten) ConnectionGroup Der Name der Connection-Group. Bei <NULL> zieht die Einstellung für alle Connection-Groups. Wenn für eine Connection-Group eine Konfiguration angegeben ist, dann hat diese Priorität. ConfigKey UNICODE Dieser ConfigKey stellt das Unicode-Verhalten des Update-Assinstenten ein. In ConfigValue sind folgende Werte zulässig: Disabled (Default) Neue Spalten werden ASCII (VARCHAR/ CLOB) angelegt. Enabled Neue Spalten werden Unicode (NVARCHAR/ NCLOB) angelegt. Adjust Bestehende Spalten werden auf Unicode umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. Important Diese Einstellung hat zur Folge, dass die GESAMTE Datenbank angefasst wird. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. ConfigKey LOB Dieser ConfigKey steuert, wie der Update-Assistent mit Langtext-Spalten umgehen soll. In ConfigValue sind folgende Werte zulässig Normal (Default) Neue Spalten werden mit LOB-Typen angelegt. Adjust Bestehende Spalten werden auf LOB-Typen umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. Entscheidend ist dabei, dass bei Zeichenketten die Definition der Tabellen-Spalte im Framework Studio eine Länge von 0 (keine Begrenzung) oder eine Länge größer als 4000 (Ansi) bzw. 2000 (Unicode) hat. SQL-Server: text => varchar(max) / ntext => nvarchar(max) image => varbinary(max) Oracle: varchar2(2000) => CLOB / nvarchar2(2000) => NCLOB LONG => CLOB Important ACHTUNG! Diese Einstellung hat zur Folge, dass große Teile der Datenbank angefasst werden. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. Bei Oracle kann sein ggf. sein, dass einige ältere Programme (wie z.B. SQL-Business) nicht mit dem Datentyp CLOB umgehen können. In diesem Fall muss der Schalter auf Normal gesetzt werden. ConfigKey ML_SEARCH_ENABLED Dieser ConfigKey aktiviert die Such-Funktion für die ML-Columns. 0 (Default) Das Feature ist deaktiviert. 1 Das Feature ist aktiv. Die Einstellung zieht für die komplette Datenbank. Die ConnectionGroup muss null sein. Caution Wird dieser Schalter nachträglich aktiviert, dann muss einmalig für bereits existierende Einträge in der Tabelle dbRun_MLStrings die indizierte Spalte ML_SearchText gefüllt werden. -- Sql-Server: UPDATE dbRun_MLStrings SET ML_SearchText = LEFT(ML_Text, 200); -- Oracle: UPDATE dbRun_MLStrings SET ML_SearchText = SUBSTR(ML_Text, 1, 200); ConfigKey ML_DEFAULT_LANGUAGE Dieser ConfigKey legt die Default-Sprache für die ML-Columns fest. Es muss der 2-stellige Iso-Code der Sprache angegeben werden (z.B. en, fr, it). Default-Wert: de Die Einstellung zieht für die komplette Datenbank. Die ConnectionGroup muss null sein. Caution Wird die Default-Sprache geändert, dann müssen die Anwendungs-Broker und FS-Services neu gestartet werden, weil diese Informationen aus Performance-Gründen zwischengespeichert werden. Wird die Default-Sprache nachträglich geändert, dann müssen in der Tabelle dbRun_MLStrings eventuell existierende Texte für die neue Default-Sprache entfernt werden."
  },
  "doc/tables/dbrun_mlstrings.html": {
    "href": "doc/tables/dbrun_mlstrings.html",
    "title": "dbRun_MLStrings (Business-Datenbank)",
    "keywords": "dbRun_MLStrings (Business-Datenbank) In dieser Tabelle werden die Fremdsprachen-Texte für die ML-Columns abgelegt. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Spalte Beschreibung ML_TableName Der Name der Datenbank-Tabelle (Uppercase) ML_ColumnName Der Name der MLColumn-Tabellen-Spalte (Uppercase) ML_FSRowID Die FSRowID des referenzierten Datensatzes. Diese kann für SQL-Abfragen verwendet werden. ML_Iso Der 2-stellige Iso-Code der Fremdsprache (Lowercase) ML_Text Der fremdsprachige Text (Langtext) ML_SearchText Indizierte Spalte mit den ersten 200 Zeichen des fremdsprachigen Textes. Sie wird für SQL-Abfragen verwendet."
  },
  "doc/tables/dbrun_runtimeconfigtext.html": {
    "href": "doc/tables/dbrun_runtimeconfigtext.html",
    "title": "dbRun_RuntimeConfigText (Runtime-Config Datenbank)",
    "keywords": "dbRun_RuntimeConfigText (Runtime-Config Datenbank) Spalte Beschreibung RCT_Tenant Identifier des Tenants. RCT_Key Konfigurations-Schlüssel. (siehe unten) RCT_Value Wert als Langtext oder XML. Tenant-Namen Der Tenant wird in der Spalte RCT_Tenant angegeben. Der Name des Tenants kann frei vergeben werden. Er darf Buchstaben, Zahlen und Unterstriche beinhalten - z.B. MyTenant_7. Es gibt reservierte Namen für Tenants: * (Stern): Konfigurationen für diesen \"generellen\" Tenant werden von allen anderen Tenants verwendet Das gilt auch für die anderen reservierten Tenants, sofern sie den Konfigurations-Schlüssel unterstützen. Wird in anderen Tenants ebenfalls ein Eintrag für einen Konfigurations-Schlüssel definiert, dann hat dieser höhere Priorität und überschreibt so die Konfiguration des \"generellen\" Tenants. #Proxy#: In diesen speziellen \"Tenant\" werden Konfigurationen für den FrameworkBrokerHostProxy hinterlegt. #AuthService#: In diesen speziellen \"Tenant\" werden Konfigurationen für den Authentication-Service hinterlegt. Arbeitet der Auth-Service im Tenant-Betrieb, dann wird der normale Tenant verwendet. Gültigkeit Expiration Date Datum, an dem der Tenant ausläuft. Important Dieser Wert muss angegeben sein, ansonsten kann ein Tenant nicht gestartet werden. Für den generellen Tenant \"*\" darf dieser Wert nicht angegeben werden. RCT_Key: ExpirationDate RCT_Value: Datum im Format \"yyyy-MM-dd HH:mm:ss\" UTC. Gibt es kein Ablauf-Datum, dann wird * angegeben. Activation Date Ab diesem Datum darf ein Tenant benutzt werden. Diese Angabe ist optional. Important Für den generellen Tenannt \"*\" darf dieser Wert nicht angegeben werden. RCT_Key: ActivationDate RCT_Value: Datum im Format \"yyyy-MM-dd HH:mm:ss\" UTC. Lizenzen Die Lizenzen werden pro Package gespeichert. RCT_Key: License|{Package-Name} RCT_Value: Der <License> Knoten aus der Lizenz-XML-Datei inklusive der Singnatur. Beispiel: RCT_Key = 'License|FSDemo' RCT_Value = <License> <Data> <LicenseID>836ff6388f4f41be88a130e328facb90</LicenseID> <PackageID>fde6193cb96842aaaf0d5e005b1a0c8d</PackageID> <PackageName>FSDemo</PackageName><LabelName>4.3</LabelName> [...] <AccessUnits> <AU ID=\"AccessUnitRoot\" ACC=\"0\" ACD=\"0\" UPD=\"0\" INS=\"0\" DEL=\"0\" /> <AU ID=\"c8954266da5e4f0dbd0e2177393ee60c\" ACC=\"0\" ACD=\"0\" UPD=\"0\" INS=\"0\" DEL=\"0\" /> [...] </AccessUnits> </Data> <Signature>14C129D7BC2962A0C20732F2FD1484C430[...]</Signature> </License> Connections Authentication AuthService|DefaultUserName AuthService|DefaultUserPassword AuthService|PublicKey ApplicationService AppService|Id AppService|Title - Überschreibt den Titel der über den Publish in der IDE definiert wurde. AppService|Name AppService|Description AppService|PrivateKey AppService|IsAuthenticationEnabled true oder false Service-Proxies RCT_Key: ServiceProxy|<ProxyType-FullName>|Address RCT_Value: Adresse des Proxy Proxy-Settings Settings für den FrameworkBrokerHostProxy. (Tenant = #Proxy#) Use Http Startet den FrameworkBrokerHostProxy mit HTTP statt HTTPS. Diese Einstellung sollte in Produktiv-Umgebungen nicht verwendet werden. RCT_Key: Proxy|UseHttp RCT_Value: true oder false. Password Hash Password-Hash für die API des FrameworkBrokerHostProxy. RCT_Key: Proxy|PasswordHash RCT_Value: SAH512 Hashwert des API-Passworts. Z.B. auf der Seite https://passwordsgenerator.net/sha512-hash-generator/ (Benutzung auf eigene Gefahr!) kann man einen Passwort-Hash generieren. AuthService-Settings Settings für den Authentication-Service. Wird der Auth-Service pro Tenant betrieben, wird mit dem normalen Tenant mit Fallback auf den generellen Tenant \"*\" gearbeitet. Arbeitet der Auth-Service ohne Tenants, dann wird der reservierte Tenant #AuthService# mit Fallback auf den generellen Tenant \"*\" verwendet. Multi-Tenant Gibt an, ob der Auth-Service als Multi-Tenant betrieben werden soll. In diesem Fall werden Tenant-Spezifische Instanzen des Auth-Service, die ihre Einstellungen über den normalen Tenant beziehen. Für diese Einstellung muss der reservierte \"Tenant\" #AuthService# verwendet werden. RCT_Tenant: #AuthService# RCT_Key: AuthService|MultiTenant RCT_Value: false (default) | true Enabled Gibt an, ob für den Tenant der Auth-Service gestartet werden soll. Diese Einstellung zieht nur im Tenant-Betrieb. RCT_Key: AuthService|Enabled RCT_Value: false (default) | true Connection Im Tenant-Betrieb greift ein Fallback auf Connection|RuntimeConnection, falls dieser Key nicht gefüllt ist. RCT_Key: AuthService|Connection RCT_Value: Connection-String Service-ID Eindeutige ID des Service. RCT_Key: AuthService|Id RCT_Value: guid-String Service-Uri Url des Auth-Service RCT_Key: AuthService|Uri RCT_Value: Url des Auth-Service Service-Name RCT_Key: AuthService|Name RCT_Value: Name des Service. Wenn nicht angegeben, dann ist der Default-Wert \"AuthenticationService\" Service-Description RCT_Key: AuthService|Description RCT_Value: Beschreibung des Service Public Key Öffentlicher Schlüssel des Authentication-Service. Dieser kann auch im generellen Tenant \"*\" definiert und so automatisch von allen Tenants verwendet werden. RCT_Key: AuthService|PublicKey RCT_Value: Public Key in Hex-Schreibweise Private Key RCT_Key: AuthService|PrivateKey RCT_Value: Private Key in Hex-Schreibweise Runtime Supervisor Gibt an, ob der Runtime-Supervisor aktiviert ist: RCT_Key: RuntimeSupervisorEnabled RCT_Value: true oder false Gibt die URL des Runtime-Supervisor an: RCT_Key: RuntimeSupervisorUri RCT_Value: Url des Runtime-Supervisor"
  },
  "doc/tables/ml_config.html": {
    "href": "doc/tables/ml_config.html",
    "title": "ML_Config (Business-Datenbank)",
    "keywords": "ML_Config (Business-Datenbank) Caution Diese Tabelle ist veraltet. Die Default-Sprache kann seit Framework Studio 4.2.1 in der Datenbank-Tabelle dbRun_Config mit dem ConfigKey ML_DEFAULT_LANGUAGE definiert werden. Existiert der neue ConfigKey nicht, dann erfolgt weiterhin ein Fallback auf diese Tabelle. Es wird empfohlen die Konfiguration in die neue Tabelle zu übertragen und diese Tabelle zu löschen. Die ML-Columns arbeiten standardmäßig mit der Default-Sprache de Deutsch. Ist die \"führende\" Sprache nicht de, dann kann über diese Tabelle die korrekte Default-Sprache eingestellt werden. Das geschieht in der Business-Datenbank, wo auch die Übersetzungs-Tabelle dbRun_MLStrings abgelegt ist, welche die anderssprachigen Werte speichert. Die Einstellung muss in dieser Datenbank stehen, damit sichergestellt ist, dass die Übersetzungs-Tabelle immer mit derselben Konfiguration angesprochen wird - unabhängig davon, wie die Anwendung FS-seitig konfiguriert ist. Die Tabelle muss bei Bedarf manuell per SQL angelegt werden. Dazu können die folgenden Scripte verwendet werden. Das Iso-Sprach-Kürzel de muss entsprechend durch das gewünschte Iso-Sprach-Kürzel ersetzt werden. -- SQL-Server CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR(2), CONSTRAINT PK_ML_CONFIG PRIMARY KEY CLUSTERED (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); -- Oracle CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR2(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR2(2) NULL, CONSTRAINT PK_ML_CONFIG PRIMARY KEY (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); Caution Wenn die Konfiguration geändert wurde, dann müssen die Anwendungs-Broker und FS-Services neu gestartet werden, weil diese Informationen aus Performance-Gründen zwischengespeichert werden. Die Konfiguration darf nicht nachträglich geändert werden, weil ansonsten die in der Übersetzungs-Tabelle abgelegten Texte nicht mehr stimmen. Wenn die Konfiguration zu Beginn bei Einrichtung der Business-Datenbank vorgenommen wird, dann muss im Anschluss sichergestellt werden, dass die Tabelle dbRun_MLStrings leer ist. Wenn bei einer Änderung der Konfiguration doch dbRun_MLStrings-Inhalte erhalten bleiben sollen, müssen alle Einträge, für die neue Default-Sprache gelöscht werden."
  },
  "doc/tables/rptRun_PrintTransaction.html": {
    "href": "doc/tables/rptRun_PrintTransaction.html",
    "title": "rptRun_PrintTransaction (Runtime-Repository)",
    "keywords": "rptRun_PrintTransaction (Runtime-Repository) Diese Tabelle beinhaltet die Transaktionen der Druck-Aufträge für den Print-Server. Die Druckaufträge werden in der Tabelle rptRun_ReportPrintQueue gespeichert. Spalte Beschreibung PRTR_ID Eindeutige ID der Transaktion (Guid) PRTR_PRS_ID ID des Print-Servers (FK ) PRTR_Status Status der Transaktion 0 = Transaktion ist offen. Es werden Druckaufträge zur Transaktion hinzugefügt 1 = Transaktion ist bereit zu drucken. Alle Druckaufträge sind hinzugefügt und der Printserver kann mit dem Druck beginnen. 2 = Der Druck läuft gerade 3 = Druckauftrag ist abgeschlossen. 4 = Der Druckauftrag wurde mit einem Fehler beendet. PRTR_Owner Der Eigentümer des Druck-Auftrages. Prio 1.) Name des authentifizierten Benutzers Prio 2.) Der Name des Windows Benutzers am Client Prio 3.) Der Name des Windows-Benutzers am Server (Environment.UserName) PRTR_CreateDate Zeitpunkt, an dem die Transaktion erzeugt wurde"
  },
  "doc/tables/rptRun_RPQReportFile.html": {
    "href": "doc/tables/rptRun_RPQReportFile.html",
    "title": "rptRun_RPQReportFile (Runtime-Repository)",
    "keywords": "rptRun_RPQReportFile (Runtime-Repository) In dieser Tabelle werden die Report-Dateien für die Druck-Aufträge gespeichert. Spalte Beschreibung RPQRPT_RPQ_ID ID des Druckauftrages (FK zur Tabelle rptRun_ReportPrintQueue) RPQRPT_NAME Name der Report-Datei, wie er im Report Document Type definiert ist (z.B. Invoice.rpt) RPQRPT_DATA Report-Datei als Binärdaten"
  },
  "doc/tables/rptRun_ReportPrintQueue.html": {
    "href": "doc/tables/rptRun_ReportPrintQueue.html",
    "title": "rptRun_ReportPrintQueue (Runtime-Repository)",
    "keywords": "rptRun_ReportPrintQueue (Runtime-Repository) In dieser Tabelle werden dir Druck-Aufträge für den Print-Service gespeichert. Es können mehrere Druckaufträge zu einer Transaktion zusammengefasst sein. Diese wird in der Tabelle rptRun_PrintTransaction gespeichert. Spalte Beschreibung RPQ_ID Eindeutige ID des Druck-Auftrages (Guid) RPQ_PRTR_ID ID der Transaktion (FK zu Tabelle rptRun_PrintTransaction ) RPQ_CREATEDATETIME Zeitpunkt, an dem der Druckauftrag erzeugt wurde RPQ_ADAPTER Der zu verwendende Print-Adapter RPQ_ORDERID definiert die Reihenfolge bei mehereren Druckaufträgen in einer Transaktion RPQ_PRSP_ID ID des Druckers RPQ_COPIES Anzahl der Kopien RPQ_STARTPAGE Erste Seite RPQ_ENDPAGE Letzte Seite RPQ_COLLATE Sortieren Die Report-Datei wird in der Tabelle rptRun_RPQReportFile gespeichert."
  },
  "doc/tables/tblrep_reportinstance.html": {
    "href": "doc/tables/tblrep_reportinstance.html",
    "title": "tblRep_ReportInstance (Runtime-Repository)",
    "keywords": "tblRep_ReportInstance (Runtime-Repository) Diese Tabelle beinhaltet die Druck-Jobs die per Anzeige / Vorschau direkt am Client angezeigt werden. Spalte Beschreibung RPTI_ID Eindeutige ID des Print-Jobs (Guid) RPTI_Reportname Der Name der Report-Datei RPTI_XML XML-Serialisierte Form der Datei RPTI_RPTExpF_ID Das Format in dem der Druck ausgegeben werden soll. 1 = CrystalReport 2 = RichText 3 = Word 4 = Excel 5 = PDF 6/7 = HTML RPTI_CreateDateTime Zeitpunkt, an dem der Print-Job erzeugt wurde RPTI_XSDFileName Der Name der XSD-Schemadatei, welche den Aufbau der Datenquelle beschreibt. RPTI_Orientation Die Orientierung (Portrait/Hochkant), in welcher gedruckt werden soll RPTI_ReportFile Der Inhalt der Datei im Binär-Format. Normalerweise werden die Datensätze in dieser Tabelle nach 10 Minuten automatisch gelöscht. Sollten dennoch Einträge stehen bleiben, dann können veraltete Einträge auch manuell gelöscht werden. -- SQL-Server: DELETE FROM [tblRep_ReportInstance] WHERE DATEADD(minute, 10, [RPTI_CreateDateTime]) < GetDate (); -- Oracle: DELETE FROM tblRep_ReportInstance WHERE (RPTI_CreateDateTime + (10 / 1440)) < sysdate;"
  },
  "doc/tables/tblrep_sessiondata.html": {
    "href": "doc/tables/tblrep_sessiondata.html",
    "title": "tblRep_SessionData (Runtime-Repository)",
    "keywords": "tblRep_SessionData (Runtime-Repository) Diese Tabelle speichert verschlüsselte Sitzungs-Daten. Die Speicherung erfolgt im Broker über SessionData. Abgelaufene Daten werden automatisch durch den Broker bereinigt. Spalte Beschreibung SD_ID Eindeutige ID, die den Client identifiziert SD_Created Zeitpunkt, an dem die Daten gespeichert wurden SD_Expires Zeitpunkt, an dem die Daten ablaufen SD_Data Verschlüsselte Daten"
  },
  "doc/tables/tblrep_sessionlogging.html": {
    "href": "doc/tables/tblrep_sessionlogging.html",
    "title": "tblRep_SessionLogging (Runtime-Repository)",
    "keywords": "tblRep_SessionLogging (Runtime-Repository) Diese Tabelle speichert die von jeder Application automatisch erzeugten Session-Logging Informationen. Ausgewertet werden können die Daten mit dem Session Logging Analyzer. Spalte Beschreibung SL_ID Eindeutige ID der Session (Guid) SL_SessionStart Zeitpunkt, an dem die Session gestartet wurde SL_LastUpdate Zeitpunkt, an dem der Datensatz zuletzt aktualisiert wurde SL_State Status der Session SL_RequestsCount Anzahl der Broker-Requests SL_TopRequests Informationen über alle Requests, aggregiert pro Event (XML) SL_CommandsCount Anzahl der Datenbank-Befehle SL_TopCommands Informationen über die langsamsten Datenbank-Befehle (XML) SL_ObjectsCount Aktuelle Anzahl von Framework-Studio Objekten SL_CreatedObjectsCount Gesamt-Anzahl der während der Session erzeugten Framework-Studio Objekte SL_UserName Name des Benutzers SL_MachineName Name des Broker-Servers SL_DBDuration Gesamte Dauer aller Datenbank-Befehle in Millisekunden SL_RequestDuration Gesamte Dauer aller Broker-Requests in Millisekunden (am Broker gemessen) SL_ClientRequestDuration Gesamte Dauer aller Broker-Requests in Millisekunden (am Client gemessen) SL_ClientDuration Gesamte Dauer der Client-Zeit in Millisekunden SL_RequestSize Summe der Größe aller Requests in Bytes (vom Client zum Broker gesendeten Daten) SL_ResponseSize Summe der Größe aller Responses in Bytes (vom Broker zum Client gesendeten Daten) SL_ClientInfo Textuelle Liste mit Informationen zum Client und Package-Versionen"
  },
  "doc/textcoll/textcollection.html": {
    "href": "doc/textcoll/textcollection.html",
    "title": "Textcollections",
    "keywords": "Textcollections Textcollections beinhalten mehrere Einträge mit Zeichenketten. Die Zeichenketten können in den verschiedenen Sprachen angegeben werden. Ein Eintrag beinhaltet immer eine in der Collection eindeutige ID und für jede Sprache eine Zeichenkette. Je nachdem, mit welcher Sprache die Anwendung gestartet wird, geben die Einträge mit dem Property value die Zeichenkette für die entsprechende Sprache zurück. Die Textcollections können im Form-Designer z.B. für Comboboxen, für Messageboxen oder auch frei im Code verwendet werden, um sprachabhängig Texte zusammenzubauen. Erstellt werden kann eine Textcollection über das Kontext-Menü des jeweiligen Namespaces. Dort steht der Befehl New / Textcollection (Menü File >> New >> Textcollection) zur Verfügung. Customizing von Textcollections ist möglich, um neue Einträge hinzuzufügen und bestehende Einträge abzuändern. Wenn ein neuer Eintrag mit einer ID hinzugefügt wurde, die in einem der Basis Packages verwendet wird, wird eine Warnung (FSWarn[2017]) generiert. Warning Das Customizing von Textcollections, um neue Einträge hinzuzufügen ist nur dann sinnvoll, wenn zwingend eine bestehende Textcollection erweitert werden muss. In so einem Fall sollte der neue Eintrag einen Wert erhalten, bei dem die Gefahr von nachträglicher Überschneidung möglichst gering ist. Registerkarte General Description Beschreibung für die Component. Control Types Hier können analog zu den Components Controls hinterlegt werden. Registerkarte Data Auf dieser Registerkarte werden die Einträge der Textcollection verwaltet. Die Tabelle zeigt alle vorhandenen Einträge an. Es werden die ID und die Zeichenkette in der in Framework Studio eingestellten Sprache angezeigt. Markieren Sie den Eintrag, den Sie bearbeiten möchten. Rechts neben der Tabelle werden dann die Daten zu diesem Eintrag angezeigt. Diese können auch bearbeitet werden. Button New Erstellt einen neuen Eintrag. Button Delete Löscht den markierten Eintrag. Methoden der Textcollection string GetTextOnID(Int32 id, string defaultText) Liefert den Text zur übergebenen ID in der aktuellen Sprache. Wird die ID in der TextCollection nicht gefunden, wird der im Parameter defaultText übergebene Wert zurückgegeben. IDevFrameworkObjectMLString GetOnID(Int32 id) Liefert das Element der angegebenen Position zurück. Wird die Position in der Collection nicht gefunden, wird null zurückgegeben. Um Ressourcen zu schonen, kann man die Methoden an der Factory-Klasse verwenden. Dadurch braucht für den Zugriff keine Instanz der TextCollection zu existieren. string GetText(GlobalObject, Int32 id, string defaultText) Statische Methode an der Factory-Klasse der Text-Collection. Sie liefert den Text zur übergebenen ID in der aktuellen Sprache. Wird die ID in der TextCollection nicht gefunden, wird der im Parameter defaultText übergebene Wert zurückgegeben. Beispiel: string sText = ctTextCollFactory.GetText(this.Global, id, \"invalid id\"); IDevFrameworkObjectMLString Get(GlobalObject, Int32 id) Liefert das Element der angegebenen Position zurück. Wird die Position in der Collection nicht gefunden, wird null zurückgegeben. Beispiel: IDevFrameworkObjectMLString mlText = ctTextCollFactory.Get(this.Global, id); string sText; if (mlText != null) { sText = mlText.Text; } else { sText = “invalid id”; } Konstanten Wird an einem Texteintrag ein Konstantenname vergeben, so wird in der Textcollection-Factory eine Konstante erzeugt. Wenn in einer Textcollection nur eine Teilmenge der Einträge mit einem Konstantennamen versehen sind, erzeugt der Compiler für die übrigen jeweils eine Warnung. Es sollten also entweder keine oder alle Einträge einen Konstantennamen besitzen. Beispiel für die Konstantennamen: Code-Beispiel: public virtual void btnBuyArticle_OnClick() { switch(PurchaseArticle()) { case ctArticleTextFactory.Purchased: // Artikel versenden break; case ctArticleTextFactory.NotInStock: // Nachbestellen break; case ctArticleTextFactory.NotExisting: // ... break; } } ctSystemMessages Im Namespace FSGeneral existiert bereits im SystemPackage eine Textcollection mit dem Namen ctSystemMessages. Diese Textcollection enthält Systemmeldungen, die von den Clients benutzt werden (z.B. \"Soll die Anwendung geschlossen werden?\" oder \"Abbrechen\"). Auf diese Weise wird dem Client ermöglicht, auch Systemmeldungen in der Sprache anzeigen zu können, in der die Anwendung gestartet wurde. Diese Textcollection kann in jedem Package customized werden, so dass zum Beispiel in einem landesspezifischen Package die Systemmeldungen in der entsprechenden Sprache nachgepflegt werden können."
  },
  "doc/themes/aufraeum-routine.html": {
    "href": "doc/themes/aufraeum-routine.html",
    "title": "Aufräum-Routine",
    "keywords": "Aufräum-Routine Diese Routine ist verantwortlich dafür, Themes korrekt aus einem Package zu entfernen. Da nicht nur die Themes alleine von Framework Studio gespeichert werden, sondern auch Referenzen von den Applications, Default Control Styles und Ressourcen auf die Themes verweisen, müssen vor dem endgültigen Löschen der Themes erst alle Referenzen in diesen Elementen eliminiert werden. Gelöscht werden grundsätzlich alle Themes im aktuellen Package, die im Theme Manager auf „Deprecated“ gesetzt wurden. Es werden erst alle Applications, Default Control Styles und Ressourcen durchlaufen und jegliche Referenzen auf nicht vorhandene oder auf Deprecated gesetzte Themes eliminiert und danach die Themes an sich gelöscht. Mit dem Button im Theme Manager kann die Routine gestartet werden. Es erfolgt zur Sicherheit noch eine Abfrage, ob fortgefahren werden soll: Sicherheitsabfrage der Aufräum-Routine Bevor die Routine startet, wird von Framework Studio auf das Default-Theme gewechselt. Um Änderungen an den Applications, Default Control Styles und Ressourcen vornehmen zu können, müssen diese Elemente ausgecheckt sein. Dies wird von der Routine selbst übernommen. Ist ein zu bearbeitendes Element nicht ausgecheckt, wird es automatisch ausgecheckt und nach erfolgreichem Ablauf der Routine wieder eingecheckt. Sollte ein zu änderndes Element schon vom Benutzer ausgecheckt worden sein, wird die Routine die Änderungen am Element durchführen, es aber nach erfolgreichem Ablauf NICHT einchecken (Der Benutzer könnte schon andere Änderungen am Element vorgenommen haben, die er vielleicht noch gar nicht einchecken will). Der Ablauf der Routine selbst ist im Output-Fenster von Framework Studio einsehbar: Ablauf der Routine im Output-Fenster: Nun muss noch folgender Fall betrachtet werden: Was ist, wenn ein Package Theme-Informationen beinhaltet, die auf Themes verweisen, die im Basis-Package definiert wurden und dort gelöscht werden? Dafür wird noch einmal die Konstellation von 3 Packages und 2 Themes betrachtet: Theme-Definition für die FocusHighlightColor: Beide Themes sind im Package „BasePackage“ über den Theme-Manager angelegt worden. Nun gibt es 2 Szenarien, in denen „unnötige Theme-Daten“ in den aufgesetzten Packages (CustomPackage und AdditionalPackage) entstehen. Szenario 1 Im BasePackage werden z.B. beide Themes auf Deprecated gesetzt und die Aufräum-Routine ausgeführt. Danach ist im BasePackage nur noch das Default-Theme vorhanden und jegliche Informationen zu den Themes in den Applications, Default Control Styles und Ressourcen gelöscht. Da die Themes im BasePackage gelöscht wurden, sind diese nun auch nicht mehr in den aufsetzenden Packages auswählbar. Die Property-Informationen zu den Themes in den aufsetzenden Packages sind jedoch noch im Repository gespeichert. So ist die Information Yellow für die FHC für Theme1 im AdditionalPackage immer noch im Repository vorhanden, obwohl das Theme längst aus dem BasePackage gelöscht wurde. Dies hat zur Folge, dass bei jedem CheckIn/CheckOut der Application diese nunmehr sinnlose Information mitgeschleift wird. Es empfiehlt sich also, die Aufräum-Routine auch in den aufsetzenden Packages durchzuführen. Die Routine erkennt nicht nur auf Deprecated gesetzte Themes, sondern eliminiert auch jegliche Informationen zu Themes, die in der Package-Hierarchie nicht mehr auffindbar sind. Im konkreten Fall würde die Routine im AdditionalPackage die Application durchgehen, in der für Theme1 für die FHC Yellow definiert wurde. Sie erkennt dann, dass die das Theme Theme1 gar nicht mehr in der Package-Hierarchie auffinden kann (da es ja im BasePackage gelöscht wurde). Somit wird diese Property-Information aus dem AdditionalPackage gelöscht und die Application hat, bezogen auf die Themes, wieder einen sauberen Stand. Szenario 2 Da Framework Studio die Möglichkeit bietet, Packages beliebig in der Hierarchie anzuordnen, kann folgender Fall eintreten: Das BasePackage mit den 2 definierten Themes wird aus der Hierarchie entfernt und ein neues BasePackage wird an dessen Stelle gesetzt. In diesem neuen BasePackage sind jedoch die Themes überhaupt nicht definiert. Ab diesem Zeitpunkt ist die Situation wieder wie in Szenario 1. Die aufsetzenden Packages CustomPackage und AdditionalPackage haben in ihren Elementen Theme-Informationen für Themes, die gar nicht mehr in der Package-Hierarchie existieren. Das Starten der Aufräum-Routine in den Packages CustomPackage und AdditionalPackage würde diese Unsauberkeiten bereinigen. Note Wenn Themes gelöscht werden und die Aufräum-Routine in aufsetzenden Packages NICHT ausgeführt wird, hat dies funktional KEINEN Einfluss auf die Anwendungen. Es werden lediglich unnütze Daten im Repository von Version zu Version mitgeschleift."
  },
  "doc/themes/einfuehrung.html": {
    "href": "doc/themes/einfuehrung.html",
    "title": "Einführung",
    "keywords": "Einführung Durch Themes wird die Möglichkeit gegeben, einer FS-Anwendung ein anderes Aussehen zu geben, ohne dabei auf die Geschäftslogik und damit den Sourcecode Einfluss zu nehmen. Beispiel FS-Demo mit Standard-Theme: Das Bild zeigt die FS-Demo-Anwendung, wie sie standardmäßig von Framework Studio erstellt wird. Im folgenden Bild wurde das Aussehen der Anwendung durch Hinzufügen eines Themes grundlegend verändert: In diesem neuen Theme wurden folgende Änderungen durchgeführt: Hintergrundbild geändert. Transparenz des Grids deaktiviert. Button-Images durch blaue Bilder ersetzt. Schriftfarbe der Labels auf blau gesetzt. FocusHighlightColor auf hellgelb gesetzt."
  },
  "doc/themes/hierarchie-bei-mehreren-package-und-themes.html": {
    "href": "doc/themes/hierarchie-bei-mehreren-package-und-themes.html",
    "title": "Hierarchie bei mehreren Packages und Themes",
    "keywords": "Hierarchie bei mehreren Packages und Themes Wenn mehrere Packages übereinander liegen und mehrere Themes verfügbar sind, folgt Framework Studio einem gewissen Schema, woher die einzelnen Property-Werte bezogen werden. Dieses Schema ist für Properties der Applications, der Default Control Styles, sowie der Bilder der Ressourcen exakt gleich. Im folgenden Beispiel wird angenommen, dass 3 Packages übereinander liegen und im untersten Package (BasePackage) 2 Themes definiert wurden, die somit auch den anderen Packages zur Verfügung stehen. Das Property, welches hier betrachtet werden soll, ist die FocusHighlightColor (im Folgenden FHC) einer Application. Die FHC soll in der Package-Hierarchie wie folgt definiert sein: Theme-Definition für die FocusHighlightColor: Ist die FHC im aktuellen Package für das gewählte Theme nicht definiert (wie z.B. bei CustomPackage/Theme2), werden erst alle Basis-Packages durchsucht, ob dort das Property für das gewählte Theme gesetzt ist. Ist dies nicht der Fall, wird die gleiche Suche für das Property im Default-Theme angestoßen (siehe Pfeile). Anhand der folgenden Grafik soll nun erläutert werden, welche Werte die FHC je Package und Theme annehmen würde: Lookup-Pfad des Themeable Properties: Beispiel BasePackage/Theme1 Da im BasePackage für das Theme Theme1 die FHC explizit auf Purple gesetzt wurde, wird keine Hierarchiesuche angestoßen und die FHC ist somit Purple. Beispiel BasePackage/Theme2 Im BasePackage ist die FHC für das Theme Theme2 nicht definiert. Da das BasePackage kein weiteres Basis-Package hat, wird der Wert des Default-Theme zurückgegeben. In diesem Fall ist im Default-Theme auch nicht explizit ein Wert gesetzt, also wird die Standardfarbe für die FHC (Black) zurückgegeben. Beispiel CustomPackage/Theme1 Für Theme1 ist im CustomPackage keine FHC definiert, also wird im Basis-Package von CustomPackage (BasePackage) für das Theme1 nach der FHC gesucht. Dort ist Purple definiert und wird somit zurückgegeben. Beispiel CustomPackage /Theme2 Im CustomPackage ist die FHC für Theme2 nicht definiert. Es wird somit in BasePackage für Theme2 nach einem Wert gesucht. Dort ist ebenso kein Wert definiert. Es verbleiben keine weiteren Basis-Packages, also wird wieder vom CustomPackage aus durch die Hierarchie gesucht, diesmal jedoch mit dem Default-Theme (da für Theme1 in keinem Package ein Wert für FHC definiert wurde). Für das Default-Theme ist im CustomPackage der Wert Red für die FHC definiert und wird somit zurückgegeben. Beispiel AdditionalPackage/Theme1 In diesem Beispiel ist im AdditionalPackage für das Theme1 gleich ein Wert für die FHC definiert. Yellow wird sofort zurückgegeben. Beispiel AdditionalPackage /Theme2 Für Theme2 ist in keinem der Packages ein Wert für die FHC definiert. Somit wird die Package-Hierarchie für das Default-Theme nach einem Wert für die FHC durchsucht. Im AdditionalPackage wird für das Default-Theme gleich ein Wert Blue gefunden und zurückgegeben."
  },
  "doc/themes/properties-theme-abhaengig-aendern.html": {
    "href": "doc/themes/properties-theme-abhaengig-aendern.html",
    "title": "Properties Theme-abhängig ändern",
    "keywords": "Properties Theme-abhängig ändern Um in Applications oder Default Control Styles Properties Theme-abhängig ändern zu können, muss nur das entsprechende Theme ausgewählt werden. Wird nun ein Property modifiziert, wird die Information automatisch dem aktuell aktiven Theme zugeordnet. Properties ändern bei Applications Beispiel Wurde vom Benutzer kein Theme ausgewählt (d.h. das Default-Theme ist aktiv), sieht die FSDemoApplication im Design-Panel wie folgt aus: Application PropertyGrid im Default-Theme: Ein BackImage wurde definiert, IsTransparent aktiviert, SplitterBackColor und die Farben für Menüs wurden modifiziert. Wird nun ein anderes Theme (über Tools > Choose Theme) ausgewählt, werden die Properties, bezogen auf das nun ausgewählte Theme, angezeigt und können geändert werden: Application PropertyGrid im angepassten Theme: Im Gegensatz zum Default-Theme wurde hier ein anderes BackImage definiert. Das Property „FocusHighlightColor“ ist auf einen Gelbton abgeändert worden (im Default-Theme war hier nichts definiert). Auch die SplitterBackColor wurde neu zugewiesen. Properties ändern bei Default Control Styles Das Theme-abhängige Modifizieren von Properties eines Default Control Styles gestaltet sich analog zu den Applications: Beispiel Im Folgenden wird der Default Control Style des Button-Controls angezeigt, während der Benutzer das Default-Theme ausgewählt hat: DefaultControlStyle PropertyGrid im Default-Theme: Die BackColor wurde auf ButtonFace, die Font auf Arial; 12pt und die ForeColor auf Red gesetzt. Wird nun wiederrum ein Theme ausgewählt, könnten die Properties z.B. wie folgt umdefiniert werden: DefaultControlStyle PropertyGrid im angepassten Theme: Bild ändern bei Ressourcen Ist das Default-Theme aktiv, kann ein Bild über den Button Import File an die Resource gebunden werden. Der Name der Resource wird dabei standardmäßig auf den Namen der importierten Datei angepasst: Bild-Resource im Default-Theme: Wird nun ein Theme vom Benutzer ausgewählt, hat der Benutzer die Möglichkeit über den Button Import File erneut eine Bilddatei zu importieren. Diese wird dann jedoch dem Theme zugeordnet und das Bild des Default-Themes (der graue Buttonhintergrund) bleibt erhalten. Resource mit angepasstem Bild: In dieser Grafik wurde für die Resource NVButton1.gif ein neues Bild für das ausgewählte Theme importiert. Dass das Bild im aktiven Theme überschrieben ist, zeigt sich an der fetten Schrift des Relative Path und daran, dass der Reset-Button aktiv ist. In der Resource wurde der graue Button-Hintergrund durch einen bläulichen ausgetauscht. Wird wieder zum Default-Theme gewechselt, würde die Resource wieder den grauen Button-Hintergrund anzeigen. Bild zurücksetzen Ist einer Resource für ein Theme ein abweichendes Bild zugeordnet, kann dies durch den Reset-Button wieder auf das Default-Bild zurückgesetzt werden. Beispiel Der Resource ist im Default-Theme, wie in den obigen Grafiken zu sehen, der graue Button-Hintergrund zugewiesen und im Theme der bläuliche. Befindet sich der Benutzer nun im Theme und klickt den Reset-Button, wird der bläuliche Buttonhintergrund aus der Resource für das Theme entfernt und der graue Button-Hintergrund würde auch für das Theme verwendet werden (siehe Hierarchie bei mehreren Packages und Themes). Important Wird einer Resource bei aktiviertem Theme ein Bild zugewiesen und ist das Bild für das Default-Theme noch nicht gesetzt, wird das im Theme importierte Bild auch als Bild für das Default-Theme hinzugefügt."
  },
  "doc/themes/themeable-properties.html": {
    "href": "doc/themes/themeable-properties.html",
    "title": "Themeable Properties",
    "keywords": "Themeable Properties Um der Anwendung ein anderes Aussehen zu geben, können folgende Elemente auf Theme-Ebene angepasst werden: Applications Default Control Styles Resources (nur Bilder) Im Folgenden werden die verschiedenen Properties dieser Elemente aufgelistet, die im Rahmen eines Themes verändert werden können: Themeable Application Properties BackImage FocusHighlightColor Icon IsTransparent MenuBackColor MenuBackColorAlpha MenuItemBackColor MenuItemBackColorAlpha SplitterBackColor SplitterBackColorAlpha StartImage Themeable Default Control Styles Für jeden Default Control Style BackColor ForeColor Font IsEditable IsVisible IsTransparent EditField DisableBackColor TextAlign ImageButton CaptionAlign ScaleMode Picture ContentAlignment PictureScaleMode TabbedWindow TabAlignment TabLayout TreeView IsBorderVisible IsFirstExpandIconVisible IsHeaderVisible Themeable Resource Property Da Bilder die einzigen Ressourcen sind, die durch Themes angepasst werden können, ist auch das einzige Property, welches anpassbar ist, das Bild, welches die Resource definiert."
  },
  "doc/themes/verwalten.html": {
    "href": "doc/themes/verwalten.html",
    "title": "Verwalten",
    "keywords": "Verwalten Die Themes werden über den Theme Manager verwaltet. Dieser kann über das Menü Tools > Manage Themes aufgerufen werden. In der Liste werden alle verfügbaren Themes angezeigt. Sind Themes in einem oder mehreren Basis-Packages des aktuellen Packages definiert, werden diese mit dem jeweiligen Packagenamen in Klammern angezeigt, können aber nicht geändert werden. Menü: Über den Button wird ein neues Theme angelegt werden. Neue Themes erhalten ein (+)-Zeichen. Nur neu angelegte Themes können ohne die Aufräum-Routine gelöscht werden. Mit werden alle Änderungen gespeichert. Neue Themes mit (+) werden dann persistent gespeichert und können dann nur noch über die Aufräum-Routine gelöscht werden. Mit können noch nicht persistent gespeicherte Themes (mit (+)) wieder gelöscht werden. Mit kann die Aufräum-Routine angestoßen werden. Properties: ID: Die ID wird beim Anlegen eines Themes generiert und ist eindeutig. Name: Name des Themes. Kann auch im Nachhinein noch geändert werden, da die Themes über die ID identifiziert werden. Der Name darf maximal 20 Zeichen lang sein. Deprecated: Wird ein Theme auf „Deprecated“ gesetzt, steht es in der Theme-Auswahl nicht mehr zur Verfügung. Es wird zudem auch bei Publish-Vorgängen nicht mehr beachtet. Deprecated gilt somit als Vorstufe zum Löschen des Themes mittels der Aufräum-Routine (siehe Aufräum-Routine). Caution Sind in einem Package Themes auf Deprecated gesetzt, werden diese von der Aufräum-Routine endgültig aus dem Package gelöscht. Für Packages, die auf dem Package aufsetzen, in dem das Theme definiert war, ist das Theme dann auch nicht mehr verfügbar."
  },
  "doc/themes/zwischen-themes-wechseln.html": {
    "href": "doc/themes/zwischen-themes-wechseln.html",
    "title": "Zwischen Themes wechseln",
    "keywords": "Zwischen Themes wechseln Sind im aktuellen Package oder in dessen Basis-Packages Themes definiert (und nicht auf Deprecated gesetzt) kann das aktive Theme über das Menü Tools > Choose Theme ausgewählt werden. Note Wird Framework Studio neu gestartet, wird IMMER das Default-Theme geladen. Menü zur Auswahl des aktiven Themes: Wenn das aktive Package über ein oder mehrere Basis-Packages verfügt, in denen auch Themes definiert sind, werden diese mit dem jeweiligen Package Namen angezeigt. Themes aus Basis-Packages: Das aktuell aktive Theme wird auch rechts in der Framework Studio Statusleiste angezeigt. Anzeige des aktiven Themes:"
  },
  "doc/transformationen/transformationen.html": {
    "href": "doc/transformationen/transformationen.html",
    "title": "Transformationen",
    "keywords": "Transformationen Mit Hilfe von Transformationen können ein oder mehrere Eingabeparameter in einen Ausgabeparameter umgewandelt werden. Dies ist vor allem in Bezug auf Webservices hilfreich, bei dem z.B. eine Component, die nur im Webservice, jedoch nicht am Client bekannt ist, in einen Data Contract überführt werden soll. Es gibt zwei Arten von Transformationen: Eine graphische Transformation, bei der Properties der Eingabeparameter mit den Properties des Ausgabeparameters visuell verknüpft werden können und eine Code-Transformation, in der per C# die Eingabeparameter programmatisch in einen Ausgabeparameter konvertiert werden. Anlegen von Transformationen: Transformationen werden in einem Namespace über das Erstellmenü oder über Rechtsklick auf den Namespace in der unteren Treeview > New > FSTransformation erstellt. Code-Transformation Mit Hilfe der Code-Transformation können beliebig viele Eingabeparameter in einen Ausgabeparameter umgewandelt werden. Der Vorteil gegenüber graphischen Transformationen ist, dass der Komplexität der Transformation keine Grenze gesetzt ist. Beispiel 1: Die wohl kürzeste Code-Transformation ist die Umwandlung eines Typs in einen anderen. Hier dient als Beispiel die Umwandlung eines objects in einen string. Diese Operation kann z.B. von C# nicht implizit ausgeführt werden. Natürlich würde diese Umwandlung normalerweise vom Programmierer mit dem Aufruf der ToString()-Methode auf dem object realisiert werden. Wir wollen dies aber zu Anschauungszwecken in einer Code-Transformation abbilden: Beispiel 2: Als etwas komplexeres Beispiel wird eine Liste von Integern in einen String umgewandelt, in dem alle in der Liste enthaltenen Zahlen per Komma getrennt hintereinander stehen. Der Eingabeparameter ist also eine List<int> mit den Werten [2, 4, 6, 8] und als Ausgabe soll der String in Form von 2, 4, 6, 8 zurückgegeben werden. Die folgende Code-Transformation setzt dies um: Komplexere Code-Transformation: Eine Code-Transformation besteht immer aus einer einzigen Methode. Dabei sind Ref- und Out-Parameter nicht zulässig. Graphische Transformation Graphische Transformationen eignen sich besonders dafür, aus einer Component einen Data Contract und umgekehrt zu transformieren. Beispiel: Es existieren die Components cdArtikel und cdHersteller. Der Artikel implementiert eine Relation zu einem Hersteller. Es soll auf Basis dieser Components ein Data Contract erstellt werden, der allerdings nicht alle Properties bei der Component beinhaltet. Dieser wird wie folgt erstellt: Nun existieren die beiden Components und der Data Contract. Die Components und der Data Contract haben im FS jedoch keinerlei Verknüpfung. Um diese Verknüpfung herzustellen, d.h. festzulegen, wie aus den beiden Components ein Data Contract erstellt werden soll, bedarf es einer graphischen Transformation. Diese sieht wie folgt aus: Name Definiert den Namen der Transformation. Auf der linken Seite wird der Datentyp des Eingabeparameters ausgewählt (im Beispiel cdArtikel). Über den Button Add Argument können zusätzliche Eingabeparameter in die Transformation eingebunden werden. Alle Relationen in der jeweiligen Component (hier die Relation auf cdHersteller) werden in der Baumstruktur angezeigt. Auf der rechten Seite wird der Typ des Ausgabeparameters definiert (in diesem Beispiel dcArtikel). Anschließend können auf der linken Seite Properties markiert und per Drag&Drop auf ein Property des Ausgabeparameters gezogen werden. Verknüpfte Properties werden gelb markiert. Wird ein gelbes Property mit der Maus angeklickt, wird sein verknüpftes Property auf der anderen Seite grün markiert. So kann schnell eingesehen werden, welches Property der linken mit welchem Property der rechten Seite verknüpft ist. Transformationen der Properties Es kann vorkommen, dass die Properties, die verbunden werden sollen, vom Typ her nicht zusammenpassen. Im Beispiel befindet sich in cdArtikel ein Property namens oEinObjekt vom Typ object. Dieses ist jedoch in dcArtikel mit dem Property SEinStringVomObjekt verknüpft, welches vom Typ string ist. In diesen Fällen können pro Property wiederum Transformationen definiert werden, mit denen die Properties selbst transformiert werden sollen. Im Beispiel wird cdArtikel.oEinObjekt mit Hilfe der trObject2String-Transformation nach dcArtikel.SEinStringVomObjekt transformiert. Dabei ist trObject2String äquivalent zur FSTransformation1 aus Beispiel 1 im Kapitel Code-Transformation: Transformation von Object nach String Ableiten und Customizen von Transformationen Transformationen können gecustomized werden. Ableitungen sind nur für Code-Transformationen zulässig. In Code-Transformationen können die Methoden normal überschrieben werden. In graphischen Transformationen können neue Property-Verbindungen hergestellt oder Property-Transformationen ausgetauscht werden. Das Hinzufügen neuer Argumente ist nicht zulässig. Generierung des Data Contracts und der Transformationen aus Components Um die Erstellung von graphischen Transformationen erheblich zu vereinfachen, kann FS aus Components heraus eigenständig Data Contracts und die zugehörigen Transformationen zwischen der Component und des Data Contracts generieren. Hierzu muss in einer Component im Menü Edit > Autogenerate Data Contract gewählt werden. Data Contract Wizard: In diesem Formular können die Properties selektiert werden, die der Data Contract beinhalten soll. Mit dem Häkchen Inverse transformation kann gewählt werden, ob auch eine Transformation vom Data Contract zurück zur Component erstellt werden soll. Mit Klick auf den Button OK werden im Namespace der Data Contract und die zugehörigen Transformationen erzeugt."
  },
  "doc/webservices/certificates.html": {
    "href": "doc/webservices/certificates.html",
    "title": "SSL Zertifikate",
    "keywords": "SSL Zertifikate Allgemein Einleitung Wenn ein Webservice veröffentlicht wird, sollte dieser mit einer SSL-Verschlüsselung, also einer HTTPS-Verbindung, gesichert werden. Insbesondere dann, wenn der Dienst über das Internet zugänglich ist, ist die Absicherung der kommunizierten Daten essenziell. SSL bietet dafür zwei äußerst wichtige Dinge: Die Kommunikation wird verschlüsselt und die Daten sind auf ihrem Weg zwischen Server und Client nicht durch fremde Instanzen einzusehen Durch ein vertrauenswürdiges Zertifikat wird die Identität des Servers sichergestellt. Das verhindert, dass sich jemand in die Kommunikationen einklinkt und sich als der angesprochene Server ausgibt (MITM-Attacke) Zertifikate von öffentlichen Anbietern Es ist empfehlenswert, für den Webserver ein vertrauenswürdiges Zertifikat über einen offiziellen Anbieter oder ein Hosting-Unternehmen zu erwerben. Diese Zertifikate gibt es in allen möglichen Ausführungen und Sicherheitsstufen. Bei diesem Prozess wird Ihre Firma verifiziert. Wenn außenstehende Clients mit Ihrem Webserver kommunizieren, können Sie sich sicher sein, dass alles in Ordnung ist, da die Daten des Zertifikats erstens öffentlich einsehbar sind und zweitens durch die Signierungsstelle verifiziert wurden. Wenn Sie ein Zertifikat erworben haben, muss dies auf dem Server installiert werden. Der Anbieter des Zertifikats stellt in der Regel passende Anleitungen zur Verfügung. Wichtig für die Einbindung des Zertifikats in einen Framework Studio Service Host ist dabei der Fingerabdruck. Dieser ist Bestandteil des Zertifikats und identifiziert dieses eindeutig auf dem System. Self-Signed Zertifikate SSL-Zertifikate sind nicht billig und es wäre unangebracht für den Entwicklungsprozess einer Firma potenziell mehrere SSL-Zertifikate zu kaufen, nur um sie intern in Testszenarien zu nutzen. Abhilfe schaffen dabei die sogenannten Self-Signed-Zertifikate. Diese sind exakt dasselbe wie gekaufte SSL-Zertifikate, nur dass sie nicht von einer öffentlichen Zertifizierungsstelle verifiziert wurden. Würde man einen öffentlichen Webserver mit einem Self-Signed-Zertifikat ausstatten, könnten Clients nicht mit dem Server kommunizieren, da diese das Zertifikat nicht anerkennen (mangels öffentlicher Verifizierung). Die nachfolgenden Abschnitte befassen sich daher mit dem Thema, wie Self-Signed-Zertifikate dennoch für den hausinternen Gebrauch verwendet und ggf. auch als Vorbereitung auf ein \"echtes\" SSL-Zertifikat genutzt werden können. FS-Webservice mit SSL-Unterstützung publishen Um einen Service Host auf die Nutzung eines SSL-Zertifikats vorzubereiten, wird dieses tatsächlich erst einmal gar nicht benötigt. Der Service Host selbst muss vom Zertifikat überhaupt nichts wissen. Ausschlaggebend für eine erfolgreiche SSL-Kommunikation ist das Registrieren des Zertifikats auf dem Port, unter dem der Service Host nach außen erreichbar ist. Siehe Registrieren von SSL-Zertifikaten Ganz ohne Änderungen an der Konfiguration des Service Hosts geht es aber dann doch nicht. Framework Studio macht dies jedoch extrem einfach. Um einen Service Host für die Kommunikation über einen SSL-Tunnel vorzubereiten, muss einfach die Checkbox SSL im Publish Wizard angehakt werden. Dies ändert nicht nur die Url des Service Hosts von HTTP auf HTTPS, sondern nimmt auch automatisch die nötigen Änderungen an der Konfiguration des Service Hosts vor, um eine sichere Kommunikation zu gewährleisten. Wenn ein bestehender Service Host von HTTP auf HTTPS gestellt werden soll, muss dieser mit der aktivierten Checkbox neu gepublished werden. Eine manuelle Änderung der Konfiguration des gepublishten Service Hosts ist zwar grundsätzlich möglich, wird aber auf Grund des vorhandenen Automatismus nicht empfohlen. Self-Signed-Zertifikat nutzen Erstellen mit Powershell Für das Erstellen eines Self-Signed-Zertifikats wird die Powershell benötigt. Diese muss mit Adminrechten gestartet werden, da das erstellte Zertifikat in den systemweiten Zertifikatspeicher geladen werden muss. Zwischen den einzelnen Schritten darf die Powershell nicht geschlossen werden, da Variablen angelegt werden, auf die später wieder zugegriffen wird. Ein neues Zertifikat wird mit folgendem Befehl erstellt: $cert = New-SelfSignedCertificate -Subject \"CN=[NAME]\" -DnsName \"[DOMAIN]\" -CertStoreLocation Cert:\\LocalMachine\\My -HashAlgorithm SHA1 -FriendlyName \"Framework Studio Development Certificate\" Beispiel: Die Platzhalter [NAME] und [DOMAIN] müssen dabei entsprechend durch die gewünschten Werte ersetzt werden. Platzhalter Beschreibung Beispiele [NAME] Der im Zertifikatspeicher angezeigte Name des Zertifikats. Es können auch Namen mit Leerzeichen verwendet werden. Server123, Server 123 Dev, WebServer SSL Development [DOMAIN] Muss exakt diejenige Domain sein, unter welcher der Service von außen erreichbar ist. Es können auch Domain-Wildcards verwendet werden. Wenn der Service Host z.B. unter https://Server123.de:1234/TestServiceHost/ erreichbar ist, muss als Domain Server123.de angegeben werden. Wenn der Befehl ausgeführt wird, passieren mehrere Dinge: Ein neues Self-Signed-Zertifikat mit Public- und Private-Key wird erstellt Es wird in die Variable $cert gespeichert Es wird in den persönlichen Bereich des systemweiten Zertifikatspeichers geladen Um das Zertifikat später auf einem Port registrieren zu können, wird dessen Fingerabdruck benötigt. Durch folgenden Befehl werden die Informationen des neuen Zertifikats ausgegeben: $cert Beispiel: Der Fingerabdruck ist ein 40 Zeichen langer Hex-String (rot markiert). Dieser wird später noch benötigt. Exportieren des Client-Zertifikats für andere Rechner (Optional) Dieser Schritt wird nur benötigt, wenn der Service Host von einem anderen Rechner aus angesprochen werden soll. Wird der Service Host z.B. nur lokal auf einem Entwicklungsrechner benutzt, dann ist das im letzten Abschnitt neu erstellte Server-Zertifikat ausreichend. Export-Certificate -Cert $cert -FilePath \"NV324.cer\" Beispiel: Dieser Befehl exportiert das neue Zertifikat als Datei im angegebenen Ordner. Wird wie im Beispiel nur der Dateiname angegeben, wird das Zertifikat im aktuell von der Powershell genutzten Ordner abgelegt. Beim Export wird ausschließlich der Public-Key des Zertifikats gespeichert. Greift ein Rechner auf den Service Host zu, kann der Public-Key mit dem Private-Key des Server-Zertifikats validiert werden. Das Importieren des Client-Zertifikats wird hier beschrieben. Verschieben des Zertifikats in den korrekten Zertifikatspeicher Nach dem Erstellen des Server-Zertifikats befindet sich dieses im persönlichen Bereich des systemweiten Zertifikatspeichers. Da es sich aber um ein Self-Signed-Zertifikat handelt, kann der Rechner einem solchen Zertifikat noch nicht vertrauen. Um dies zu ändern, muss das Zertifikat in den Bereich der vertrauenswürdigen Stammzertifikate verschoben werden. Dazu muss in der Powershell der Befehl mmc eingegeben werden. Es öffnet sich die Windows Management Console ebenfalls mit Adminrechten. Im Menü File den Eintrag Add/Remove Snap-In... auswählen. Danach den Eintrag Certificates auswählen und den Button Add drücken. Computer account auswählen. Local computer auswählen. Das im vorherigen Abschnitt erstellte Server-Zertifikat befindet sich unter Certificates (Local Computer) -> Personal -> Certificates. Dieses muss nun in den Bereich Trusted Root Certification Authorities -> Certificates verschoben werden. Damit ist das Self-Signed-Zertifikat nun systemweit als vertrauenswürdig eingestuft und kann vom Service Host verwendet werden. Registrieren von SSL-Zertifikaten Um das Zertifikat nun nutzen zu können, muss es auf dem Port registriert werden, auf dem der Service Host zu erreichen ist. Im obigen Abschnitt ist im Publish Wizard der Port 1234 angegeben. Mit folgendem Befehl kann das Zertifikat nun auf dem gewünschten Port registriert werden: netsh http add sslcert ipport=0.0.0.0:[PORT] certhash=[THUMBPRINT] certstorename=root Beispiel: Platzhalter Beschreibung Beispiele [PORT] Der Port unter dem der Service Host erreichbar ist. 1234, 5000, 8888 [THUMBPRINT] Der Fingerabdruck des Zertifikats, welcher im Erstellprozess in der Powershell ausgegeben wurde. BAF167BA54F5B508F0B50B2A646D1551BFD3A5C5 Anschließend ist der Service Host unter seiner im Publish Wizard angegebenen HTTPS-Url im Browser ansprechbar und dem Self-Signed-Zertifikat wird vertraut. Deregistrieren von SLL-Zertifikaten Wird ein Service Host nicht mehr genutzt oder soll ein anderes Zertifikat auf einem Port registriert werden, muss zuvor das alte Zertifikat vom Port deregistriert werden. Dies kann mit folgendem Befehl durchgeführt werden: netsh http delete sslcert ipport=0.0.0.0:[PORT] Platzhalter Beschreibung Beispiele [PORT] Der Port unter dem der Service Host erreichbar ist. 1234, 5000, 8888 Importieren des Zertifikats auf einem Client (Optional) Wenn der Service Host von einem anderen Rechner aus angesprochen werden soll, muss das im Abschnitt Exportieren des Client-Zertifikats für andere Rechner (Optional) exportierte Client-Zertifikat in den Zertifikatspeicher des Client-Rechners importiert werden. Auch hier muss wie beim Server auch darauf geachtet werden, dass das Zertifikat in den Bereich Trusted Root Certification Authorities -> Certificates importiert wird. Danach kann der Service Host über HTTPS angesprochen werden."
  },
  "doc/webservices/data-contract.html": {
    "href": "doc/webservices/data-contract.html",
    "title": "Data Contract",
    "keywords": "Data Contract Es kann sein, dass Webservices komplexere Datenstrukturen empfangen oder versenden müssen als die normalen Datentypen wie Integer, String, Boolean usw. Beispiel: Ein Webservice erhält eine ID eines Herstellers in Form eines Integer. Er sucht dann in einer Datenbank nach allen PC’s, die von diesem Hersteller am Lager sind. Der Webservice wird also als Rückgabewert eine Liste von PC’s generieren. Intern im Webservice kann mit Klassen des PC’s oder auch des Herstellers operiert werden. Der Client, der den Webservice aufruft, kennt diese Klassendefinitionen jedoch nicht. Es wird also eine Datenbasis benötigt, die sowohl der Client als auch der Server kennt. Diese muss sich somit in die WSDL-Definition des Webservices integrieren und vom Client abrufbar sein. Name Definiert den Namen des Data Contracts. Type Wie Service Contracts können auch Data Contracts generiert werden. Dies geschieht bei Data Contracts mit Hilfe des ServiceProxies (siehe Generieren eines Data Contracts aus einem Service Proxy). Dieser liest die WSDL-Definition des Webservice aus. In dieser sind alle Data Contracts als XSD-Definition hinterlegt. Sind in einem Webservice mehrere Data Contracts definiert, wird der Service Proxy auch mehrere Data Contract-Elemente erstellen. Somit existieren Data Contracts des Typs Userdefined Contract und External Contract, wenn dieser über einen Service Proxy generiert wurde. Registerkarte General Contract Type Hier kann definiert werden, von welchem Typ der Data Contract sein soll. Wird als Typ ein Collection-Type ausgewählt, muss der Datentyp der Collection-Elemente in der Combobox Element datatype definiert werden. Dies kann z.B. ein weiterer Data Contract sein. Interfaces Hier können per Komma getrennt Interfaces angegeben werden, die die Data Contract-Klasse implementieren soll. Binden eines externen Data Contracts Es besteht die Möglichkeit, in externen Assemblies untergebrachte WCF Data Contracts direkt in Framework Studio einzubinden. Hierzu kann über den Button Bind Contract eine .NET-Dll importiert werden. Importieren eines Data Contracts aus einer Assembly: Mit dem Button Add Assembly kann nach einer gewünschten Assembly auf dem System gesucht werden. Nach dem Import wird die Assembly automatisch nach Klassen mit dem Attribut [Data Contract] durchsucht und diese in der Combobox Choose Contract angezeigt. Die importierte Assembly wird als Ressource in Framework Studio eingebunden und bei einem Anwendungsstart oder Publish in das /bin-Verzeichnis des Brokers herausgeschrieben. Registerkarte Properties Hier werden die Properties des Data Contracts definiert. Mit Rechtsklick auf die Liste > New > Property wird ein neues Property angelegt. Name Definiert den Namen des Properties. Der erste Buchstabe des Namens wird immer in einen Großbuchstaben umgewandelt. Datatype Definiert den Datentyp des Properties. (Siehe Datentyp bearbeiten). Property Type Definiert die Art des Properties (siehe Membervariablen). Attributes Das Häkchen [DataMember] definiert, dass das Property des Data Contracts Bestandteil der XSD-Definition sein wird, welche in die WSDL-Definition eingebunden wird. Es müssen also nicht zwingend alle Properties des Data Contracts über den Webservice abrufbar gemacht werden. In der Textbox können zusätzliche Attribute zum Property definiert werden. Muss z.B. auf jeden Fall ein Wert in einem Property an den Webservice übergeben werden, kann dieses Property mit [DataMember(IsRequired=true)] erweitert werden. Ableiten und Customizen von Data Contracts Data Contracts können gecustomized werden. Dabei können neue Properties hinzugefügt werden oder Get-/Set-Methoden von Individual Properties überschrieben werden. Ableitungen von Data Contracts sind nicht möglich. Service Contract automatisch generieren In WCF ist für jeden Webservice zwingend ein Service Contract nötig. Der Service Contract wird dem Konsumenten über die WSDL zur Verfügung gestellt. Zur Vereinfachung der Implementierung eines Services in Framework Studio bietet dieses an, den Service Contract aus den Informationen des Servives automatisch zu generieren. Es wird also kein Service Contract-Element benötigt, um den Service zu betreiben. Um die automatische Generierung des Service Contracts am Service zu aktivieren, muss die Combobox Implement auf Yes gestellt werden (siehe Registerkarte Contracts). Dies ist gleichzeitig der Standardwert für neu erstellte Service-Elemente. Auch wenn an einem Service der letzte zugeordnete Service Contract gelöscht wird, wird die automatische Generierung des Contracts aktiviert. Um aus einem Service den Contract automatisch zu generieren, wird der Service von Framework Studio nach allen Methoden mit Access Level public durchsucht. Öffentliche Methoden am Service: Der Name des automatisch generierten Contracts wird wie folgt abgeleitet: I + [Servicename] + Contract Für den Service AtricleInfoService aus dem Beispiel heißt der zugehörige, automatisch generierte Contract somit IArticleInfoService Contract. In der folgenden Abbildung wird verdeutlicht, wie der Code für den autogenerierten Contract erzeugt wird. Automatisch generierter Service Contract in der Use-Schicht: Es ist zu erkennen, dass die beiden öffentlichen Methoden aus dem Service in das Contract-Interface aufgenommen wurden und dass der Service den automatisch generierten Contract implementiert. Zusätzlich hat die Methode GetArticleByID(string id) ein FaultContract-Attribut erhalten, da an der Service-Methode der Data Contract „dcArticleError“ entsprechend als Fault Contract hinterlegt wurde (siehe Registerkarte Methods)."
  },
  "doc/webservices/fault-contracts.html": {
    "href": "doc/webservices/fault-contracts.html",
    "title": "Fault Contracts",
    "keywords": "Fault Contracts Wird eine Webservicemethode von einem Client (z.B. ein C#-Programm) aufgerufen, kann es auf dem Server zu Exceptions kommen. Im Normalfall können auf Client-Seite diese Exceptions abgefangen und ausgewertet werden. Es stehen aber nur limitierte Informationen bereit (Message/StackTrace). Im folgenden Beispiel wird an einem Webservice, der mit Framework Studio erstellt wurde, die Methode string GetArticleByID(string id) aufgerufen. Wird während der Abarbeitung der Methode auf dem Server eine Exception geworfen, kann diese auf Clientseite mittels try/catch abgefangen und behandelt werden. Es gibt jedoch auch den Anwendungsfall, dass die Servicemethode ganz bewusst ein Scheitern der Abarbeitung an den Client zurückgeben soll und dies mit möglichst ausführlichen Daten, wieso es zu dem Fehler gekommen ist. Eine normale Exception mit Message und StackTrace ist dann nicht mehr ausreichend. Beispiel: Die Servicemethode string „GetArticleByID(string id)“ gibt normalerweise den Namen des Artikels zurück, welcher für die angegebene ID in der Datenbank gefunden wurde. Wenn die ID allerdings nicht gefunden wurde, soll nicht nur ein Leerstring oder Null an den Client zurückgegeben werden, sondern ein definierter Statuscode und zusätzlich eine adequate Fehlermeldung. Da dies schon zwei Properties sind, die an den Client übertragen werden müssen, wird ein Objekt benötigt, welches alle gewünschten Informationen enthält – der Fault Contract. Fault Contract = Data Contract In der Praxis ist ein Fault Contract ein Data Contract, d.h. ein komplexes Objekt mit Properties, die wiederum vom Typ eines Data Contracts sein können. Um das obige Beispiel in die Tat umsetzen zu können, wird also ein Data Contract benötigt, der einen Statuscode und die dazugehörige Fehlermeldung aufnehmen kann. Hierzu wird in Framework Studio ein neuer Data Contract erstellt, der folgendermaßen aussieht: Fault Contracts zuweisen Die Verbindung zwischen Service-Methode und Fault Contract kommt im Service Contract zustande. Dieses Interface legt fest, welche Methoden vom Service implementiert werden müssen und zusätzlich, welche Fault Contracts von welcher Methode genutzt werden dürfen. Der für das Beispiel nötige Service Contract sieht folgendermaßen aus: Es soll also später vom Service die Methode string GetArticleByID(string id) implementiert werden. Zusätzlich wurde für diese Methode in der Liste der Fault Contracts der zuvor angelegte Data Contract dcArticleFault als Fault Contract hinterlegt. Das bedeutet, die Methode GetArticleByID kann im Fehlerfall ein Objekt vom Typ „dcArticleFault“ instantiieren und dieses an den aufrufenden Client zurückgeben. Um die Funktionsweise noch weiter zu verdeutlichen, folgt nun ein kleiner Ausschnitt aus dem generierten Code von Framework Studio. Zu sehen ist der Code des Service Contracts ArticleService Contract: Zu sehen ist, dass über der Methode string GetArticleByID(string id) ein Attribut [Fault Contract(typeof(dcArticleFault))] hinzugefügt wurde. Dies bedeutet, dass ein Service, der diesen Service Contract implementiert, in der Methode GetArticleByID den Data Contract dcArticleFault als Fault Contract verwenden kann. Dabei können einer Methode beliebig viele Fault Contracts zugewiesen werden. Zurückgeben eines Fault Contracts Als erstes muss nun ein neuer Service in Framework Studio angelegt werden, der den Service Contract „ArticleService Contract“ implementiert: Zu beachten ist, dass die Option Autogenerate Contract auf No gestellt ist, da wir uns ja selbst um einen Service Contract gekümmert haben. Der Service ist nun erstellt und der Contract korrekt zugewiesen. Nun muss die Methode string GetArticleByID(string id) am Service ArticleService ausprogrammiert werden. Im Beispiel wurde die übliche Businesslogik außer Acht gelassen. Wir gehen einfach davon aus, dass für die übergebene ID kein zugehöriger Artikel in der Datenbank gefunden wurde. Diese Information soll dem Client nun adequat mitgeteilt werden. Es kann nun, nachdem der Artikel nicht in der Datenbank gefunden wurde, eine neue Instanz des Data-/Fault Contracts dcArticleFault erstellt werden. Dieser kann mit den gewünschten Werten gefüllt werden, die zum Client übertragen werden sollen. In unserem Fall ist es der Statuscode 1 als Integer und die Information, dass der Artikel nicht gefunden wurde in Form eines Strings. Alles was nun noch getan werden muss, ist das Werfen einer FaultException vom Typ des Fault Contracts. In unserem Fall also FaultException<dcArticleFault>. Dieser generischen FaultException wird die gerade eben erstellte Faultinstanz übergeben. Um den Service ansprechen zu können, bedarf es nur noch einem Service Host, der für den Service einen entsprechenden Endpoint bereitstellt. Abfangen einer FaultException am Client Das folgende Beispiel des Clients wurde in Visual Studio 2012 entwickelt. Hierzu wurde der Service Host in Framework Studio gestartet und in Visual Studio eine neue Service Referenz angelegt. Das zuvor angesprochene Attribut [Fault Contract(typeof(dcArticleFault))] über der Methode im Service Contract sorgt dafür, dass die Beschreibung des Typs dcArticleFault in das WSDL des Webservices generiert wird. Dies hat zur Folge, dass jegliche Clients, die mit dem Service arbeiten, von diesem Typ wissen und ihn somit ohne Weiteres in ihrem eigenen Code verwenden können. Es folgt der neue Clientcode: Der Client weiß also mit Hilfe des WSDL, dass die Servicemethode string GetArticleByID(string id) potenziell eine Exception vom Typ FaultException<dcArticleFault> werfen kann. Es kann immer noch eine unhandled Exception auftreten. Der Code wird also um einen neuen Catch-Block erweitert, der nur auf die FaultException hört. Würden der Servicemethode mehrere Fault Contracts zugewiesen, könnten die unterschiedlichen FaultExceptions in weiteren Catch-Blöcken abgefangen werden. Die generische FaultException<T> bietet den jeweiligen Fault Contract über das Property Detail schon korrekt typisiert an. Es muss nichts gecastet werdeb. Danach kann auf die zur Verfügung stehenden Properties des Fault Contracts zugegriffen und vom Client verarbeitet werden."
  },
  "doc/webservices/rest-endpoint.html": {
    "href": "doc/webservices/rest-endpoint.html",
    "title": "REST Endpoint für Service-Methoden",
    "keywords": "REST Endpoint für Service-Methoden Standardmäßig bietet ein Service Host den ausgewählten Service bzw. dessen Service Contract nach außen hin über WCF und damit das SOAP-Protokoll an. Moderne Applikationen und allen voran Webapplikationen in Borwsern oder auf mobilen Endgeräten unterstützen mittlerweile jedoch oft kein SOAP mehr und bevorzugen deshalb die Kommunikation über JSON. Framework Studio bietet die Möglichkeit, den Service Host so zu konfigurieren, dass vollständig automatisch ein zusätzlicher Endpoint generiert wird, mit dem die im Service Contract propagierten Methoden auch über JSON und damit über einen normalen HTTP-Request angesprochen werden können. Um die vollständige Automatisierung dieser Funktionalität gewährleisten zu können, bedarf es einiger Regeln, die beachtet werden müssen. Diese betreffen vor allem die Kommunikation zwischen dem Client und dem generierten REST Endpoint des Service Hosts. Aktivieren des REST-Endpoints Der Service Host generiert den REST Endpoint, wenn die Checkbox Generate REST Endpoint aktiviert wird. In der Konfigurationsdatei des Servic Hosts wird dadurch ein neuer Endpoint mit dem ausgewählten Contract registriert: <endpoint name=\"rest\" address=\"api\" binding=\"webHttpBinding\" contract=\"App.IHelloServiceContract\" /> Warning Der REST Endpoint basiert auf der in WCF integrierten webHttpBinding. In einem WCF-Service darf für einen Service Contract nur ein Binding eines bestimmten Typs registriert werden. Sollte am Service Host schon ein Endpoint mit einem webHttpBinding für den ausgewählten Contract existieren, so kann das automatische Generieren des REST Endpoints nicht verwendet werden bzw. wird beim Start des Service Host zu Fehlern führen. Tip Der REST-Endpoint kann alternativ auch individuell definiert werden, wenn die Standard-Konfiguration den Anforderungen nicht genügt. Der Endpoint hat fest den Namen api und wird immer auf der im Service Host angegebenen Base Address registiert. Ist die Base Address z.B. http://localhost:1234/HelloServiceHost dann wird der REST Endpoint unter http://localhost:1234/HelloServiceHost/api zu finden sein. Im Development Service ist der neue Endpoint auch in der Auflistung im System Tray zu sehen: Aufrufen von Service-Methoden am REST Endpoint Das Aufrufen einer durch den REST Endpoint bereitgestellten Service Methode erfolgt über einen normalen HTTP-Request. Dabei gibt es einige Regeln, die beachtet werden müssen. Nachfolgend werden alle Spezialitäten der Kommunikation detailliert beschrieben und mit mehreren Beispielen transparent dargestellt. In den Beispielen wird ein Service namens \"HelloService\" verwendet. Dieser besteht aus 4 Methoden, die den Benutzer auf unterschiedliche Weise grüßen. Separate Urls für Service-Methoden Um die Methoden am REST Endpoint voneinander unterscheiden zu können, besitzt jede Methode eine eigene Url. Ist der REST Endpoint beispielsweise unter http://localhost:1234/HelloServiceHost/api registriert, so werden die einzelnen Methoden wie folgt angesprochen: Methodenname Url SayHello http://localhost:1234/HelloServiceHost/api/sayhello SayHelloComplex http://localhost:1234/HelloServiceHost/api/sayhellocomplex SayHelloFault http://localhost:1234/HelloServiceHost/api/sayhellofault SayHelloName http://localhost:1234/HelloServiceHost/api/sayhelloname Der Methodenname wird also als Url-Erweiterung am REST Endpoint genutzt. Auf Groß- und Kleinschreibung muss an dieser Stelle nicht geachtet werden. Um testweise HTTP-Requests auf den Service Host absetzen zu können, wird in den nachfolgenden Beispielen die App Postman genutzt. Sie ist kostenlos unter https://www.postman.com erhältlich. Beispiel 1: Parameterlose Methoden public virtual string SayHello() { return \"Hello!\"; } Am REST Endpoint ist diese Methode unter http://localhost:1234/HelloServiceHost/api/sayhello aufrufbar. Parameterlose Methoden können ausschließlich mit HTTP GET aufgerufen werden. Die Header Content-Type und Content-Encoding müssen nicht zwingend gesetzt sein, da bei parameterlosen Methoden im Request kein HTTP-Content übertragen wird. Der Header Accept muss auf application/json gesetzt sein oder diesen MIME-Type beinhalten (wird im Beispiel durch */* abgedeckt), ansonsten führt der Response am Client zu einem Fehler. Der Response hat ausschließlich den Content-Type application/json und das Content-Encoding utf-8. Somit kann der Response ohne Umwege z.B. vom im JavaScript integrierten JSON-Parser eingelesen werden. Beispiel 2: Methoden mit Parametern (einfache Datentypen) public virtual string SayHelloName(string name) { return \"Hello \" + name + \"!\"; } Am REST Endpoint ist diese Methode unter http://localhost:1234/HelloServiceHost/api/sayhelloname aufrufbar. Methoden mit Parametern müssen zwinged mit HTTP POST aufgerufen werden. Der Header Content-Type muss zwingend auf application/json gesetzt sein, da der Service Host eine JSON-Kommunikation erwartet. Um Encoding-Fehlern vorzubeugen, wird empfohlen, den Header Content-Encoding entsprechend des übertragenen Contents zu setzen (vorzugsweise utf-8). Der Header Accept muss auf application/json gesetzt sein oder diesen MIME-Type beinhalten (wird im Beispiel durch */* abgedeckt), ansonsten führt der Response am Client zu einem Fehler. Methodenparameter müssen im HTTP-Content in einem JSON-Objekt übertragen werden. Url-Parameter werden nicht unterstützt. Jeder Methodenparameter wird als JSON-Property mit dem exakten Namen (Groß- und Kleinschreibung beatchen) übergeben. Im Beispiel wäre das der Parameter string name. Der Parameter wird im JSON wie folgt übertragen: { \"name\": \"Max Mustermann\" } Der Response hat ausschließlich den Content-Type application/json und das Content-Encoding utf-8. Somit kann der Response ohne Umwege z.B. vom im JavaScript integrierten JSON-Parser eingelesen werden. Hat eine Methode mehrere Parameter, so werden diese im JSON-Objekt ebenfalls als Properties hinzugefügt. Die Reihenfolge ist dabei nicht relevant. public virtual string SayHelloMultiple(string name, int age, string city) Diese Methode würde folgendes JSON-Objekt wie gewünscht verarbeiten, obwohl die Parameter vertauscht sind: { \"name\": \"Max Mustermann\", \"city\": \"Stockach\", \"age\": 36 } Beispiel 3: Methoden mit Parametern (komplexe Datentypen) public virtual dcHelloResult SayHelloComplex(dcHelloInput input) { dcHelloResult result = new dcHelloResult() { sGreeting = \"Welcome!\", sFirstName = input.sFirstName, sLastName = input.sLastName }; return result; } Für einen Methodenaufruf mit komplexen Datentypen wie z.B. DataContracts oder Arrays gelten dieselben Regeln wie für einen Methodenaufruf mit einfachen Datentypen. Der einzige Unterschied ist, dass der jeweilige Parameter als JSON-Objekt übertragen wird. Im Beispiel hat die Methode einen Parameter vom Typ dcHelloInput mit zwei Properties. Dieser DataContract sieht im Framework Studio folgendermaßen aus: Als Rückgabetyp dient der DataContract dcHelloResult mit drei Properties, welcher so definiert ist: Der Aufruf der Service-Methode gestaltet sich intuitiv wie folgt: Hat eine Methode mehrere komplexe Parameter, so gilt dieselbe Nomenklatur wie in Beispiel 2. public virtual string SayHelloComplexMultiple( dcHelloInput input, dcHelloInput inputOther, string greeting) { return $\"{greeting} {input.sFirstName} {input.sLastName}! \" + $\"{greeting} {inputOther.sFirstName} {inputOther.sLastName}!\"; } Diese Methode würde folgendes JSON-Objekt wie gewünscht verarbeiten: { \"input\": { \"sFirstName\": \"Max\", \"sLastName\": \"Mustermann\" }, \"inputOther\": { \"sFirstName\": \"Peter\", \"sLastName\": \"Pan\" }, \"greeting\": \"Hi\" } Beispiel 4: Exceptions und FaultContracts public virtual void SayHelloFault() { dcFault fault = new dcFault() { sProp1 = \"Fault Property 1\", sProp2 = \"Fault Property 2\" }; throw new FaultException<dcFault>(fault, \"OH NO!\", new FaultCode(\"Custom Fault Code\"), \"Custom Fault Action\"); } Tritt währende der Verarbeitung im Service eine Exception auf oder wird aus der Logik heraus eine FaultException geworfen, so werden auch diese im JSON an den Client übertragen. Die FaulException aus obigem Code stellt sich im JSON folgendermaßen dar: { \"Action\": \"Custom Fault Action\", \"Code\": { \"IsPredefinedFault\": true, \"IsSenderFault\": false, \"IsReceiverFault\": false, \"Namespace\": \"\", \"Name\": \"Custom Fault Code\", \"SubCode\": null }, \"Reason\": { \"Translations\": [ { \"XmlLang\": \"en-US\", \"Text\": \"OH NO!\" } ] }, \"Detail\": { \"sProp2\": \"Fault Property 2\", \"sProp1\": \"Fault Property 1\" }, \"Exception\": { \"ClassName\": \"System.ServiceModel.FaultException`1[App.dcFault]\", \"Message\": \"OH NO!\", \"Data\": {}, \"InnerException\": null, \"HelpURL\": null, \"StackTraceString\": \" at App.REST_HelloService.SayHelloFault()\\r\\n at SyncInvokeSayHelloFault(Object , Object[] , Object[] )\\r\\n at System.ServiceModel.Dispatcher.SyncMethodInvoker.Invoke(Object instance, Object[] inputs, Object[]& outputs)\\r\\n at System.ServiceModel.Dispatcher.DispatchOperationRuntime.InvokeBegin(MessageRpc& rpc)\\r\\n at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage5(MessageRpc& rpc)\\r\\n at System.ServiceModel.Dispatcher.MessageRpc.Process(Boolean isOperationContextSet)\", \"RemoteStackTraceString\": null, \"RemoteStackIndex\": 0, \"ExceptionMethod\": \"8\\nSayHelloFault\\nApp_Svc, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\\nApp.REST_HelloService\\nVoid SayHelloFault()\", \"HResult\": -2146233087, \"Source\": \"App_Svc\", \"WatsonBuckets\": null, \"code\": [ {} ], \"reason\": [ {} ], \"messageFault\": null, \"action\": \"Custom Fault Action\", \"detail\": { \"sProp2\": \"Fault Property 2\", \"sProp1\": \"Fault Property 1\" } }, \"Message\": \"OH NO!\", \"StackTrace\": \" at App.REST_HelloService.SayHelloFault()\\r\\n at SyncInvokeSayHelloFault(Object , Object[] , Object[] )\\r\\n at System.ServiceModel.Dispatcher.SyncMethodInvoker.Invoke(Object instance, Object[] inputs, Object[]& outputs)\\r\\n at System.ServiceModel.Dispatcher.DispatchOperationRuntime.InvokeBegin(MessageRpc& rpc)\\r\\n at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage5(MessageRpc& rpc)\\r\\n at System.ServiceModel.Dispatcher.MessageRpc.Process(Boolean isOperationContextSet)\" } Folgende Properties stehen zur Verfügung, um am Client ggf. eine adequate Fehlermeldung anzeigen zu können: Property Typ Beschreibung Action String Beinhaltet die angegebene FaulAction Code Object Beinhaltet den angegebenen FaulCode inkl. aller SubCodes Reason Object Beinhaltet den angegebenen FaulReason, ggf. mit allen übergebenen Übersetzungen Detail User Defined Beinhaltet das Objekt, welches vom Entwickler als Fault in die FaultException gegeben wurde. Im Beispiel die Variable fault vom Typ dcFault Exception Object Beinhaltet die in Gänze serialisierte Exception mit allen Properties Message String Beinhaltet das Message-Property der Exception StackTrace String Beinhaltet das StackTraceString-Property der Exception JSON Format JSON kann verschiedene Datentypen in unterschiedlichsten Formaten übertragen. Für eine Datums- und Zeitangabe gibt es im JSON z.B. keinerlei Spezifikation, wie diese Information dargestellt werden soll. Da es im JSON keinen dedizierten DateTime-Typ gibt, wird ein Datum meist als String repräsentiert. Wie genau dieser String letztenendes aussieht, hängt vom JSON-Serializer ab. Der in WCF integrierte DataContractJsonSerializer von Microsoft überträgt den .NET-Typ DateTime z.B. so: { \"datetime\": \"/Date(1335205592410-0500)/\" } JavaScript serialisiert ein Datum aber so: { \"datetime\": \"2012-04-23T18:25:43.511Z\" } Der Effekt ist, dass sich ggf. Server und Client nicht verstehen und letztenendes auf Fehler laufen, da sie einen unterschiedlichen \"JSON-Dialekt\" sprechen. Aus diesem Grund arbeitet der REST Endpoint in einem Framework Studio Service Host mit dem bekannten JSON.NET Serializer, der weltweit in millionen von Anwendungen zum Einsatz kommt. Das von diesem Serializer ausgegebene JSON ist kompatibel mit JavaScript und versteht im Umkehrschluss auch die meisten Dialekte, ohne dass der Entwickler selbst in den Serialisierungsprozess eingreifen muss. ref- und out-Parameter WCF unterstützt generell ref- und out-Parameter in Service Methoden. Dies mündet in der SOAP-Kommunikation letztenendes in mehreren Rückabewerten einer Methode. Der REST Endpoint unterstützt ref- und out-Parameter NICHT. Wenn mehr als ein Rückgabeparameter in einer Service-Methode nötig sind, wird empfohlen, einen DataContract für diesen Zweck zu erstellen und diesen als Rückgabetypen für die Methode zu verwenden (siehe Beispiel 3). Individueller Rest-Endpoint Mit der Checkbox Generate REST Endpoint wird ein Endpoint mit Standard-Einstellungen definiert. Werden bei den Operationen große Datenmengen transportiert oder dauern die Operationen ungewöhnlich lange, dann kann es zu entsprechenden Fehlermeldungen oder Timeouts kommen. Es kann manuell ein REST-Endpoint mit individuellen Binding-Einstellungen definiert werden: Die Checkbox Generate REST Endpoint darf nicht mehr gesetzt sein. Es muss ein neuer EndPoint angelegt werden. Bei diesem muss als Name rest gesetzt sein. Dieser Name wird, wie beim automatischen REST-Endpoint, erkannt und so entsprechend für die JSON-Kommunikation konfiguriert. Wenn gewünscht, kann die Address angepasst werden. Die automatisch generierte Adresse bekommt am Ende den Namen des EndPoints - (.../rest). Damit das Verhalten identisch zum automatischen REST-Endpoint ist (.../api), muss die Address mit dem folgenden Wert überschrieben werden: http://%SERVER%:%PORT%/%HOSTNAME%/api Bei Binding muss webHttpBinding ausgewählt werden. Es kann eine eigene Binding Configuration angegeben werden. Diese muss zuvor im Register EndPoint Bindings erstellt werden (siehe unten). Behavior darf nicht angegeben werden, darum kümmert sich der Automatismus. Die Binding Configurationen kann folgendermaßen definiert werden: Ein neues EndPoint Binding anlegen und den Namen vergeben (z.B. RestEndPointBinding) Bei Binding Type muss webHttpBinding definiert werden. In den Registerkarten Default Properties und Reader Quotas Properties können die Größen entsprechend angepasst werden. Bei Bedarf können auch die verschiedenen Timeout-Zeiten erhöht werden. Warning Im folgenden Screenshot wurde überall der maximale Wert 2147483647 angegeben - das sind 2 GB. Das ist bequem und man hat keine Sorge mehr, dass Nachrichten die Konfiguration sprengen. Das bedeutet aber, dass der Service praktisch keinen Schutz mehr vor zu großen Nachrichten hat. Ein Angreifer könnte diesen Umstand nutzen und dem Service schaden. Dasselbe gilt auch bei sehr großzügigen Timeout-Zeiten."
  },
  "doc/webservices/service-contract.html": {
    "href": "doc/webservices/service-contract.html",
    "title": "Service Contract",
    "keywords": "Service Contract Der Service Contract stellt eine funktionelle Beschreibung des zu implementierenden Webservices in Form eines Interfaces dar. Der Contract enthält die Deklarationen der Methoden, die der Webservice implementieren soll. Name Name des Service Contracts, standardmäßig beginnend mit einem großen I (Interface). Auch im IntelliSense ist der Service Contract unter diesem Namen zu finden. Type Es gibt zwei Arten von Service Contracts: Userdefined Contract Ein vom Programmierer erstellter Service Contract. Dieser Service Contract enthält ausschließlich diejenigen Methoden, die auf der Registerkarte Operations angelegt wurden. External Contract Wenn ein Service Contract aus einer externen Assembly implementiert wird, der an den Framework Studio Service Contract gebunden wird, ist dieser als External Contract gekennzeichnet. Registerkarte General Service Contract Attributes In dieser Textbox können zusätzliche Attribute für den WCF Service Contract definiert werden. Das Attribut [Service Contract] wird automatisch hinzugefügt und muss nicht manuell angegeben werden. Binden eines externen Service Contracts Es besteht die Möglichkeit, in externen Assemblies untergebrachte WCF Service Contracts direkt in Framework Studio einzubinden. Hierzu kann über den Button Bind Contract eine .NET-Dll importiert werden. Importieren eines Service Contracts aus einer Assembly: Mit dem Button Add Assembly kann nach einer gewünschten Assembly auf dem System gesucht werden. Nach dem Import wird die Assembly automatisch nach Interfaces mit dem Attribut [Service Contract] durchsucht und diese in der Combobox Choose Contract angezeigt. Die importierte Assembly wird als Ressource in Framework Studio eingebunden und bei einem Anwendungsstart oder Publish in das /bin-Verzeichnis des Brokers herausgeschrieben. Die Verbindung zum WCF Service Contract kann über einen Klick auf den Button Unbind Contract wieder gelöscht warden. Dann fungiert der Service Contract wieder als Userdefined Contract und es können manuell Methoden deklariert werden. Im Textfeld External Contract Information werden alle verfügbaren Methoden des WCF Service Contracts aus der externen Assembly angezeigt. Solange ein externer WCF Service Contract gebunden ist, steht die Registerkarte Operations nicht zur Verfügung. Registerkarte Operations Hier werden die Methoden deklariert, welche der Webservice später implementieren soll. Mit Rechtsklick in das Grid -> New -> Operation wird eine neue Methode angelegt. Anschließend werden in der Textbox Declaration Rückgabewert, Methodenname und optional Übergabeparameter definiert. Der Access Level der Methode wird automatisch auf public gesetzt. In der Textbox Attributes können zusätzliche Attribute für die Operation definiert werden. Das Attribut [OperationContract] wird automatisch hinzugefügt und muss nicht manuell angegeben werden. In der Liste Fault Contracts können zur derzeit ausgewählten Operation Fault Contracts hinzugefügt werden, die später im Service als Type für eine FaultException<T> verwendet werden können. Mehr Information hierzu im Kapitel Fault Contracts. Generieren eines Services aus einem Service Contract Im Menüpunkt Edit befindet sich der Eintrag New service implementing this contract. Damit wird auf Basis des ausgewählten Service Contracts ein Service-Element (Service) im selben Namespace generiert, welches den Service Contract implementiert. Dies erspart dem Programmierer das Anlegen eines Service-Elements und das manuelle Einbinden des zugehörigen Service Contracts zum Service-Element. Customizen von Service Contracts Service Contracts können in Framework Studio nur gecustomized werden. Es besteht die Möglichkeit, den Service Contract um Methoden zu erweitern. Das Ableiten von Service Contracts ist nicht möglich. Methoden aus der Basis werden ausgegraut dargestellt. Werden in der Ableitung oder Customization Attribute am Service Contract oder an dessen Methoden definiert, werden diese als zusätzliche Attribute in den Code generiert. Attribute aus der Basis werden demnach NICHT überschrieben."
  },
  "doc/webservices/service-host.html": {
    "href": "doc/webservices/service-host.html",
    "title": "Service Host",
    "keywords": "Service Host Ein Service Host legt die Richtlinien fest, wie ein Service veröffentlicht wird. Dabei bezieht er sich immer auf einen Service und einen dem Service zugeordneten Service Contract. Service Host Properties Name Name des Service Host. Dies ist gleichzeitig der Name der Klasse im IntelliSense. Service Über den Button Select Service wird der Service ausgewählt, den der Service Host nach außen hin anbieten soll. Service Contract Wenn am zugeordneten Service die Option Autogenerate Contract aktiviert ist, besteht hier am Service Host die Möglichkeit den vom Service generierten Service Contract zu verwenden, indem die Checkbox Use Autogenerated aktiviert wird. Soll ein benutzerdefinierter Service Contract des Services genutzt werden, kann dieser mittels der Combobox ausgewählt werden. Wenn in einer Customization eines Service Hosts zeitweise ein anderer Service Contract ausgewählt war, kann mit dem Button Inherit Contract wieder die Einstellung des Basis-Service Hosts übernommen werden. Host Type Hier wird ausgewählt, wie der Service Host den Service anbietet. Derzeit ist nur die Veröffentlichung als Windows Service möglich. Generate REST Endpoint Diese Option bestimmt, ob am Service Host automatisch ein zusätzlkicher Endpoint generiert wird, welcher alle Service-Methoden als JSON-API nach außen hin anbietet. Eine detaillierte Beschreibung dieser Funktionalität befindet sich im Kapitel REST Endpoint für Service-Methoden. Use WebServiceHost instead of ServiceHost Wählt die .NET Service Host-Klasse aus, von der der Service Host abgeleitet wird. Standard ist ServiceHost. Launch Debugger on Startup Wenn der Service über Framework Studio gestartet wird (siehe Start/Stop current development FSDomain), wird er im Development Service Host bereitgestellt. Ist Launch Debugger on StartUp aktiviert, erscheint beim Starten der FSDomain ein Fenster, in dem eine neue Instanz des VisualStudio Debugger erstellt werden kann. Just-In-Time-Debugger: Wird mit Ja bestätigt, wird der Code des Service im Visual Studio angezeigt, der Prozess des Development Service Hosts unterbrochen und es kann mit dem Debugging begonnen werden. Registerkarte Service Behaviors Base Address Definiert die Adresse, an der der Webservice verfügbar gemacht werden soll. Aus der Combobox können von FS vorgegebene Adressen ausgewählt werden. Ist die Checkbox aktiviert, kann die Adresse überschrieben und manuell konfiguriert werden. Es stehen folgende Platzhalter zur Verfügung: %SERVER% %PORT% %REPOSITORY% %VERSION% %USER% %HOSTNAME% %HOSTFULLNAME% Wird der Port mit 0 angegeben, wird zur Laufzeit ein freier Port vom System zugewiesen. HttpGetEnabled Diese Checkbox definiert, ob die Dienstmetadaten in Form von WSDL über HTTP/GET bereitgestellt werden. Ein Client kann also über die Adresse des Webservice inklusive eines angehängten ?wsdl die Definition des Webservice z.B. in einem Browser auslesen. Beispiel: Existiert ein Webservice auf dem lokalen System an der Adresse http://localhost:8082/FSDemo/ArticleInfoService Host kann die Definition dieses Service mit dem Aufruf http://localhost:8082/FSDemo/ArticleInfoService Host?wsdl eingesehen werden. Über diese Definition können Clients für diesen Webservice automatisch erstellt werden, z.B. in einem Visual Studio-Projekt oder einem anderen Framework Studio Package. Warning Wird keines der Häkchen gesetzt, kann ein Client, der die Implementierung des Webservice nicht kennt, die Definition für die Benutzung des Webservice via WSDL nicht auslesen. Der Client muss also wissen, welche Methoden mit welchen Parametern und Rückgabewerten an diesem Webservice veröffentlicht werden, um Aufrufe zu tätigen. IncludeExceptionDetailInFaults Sollte nach einem Request eines Clients an einen Webservice zur Laufzeit eine Exception auftreten, kann mit diesem Flag bestimmt werden, ob der Webservice die Details der geworfenen Exception mit in den SOAP-Envelope mit einbezieht, der als Response an den Client zurück geschickt wird. Beispiel: <s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\"> <s:Body> <s:Fault> <faultcode mlns:a=\"http://schemas.microsoft.com/net/2005/12/wcf/dispatcher\"> a:InternalServiceFault </faultcode> <faultstring xml:lang=\"en-US\"> Exception in FindEmployeeByLastName </faultstring> <detail> <ExceptionDetail xmlns=\"http:// org/2004/07/System.ServiceModel\" xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\"> <HelpLink i:nil=\"true\"/> <InnerException i:nil=\"true\"/> <Message>Exception in FindEmployeeByLastName</Message> <StackTrace> at EmployeeService.ServiceImplementation.EmployeeManager. FindEmployeeByLastName( String request) in C:\\Dev\\EmployeeSvcManual\\Source\\Service\\EmployeeService.ServiceImplementation\\EmployeeManager.cs:line 25&#xD; at SyncInvokeFindEmployeeByLastName(Object , Object[] , Object[] )&#xD; at System.ServiceModel.Dispatcher.InvokeDelegate.Invoke(Object target, Object[] inputs, Object[] outputs)&#xD; at System.ServiceModel.Dispatcher.SyncMethodInvoker.Invoke(Object instance, Object[] inputs, Object[]&amp; outputs)&#xD; at System.ServiceModel.Dispatcher.DispatchOperationRuntime.InvokeBegin( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage5( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage4( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage3( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage2( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage1( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.MessageRpc.Process(Boolean isOperationContextSet) </StackTrace> <Type>System.ApplicationException</Type> </ExceptionDetail> </detail> </s:Fault> </s:Body> </s:Envelope> Der Client kann demnach den <detail>-Block auswerten und in ein mögliches Error-Handling mit einbeziehen. Hier sind auch die Details der Exception, die zur Laufzeit der Webservice-Methode aufgetreten sind, zu sehen. Zusätzlich wird auch der gesamte Stack-Trace mit übergeben. Die Implementierung des Exceptionhandlings wird durch die meisten generierten Clients automatisch mit abgedeckt. Caution Diese Einstellung ist bei der Entwicklung von Webservices sehr hilfreich, sollte jedoch in produktivem Betrieb deaktiviert werden. Da der Stack-Trace dem Client einige Informationen über die internen Abläufe des Webservice offenbart, könnte der Webservice ggf. leicht angreifbar werden. Textbox <ServiceBehavior> Zusätzlich zu den per Checkbox auswählbaren Parametern können hier noch manuell Behavior-Attribute in Form von XML gesetzt werden. Diese werden beim Start des Service Hosts in die Web.config geschrieben. Registerkarte EndPoints EndPoint Konfiguration: Hier können verschiedene Arten von EndPoints für den Webservice definiert werden. Beim Aufruf eines WCF-Services durchläuft der Request in der WCF-Runtime den sogenannten Stack-Channel. Dieser beschreibt, wie die Kommunikation zwischen Client und Server stattfindet. Er enthält Informationen zu Interoperabilität, Sicherheit, Protokollen, Encodierungen, Transaktionsfluss und vieles mehr (siehe auch http://msdn.microsoft.com/en-us/library/ms730879.aspx). Die EndPoints eines Webservice kapseln genau diese Informationen. Soll ein Webservice über unterschiedliche Kommunikationsarten aufrufbar sein, können mehrere EndPoints zu einem Webservice definiert werden (z.B. einer für HTTP und einer für die Kommunikation via NamedPipes). Default Properties Name Name des EndPoints. Dieser ist auch in der WSDL-Definition des Webservice zu sehen. Address Adresse des EndPoints für den Webservice. In der Combobox werden seitens FS lokale Adressen zur Auswahl angeboten. Diese können mittels der Checkbox überschrieben werden. Folgende Platzhalter stehen zur Verfügung: %SERVER% %PORT% %REPOSITORY% %HOSTNAME% %ENDPOINT% %VERSION% %USER% %HOSTNAME% %HOSTFULLNAME% Wird der Port mit 0 angegeben, wird zur Laufzeit ein freier Port vom System zugewiesen. Binding Hier wird die Binding des Services ausgewählt. In der Combobox stehen alle von WCF vordefinierten Bindings. Jede dieser Bindings generiert einen unterschiedlichen WCF-Stack-Channel und wirkt sich somit direkt auf die Kommunikation und Erreichbarkeit des Webservices aus. Eine genaue Beschreibung der unterschiedlichen Bindings befindet sich unter http://msdn.microsoft.com/en-us/library/ms730879.aspx oder http://msdn.microsoft.com/en-us/magazine/cc163394.aspx Binding Configuration Sind auf der Registerkarte EndPoint Bindings Einträge vorhanden, können diese dem EndPoint zugewiesen werden. Binding Name Name der Binding in der WSDL-Definition. Behavior Sind auf der Registerkarte EndPoint Behaviors Einträge vorhanden, können diese dem EndPoint zugewiesen werden. Additional Properties Hier kann die EndPoint-Konfiguration mittels XML manuell erweitert werden. Beim Start des Service Hosts werden alle Eingaben in die Web.config übernommen. Registerkarte EndPoint Bindings EndPoint Binding Konfiguration: Mit EndPoint Bindings lässt sich die Kommunikation - wenn erwünscht - zwischen Client und Webservice genauer spezifizieren. Wird in einen Service keine EndPoint Binding eingebunden, gelten die Default-Werte seitens der WCF-Spezifikation in Abhängigkeit des im EndPoint angegebenen Binding Types. Name Definiert den Namen der EndPoint Binding. Binding Type Definiert den Binding Type der EndPoint Binding. Warning Es können nur EndPoint Bindings zu EndPoints zugeordnet werden, die den gleichen Binding Type haben. Default Properties Die Werte werden je nach ausgewähltem Binding Type aktiviert oder deaktiviert. Als Standardwerte dienen die Standardwerte der WCF-Spezifikation. AllowCookies Kann nur bei HTTP-Bindings aktiviert werden. Wenn das Häkchen gesetzt ist, wird dem Webservice der Umgang mit Cookies erlaubt. Eine dem Webservice entsprechende Client-Implementierung beinhaltet dann das WCF-Managementsystem für den Umgang mit Cookies. BypassProxyOnLocal Wenn gesetzt, wird der Proxy vom System für alle Aufrufe ins Internet umgangen. Wenn nicht gesetzt, werden alle Aufrufe ins Internet durch den Proxy geleitet. CloseTimeout Definiert die Zeitspanne, die dem Webservice eingeräumt wird, um eine Close-Operation auszuführen. OpenTimeout Definiert die Zeitspanne, die dem Webservice eingeräumt wird, um eine Open-Operation auszuführen. ReceiveTimeout Definiert die Zeitspanne, die dem Webservice eingeräumt wird, um eine Empfangs-Operation auszuführen. SendTimeout Definiert die Zeitspanne, die dem Webservice eingeräumt wird, um eine Sende-Operation auszuführen. HostNameComparisonMode Mit diesem Wert werden die URI-Übereinstimmungsregeln angegeben, die vom Dispatcher eines Transportprotokolls wie HTTP, TCP oder NamedPipes beim Verteilen von eingehenden Nachrichten an die im Webservice verfügbaren EndPoints verwendet werden. Jeder Wert von HostNameComparisonMode entspricht einer bestimmten Übereinstimmungsregel. Die Priorisierung der Übereinstimmungsregeln gestaltet sich wie folgt: StrongWildcard Exact WeakWildcard StrongWildcard ignoriert den Hostnamen bei der Übereinstimmungsprüfung. Er hat die höchste Priorität der drei verschiedenen Übereinstimmungsmodi. Dies ist der Standardwert für eine von WCF bereitgestellte Binding. Dadurch wird angegeben, dass ein EndPoint eines Webservices mit jedem gültigen Hostnamen erreicht werden kann. Beispiel: Wenn MyService beispielsweise auf http://localhost/MyService gehostet wird, ist er immer noch über http://www.anotherhost.com/MyService erreichbar, da der Hostname anotherhost.com ignoriert wird. Exact erfordert, dass mithilfe der angegebenen Url eine exakte Übereinstimmung, einschließlich des Host-Namens, gefunden werden muss, wenn sonst keine hinreichende Übereinstimmung erzielt werden kann mit der die Url genau einem EndPoint zugeordnet werden kann. Dieser Modus prüft z.B. nicht die Übereinstimmung von kurzen Hostnamen mit vollqualifizierten Domänennamen. Auf diese Weise können Hostnamen als Suchkriterien in solchen Szenarien verwendet werden, in denen mehreren Hosts die gleiche IP-Adresse zugewiesen wird. WeakWildcard ignoriert den Hostnamen, wenn sonst keine hinreichende oder exakte Übereinstimmung erzielt werden kann. MaxBufferPoolSize Definiert die Größe des Hauptspeichers, welcher vom WCF-Message-Buffer-Manager für eingehende Nachrichten verwendet werden darf. MaxBufferSize Ein Wert in Bytes, welcher die maximale Größe des Puffers angibt, der die zu bearbeitenden Nachrichten für den EndPoint beinhaltet, zu dem diese Binding zugeordnet ist. Der Wert kann nicht kleiner als „MaxReceivedMessageSize“ sein. MaxReceivedMessageSize Ein Wert in Bytes, der die maximale Größe einer Nachricht zum verknüpften EndPoint angibt. Der Versender der Nachricht erhält als Antwort bei Überschreitung des Wertes einen SOAP-Fault. Der Webservice verwirft die eingehende Nachricht und schreibt das Ereignis in das Trace-Log. TextEncoding Definiert, wie der in der Nachricht enthaltene Text codiert ist. Beispiele: UFT-8, ISO-8559-1. MessageEncoding Je nach Binding Type stehen Text, Binary oder MTOM (Message Transmission Optimization Mechanism) zur Verfügung. TransferMode Definiert, wie die Nachrichten über den Stack-Channel versendet und gepuffert werden. Es stehen folgende Transfermodes zur Auswahl: Buffered: Die Anforderungs- und Antwort-Nachrichten werden gepuffert. Streamed: Die Anforderungs- und Antwort-Nachrichten werden per Stream übertragen. StreamedRequest: Die Anforderungsnachricht wird per Stream übertragen, und die Antwortnachricht wird gepuffert. StreamedResponse: Die Anforderungsnachricht wird gepuffert, und die Antwort-Nachricht wird per Stream übertragen. UseDefaultWebProxy Wenn im System ein Proxy hinterlegt ist, wird dieser vom Webservice mit der vom System veröffentlichten Konfiguration verwendet. Reader Quotas Properties maxArrayLength Definiert die maximale Größe von Arrays, die in einer Nachricht übertragen werden dürfen. maxBytesPerRead Definiert die maximale Anzahl an Bytes die pro Lesevorgang zurückgegeben werden darf. maxDepth Definiert die maximale Knotentiefe, die pro Lesevorgang erreicht werden darf. maxNameTableCharCount Definiert die maximale Anzahl an Buchstaben, die ein Tabellenname beinhalten darf. maxStringContentLength Definiert die maximale Anzahl an Buchstaben im Inhalt von übertragenen XML-Elementen. Additional Properties Hier kann die EndPoint-Binding-Konfiguration mittels XML manuell erweitert werden. Beim Start des Service Hosts werden alle Eingaben in die Web.config übernommen. Registerkarte EndPoint Behaviors Ein EndPoint Behavior definiert ein Verhalten eines zugehörigen EndPoints. Wird in einem EndPoint kein explizites Verhalten angegeben, gelten die Standardwerte seitens der WCF-Spezifikation. Name Definiert den Namen der EndPoint Behavior. Properties enableWebScript Aktiviert das Endpunktverhalten, durch das der Dienst über ASP.NET AJAX-Webseiten genutzt werden kann. Das Verhalten sollte nur in Verbindung mit entweder dem <webHttpBinding>- oder dem <webMessageEncoding>-Binding Type verwendet werden. synchronousReceive Gibt das Laufzeitverhalten für das Empfangen von Nachrichten in einem Dienst oder einer Clientanwendung an. Es enthält keine Attribute oder untergeordnete Elemente. transactedBatching Gibt an, ob Transaktionsbatching für Empfangsvorgänge unterstützt wird. MaxBatchSize Eine ganze Zahl, die die maximale Anzahl an Empfangsvorgängen angibt, die in einer Transaktion zusammengefasst werden können. webhttp Gibt WebHttpBehavior an, anhand der Konfiguration in einem Endpunkt. Wenn dieses Verhalten zusammen mit der -Binding verwendet wird, wird das Webprogrammiermodell für einen WCF-Dienst aktiviert. Registerkarte Methods Hier können beliebig Methoden implementiert werden, die die Service Host-Klasse anbieten soll. Registerkarte Variables Hier können beliebig Variablen für die Service Host-Klasse deklariert werden. Es können auch statische Variablen verwendet werden. Generieren eines ServicesProxy aus einem Service Host Im Menüpunkt Edit befindet sich der Eintrag New proxy for this service host. Damit wird auf Basis des ausgewählten Service Hosts ein Service Proxy-Element (siehe Fehler! Verweisquelle konnte nicht gefunden werden.) im selben Namespace generiert, welches sich automatisch für den Zugriff auf einen EndPoint des Webservices konfiguriert. Dies erspart dem Programmierer das Anlegen eines Service Proxy-Elements und das manuelle Einbinden des zugehörigen Service Hosts und EndPoints. Ableiten und Customizen von Service Hosts Service Hosts können abgeleitet und gecustomized werden. Alle Properties, Endpoints, Behaviors, Methoden usw. sind überschreib- oder änderbar."
  },
  "doc/webservices/service-proxy.html": {
    "href": "doc/webservices/service-proxy.html",
    "title": "Service Proxy",
    "keywords": "Service Proxy Ein Service Proxy verschafft einem Client Zugang zu einem Webservice. Dieser kann ein Webservice (also ein Service Host, der auf einen Service inklusive Service Contract zeigt) sein, der lokal im FS definiert wurde oder ein externer Webservice im Internet. Der Service Proxy übernimmt an dieser Stelle die Generierung des Codes, der nötig ist, um auf die Operationen, die der Webservice bereitstellt, zuzugreifen. Er kapselt somit auch die gesamte EndPoint- und somit WCF-Stack-Channel-Definition des Webservice. Dies wird vor allem dann hilfreich, wenn aus der WSDL-Definition eines Webservices im Internet ein passender Client erstellt werden soll, der sich genau an die Richtlinien des Webservice hält. Service Proxy für Service Hosts aus dem Repository Name Definiert den Namen des Service Proxy. Registerkarte General Um Service Hosts aus dem Repository in den Service Proxy einzubinden wird der Radiobutton Service from this repository gewählt. Danach kann über den Button Choose Host aus dem Namespace-Tree ein beliebiges Service Host-Element ausgewählt werden. Die Combobox EndPoint zeigt nun alle im Webservice verfügbaren EndPoints, die angesprochen werden können. Mit der Checkbox Generate wrapper for all proxy methods kann im generierten Code des Service Proxy für jede Methode eine Wrapper-Methode angelegt werden. Beispiel: Ist das Häkchen gesetzt, kann später im Code (z.B. in einer Component) wie folgt auf die Methoden zugegriffen werden: dcPC[] pcs; using (PcListSvcProxy proxy = new PcListSvcProxy()) { pcs = proxy.GetPcList(ID); } Ist das Häkchen nicht gesetzt, sieht der Aufruf wie folgt aus: dcPC[] pcs; using (PcListSvcProxy proxy = new PcListSvcProxy()) { pcs = proxy.Proxy.GetPcList(ID); } Der Aufruf findet also über die Interne Proxy-Klasse des Service Proxy-Elements statt. Registerkarte Methods Hier können beliebig Methoden implementiert werden, die die Service Proxy-Klasse anbieten soll. Registerkarte Service Operations Liste der Methoden am Service Proxy: Hier werden alle Methoden des Webservice aufgelistet, die der Webservice anbietet bzw. auf die der Service Proxy zugreifen kann. Registerkarte EndPoint Hier wird die EndPoint-Definition in Form von XML angezeigt. Diese kann mit dem Häkchen Overwrite EndPoint manuell überschrieben werden. Registerkarte Binding Hier wird die Binding-Definition in Form von XML angezeigt. Diese kann mit dem Häkchen Overwrite Binding manuell überschrieben werden. Registerkarte EndPoint Behavior Hier wird die EndPoint Behavior-Definition in Form von XML angezeigt. Diese kann mit dem Häkchen Overwrite EndPoint Behavior manuell überschrieben werden. Service Proxy für einen externen Webservice im Internet Um externe Webservices im Internet in die Anwendung einzubinden, wird der Radiobutton External service im Service Proxy gewählt. Im Feld Service Address wird die Adresse des Webservices im Internet angegeben. Mit der Combobox Contract kann optional aus dem Namespace-Tree ein Service Contract ausgewählt werden, den der Proxy mit implementieren soll. Die Combobox EndPoint wird automatisch gefüllt, wenn die Proxy-Klasse mit dem Button Generate Proxy (siehe Registerkarte SvcUtil Options) aus der WSDL-Definition des Webservice generiert wird. Danach stehen alle EndPoints, die der Webservice anbietet, zur Auswahl. Mit dem Button Test Service wird der mit Visual Studio ausgelieferte WCF-Testclient gestartet und versucht, den angegebenen Webservice zu laden. Die verschiedenen EndPoints (im Beispiel „CurrencyCenvertorSoap“ und „CurrencyConvertorSoap12“) und die erreichbaren Methoden werden angezeigt. Mit einem Doppelklick auf eine der Methoden kann diese im rechten Fenster getestet und die SOAP-Envelopes des Request und Response in XML-Format eingesehen werden. Registerkarte SvcUtil Options Mit dem Häkchen bei \\Async wird bei der Generierung des Proxy-Codes je Methode eine Signatur für den synchronen und eine für den asynchronen Aufruf erstellt. Somit ist es möglich, später in der Anwendung zu entscheiden, ob der Webservice synchron oder asynchron (z.B. wie bei AJAX) aufgerufen werden soll. Mit \\Collection Type wird angegeben, welche Art von Collection-Typ die Proxy-Klasse für Collection-Parameter im Webservice verwenden soll. Mit dem Button Generate Proxy wird im Hintergrund der tatsächliche Programmcode des Proxy und die dazugehörige App.Config-Datei generiert. Dies geschieht über das Tool SvcUtil.exe, welches mit dem Windows SDK ausgeliefert wird. Wo die EXE auf dem System liegt, kann unter Tools > Options > Utilities > SvcUtil angegeben werden. Der Standardpfad ist C:\\Programme\\Microsoft SDKs\\Windows\\v6.0A\\bin\\SvcUtil.exe. Die Metadaten des Webservice werden in Form der WSDL-Definition heruntergeladen und auf Basis dieser der Proxy erstellt. Dabei werden auch die Informationen über die verfügbaren EndPoints eingelesen und in der Combobox EndPoint zur Auswahl bereitgestellt. Registerkarte Generated Code Hier kann der von SvcUtil.exe generierte Proxy-Code eingesehen werden. Registerkarte Generated App.Config Hier kann die von SvcUtil.exe generierte App.Config-Datei eingesehen werden. Generieren eines Data Contracts aus einem Service Proxy Im Menüpunkt Edit befindet sich der Eintrag Generate Data Contracts. Damit wird auf Basis des ausgewählten Service Proxy ein (oder mehrere) Data Contract-Element(e) im selben Namespace generiert. Dies ist nur für externe Webservices möglich. Ableiten und Customizen von ServiceProxies ServiceProxies können abgeleitet und gecustomized werden. Lediglich EndPoints, Bindings und Behaviors können bearbeitet werden. Eine Änderung des Service Host ist nicht möglich und auch ein Aufruf von SvcUtil.exe wird nicht angeboten."
  },
  "doc/webservices/service.html": {
    "href": "doc/webservices/service.html",
    "title": "Service",
    "keywords": "Service Ein Service ist das Element, das die Methoden, welche in einem Service Contract definiert sind, implementiert. Jeder Service muss dabei mindestens einen Service Contract implementieren. Es besteht allerdings auch die Möglichkeit, den Service Contract automatisch aus den Metadaten des Service generieren zu lassen (siehe Service Contract automatisch generieren). Name Name des Service-Elements. Dies ist gleichzeitig der Name der Klasse im IntelliSense. Registerkarte General In der Textbox Service Class Attributes können zusätzliche Attribute für die Service-Klasse definiert werden (z.B. [System.Serializable]). Registerkarte Methods Hier werden die Methoden des Services implementiert. In der Liste können mit Rechtsklick -> New -> Method/Method Override neue Methoden angelegt und im Codefenster ausprogrammiert werden. Das Property Misc -> GenerateGlobalObject kann für jede Methode unabhängig auf true oder false gesetzt werden. Ist es auf True gesetzt, wird im Hintergrund ein GlobalObject (siehe Global Objects) generiert, welches im Code mit Global angesprochen und übergeben werden kann. Der Zugriff auf Global ist nötig, wenn eine Servicemethode Elemente aus Framework Studio instantiiert, bei deren Instantiierung ein GlobalObject nötig ist. Im Beispiel wird eine cdArticleColl über ihre Factory-Klasse mit cdArticleCollFactory.Create(Global) erstellt. Groupbox Properties for autogenerated Service Contract Method: Alle hier definierten Eigenschaften für die ausgewählte Service-Methode werden nur verwendet, wenn für den Service ein automatisch generierter Service Contract verwendet wird (siehe Service Contract automatisch generieren). In der Textbox Attributes können Attribute für die automatisch generierte Interface-Methode im Service Contract definiert werden. Das für den Service Contract benötigte Attribut [OperationContract] wird automatisch hinzugefügt und muss nicht manuell eingetragen werden. In der Liste Fault Contracts können zur derzeit ausgewählten Service-Methode Fault Contracts hinzugefügt werden, die später im Code als Typ für eine FaultException verwendet werden können. Mehr Information hierzu im Kapitel Fault Contracts. Registerkarte Contracts Groupbox Autogenerated Service Contract: Die Combobox Implement gibt an, ob für den Service ein Service Contract automatisch generiert und implementiert werden soll (siehe Service Contract automatisch generieren). In der Textbox Attributes können Attribute für das automatisch generierte Service Contract Interface definiert werden. Das für den Service Contract benötigte Attribut [OperationContract] wird automatisch hinzugefügt und muss nicht manuell eingetragen werden. Groupbox Implemented Service Contracts: In dieser Liste werden alle Service Contracts aufgelistet, die der Service implementiert. Die Spalte Type zeigt an, ob es sich bei einem Service Contract um einen benutzerdefinierten oder externen Service Contract handelt. Generieren eines Service Hosts aus einem Service Im Menü Edit befindet sich der Eintrag New service host for this service. Damit wird auf Basis des ausgewählten Services ein Service Host-Element im gleichen Namespace erstellt (siehe Fehler! Verweisquelle konnte nicht gefunden werden.). Ableiten und Customizen von Services Services sind vollständig ableit- und customizbar. Es können neue Methoden hinzugefügt oder Basismethoden überschrieben werden. Implementierte Service Contracts aus der Basis können nicht gelöscht werden."
  },
  "doc/webservices/webservices.html": {
    "href": "doc/webservices/webservices.html",
    "title": "Webservices",
    "keywords": "Webservices Framework Studio bietet die Möglichkeit, mit einfachen Mitteln Webservices auf Basis der Microsoft Windows Communication Foundation (WCF) zu erstellen und zu konsumieren. Hierzu wird die Komplexität von WCF mittels einiger Service-Elemente seitens Framework Studio abstrahiert und vereinfacht. Service-Elemente anlegen Es wird der Namespace ausgewählt, in dem das neue Element angelegt werden soll. Danach wird über den Button New des Registerkartes Service und anschließend das gewünschte Service-Element ausgewählt."
  },
  "doc/weitere-themen/clientoptions-xml.html": {
    "href": "doc/weitere-themen/clientoptions-xml.html",
    "title": "ClientOptions.xml",
    "keywords": "ClientOptions.xml In dieser Datei können Einstellungen für den Java-Client vorgenommen werden. Die Datei muss manuell angelegt und bearbeitet werden. Die Datei ClientOptions.xml wird auf dem Client-Rechner im Ordner %userprofile%\\FSClientLauncher\\ abgelegt. Die darin vorgenommenen Einstellungen ziehen für alle Java-Clients die auf diesem Rechner gestartet werden, sofern sie die entsprechende Einstellung unterstützen. Das gilt sowohl für Clients, die über den Client-Launcher als auch für Clients, die über Java Web Start gestartet werden. Beispiel-Datei: <ClientOptions> <add key=\"NoTooltip\" value=\"1\"/> <add key=\"NoProgressWindow\" value=\"1\"/> <add key=\"NoFrameAnimation\" value=\"1\"/> </ClientOptions> Es werden folgende Einstellungen unterstützt: NoTooltip: Es werden in der Anwendung keine Tooltips angezeigt. NoProgressWindow: Es wird in der Anwendung kein Progress-Fenster angezeigt. NoFrameAnimation: Das Ein- und Ausblenden von Frames im Frameset wird nicht animiert."
  },
  "doc/weitere-themen/clone_und_adoptvalues.html": {
    "href": "doc/weitere-themen/clone_und_adoptvalues.html",
    "title": "Clone() und AdoptValues()",
    "keywords": "Clone() und AdoptValues() Framework Studio bietet einen Mechanismus, mit dem es möglich ist, eine Component inkl. aller Unter-Objekte zu kopieren. Dafür werden an der Component und der Collection die Methoden Clone() und AdoptValues() angeboten. Clone vs. AdoptValues Beim Clone wird von einer Component eine Kopie erzeugt. Dabei bleibt die Eigenschaft ObjectRowID erhalten. Aber intern wird eine neue RuntimeID vergeben. IcdComponent oCompCloned = (IcdComponent)oComp.Clone(); Bei AdoptValues werden die Daten der übergebenen Component übernommen. Die ObjectRowID wird allerdings nicht übernommen, sie behält ihren Wert wie vor dem Aufruf von AdoptValues. IcdComponent oCompAdopted = cdComponentFactory.Create(); oCompAdopted.AdoptValues(oComp); BEIDE Routinen arbeiten standardmäßig alle Unter-Properties rekursiv durch (Tiefen-Kopie). Dabei wird intern die Methode Clone() verwendet. Das bedeutet, dass auch bei der Verwendung von AdoptValues() die ObjectRowIDs der UNTER-Objekte erhalten bleiben. AdoptMode Der Adopt-Mode beschreibt die Art und Weise, wie die Methode AdoptValues() bzw. Clone() arbeiten soll. Es gibt folgende Möglichkeiten: AdoptMode.Deep Das ist das Standard-Verhalten, wenn der Parameter nicht angegeben ist. Es wird eine Tiefen-Kopie erstellt. Das bedeutet, dass alle Unter-Objekte mit Clone() kopiert werden. AdoptMode.Flat Es wird eine flache Kopie erstellt. Dabei werden nur die direkt in der Component vorhandenen Properties übernommen. Die Unter-Objekte werden nicht kopiert, sondern als Referenz übernommen. Beispiel: // führt die Tiefen-Kopie durch. oCompAdopted.AdoptValues(oComp, AdoptMode.Deep); // analog zu: oCompAdopted.AdoptValues(oComp); // führt eine flache Kopie durch. oCompAdopted.AdoptValues(oComp, AdoptMode.Flat); Dasselbe funktioniert auch für den Clone(): // führt die Tiefen-Kopie durch. oCompCloned = oComp.Clone(AdoptMode.Flat) AdoptDictionary Clone bzw. AdoptValues erkennen bei der rekursiven Verarbeitung der Unter-Objekte identische Instanzen. Die Kopien der Components beinhalten an diesen Stellen wieder identische Instanzen. Das löst auch Probleme, wenn Objekte Zirkelbezüge haben. Dafür wird bei der Routine ein Dictionary verwendet, in dem gespeichert wird, welches Ursprungs-Objekt zu welcher Kopie zegordnet ist. Genau genommen wird die RuntimeID des Ursprungs-Objektes gespeichert. Deklaration der Klasse AdoptDictionary: public class AdoptDictionary : Dictionary<long, IDevFrameworkBaseObject> Dieser Mechanismus kann auch ganz geziehlt eingesetzt werden, um schon vor dem Aufruf der Methode AdoptValues festzulegen, welche Objekte als Kopien - oder besser noch anstatt von neuen Kopien - verwendet werden sollen. Für die Methode AdoptValues gibt es eine Überladung, in der auch ein bereits gefülltes AdoptDictionary übergeben werden kann: public void AdoptValues(IDevFrameworkBaseObject, AdoptDictionary) Um das Arbeiten mit diesem Dictionary zu erleichern, gibt es zusätzlich zu den Dictionary-Membern weitere Methoden: public void AdoptInstance(IDevFrameworkBaseObject comp) Es wird das Objekt übergeben, welches nicht kopiert, sondern direkt übernommen werden soll. adoptDict.AdoptInstance(oComp.oUnterObjekt); public void UseInstance(IDevFrameworkBaseObject comp, IDevFrameworkBaseObject sourceComp) Das im Parameter comp übergebene Objekt soll verwendet werden. Der Parameter sourceComp gibt das Objekt in der Quell-Struktur an. Anders formuliert: wenn das in sourceComp übergebene Objekt kopiert werden soll, wird stattdessen das in comp übergebene Objekt verwendet. adoptDict.UseInstance(oCompNew.oUnterObjekt, oComp.oUnterObjekt); Ein Beispiel: Beim Adopten soll die Instanz eines Unter-Objektes direkt übernommen werden. IcdComponent oCompAdopted = cdComponentFactory.Create(); AdoptDictionary adoptDict = new AdoptDictionary(); adoptDict.AdoptInstance(oComp.oUnterObjekt); // identisch mit: // adoptDict[oComp.oUnterObjekt.RuntimeID] = oComp.oUnterObjekt; oCompAdopted.AdoptValues(oComp, adoptDict); In einem weiteren Beispiel soll das Unter-Objekt am Ziel erhalten bleiben: IcdComponent oCompAdopted = cdComponentFactory.Create(); AdoptDictionary adoptDict = new AdoptDictionary(); adoptDict.UseInstance(oCompAdopted.oUnterObjekt, oComp.oUnterObjekt); // identisch mit: // adoptDict[oComp.oUnterObjekt.RuntimeID] = oCompAdopted.oUnterObjekt; oCompAdopted.AdoptValues(oComp, adoptDict); Das Unter-Objekt wird jeweils mit all seinen Unter-Objekten übernommen. ABER: wenn es sich dabei um ein Objekt handelt, welches ebenfalls vom Haupt-Objekt referenziert wird, dann wird dieses trotzdem kopiert. Beispiel: oComp (RuntimeID 1) oUnterObjekt (RuntimeID 2) oArtikel (RuntimeID 3) oKunde (RuntimeID 4) oArtikel (RuntimeID 3 - dieselbe wie oben) Das führt dann dazu, dass sich in der neuen Objekt-Struktur 2 verschiedene Instanzen des ursprünglich gleichen Objektes wiederfinden. oCompAdopted (RuntimeID 11) oUnterObjekt (RuntimeID 2 - aus Quelle übernommen) oArtikel (RuntimeID 3 - auch die Unter-Objekte) oKunde (RuntimeID 4) oArtikel (RuntimeID 12 - Kopie von Objekt 3) Wenn dieses Verhalten unterbunden werden soll, dann muss im Vorfeld auch das oArtikel in das Dictionary gepackt werden: adoptDict.AdoptInstance(oComp.oUnterObjekt); adoptDict.AdoptInstance(oComp.oArtikel); AdoptValues überschreiben In speziellen Fällen kann es Sinn machen, die Methode AdoptValues zu überschreiben, um gezielt eigene Aktionen durchzuführen oder sogar die von FrameworkStudio generierte Logik zu ersetzen. Warning Diese Methode sollte nur durch fortgeschrittene Entwickler in Ausnahmefällen überschrieben werden. Deklaration der Methode: public override void AdoptValues(DevFrameworkBaseObject fromComponent, AdoptDictionary dict, AdoptMode mode) Parameter: fromComponent: Die Component, deren Werte übernommen werden sollen. dict: Das Adopt-Dictionary, welches zur Erkennung identischer Instanzen währen dem AdoptValues-Vorgang dient. mode: AdoptMode.Flat oder AdoptMode.Deep. Alle Aufrufe von AdoptValues und Clone landen in dieser zentralen Methode. Hier können Sie abhängig von den Parametern eigene Aktionen durchführen. In der Praxis könnten Sie z.B. dafür sorgen, dass beim Aufruf einer flachen Kopie, ein besimmtes Unter-Objekt, welches immer zusammen mit dem Haupt-Objekt gespeichert wird, trotzdem kopiert wird. public override void AdoptValues(DevFrameworkBaseObject fromComponent, AdoptDictionary dict, AdoptMode mode) { base.AdoptValues(fromComponent, dict, mode) if (mode == AdoptMode.Flat) { this.oUnterObjekt = (cdObjekt)this.oUnterObjekt.Clone(dict); } }"
  },
  "doc/weitere-themen/connection-einstellungen.html": {
    "href": "doc/weitere-themen/connection-einstellungen.html",
    "title": "Connection Einstellungen",
    "keywords": "Connection Einstellungen ==> siehe Datenbank-Connection"
  },
  "doc/weitere-themen/connection-pooling-protokoll.html": {
    "href": "doc/weitere-themen/connection-pooling-protokoll.html",
    "title": "Connection Pooling Protokoll",
    "keywords": "Connection Pooling Protokoll Das Connection-Pooling bietet die Möglichkeit, die Aktionen in einer Datei zu protokollieren. Damit können Probleme besser analysiert werden. Diese Protokollierung sollte nur vorrübergend eingesetzt werden, weil dadurch sehr große Datenmengen produziert werden - vor allem auf Broker mit hoher Last. Um die Protokollierung für das Connection-Pooling zu aktivieren, muss im ConnectionString die Eigenschaft FSPoolingDebugOutput ergänzt werden. Dies muss manuell nach dem Publish der Applikation erfolgen, weil diese Eigenschaft nicht im Publish-Dialog konfiguriert werden kann. Diese Angabe kann sowohl für die Runtime-Connection als auch für die Business-Connections gemacht werden. Beispiel für die Runtime-Connection: <RuntimeDB ConnectionType=\"Oracle\" ConnectionString=\"Data Source=ORCLNV270;User ID=FSD35; Password=FSD35;Persist Security Info=False; Pooling=False; FSPoolingMin=5; FSPoolingMax=15; FSPoolingTimeout=60; FSPoolingDebugOutput=C:\\temp\\FSPool.txt; FSUseAnsiString=False\" /> Informationen zur Protokollierung 2012-05-18 20:37:01.449 PID=9976 1;DB=DEV01.sysadm Used 0 Free 0 #025EE953 CREATE Connection 1 2012-05-18 20:37:01.454 PID=9976 1;DB=DEV01.sysadm Used 1 Free 0 #025EE953 GET Connection 1 2012-05-18 20:37:17.991 PID=9976 1;DB=DEV01.sysadm Used 0 Free 1 #025EE953 FREE Connection 1 Eine Protokoll-Zeile beinhaltet die folgenden Felder: Datum/Uhrzeit PID - Prozess-ID. Wichtig, wenn auf einem Rechner mehrere Anwendungen laufen, die in dieselbe Datei protokollieren Pool-Information: eindeutige Nummer des Pools im Prozess; Datenbank Used: Anzahl der gerade verwendeten Connections Free: Anzahl der freien Connections im Pool #xxxxxxxx: Eindeutige ID der Connection. Dabei handelt es sich um den HashCode des Connection-Objektes. Dieser kann dazu verwendet werden, die Aktionen einer Connection sauber zuzuordnen. Aktion mit Connection-Nummer. Diese Nummer ist innerhalb des Pools eindeutig. Über diese Nummer können die Aktionen einander sauber zugeorndet werden und so z.B. analysiert werden, ob es zu einem \"GET Connection\" auch ein passendes \"FREE Connection\" oder \"DESTROY Connection\" gibt. CREATE Connection 1: Eine Connection wird erzeugt. Die Information \"Free\" hängt hinterher, weil die Connection erst nach dieser Aktion in den Pool gepackt wird. GET Connection 1: Eine Connection wird verwendet. Wenn im Pool keine Connection zur Verfügung steht, dann wird direkt im Vorfeld eine neue Connection geöffnet (CREATE Connection) FREE Connection 1: Die Connection wird wieder freigegeben und steht dem Pool wieder zur Verfügung. Wenn DESTROY Connection 1: Die Connection wird beendet. Das passiert, wenn bei der Aktion FREE Connection die Anzahl der offenen Connection FSPoolingMax übersteigt, oder wenn bei einer Aktion (GET Connection oder FREE Connection) der Timeout einer freien Connection erreicht ist. DISPOSE POOL: Der Pool wird geleert. Das passiert, wenn der Broker beendet wird, oder wenn die letzte Broker-Sitzung beendet wird. Wenn bei dieser Aktion noch Connections in Verwendung sind (Used), dann wird für diese Connections der Callstack ausgegeben, mit dem sie verwendet wurden. So kann analysiert werden, wer eine Connection öffnet, sie aber nicht freigibt. Diese Connections werden nicht vom Pool geschlossen. Mit dieser Aktion wird der komplette Pool zurückgesetzt. Die Informationen \"Used\" und \"Free\" beginnen wieder bei 0. Das ist auch der Fall, wenn zuvor noch Connections geöffnet waren. ESCALATION OF USED CONNECTIONS: Wenn die Anzahl der benutzten Connctions im Pool 30 übersteigt, dann werden einmalig pro Pool die momentan benutzten Connections mit den Callstacks, durch die sie geöffnet wurden, ausgegeben. Die einzelnen Felder sind mit Tabulator getrennt. So können Sie diese Daten sehr gut z.B. in Excel kopieren und weiter analysieren. Auf einem Rechner können mehrere Prozesse in dasselbe Protokoll schreiben, die Routine ist entsprechend abgesichert. Die Absicherung funktioniert NICHT auf Netzlaufwerken für mehrere Rechner!"
  },
  "doc/weitere-themen/fehlercodes-warnungen.html": {
    "href": "doc/weitere-themen/fehlercodes-warnungen.html",
    "title": "Fehlercodes Warnungen",
    "keywords": "Fehlercodes Warnungen Bei der Erzeugung des Quellcodes prüft FrameworkStudio viele Sachverhalte. Nicht alle Konflikte haben so gravierende Auswirkungen dass der Vorgang komplett abgebrochen werden muss. Diese Konflikte werden als Warnungen in den Quellcode generiert und beim Kompilieren ausgegeben. Warnings Die von Framework Studio erzeugten Warnungen sind mit Codes versehen. Diese Codes können Sie in den folgenden Abschnitten nachlesen. FSWarn[2001] FSWarn[2003] The identifier '{0}' is too long for Oracle Database (maximum 128 characters) Es wurde ein Bezeichner verwendet, der zu lang für Oracle ist. In Oracle dürfen Bezeichner nicht länger als 128 Zeichen sein. Die folgenden Bezeichner werden überprüft: Tabellen-Namen Index-Namen Spalten-Namen Spalten-Aliase in Component-Queries Tabellen-Aliase in Component-Queries FS prüft bei der Code-Generierung ob es Bezeichner gibt, die länger als 30 Zeichen sind und produziert entsprechende Warnungen. Es sind keine Errors, denn es kann durchaus mal vorkommen, dass z.B. bestehende Datenstrukturen einer SQL-Datenbank verwendet werden, die längere Namen enthält. Important Wenn die Oracle-Datenbank mit einem alten Kompatibilität-Modus kleiner als \"12.2\" betrieben wird, dann sind nur 30 Zeichen zulässig. Das wird von Framework Studio aber nicht geprüft. Nähere Details dazu gibt es direkt bei Oracle. FSWarn[2002] FSWarn[2002] The identitifier '{0}' is an keyword in Oracle Database Es wurde ein Bezeichner verwendet, der ein Schlüsselwort in Oracle ist. Die folgenden Bezeichner werden überprüft: Tabellen-Namen Index-Namen Spalten-Namen Spalten-Aliase in Component-Queries Tabellen-Aliase in Component-Queries Es ist bewusst nicht als #error gelöst, da es in SQL-Server umgeben durchaus existierende Datenstrukturen geben kann, bei denen so ein Oracle-Keyword verwendet wird. Die folgenden Schlüsselworte werden geprüft: ACCESS, ADD, ALL, ALTER, AND, ANY, AS, ASC, AUDIT, BETWEEN, BY, CHAR, CHECK, CLUSTER, COLUMN, COMMENT, COMPRESS, CONNECT, CREATE, CURRENT, DATE, DECIMAL, DEFAULT, DELETE, DESC, DISTINCT, DROP, ELSE, EXCLUSIVE, EXISTS, FILE, FLOAT, FOR, FROM, GRANT, GROUP, HAVING, IDENTIFIED, IMMEDIATE, IN, INCREMENT, INDEX, INITIAL, INSERT, INTEGER, INTERSECT, INTO, IS, LEVEL, LIKE, LOCK, LONG, MAXEXTENTS, MINUS, MLSLABEL, MODE, MODIFY, NOAUDIT, NOCOMPRESS, NOT, NOWAIT, NULL, NUMBER, OF, OFFLINE, ON, ONLINE, OPTION, OR, ORDER, PCTFREE, PRIOR, PRIVILEGES, PUBLIC, RAW, RENAME, RESOURCE, REVOKE, ROW, ROWID, ROWNUM, ROWS, SELECT, SESSION, SET, SHARE, SIZE, SMALLINT, START, SUCCESSFUL, SYNONYM, SYSDATE, TABLE, THEN, TO, TRIGGER, UID, UNION, UNIQUE, UPDATE, USER, VALIDATE, VALUES, VARCHAR, VARCHAR2, VIEW, WHENEVER, WHERE, WITH FSWarn[2014] FSWarn[2014] Please add a service contract to service {0}. Existiert für einen Service kein Service Contract oder ist dem Service kein Service Contract zugeordnet, wird diese Warning generiert, da ein Service ohne Contract keinen Sinn macht. FSWarn[2015] FSWarn[2015] A service proxy only can use a service host of the same package. If you want to use the customized service host '{0}' in the service proxy '{1}' from an other package, please customize this service. Ein Service Proxy muss aus dem gleichen Package stammen wie der zugehörige Service Host. Wenn der Service Host gecustomized ist, muss auch der zugehörige Service Proxy gecustomized werden. FSWarn[2017] FSWarn[2017] The index '{1}' in textcollection '{0}' is used more than once. Indices in TextCollections werden als Schlüssel verwendet und sollten deshalb einzigartig sein. FSWarn[2018] FSWarn[2018] Template '{0}' used in form '{1}'. Templates are obsolete and will not be supported in future releases. Templates werden in FS nicht mehr unterstützt und sollten deshalb entfernt werden. FSWarn[2019] FSWarn[2019] The grid column '{0}' in grid '{1}' has a list set but doesn't use the combobox editor. Wenn in einer Grid-Spalte eine Liste als Datenquelle angegeben ist, sollte der EditorStyle auf ComboBox gesetzt werden, um die definierte Liste auch anzeigen zu können. FSWarn[2022] FSWarn[2022] Some parameters of Link '{0}' in Workflow '{1}' have to be corrected. Please call 'Correct workflow link parameters' in Maintenance Mode. Die Identifizierung der Link-Parameter wurde geändert und es sollte auf jedem Link die 'Correct workflow link parameters‘-Funktion ausgeführt werden. Sollte dies nicht der Fall sein, wird diese Warnung generiert. FSWarn[2023] FSWarn[2023] The column '{0}' is used more than one time in the query of component '{1}'. Es führt zu Problemen, wenn auf Components ein Insert ausgeführt wird, welche eine Spalte mehrmals in der Abfrage ausgewählt haben. FSWarn[2024] FSWarn[2024] The event '{0}' of workflow '{1}' will never be fired, but it is used by link '{2}' in workflow '{3}'! Make sure that this event is fired by a form or global event inside workflow '{1}'. Wenn innerhalb eines Workflows von einer Forminstanz ein Link auf eine Workflowinstanz zeigt und ein Event der Forminstanz als Quelle nutzt, dieses seitens des Forms oder eines Global Events aber nie gefeuert wird, wird diese Warnung generiert. FSWarn[2025] FSWarn[2025] Shortcut '{0}' is assigned to more than one control of this form ({1}). Wenn in einem Form der gleiche Shortcut an mehreren Controls hinterlegt ist, wird diese Warnung generiert. FS würde ein Control zufällig wählen (unvorhersehbar) und die anderen Shourtcuts nicht ausführen. FSWarn[2027] FSWarn[2027] Avoid to use default shortcuts CtrlA, CtrlC, CtrlX, CtrlV ({0} used in {1}). Wenn Sie einem Control einen der Standard Shortcuts Strg-A, Strg-C, Strg-X oder Strg-V zuordnen, wird diese Warnung generiert. Diese Shortcuts sollten nicht verwendet werden, da sie von Windows aus schon mit Funktionen wie z.B. Kopieren und Einfügen belegt sind. FSWarn[2029] FSWarn[2029] Method Observer: One or more base methods of '{0}' have been changed. Wenn eine Methode durch den Methoden-Wächter überwacht wird und sich eine oder mehrere Basismethoden dieser Methode geändert haben, wird diese Warnung generiert. FSWarn[2036] FSWarn[2036] Aliases of query columns have to be unique. Duplicate alias:'{0}' Wenn bei den Spalten in einer Component-Query mehrdeutige Aliase vergeben werden, dann können die Spalten nicht mehr eindeutig angesprochen werden. Dies führt zu Fehlern beim Einlesen von Daten aus der Datenbank. In der Regel wird von Framework Studio automatisch ein korrekter Alias vergeben, der sich am Namen der Datenbank-Spalte orientiert. Bei manuell erstellten Queries, insbesondere bei Joins, kann es passieren, dass derselbe Spalten-Name mehrfach vorkommt. In diesem Fall muss manuell ein eindeutiger Name vergeben werden. FSWarn[2038] FSWarn[2038] SortOrder of query columns have to be unique. Duplicate SortOrder: '{0}'. Wenn bei den Spalten in einer Component-Query mehrdeutige SortOrders vergeben werden, dann können die Spalten nicht mehr eindeutig angesprochen werden. Dies führt zu Fehlern beim Einlesen von Daten aus der Datenbank. FSWarn[2039] FSWarn[2039] DeprecatedLayout. Please convert the layout. Das aktuelle Form arbeitet mit dem ‚alten‘ Layout und wurde mit dem Migrationsassistent noch nicht in das dynamische Layout konvertiert. FSWarn[2040] FSWarn[2040] Form '{0}' uses more than one container control as its root control ({1}). FSWarn[2054] FSWarn[2054] No DependsOn specified in individual property {0}. Es wurde keine DependsOn Properties für das individual Property angelegt. Hier finden Sie nähere Informationen. FSWarn[2055] FSWarn[2055] Multiple REST endpoints are specified in service host. Please rename the endpoint '{0}' or uncheck the checkbox 'Generate REST Endpoint'. Am Service Host ist die Checkbox Generate REST Endpoint gesetzt. Dieser bekommt automatisch den Namen rest. Darüber hinaus gibt es einen individuellen Endpoint mit dem Namen rest. Das führt zu einer Kollision. Es kann entweder der automatische oder ein individueller REST Endpoint definiert sein. Siehe auch: REST Endpoint für Service-Methoden Errors Im Gegensatz zu Warnings sind seitens FS generierte Errors beim Kompilieren so schwerwiegend, dass der Vorgang abgebrochen werden muss. Auch Errors sind durchnummeriert und können im Folgenden nachgelesen werden. FSErr[1000] FSErr[1000] Service property must be set. FSErr[1001] FSErr[1001] 'internal virtual' and 'protected internal virtual' is not allowed in Framework Studio: {0} FSErr[1005] FSErr[1005] Datatype of DBColumn {0}.{1}.{2} (property '{3}') is not valid. FSErr[1006] FSErr[1006] Update/Delete could not be generated because not all primary keys of table '{0}' are known as properties of this component! FSErr[1008] FSErr[1008] Update/Delete could not be generated because the rowid column of table '{0}' is not known as property of this component! FSErr[1010] FSErr[1010] RowID or RowVersion is for oracle oledb connection not allowed. Please change the datasource to oracle connection! FSErr[1011] FSErr[1011] Update/Delete could not be generated because the rowversion column of table '{0}' is not known as property of this component! FSErr[1013] FSErr[1013] Update/Delete not possible because no primary keys are published for the main table. FSErr[1015] FSErr[1015] Property '{0}' has a invalid name. {0} is a reserved keyword in c#! {Component:{1} ;Property:{2}} FSErr[1016] FSErr[1016] Property {0} is mapped with a deleted dbcolumn! FSErr[1017] FSErr[1017] PropertyTypeRecord.Relation could only be defined for components and collections. FSErr[1018] FSErr[1018] Relations: Compareoperator {0} is not supported yet! FSErr[1019] FSErr[1019] Invalid character '{0}' in identifier '{1}'. FSErr[1020] FSErr[1020] You have to use a metadatatype as datatype of property '{0}'. FSErr[1024] FSErr[1024] Property '{0}' has no database mapping. Load Condition can't be generated! FSErr[1025] FSErr[1025] {0} (Individual Consistency Message). FSErr[1028] FSErr[1028] Columns can be defined as multi-language only if the primary keys of the table are set! FSErr[1030] FSErr[1030] EditStyle '{0}' requires string as datatype of the value property! FSErr[1031] FSErr[1031] {0}: Choosen Format {1} mustn't be used with datatype '{2}' FSErr[1033] FSErr[1033] The control {0} has been moved in customization base. Please call check out at the form {1} to adjust. FSErr[1035] FSErr[1035] ActionWrapperClassName not found! FSErr[1037] FSErr[1037] format at column \"{0}\" doesn't matches to the datatype \"{1}\" FSErr[1038] FSErr[1038] The tranformation must have at least one input parameter and the output parameter cannot be void. FSErr[1039] FSErr[1039] FormatPattern should not be 'c' FSErr[1042] FSErr[1042] Incorrect format of {0} in {1}. The format have to be like '{2}' FSErr[1043] FSErr[1043] Service Contract '{0}' have to be a derivative of '{1}' FSErr[1044] FSErr[1044] Service Proxy '{0}' hasn't an Endpoint. Please execute 'Generate Proxy' FSErr[1045] FSErr[1045] A valid external or internal service must be defined for the Service Proxy '{0}' FSErr[1046] FSErr[1046] Could not determine SourceEvent! FSErr[1047] FSErr[1047] Please customize the workflow '{0}', because the base workflow '{1}' is customized in this package! FSErr[1049] FSErr[1049] Some parameters of Link '{0}' in Workflow '{1}' have to be corrected. Please call 'Correct workflow link parameters' in Maintenance Mode FSErr[1053] FSErr[1053] The value member of the list datasource '{2}' in grid '{0}' at column '{1}' is not set. FSErr[1054] FSErr[1054] The display member of the list datasource '{2}' in grid '{0}' at column '{1}' is not set. FSErr[1055] FSErr[1055] Index names mustn't be empty. FSErr[1056] FSErr[1056] Multiple indices with the same name '{0}'. FSErr[1057] FSErr[1057] The index has the same columns like index '{0}'. FSErr[1058] FSErr[1058] The index contains no columns. FSErr[1059] FSErr[1059] Index names must start with a letter or an underscore and must continue with letters, underscores or numbers. FSErr[1060] FSErr[1060] Method has to be virtual. FSErr[1061] FSErr[1061] Since the transformation is a customization, this method has to be overridden. FSErr[1062] FSErr[1062] Property '{0}' is readonly and cannot be marked as [DataMember]. FSErr[1063] FSErr[1063] No parent access unit has been assigned to access unit '{0}'. Please check out form '{1}' to reassign a parent access unit. FSErr[1064] FSErr[1064] No view definition has been specified. FSErr[1065] FSErr[1065] Error in view select statement (details see following comment) /0/ FSErr[1066] FSErr[1066] No valid select statement has been specified. FSErr[1067] FSErr[1067] Some DBTable Columns are missing in view select statement: {0}. FSErr[1068] FSErr[1068] It is required to define an alias for column {0} in view select. FSErr[1069] FSErr[1069] Asterisk Expression (*) is not allowed in view select. FSErr[1070] FSErr[1070] Ivalid object reference: {0} FSErr[1072] FSErr[1072] Property '{0}' does not exist on component '{1}'. Wenn an einem Global Objects die Checkbox Redirect to ocGlobal gesetzt ist, dann erwartet Framework Studio in der Component FSGeneral.cGlobal ein gleichnamiges Property. Dieser Fehler wird ausgegeben, wenn so ein Property nicht gefunden wurde. FSErr[1073] FSErr[1073] Property '{0}' type mismatch detected! Expected {1}, given {2}! Wenn an einem Global Objects die Checkbox Redirect to ocGlobal gesetzt ist, dann muss in der Component FSGeneral.ocGlobal das entsprechende Property denselben Typ haben wie das Global Object. Dieser Fehler wird ausgegeben, wenn die Typen abweichen. FSErr[1075] FSErr[1075] The customization base of {objectType} '{name}' has been moved from namespace '{source}' to '{target}'. Please call menu Tools / Adjust moved customizations. Im Basis-Package wurde ein Element in einen anderen Namespace verschoben. Im Customizing-Package muss dies über die Routine “Adjust moved customizations” nachgezogen werden. Siehe auch Kapitel Adjust moved customizations. FSErr[1076] FSErr[1076] In '{GridName}' the column for property '{PropertyName}' was added twice, in Form '{CurrentForm}' and in Form '{CustomizationBaseOrBaseForm}'. Please remove the column in one of the forms. FSErr[1092] FSErr[1092] The Transformation itself is used in root assignment 'Perameter -> Result'. This causes an infinite recursion. Please remove this Transformation from the assignment or use a different one. Bei einer grafischen Transformation darf bei der Zuordnung der Transformation zwischen den Hauptknoten nicht auf sich selbst verwiesen werden. Dies mündet sonst in einer Rekursion und damit in einer StackOverflowException."
  },
  "doc/weitere-themen/framework-studio-exe-config.html": {
    "href": "doc/weitere-themen/framework-studio-exe-config.html",
    "title": "FrameworkStudio.exe.config",
    "keywords": "FrameworkStudio.exe.config Die Datei FrameworkStudio.exe.config liegt im Programmverzeichnis von Framework Studio. In ihr werden Einstellungen für die Anwendung vorgenommen. Bevor Sie mit Framework Studio arbeiten, müssen Sie ggf. die Pfade in dieser Datei an Ihre Installation anpassen. Es folgt eine Beschreibung der Parameter, die Sie in dieser Datei einstellen können. Wie das Ganze in der Datei aussieht, ist im Anschluss dargestellt. DotNet Path Gibt den Pfad an, in dem die .Net-Runtime-Dateien liegen. In der Regel \"C:\\windows\\Microsoft.NET\\Framework\\ v2.0.50727\\\". ApplicationsDirectory Gibt an, in welchen Ordner die Konfigurationsdateien für die Web-Anwendung abgelegt werden sollen. In der Regel C:\\inetpub\\wwwroot\\Applications. NdocPath Gibt an, in welchem Ordner das Programm NDoc installiert ist. Z.B. C:\\Programme\\NDoc\\bin\\.net-1.1. NdocOutputPath. Gibt den Pfad an, in den die Hilfe-Dateien mit NDoc generiert werden sollen. Z.B. C:\\temp\\NdocOutput. SoundShouldBeep (true, false) Gibt an, ob nach dem Kompilieren ein Signalton ausgegeben werden soll. SoundBeepFrequenze Gibt die Frequenz des Signaltons in Hz an. Z.B. 600. DLLReference Gibt den Ordner mit den Dlls an, die der Compiler benötigt. Nach der Installation ist es hier ggf. notwendig den Pfad anzupassen. CorrectMLStrings Wenn true, dann wird eine Funktion zum Korrigieren der Default-Labels aktiviert. Im Kontext-Menu des Namespaces wird ein weiterer Eintrag \"Correct MLStrings in Components …\" angeboten. Dieses Tool sucht nach Properties von Components, bei denen das Default Label mit demselben Wert überschrieben wurde, wie er im Metadatentypen oder in der DB-Column angegeben ist. Diese Labels werden auf den Standard der Basis gesetzt. Dabei werden die Components ausgecheckt. Components, die nicht ausgecheckt werden können, werden unter \"Errors\" aufgelistet. CompileBaseDirectory Gibt den Pfad an, in dem Compile-Verzeichnisse angelegt werden sollen. Diese Einstellung muss von Hand vorgenommen werden. In den Optionen wird diese Einstellung zwar angezeigt, sie kann dort aber nicht verändert werden, weil diese Einstellung schon beim Start vom Framework Studio verwendet wird. Beispiel: <add key=\"CompileBaseDirectory\" value=\"C:\\FS30\"/> Wenn diese Einstellung nicht angegeben ist, dann werden die Verzeichnisse in das Verzeichnis des Benutzer-Profils erzeugt. DevelopementBrokerBaseDirectory Gibt den Pfad an, in dem die Verzeichnisse für die Development-Broker angelegt werden sollen. Dieser Pfad muss vom CompileBaseDirectory abweichen. Diese Einstellung muss von Hand vorgenommen werden. Beispiel: <add key=\"DevelopementBrokerBaseDirectory\" value=\"C:\\FS30_Broker\"/> Wenn diese Einstellung nicht angegeben ist, dann werden die Broker-Verzeichnisse in das Stamm-Verzeichnis des IIS generiert. z.B. C:\\inetpub\\wwwroot\\FS30\\... Es folgt ein Auszug aus einer Config-Datei: <?xml version=\"1.0\" encoding=\"Windows-1252\"?> <configuration> <appSettings> <add key=\"TempDirectory\" value=\"c:\\Temp\" /> <add key=\"DotNet Path\" value=\"C:\\windows\\Microsoft.NET\\Framework\\v1.1.4322\\\" /> <add key=\"DLLReference\" value=\"C:\\Inetpub\\wwwroot\\BusinessRep\\bin\" /> <add key=\"ApplicationsDirectory\" value=\"C:\\inetpub\\wwwroot\\Applications\" /> <add key=\"NDocPath\" value=\"C:\\Programme\\NDoc\\bin\\.net-1.1\" /> <add key=\"NDocOutputPath\" value=\"C:\\NdocOutput\" /> <add key=\"SoundShouldBeep\" value=\"true\" /> <add key=\"SoundBeepFrequenze\" value=\"600\" /> … </appSettings> … </configuration>"
  },
  "doc/weitere-themen/fs-assemblies.html": {
    "href": "doc/weitere-themen/fs-assemblies.html",
    "title": "Struktur der FS-Assemblies",
    "keywords": "Struktur der FS-Assemblies Mit der Version 4.7 wurden die Assemblies neu organisiert. Konkrete Informationen zu Änderungen finden Sie hier. Note Die Umstrukturierung ist noch nicht abgeschlossen und wird in den folgenden Versionen fortgesetzt. Der Bereich FS.Hosting ist bereits so gut wie vollständig. Der Bereich FS.IDE ist noch nicht umgestellt. Wichtig ist die saubere Trennung von IDE und Hosting. Lediglich die Shared-Assemblies ermöglichen der IDE Zugriff auf einige APIs - wie z.B. Enums. Die Namen der Assemblies sind so gestaltet, dass sie sich in verschiedene Bereiche gliedert. ...Shared - Diese Libraries beinhalten bereichsübergreifende APIs, die z.B. sowohl vom Hosting/Runtime als auch innerhalb der IDE verwendet weren. ...Win - Speziell für Windows-Prozesse vorgesehene APIs FS.Shared - Grundlegende APIs, die überall benötigt werden. FS.DataClient - Datenbank-Zugriff FS.Hosting - dieser Bereich umfasst alles, was mit der gepublishten Umgebung zu tun hat. FS.Hosting.Broker - Die normale Application FS.Hosting.Service - Service-Hosts"
  },
  "doc/weitere-themen/fsrowid_fsrowversion.html": {
    "href": "doc/weitere-themen/fsrowid_fsrowversion.html",
    "title": "FSROWID / FSROWVERSION",
    "keywords": "FSROWID / FSROWVERSION Mit der RowID-RowVersion-Logik werden Objekte gegen konkurrierende Transaktionen abgesichert. Dafür können in jeder DBTable 2 Datenbank-Spalten mit dem Namen FSROWID bzw. FSROWVERSION angegeben werden. Diese müssen mit der Einstellung IsRowID bzw. IsRowVersion gekennzeichnet werden. Siehe auch Kapitel DBTable. In der Datenbank-Tabelle haben diese Spalten folgende Bedeutung: FSROWID Eine Guid-Spalte. Diese Spalte wird von Framework Studio beim Insert eines neuen Datensatzes generiert. Die Datenbank-Spalten werden mit einem Default-Constraint angelegt. Dadurch werden sie automatisch befüllt, wenn Datensätze durch ein anderes Programm angelegt und kein Wert für diese Spalte angegeben wurde. Datenbank Datentyp SQL-Server uniqueidentifier Oracle RAW(16) Diese Spalte wird von Framework Studio als PrimaryKey-Spalte verwendet und dient beim Update und beim Nachlesen der eindeutigen Identifikation von Datensätzen. Darüber hinaus in der DBTable definierte PK-Spalten sind dafür unerheblich. Diese haben lediglich den Effekt, dass Framework Studio ein Update auf diese Spalten unterbindet. FSROWVERSION Ein numerischer Zähler, der von Framework Studio bei jedem Update des Datensatzes hochgezählt wird. Dadurch werden konkurrierende Updates erkannt und verhindert. Beim Anlegen der Tabelle muss diese Spalte erzeugt werden. Die Mechanismen von RowID und RowVersion sind unabhängig voneinander. So kann die RowVersion sowohl mit einer RowID als auch mit einem individuellen Primär-Schlüssel (PK) verwendet werden. Beim Anlegen neuer Tabellen müssen die Spalten wie folgt angelegt werden: SQL-Server: CREATE TABLE <table> ( FSROWID uniqueidentifier NOT NULL DEFAULT (NEWSEQUENTIALID()) PRIMARY KEY CLUSTERED, FSROWVERSION bigint, <columns> ); Oracle: CREATE TABLE <table> ( FSROWID RAW(16) DEFAULT SYS_GUID() NOT NULL, FSROWVERSION INTEGER, <columns> ); CREATE UNIQUE INDEX IXROWID_<table> ON <table> (FSROWID) TABLESPACE INDEX1; Für die Spalten FSROWID und FSROWVERSION generiert FrameworkStudio in den Components entsprechende Properties. Diese sehen wie folgt aus: FSSystemGuid ROWID FSlong ROWVERSION Das Property ROWID erhält seinen Wert unmittelbar beim Insert in die Datenbank. Der Wert steht also erst nach dem Insert zur Verfügung. Im OnBeforeSave() hat somit das Property ROWID bei einem neuen Datensatz noch den Wert FSSystemGuid.Null. Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine RowVersionInvalidException geworfen. An der Component gibt es folgende Methoden, mit denen dieser Exception vorgebeugt werden kann: HasDBChanged() ReloadData() Tip Die Spalten können bei Bedarf auch nachträglich angelegt werden. Der Update-Assistent wendet die notwendigen Änderungen inklusive dem Primary-Key automatisch auf der Datenbank an."
  },
  "doc/weitere-themen/service-release-modus.html": {
    "href": "doc/weitere-themen/service-release-modus.html",
    "title": "Service-Release-Modus",
    "keywords": "Service-Release-Modus Nachdem eine Package-Version versiegelt wurde und dadurch die weitere Bearbeitung von Inhalten unterbunden wurde. kann sie wieder für eine eingeschränkte Bearbeitung im Service-Release Modus geöffnet werden. Bei jedem Kompilieren einer Package-Version wird diese mit einem neuen Stempel (Compile-Stamp) versehen. Dieser hat zur Folge, dass alle darauf aufsetzenden Package-Versionen ebenfalls neu kompiliert werden müssen. Dadurch wird sichergestellt, dass alle Schnittstellen-Änderungen auch in den abhängigen Package-Version korrekt berücksichtigt werden. Eine Fehlerkorrektur in einer Package-Version, auf der viele andere Package-Versionen aufsetzen, führt so zu einem aufwändigen Update-Szenario, da alle abhängigen Package-Versionen ebenfalls neu kompiliert werden müssten. Der Service-Release-Modus löst genau diese Problematik: Er ermöglicht eine eingeschränkte Bearbeitung mit Framework-Studio und lässt dabei aber keine Änderung von Schnittstellen zu. Bei einem anschließenden Kompilieren bleibt der zuletzt vor der Versiegelung erzeugte Compile-Stamp erhalten. Er bietet einen speziellen Export, der nur die seit der Versiegelung bearbeiteten Elemente berücksichtigt. Die relativ kleine Export-Datei kann schnell in einem Ziel-Repository importiert werden. Dabei werden die geänderten Daten einfach ersetzt und stehen sofort auch ohne zusätzliches Kompilieren in den abhängigen Package-Versionen zur Verfügung. Wenn sich eine Package-Version im Service-Release-Modus befindet, dann sind in Framework Studio grundsätzlich alle Eingaben gesperrt und es können weder neue Elemente (z.B. Components oder Forms) angelegt, noch bestehende Elemente gelöscht werden. Ausschließlich die folgenden Änderungen sind möglich: Es können alle Methoden-Inhalte bearbeitet werden. Bei Individual Component-Properties können die Get- und die Set-Methode bearbeitet werden. An Custom Control Data Sources können die Methoden GetXML und SetXml bearbeitet werden. In Text-Collections können neue Einträge angelegt werden. So können in Methoden neue Meldungen mit dem Exception- oder MessageBox-Wizard erzeugt werden. In ReportDocumentTypes können vorhandene Report-Dateien bearbeitet werden. Eine Änderung der Schnittstelle (XSD-Datei) ist nicht möglich. Beschriftungen / MLKeys können durchgängig geändert werden. Eigenschaften von Form-Controls können geändert werden. Strukturelle Erweiterungen Important Im Service-Release sollten grundsätzlich nur Fehler behoben werden. Die hier aufgezeigten Möglichkeiten sind ausdrücklich nicht dafür gedacht, neue Funktionalitäten zu realisieren. Im Service-Release-Modus sind alle existierenden Strukturen vor Änderungen geschützt. Das stellt sicher, dass sich die Schnittstellen nicht ändern und es so in abhängigen Package-Versionen nicht zu Compile-Fehlern kommt. Das umfasst z.B. die folgenden Regeln: Datenbank-Strukturen dürfen nicht geändert werden. Es dürfen keine Elemente (Metadatentypen, Components, Forms, ...) umbenannt oder gelöscht werden. Innerhalb dieser Elemente dürfen Properties und Methoden nicht umbenannt oder gelöscht werden. Die Deklaration von Methoden darf nicht geändert werden. In einem begrenzten Umfang können auch im Service-Release neue Strukturen angelegt werden. Diese werden nicht geschützt und können bis zur nächsten Auslieferung geändert oder gelöscht werden. Important Findet am Ende des Service-Release-Zyklus eine Auslieferung statt, dann muss im Package-Manager an der Package-Version mit Button Start new Service Release cycle das Auslieferungs-Datum (Last Deployment) gesetzt werden. Nur so werden die bis jetzt neu angelegten Strukturen ebenfalls geschützt. Folgende strukturelle Erweiterungen sind möglich: Components Neue Methoden Neue Properties Forms Neue Methoden Neue Properties Service Contract Neue Methoden Service Neue Methoden Service Host Neue Methoden Service Proxy Neue Methoden Data Contract Neue Properties Resourcen Neue Resourcen hinzufügen Resourcen importieren Methoden im Service-Release-Modus Von Methoden kann nur der Inhalt bearbeitet werden. Die Deklaration der Methode wird nicht im Code-Editor angezeigt, damit keine versehentlichen Änderungen durchgeführt werden können."
  },
  "doc/weitere-themen/timeout-inaktive-broker-session.html": {
    "href": "doc/weitere-themen/timeout-inaktive-broker-session.html",
    "title": "Timeout für inaktive Broker-Sessions",
    "keywords": "Timeout für inaktive Broker-Sessions Wenn der Java-Client unerwartet beendet wird, existieren die Sessions auf dem Broker weiter. Das kann z.B. dann passieren, wenn der Computer ausgeschaltet wird, eine Remote-Desktop-Sitzung beendet wird oder der Client-Prozess direkt über den Task-Manager abgebrochen wird. Mit den hängengebliebenen Sessions werden nicht nur wertvolle Ressourcen im Broker, sondern ggf. auch Lizenzen blockiert. Die Sessions werden nur dann abgeräumt, wenn sich auch der Java-Client regulär beendet. Die Lizenz-Prüfung orieniert sich an den real vor dem PC sitzenden Personen. Dazu wird auf dem Terminal-Server die ID der Sitzung ermittelt. Genau das kann zu einem Problem werden, wenn die Terminal-Server-Sitzung beendet wird und dieselbe Person später eine neue Sitzung startet und dadurch eine neue Sitzungs-ID erhält. Wenn der Java-Client nicht regulär beendet wurde, blockiert die noch laufende Broker-Sitzung eine Lizenz und in der neuen Terminal-Server-Sitzung wird aufgrund der abweichenden Sitzungs-ID eine weitere Lizenz verbraucht. Aus diesem Grund gibt es einen Mechanismus, der solche Sitzungen im Broker abräumt: Der Client sendet dazu mind. alle 2 Minuten ein Lebenszeichen an den Broker – auch dann, wenn der Benutzer keine Aktionen ausführt – also der Java-Client unbenutzt am Bildschirm steht. Der Broker prüft regelmäßig ob sich der Client gemeldet hat. Sitzungen, die mehr als 5 Minuten kein Lebenszeichen gemeldet haben, werden beendet. Dadurch werden sowohl die Ressourcen als auch die Lizenzen wieder freigegeben. Der Broker prüft dies auch dann, wenn im Moment kein Benutzer aktiv ist. Mit diesem Mechanismus werden auch Sitzungen abgeräumt, bei denen der Benutzer durch eine Aktion einen sehr langen Request angestoßen UND den Client anschließend hart beendet hat. In diesem Fall wird der noch laufende Request durch Thread.Abort() abgebrochen. Es wird dadurch in diesem Request eine ThreadAbortException ausgelöst. Warning Wenn der Client-Arbeitsplatz in den Standby- bzw. Energiesparmodus schaltet, dann sendet der Java-Client kein Lebenszeichen mehr an den Broker. In diesem Fall wird die Sitzung vom Broker beendet. Der Benutzer erhält bei Wiederaufnahme der Arbeit die Meldung Session has been terminated."
  },
  "doc/weitere-themen/transaktionen.html": {
    "href": "doc/weitere-themen/transaktionen.html",
    "title": "Transaktionen",
    "keywords": "Transaktionen Framework Studio besitzt ein eigenes Transaktionsmanagement. In den meisten Fällen müssen Sie sich nicht um Transaktionen kümmern, da jeder Save auf einer Component mit einem Datasource automatisch in einer Transaktion verpackt wird. Jede Transaktion wird in Form eines FrameworkDataTransaction-Objekts repräsentiert. Dieses implementiert die Schnittstelle IDisposable, weshalb sich ein using-Block für Aktivitäten innerhalb der Transaktion empfiehlt. // FrameworkDataConnection ermitteln FrameworkDataConnection connection = ...; // Transaktion starten using(FrameworkDataTransaction transaction = connection.BeginTransaction()) { // Nun kann mit dieser Transaktion gearbeitet werden [...] transaction.Commit(); } Werden FrameworkDataTransaction-Objekte verschachtelt erzeugt, so muss sichergestellt sein, dass innere Transaktionen vor den äußeren abgeräumt werden. Andernfalls wird eine Exception geworfen: Innere Transaktionen müssen vor äußeren beendet werden: Beim Aufruf der Methode Commit an einer inneren Transaktion wird sie lediglich als geschlossen markiert und es erfolgt kein echter Commit. Dennoch wird aus Sauberkeitsgründen ggf. eine FrameworkDataTransactionException geworfen, falls die Aktion in dem aktuellen Transaktionsstapel ungültig sein sollte. Bis zum Dispose-Aufruf dieser inneren Transaktion darf dann keine weitere Transaktion geöffnet werden. Aus diesem Grund sollte der Dispose-Aufruf zeitnah auf das Commit folgen. Die Methode Rollback hingegen führt wirklich zu einem Rollback bis zum Erstellungszeitpunkt der äußersten (physischen) Transaktion. Daher darf, bis die äußerste Transaktion geschlossen wurde, keine weitere Transaktion geöffnet werden: Nach einem Rollback müssen alle Transaktionen der Verbindung freigegeben werden, bevor die nächste geöffnet wird. Zur Fehlerprotokollierung nach einem Rollback wurde ein Modus geschaffen, mit dem Transaktionen auch dann gestartet werden können, wenn noch nicht alle Transaktionen abgeräumt wurden. Das erfolgt durch den Aufruf von Begin-/CreateTransaction (TransactionBeginMode.Rollback). Dadurch wird jedoch eine innere Transaktion zur physischen Transaktion und es können weitere, innere Transaktionen auf Basis dieser erstellt werden. Die folgende Tabelle zeigt die Eigenschaften und Methoden der Klasse FrameworkDataTransaction. Eigenschaft ActiveTransaction Die innerste Transaktion der Verbindung. Connection Die FrameworkDataConnection, mit der das Transaktionsobjekt erzeugt wurde. InnerTransaction Die innere Transaktion oder null, falls diese nicht existiert. IsActive Genau dann true, wenn die Transaktion die innerste ist. IsDisposed Genau dann true, wenn bereits ein Dispose aufgerufen wurde. Dies geschieht auch an allen inneren Transaktionen der Wurzeltransaktion nachdem ein Rollback ausgeführt wurde. IsolationLevel Die Isolationsstufe. IsOpen Genau dann true, wenn die Transaktion noch nicht Comitted, Rollbacked oder Disposed wurde. IsPhysical Genau dann true, wenn die Transaktion die physische ist. IsRoot Genau dann true, wenn die Transaktion die äußerste ist. OuterTransaction Die äußere Transaktion oder null, falls diese nicht existiert. PhysicalTransaction Die physische Transaktion, auf die diese Transaktion verweist. RootTransaction Die äußerste Transaktion der Verbindung. TransactionProvider Die native Transaktionsinstanz der Root-Transaction (innere Transaktionen besitzen keinen eigenen TransactionProvider und zeigen nur auf den der RootTransaction). Methode Commit() Schreibt die Änderungen in die Datenbank. Danach darf bis zum Dispose-Aufruf keine weitere Transaktion an der Verbindung geöffnet werden. Dispose() Wird üblicherweise vom using-Block automatisiert am Ende aufgerufen. Sollte bis dahin kein Commit-Aufruf erfolgt sein, so wird Rollback aufgerufen. Rollback() Verwirft alle Änderungen, die seit dem Öffnen der äußersten Transaktion gemacht wurden. Danach müssen alle Transaktionen geschlossen werden, bevor eine neue erzeugt wird. RegisterkarteSource(FrameworkDataTransaction.ISource) Registriert ein FrameworkDataTransaction.ISource Objekt an der Transaktion. Components und Collections implementieren dieses Interface, um nach einem Commit/Dispose die Methoden OnRollback() bzw. OnAfterCommit() aufzurufen. In OnRollback() würden die Originalwerte wiederhergestellt werden. Parallel zu OnAfterCommit() wird ApplyChanges() ausgeführt. Wird darin ein Save einer anderen Component aufgerufen, nimmt dieser quasi an der bereits geöffneten Transaktion teil. Transaktionen manuell verwalten Für komplexere Operationen kann es notwendig sein, dass eine Transaktion manuell gesteuert werden muss. Das kann zum einen in einer Komponente notwendig sein, wenn Sie in einer Methode hintereinander an anderen Components einen Save ausführen möchten, und das alles aber eine Transaktion ergeben soll. Eine Component besitzt eine CreateTransaction-Methode zur Erzeugung einer Transaktion (Methoden in jeder Component / Collection). Das folgende Beispiel zeigt, wie eine eigene Transaktion damit aufgebaut sein sollte. using(FrameworkDataTransaction transaction = this.CreateTransaction()) { this.oComponent1.Save(); this.oComponent2.Save(); transaction.Commit(); } Unabhängig von Komponenten kann auch an FrameworkDataConnection-Instanzen mittels BeginTransaction() eine Transaktion geöffnet werden. Jede Komponente, der ein DataSource zugewiesen ist, besitzt eine FrameworkDataConnection. Es sollte bevorzugt die Komponente gewählt werden, an der ggf. ein Save-Aufruf erfolgt. Das folgende Beispiel zeigt, wie eine Transaktion aufgebaut wird: FrameworkDataConnection connection = this.oComponent1.Connection; using(FrameworkDataTransaction transaction = connection.BeginTransaction()) { this.oComponent1.Save(); this.oComponent2.Save(); transaction.Commit(); } Der Unterschied zwischen dieser und der CreateTransaction-Vorgehensweise besteht darin, dass die Component/Collection sich in CreateTransaction zusätzlich an der äußersten Transaktion als FrameworkDataTransaction.ISource-Objekt registriert. Sobald die Transaktion endgültig geschlossen wird, teilt die Transaktion es den daran registrierten ISource-Objekten mit. Die Components und Collections benötigen diese Information, da sie ihre internen Originalwerte (die im Falle eines RollbackChanges-Aufrufs herangezogen werden) wiederherstellen oder die Änderungen akzeptieren müssen. Die folgenden zwei Beispiele zeigen, wie das zu verstehen ist. Ihre Wirkung ist identisch, sofern es sich bei der Transaktion um die einzige Transaktion der Verbindung handelt: using(FrameworkDataTransaction transaction = this.CreateTransaction()) { this.Save(); ... transaction.Commit(); bool committed = false; // bezieht sich auf die äußerste Transaktion using(FrameworkDataTransaction transaction = this.Connection.BeginTransaction()) { this.Save(); ... transaction.Commit(); committed = true; // sofern transaction die äußerste Transaktion ist } // Nachdem selbst auf der äußersten Transaktion ein Dispose aufgerufen wurde: if(committed) { this.ApplyChanges(); // Änderungen akzeptieren this.OnAfterCommit(); } else { this.OnRollback(); // Eine interne Routine => DB Originalwerte wiederherstellen } } Handelt es sich um eine innere Transaktion, so müsste im zweiten Beispiel der if-Block hinter der Freigabe der äußersten Transaktion erfolgen. Genauso muss sich die Variable comitted auf die äußerste Transaktion beziehen, da nur auf der äußersten Transaktion ein Commit erfolgen kann. Transaktionen Fehlerbehandlung Wenn bei einem Save eine Exception auftritt, darf diese nicht unterdrückt werden. Dadurch würde die Transaktion nicht mehr korrekt arbeiten und ggf. falsche Daten in die Datenbank gelangen. Wenn während dem Save in einer Component ein Fehler auftritt, dann wird die Transaktion mit einem Rollback() zurückgesetzt. Der Rollback() wird – im Gegensatz zum Commit() – sofort ausgeführt. Wenn durch das Unterdrücken der Exception nachfolgende Speicher-Vorgänge normal aufgerufen werden, hat das zur Folge, dass beim nächsten Save eine neue Transaktion gestartet wird. Diese würde dann außerhalb der ursprünglich geöffneten Transaktion laufen. Deshalb muss im Fehlerfall immer eine weitere Exception geworfen werden. try { this.oComponent1.Save( ); this.oComponent2.Save( ); } catch (Exception e) { throw new Exception(`Error”, e); } Wenn im Falle einer Exception innerhalb einer Transaktion eine eigene Protokollierung oder ein kontrolliertes Zurücksetzten von Daten in der Datenbank realisiert werden soll, dann muss dafür eine spezielle Transaktion geöffnet werden. Zuvor muss ein Rollback auf der aktuellen Transaktion ausgeführt werden. ... } // eine Fehlerbehandlung mit try-catch catch { ... // oder eine andere Fehler-Situation: if( bError ) { IcdLogEntry oLogEntry = cdLogEntryFactory.Create(); // Fehler, also Rollback – wenn eine Transaktion offen ist if (oLogEntry.Connection.ActiveTransaction != null) { oLogEntry.Connection.ActiveTransaction.Rollback(); } // Wenn die Transaktion bekannt ist, geht auch oTrans.Rollback(); // nun wird eine eigene spezielle Hilfs-Transaktion aufgemacht.. // Diese sollte immer oTransError heißen. using (FrameworkDataTransaction oTransError = oLogEntry.CreateTransaction(TransactionBeginMode.Rollback)) { ... oLogEntry.Save(); ... // Daten zurücksetzen uns speichern... ... oTransError.Commit(); } // In einer Exceptiopn den Fehler weiterwerfen oder anders behandeln throw; // Ansonsten eine Excetpion bzw. FrameworkApplicationException auslösen, damit evtl. // außerhalb organisierte Transaktion richtig reagieren können. throw new FrameworkApplicationException (\"error..\"); } Dieser Mechanismus funktioniert nur nach einem Rollback. Ansonsten wird eine ganz normale Transaktion geöffnet, die sich unter die bereits geöffnete Transaktion eingliedert. Diese würde entweder erst ganz am Ende commitet oder im Fehlerfall auch wieder rollbacked werden. Beispiel einer Transaktion // Transaktion starten using (FrameworkDataTransaction oTrans = oObjectXY.CreateTransaction()) { // Nun kann mit dieser Transaktion gearbeitet werden ... // z.B. auch ein Save am oObjectXY: oObjectXY.Save(); oObjectOtherColl.Save(); ... // wird hier kein Commit() ausgeführt, so wird am Ende des using-Blocks // automatisch ein Rollback() ausgelöst oTrans.Commit(); } Anstatt mit oObjectXY kann innerhalb einer Component-Methode auch direkt mit this.CreateTransaction() gearbeitet werden, sofern das this-Objekt einen Data-Source besitzt und dieser den o.g. Anforderungen an die Connection-Einheitlichkeit erfüllt. Weitere wichtige Fakten Der Commit-Aufruf sollte möglichst immer der letzte Code im using-Block sein. Aktionen nach dem Commit – insbesondere Save-Aktionen – könnten zu Exceptions führen. Wenn, dann müssen diese Aktionen hinter den using-Block gepackt werden. Besonders zu beachten sind vorzeitige Ausstiege aus der Funktion (return…) oder verschluckte Exceptions (catch). Beim Code-Review oder einem Umbau können Sie diese Stellen ganz einfach mit einer Suche nach return bzw. catch finden. Siehe auch Abschnitt Using-Block vorzeitig verlassen. Die alte Transaktions-Logik muss durch die neue ersetzt werden. Die alten Methoden sind als [Obsolete] gekennzeichnet und deren Verwendung führt beim Compile zu Warnungen. Es dürfen keine eigenen Transaktionen an der physischen Connection (ConnectionProvider) geöffnet werden. Diese würden die FS-Logik durcheinander bringen. Die Arbeit mit den Provider-Objekten ist prinzipiell Tabu!!! Exception-Handling Wenn beim Einsatz einer Transaktion eine Exception behandelt werden soll, dann ist es empfehlenswert, dies außerhalb des using-Blocks zu machen. Beispiel: try { using (FrameworkDataTransaction oTrans = this.CreateTransaction()) { ... oTrans.Commit(); } } catch (Exception ex) { // Ausnahme hier behandeln } Using-Block vorzeitig verlassen Manchmal kann es nötig sein, eine Funktion und damit den using-Block vorzeitig zu verlassen. Sollen die Daten gespeichert bleiben, muss frühzeitig ein Commit() stattfinden. Findet dieser nicht statt, wird der using-Block ohne Commit() verlassen und es gibt automatisch einen Rollback. using (FrameworkDataTransaction oTrans = this.CreateTransaction()) { ... if (bAllCompleted_Vorzeitig) { oTrans.Commit(); return; } if (bXyz) { return; // würde automatisch einen Rollback() erzeugen. } ... oTrans.Commit(); } Spezialfall: Transaktionen bei mehreren Connections Wenn mehrere Connections bei einer Logik betroffen, sind und auf beiden übergreifend eine Transaktion organisiert werden soll, dann müssen jeweils Transaktionen geöffnet und diese verschachtelt werden. Auch hier sollten beide Commit()-Aufrufe ganz am Ende der using-Blöcke stehen. using(FrameworkDataTransaction oTrans1 = oObject1.CreateTransaction()) { using(FrameworkDataTransaction oTrans2 = oObject2.CreateTransaction()) { // Aktionen auf beiden Connections... ... oTrans2.Commit(); } oTrans1.Commit(); } Oder direkt mit den Connections, wenn diese verfügbar sind. Es könnte auch Connection und Object gemischt werden. using(FrameworkDataTransaction oTrans1 = oConnection1.BeginTransaction()) { using(FrameworkDataTransaction oTrans2 = oConnection2.BeginTransaction()) { // Aktionen auf beiden Connections... ... oTrans2.Commit(); } oTrans1.Commit(); }"
  },
  "doc/weitere-themen/unit-tests.html": {
    "href": "doc/weitere-themen/unit-tests.html",
    "title": "Unit-Tests",
    "keywords": "Unit-Tests Note Dieses Feature steht aktuell nur im Haus von Nissen & Velten zur Verfügung. Über einen Befehl Run UnitTest ist es möglich eine spezielle Application zu starten, die dafür vorgesehen ist, Unit-Tests auszuführen. Beim Start der Application mit F5 zieht das aktuell eingestellte Setting. Für die Unit-Tests gibt es parallel ein eigenes \"aktuelles Unit-Test-Setting\" gespeichert. Darin kann z.B. eine eigene Application mit einem anderen Start-Workflow verwendet werden, damit ein direkter Einstieg in die Unit-Test-UI gewährleistet wird. Es können (und müssen) aber auch alle anderen Einstellungen wie z.B. DB-Connections und Runtime-Lizenzen definiert werden. Im Run-Wizard können diese Settings ganz normal, wie alle anderen Setting auch, gespeichert und geladen werden. Im Menu Compile gibt es 2 Menu-Items für den Start dieser Application: Run UnitTest: Beendet die laufende Application und startet eine neue Application mit dem aktuellen Unit-Test-Setting. Run Wizard UnitTest...: Es öffnet sich der Run-Wizard und es kann das aktuellen Unit-Test-Setting konfiguriert werden. Beim ersten Aufruf wird das aktuelle (normale) Setting kopiert. In den Designer-Fenstern für Components und CodeFiles gibt es im Menu UnitTest dieselben Befehle. Damit können gezielt diese Tests dieser konkreten Klasse ausgeführt werden. Note Diese Befehle sind nur bei entsprechend markierten Test-Klassen aktiv. Bei Code-Files muss der Name mit ...Test enden. z.B. StringUtilTest. Zudem kann hier der Compile step UnitTest gewählt werden. Bei Components muss am Anfang der Description ein [Test...]-Attribut stehen. [TestClass] In dieser Klasse werden Tests für Abc abgebildet ... Der FullName der Component bzw. des CodeFiles wird als Envrionment-Variable NVUnitTestItem an die Application übergeben. Diese Variable kann in der Application an jeder beliebigen Stelle ausgewertet werden: string testClassFullName = Environment.GetEnvironmentVariable(\"NVUnitTestItem\");"
  },
  "doc/weitere-themen/webconfig.html": {
    "href": "doc/weitere-themen/webconfig.html",
    "title": "web.config",
    "keywords": "web.config Die Datei web.config ist die Konfigurations-Datei der ASP.net-Seite, welche die Anfragen des Brokers verarbeitet. Sie liegt im Ordner der Web-Application. Im Abschnitt <appSettings> müssen einige Einstellungen vorgenommen werden, damit der Broker seine Arbeit verrichten kann: ApplicationsDirectory Gibt an, in welchem Ordner die Anwendungs-Dateien abgelegt sind. Hier muss der gleiche Ordner wie in der FrameworkStudio.exe.config angegeben werden. Application Gibt an, welche Applikation gestartet werden soll. Hier muss der Name der Applikation angegeben werden, mit der im Code-Builder kompiliert wurde. LogRequestXmlPath Gibt an, in welche Datei das XML geschrieben werden soll, das bei jeder Anfrage an den Broker geschickt wird. Diese Einstellung braucht nicht angegeben zu werden. Wenn dieser Eintrag nicht vorhanden ist, wird die Datei einfach nicht geschrieben. Wenn dieser Eintrag angegeben ist, wird dafür gesorgt, dass der Windows-Benutzer ASP.net Schreibzugriff auf diese Datei hat. LogResponseXmlPath Gibt an, in welche Datei das XML geschrieben werden soll, das der Broker an den Client zurückschickt. Es gilt hier das gleiche wie bei LogRequestXmlPath. Als Beispiel folgt ein Auszug aus einer Web.config: <configuration> <appSettings> <add key=\" RepSerConStr\" value=\"data source=NVDEV;initial catalog=BusinessRep;integrated security=false;persist security info=False;user id=FrameworkBroker;password=nv;packet size=4096\" /> <add key=\"ApplicationsDirectory\" value=\"C:\\\\inetpub\\\\wwwroot\\\\Applications\"/> <add key=\"Application\" value=\"BusinessRep.Start\" /> <add key=\"LogRequestXmlPath\" value=\"C:\\\\Inetpub\\\\wwwroot\\\\businessrep\\\\FrameworkRequest.xml\"/> <add key=\"LogResponseXmlPath\" value=\"C:\\\\Inetpub\\\\wwwroot\\\\businessrep\\\\FrameworkResponse.xml\"/> </appSettings> …"
  },
  "doc/workflow-designer/bearbeiten.html": {
    "href": "doc/workflow-designer/bearbeiten.html",
    "title": "Erstellen, Öffnen und Löschen eines Workflows",
    "keywords": "Erstellen, Öffnen und Löschen eines Workflows Erstellen Wenn Sie einen Workflow erstellen wollen, der ausschließlich eine Instanz eines bereits erstellten Forms enthält, dann wählen Sie im Form Designer des gewünschten Forms den Menüpunkt Edit / New Workflow for WorkflowForm aus. Ihnen wird dann vollautomatisch ein Workflow mit geeignetem Namen und der gewünschten Form Instanz im Namespace des Forms erzeugt. In allen anderen Fällen gehen Sie wie folgt vor: Markieren Sie den Namespace, in dem der Workflow erstellt werden soll. Um jetzt einen Workflow zu erstellen, gibt es zwei Möglichkeiten: Mit dem Button (New) oder über das Context-Menu des Namespaces (New / Workflow). Direkt nachdem der Workflow erzeugt wurde, können Sie den Namen des Workflows überschreiben. Es empfiehlt sich, den Namen mit wfl zu beginnen. Der Name des Workflows kann auch nachträglich noch geändert werden. Das geht mit dem Befehl Rename im Context-Menu des Workflows. Öffnen Durch einen Doppelklick auf einen Workflow auf der Registerkarte Overview wird dieser geöffnet. Für diesen Workflow wird auf der rechten Seite des Fensters eine Registerkarte mit dem Namen des Workflows erstellt. Auf dieser Registerkarte wird der Workflow angezeigt. Es können mehrere Workflows gleichzeitig geöffnet sein. Löschen Löschen können Sie einen Workflow mit dem Button (Delete). Sie müssen dazu den gewünschten Workflow im Namespace-Baum markiert haben. Es gibt auch im Context-Menu einen Eintrag Delete. Der Löschvorgang wird erst wirksam, wenn Sie den Button (Save All) drücken."
  },
  "doc/workflow-designer/design.html": {
    "href": "doc/workflow-designer/design.html",
    "title": "Design des Workflows",
    "keywords": "Design des Workflows Nachdem der Workflow geöffnet wurde, wird dieser auf der Registerkarte Designer grafisch dargestellt und bearbeitet. Um den Workflow und dessen Elemente zu bearbeiten, müssen Sie das entsprechende Element markieren; anschließend können Sie im Property-Grid oder über das Context-Menu Einstellungen ändern. Es gibt zum einen den Workflow selber, der markiert wird, in dem Sie auf den Hintergrund klicken und die Workflow-Elemente; das können Forms oder andere Workflows sein. Weiterhin gibt es noch Links, welche die einzelnen Workflow-Elemente verbinden und Branches und Switches, mit denen es möglich ist, Links zu verzweigen und mit Bedingungen zu versehen. Um neue Workflow-Elemente in einem Workflow zu erstellen, müssen Sie ein Form oder einen Workflow per Drag & Drop auf die Design-Fläche ziehen. Wie was auf den Workflow gezogen wird, ist in den folgenden Abschnitten beschrieben. Workflow-Properties DesignSize Größe des Design-Bereiches. Dieser Wert kann in den Properties nicht geändert werden. Um die Größe zu ändern, kann der Design-Bereich markiert und mit der Maus vergrößert oder verkleinert werden. Name Bezeichnung des ausgewählten Workflows. StartInstance (Workflow-Form) Gibt an, welches Form beim Start des Workflows angezeigt werden soll. Alternativ können Sie in den Properties des Workflow-Forms IsStartinstance auf True setzen. StartMethod Gibt an, welche Form-Methode aufgerufen werden soll, wenn beim Start des Workflows ein Form angezeigt werden soll. Es werden die Methoden des unter StartInstance eingestellten Forms angeboten. Wird der Workflow so aufgerufen, dass gezielt ein Form mit einer Methode gestartet werden soll, ist diese Angabe hier hinfällig. IsStartable (True, False) Wollen Sie den ausgewählten Workflow zu einer Startinstanz für Ihre Applikation machen, müssen Sie hier True auswählen. Default: False. SafeInitialize (True, False) Gibt an, ob beim Start der Anwendung der Safe-Initialize-Modus aktiviert werden soll. Diese Einstellung kann nur an einem Start-Workflow vorgenommen werden. Der Safe-Initialize-Modus dient dazu, z.B. in einer Update-Situation Fehlermeldungen zu unterbinden. Über this.Global.SafeInitializing kann der Status dieses Modus abgefragt werden. Der Modus muss mithilfe der Funktion this.Global.EndSafeInitialize() nach dem Start der Anwendung zurückgesetzt werden. BaseFullName Dieses Property ist für spätere Erweiterungen vorgesehen und zurzeit ohne Funktion. CheckedOutDateString (Schreibgeschützt) Datum des letzten Checkouts. CheckedOutUserName (Schreibgeschützt) Benutzer, der den Workflow zuletzt bearbeitet und eingecheckt hat. Wenn Sie den Workflow gerade ausgecheckt haben, steht Ihr Benutzername in diesem Feld. Workflow-Form Die Forms werden in der Registerkarte Design auf der linken Seite des Fensters angeboten und können von dort aus in den Workflow gezogen werden. Ein Form kann als Start-Instance und/oder Entrance-Instance definiert werden. Wenn ein Workflow gestartet wird, gibt es zwei Möglichkeiten, wie entschieden wird, welches Form aufgerufen werden soll: Beim Aufruf wird nichts angegeben, d.h. es wird nur der Workflow gestartet, ohne dass ihm gesagt wird, was er machen soll. Dann wird das Form gestartet, das als Start-Instance definiert ist. Beim Aufruf des Workflows wird gesagt, welches Form gestartet werden soll. Das lässt sich aber nur mit Forms machen, die als Entrance-Instance definiert sind. (Weitere Einzelheiten dazu sind im Workflow-Link erklärt.) Wenn Sie das erste Form in den Workflow ziehen, wird es automatisch als Start-Instance definiert. Workflow-Form Properties Die Eigenschaften des Workflow-Elements werden im Property-Grid definiert. Frame Gibt an, in welchem Frame das Fenster angezeigt werden soll. Es werden hier alle Frames angezeigt, die im Frameset in der Configuration definiert sind. Wird das Form als modaler Dialog angezeigt, hat diese Einstellung keine Auswirkung. (siehe Property IsModal) IsEntranceInstance (True, False) Gibt an, ob es sich bei diesem Form um eine Entrance-Instance handelt. Forms, die als Entrance-Instance definiert sind, können beim Aufruf des Workflows direkt angesprochen werden. Andere Forms können nur innerhalb des Workflows, indem sie sich befinden, angesprochen werden. IsModal (true, false) Gibt an, ob das Form als modaler Dialog geöffnet werden soll. Wird ein Form von einem anderen modalen Dialog geöffnet, wird dieses immer modal angezeigt – egal was bei IsModal angegeben ist. IsStartInstance (True, False) Gibt an, ob das Form eine Start-Instance sein soll. Wird der Workflow geöffnet und kein Form direkt angesprochen, wird das Form geöffnet, das als Start-Instance definiert ist. Warning Es kann maximal ein Form als Start-Instance gekennzeichnet sein. Location (schreibgeschützt) Position des Forms innerhalb des Workflows. In den Properties kann dieser Wert nicht verändert werden. Um die Position zu verändern, muss das Form im Design-Panel mit der Maus verschoben werden. Name Name des Workflow-Elements. Wenn das Form in den Workflow gezogen wird, wird der Name des Forms vorbelegt. Size (schreibgeschützt) Größe des Forms im Workflow. In den Properties kann der Wert nicht verändert werden. Um die Größe des Forms zu ändern, muss diese im Designer mit der Maus geändert werden. BaseFullName Dieses Property ist für spätere Erweiterungen vorgesehen und zurzeit ohne Funktion. Workflow-Forms Events Im Event-Teil des Property-Grids können die Workflow-Events des Forms mit den Workflow-Events des Workflows, in dem sich das Form befindet, verbunden werden. Das ist aus folgendem Grund notwendig: Wenn dieser Workflow in einen anderen Workflow eingebunden wird und dort wollen Sie auf ein Workflow-Event aus dem Form reagieren, dann ist es notwendig dieses Form-Event nach außen weiter zu reichen. Das passiert hier in dieser Zuordnung. In dieser Liste werden alle Workflow-Events des Forms aufgelistet. FiredEvent Soll das Workflow-Event eines Forms im Workflow selber nach außen angeboten werden, muss das Event des Forms mit einem Event aus dem Workflow verbunden werden. Diese Zuordnung kann in FiredEvent vorgenommen werden. Workflow im Workflow Die Workflows werden in der Registerkarte Namespaces angeboten (dort wo sie auch verwaltet werden). Von dort aus können sie per Drag & Drop in die Design-Fläche gezogen werden. Workflow im Workflow Properties Die Eigenschaften des Workflow-Elements werden auf der Registerkarte Property definiert. IsEntranceInstance (true, false) Gibt an, ob das Workflow-Element als Entrance-Instance fungieren soll. Wenn ja, dann ist es möglich diesen Workflow (das Element) von außen direkt anzusprechen (analog zu den Forms). Location (schreibgeschützt) Position des Workflows innerhalb des Workflows. In den Properties kann dieser Wert nicht verändert werden. Um die Position zu verändern, ist es erforderlich diesen Workflow im Design-Panel mit der Maus zu verschieben. Name Name des Workflow-Elements. Dieser Wert wird automatisch mit dem Namen des Workflows, der hineingezogen wird, vorbelegt. Size (schreibgeschützt) Größe des Workflows im Workflow. In den Properties kann der Wert nicht verändert werden. Um die Größe des Workflows zu ändern, wird diese im Designer mit der Maus geändert. BaseFullName Dieses Property ist für spätere Erweiterungen vorgesehen und zurzeit ohne Funktion. Workflow im Workflow Events Auch Workflows können wie die Forms Workflow-Events besitzen. Wenn diese nach außen weitergereicht werden sollen, funktioniert das genau wie bei den Forms. (Workflow-Forms Events) Link Ein Link dient zum Verbinden zweier Workflow-Elemente. Er hat als Ausgangspunkt ein Workflow-Event von einem Workflow-Element. Als Ziel hat er ein anderes Workflow-Element. Auf der Registerkarte Design wird der Link angeboten. Ziehen Sie ihn per Drag & Drop auf das Ausgangs-Element. Anschließend ziehen Sie das Ende des Pfeils auf das Ziel-Element. Es öffnet sich ein Dialog, in dem Sie genau einstellen können, wie sich der Link verhalten soll. Sie können diesen Dialog auch später wieder öffnen, um Änderungen am Link durchzuführen. Im Context-Menu des Links wird dazu der Befehl Properties angeboten. Link-Properties Name Name des Links. Dieser wird immer mit Link1 vorbelegt. Source (schreibgeschützt) Name des Ausgangs-Elements. SourceEvent In dieser Combobox werden alle Workflow-Events des Ausgangs-Elements angeboten. Sie müssen hier auswählen, auf welches der Link reagieren soll. Container In dieser Combobox werden alle FormContainer- und DashboardContainer-Steuerelemente des Quellformulars angezeigt. Wird ein Wert ungleich null eingestellt, so wird das Zielformular in diesem Container erstellt und angezeigt. In diesem Fall ist jedoch keine automatische Fokussierung möglich. Target Gibt das Ziel-Element an. Das kann hier nachträglich noch geändert oder auch genauer angegeben werden. Die Combobox zeigt alle Workflow-Elemente des Workflows an. Zusätzlich werden für jeden Workflow die als Entrance-Instance definierten Elemente angezeigt. Sie können z.B. gezielt ein Form ansprechen. Wenn Sie das machen, gibt es auch die Möglichkeit an dem Form eine Methode anzustoßen. Target Method Ist in Target ein Form angegeben, werden in der Combobox alle public-Methoden des Forms angeboten und Sie können eine Methode auswählen, die angestoßen werden soll. Hat die Methode Parameter, werden diese in der Tabelle unter der Methode aufgelistet. Es wird der Name das Parameters und der Typ des Parameters angezeigt. In der dritten Spalte geben Sie an, welcher Wert übergeben werden soll. In der Combobox werden alle public Membervariablen des Forms mit deren Properties angegeben. Sie können einen Wert aus der Liste angeben. Wenn es sich bei dem Parameter um eine Zahl oder einen String handelt, können Sie auch bestimmte Werte angeben. Z.B. Löschen können Sie einen Link über das Context-Menu des Links mit dem Befehl Delete. InstanceID Um mehrere Instanzen eines Formulars anlegen zu können, muss am Quellformular ein Property vom Datentyp string oder FSstring angelegt werden. Dieses Property enthält die Instanz ID des nächsten Formulars, welches mittels Workflow-Event erstellt wird. Genau dann, wenn diese Instanz ID beim Aufruf des Workflow Events mit keiner bereits existierenden übereinstimmt, wird eine neue Instanz erzeugt. Das Property, welches die neue ID darstellt, wird in diesem Feld innerhalb der Workflow-Link Eigenschaften angegeben. Wird das Feld leer gelassen, so gilt die Instanz-ID des Workflows. Create Target Nur wenn dieser Wert auf „true“ steht wird für den Fall, dass das Formular (unter Berücksichtigung der InstanceID) noch nicht instanziiert wurde, ein neues Formular erzeugt. AutoFocus Steht dieser Wert auf true, so wird der Fokus nach Aufruf des Workflow-Events in das Zielformular gesetzt. Branch Mit einem Branch können Sie einen Link mit einer Bedingung versehen oder verzweigen. Ein Branch hat immer einen Link als Eingang und einen oder zwei Links als Ausgang. Welcher der Ausgänge aufgerufen wird, wird mit der Bedingung im Branch ermittelt. Die Bedingung ist ein boolscher Ausdruck. Je nachdem, wie das Ergebnis dieses boolschen Ausdrucks ist, wird der True-Zweig oder der False-Zweig aufgerufen. Indem nur einer dieser beiden Zweige verwendet wird, können Sie einen Link mit einer Bedingung erstellen. Einen Branch binden Sie ein, indem Sie ihn per Drag & Drop in den Workflow ziehen. Das Symbol befindet sich im unteren Teil der Registerkarte Design. Anschließend erstellen Sie einen Link von der Quelle zum Branch. Über das Context-Menu des Branchs können Sie den Property-Dialog öffnen. In ihm wird die Bedingung festgelegt. Im linken Teil des Fensters befinden sich alle Properties, die das Quellobjekt anbietet. Aus diesen Properties kann die Bedingung zusammengesetzt werden. Darunter befindet sich eine Liste der Operatoren. Mit einem Doppelklick in eine der beiden Listen wird der entsprechende Text in die Bedingung eingefügt. Der Text wird dabei an die Stelle des Cursors gesetzt. Es muss eine Bedingung herauskommen, die von .NET verarbeitet werden kann. Es wird später daraus folgender Code erstellt: if (Bedingung) { True-Link } else { False-Link } Wenn die Bedingung fertiggestellt ist, können die Links vom Branch zum Ziel (zu den Zielen) definiert werden. Dazu ziehen Sie einen neuen Link auf den Branch und den Pfeil des Links auf das Ziel. Es öffnet sich wie bereits beschrieben der Property-Dialog des Links. Als Source-Event kann jetzt true oder false ausgewählt werden. Es können jetzt noch weitere Links mit true oder false definiert werden. Beim Ausführen werden dann, wenn die Bedingung wahr ist, alle Links aufgerufen, die als Source-Event true besitzen und wenn die Bedingung falsch ist, alle Links, die als Source-Event false haben. Wird am Ziel eine Target-Method mit Parameter aufgerufen, können dieser Methode Werte aus der Quelle vor dem Branch mitgegeben werden. Switch Mit einem Switch kann ein Link mehrfach verzweigt werden. Ein Switch hat einen Link als Eingang und kann mehrere Links als Ausgang besitzen. Im Switch wird ein Property des Quell-Elements ausgewertet. Je nachdem, welchen Wert dieses Property besitzt, wird einer der Ausgänge angesprochen. Einen Switch binden Sie ein, indem Sie Ihn per Drag & Drop in den Workflow ziehen. Das Symbol befindet sich im unteren Teil der Registerkarte Design. Anschließend müssen Sie einen Link vom Quell-Element in den Switch ziehen. Über das Context-Menu des Switches gelangen Sie in einen Dialog, in dem Sie die Einstellungen des Switches festlegen können. Unter Object können Sie ein Property aus dem Quell-Element angeben. Für dieses Property wird anschließend unter Events festgelegt, welche Werte ausgewertet werden sollen. Jeder dieser Werte stellt einen Ausgang aus dem Switch dar. Es können Zahlen und Zeichenketten eingegeben werden. Jetzt müssen noch die Links vom Switch zu den Zielen definiert werden. Ziehen Sie dazu einen Link auf den Switch und verbinden Sie das Ende des Links mit dem Ziel. Als Source-Event werden jetzt die unter Event hinterlegten Einträge angeboten. Der Quellcode, der aus diesen Angaben generiert wird, sieht in etwa so aus: switch Form.Property { case Event1: { Link 1 } case Event2: { Link 2 } default: { Link 3 } } Global Events Mit Global Events können Events an alle geöffneten Workflows gesendet werden. Global Events werden auf der Registerkarte Namespaces abgelegt und mit Drag & Drop in den Designer gezogen werden. Auf der Registerkarte Namespaces werden direkt unter dem Event zwei Einträge angeboten: Das Event, das aufgerufen werden kann und der Event Handler, mit dem Sie auf das Event reagieren können. Global Events aufrufen Um ein Global Event aufzurufen, ist es nötig den ersten Eintrag per Drag & Drop in den Workflow zu ziehen. Anschließend wird ein Link vom aufrufenden Element in das Global Event gezogen. In den Link-Properties kann dann am Global Event eine Methode Init angegeben werden. Diese Methode enthält alle im Global Event definierten Parameter. So können Sie dem Global Event alle am aufrufenden Element zur Verfügung stehenden Properties übergeben. (Link-Properties) Auf Global Events reagieren Um auf ein Global Event zu reagieren, ist es erforderlich aus der Registerkarte Namespaces den zweiten Eintrag unter dem Global Event per Drag & Drop in den Workflow zu ziehen (gevXxxHandler). Den Event Handler erkennen Sie an dem Strich links am Oval und der Inschrift gevXxxHandler. Anschließend wird ein Link vom Global Event Handler in des Ziel-Element gezogen. In den Link-Properties können Sie bei einem Methoden-Aufruf am Ziel-Element als Parameter alle Parameter aus dem Global Event übergeben. In der Combobox für die Parameter werden die Parameter unter dem Eintrag „e“ angezeigt. (Link-Properties)"
  },
  "doc/workflow-designer/ueberblick.html": {
    "href": "doc/workflow-designer/ueberblick.html",
    "title": "Workflow Designer",
    "keywords": "Workflow Designer Der Workflow-Designer wird im Hauptfenster über das Menü Workflow >> Workflow Designer aufgerufen. Er dient – wie es der Name schon sagt – zum Gestalten von Workflows. In den Workflows wird festgelegt, wie die einzelnen Forms miteinander kommunizieren, bzw. wann welches Form angezeigt wird. Workflows können nicht nur Forms, sondern auch wiederum andere Workflows enthalten. Somit ist es möglich, Workflows modular aufzubauen und an jeder beliebigen Stelle wiederzuverwenden. Zur Orientierung folgt zunächst ein Überblick über den Workflow-Designer. Überblick Workflow Designer Registerkarte Namespaces Aus der Namespaces-Registerkarte können Forms, Global Events oder andere Workflows per Drag & Drop in den Workflow gezogen werden. ClassView Registerkarte Auf der Registerkarte ClassView werden die Workflow-Events des Workflows aufgelistet. Toolbox-Registerkarte Auf der Registerkarte Toolbox werden folgende Elemente angeboten: Link Switch Branch Sie können per Drag & Drop in den Workflow gezogen werden. Diese Elemente werden weiter unten genauer beschrieben. Registerkarte Designer Auf dieser Registerkarte wird der Workflow grafisch dargestellt. Auf diese Fläche müssen auch die Elemente gezogen werden, wenn sie dem Workflow hinzugefügt werden sollen."
  },
  "index.html": {
    "href": "index.html",
    "title": "Framework Studio 4.8",
    "keywords": "Framework Studio 4.8 Andere Versionen können hier aufgerufen werden. Diese Seite gliedert sich in folgende Teile, die über die Navigation im oberen Bereich aufgerufen werden können: 1.) Framework Studio 4.8 Hier finden sie Neuheiten, Release-Listen, aktuelle Informationen und Systemvoraussetzungen 2.) Technische Dokumentation Alle Dokumentationen und Anleitungen für die Framework Studio IDE, Programmier-Themen und andere Programme. 3.) Api-Dokumentation Umfasst eine generierte Dokumentation der von Framework Studio bereitgestellten Klassen und Schnittstellen."
  }
}