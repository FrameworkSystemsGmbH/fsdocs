{
  "api/FrameworkSystems.FrameworkBase.AccessControl.AccessUnit.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AccessUnit.html",
    "title": "Class AccessUnit",
    "keywords": "Class AccessUnit Die AccessUnit Klasse enthält die ID und Name einer AccessUnit. Inheritance Object AccessUnit Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class AccessUnit"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.AuthenticationEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.AuthenticationEnabled.html",
    "title": "Property AuthenticationEnabled",
    "keywords": "Property AuthenticationEnabled AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. Declaration public bool AuthenticationEnabled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePassword.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePassword.html",
    "title": "Method ChangePassword",
    "keywords": "Method ChangePassword ChangePassword(String, String) Ändert das Passwort des momentan angemeldeten Benutzers. Declaration public void ChangePassword(string oldPassword, string newPassword) Parameters oldPassword String newPassword String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePasswordChecked.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePasswordChecked.html",
    "title": "Method ChangePasswordChecked",
    "keywords": "Method ChangePasswordChecked ChangePasswordChecked(String, String, String, out Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. Declaration public void ChangePasswordChecked(string username, string oldPassword, string newPassword, out Message message, string loginInfo) Parameters username String oldPassword String newPassword String message AuthenticationService.Message loginInfo String beliebiger Text, der vom Authentication Service geloggt wird, darf null sein ChangePasswordChecked(String, Byte[], String, out Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. Declaration public void ChangePasswordChecked(string username, byte[] oldHashSign, string newPassword, out Message message, string loginInfo) Parameters username String oldHashSign Byte [] Der Hashwert des alten Passwortes. newPassword String message AuthenticationService.Message loginInfo String beliebiger Text, der vom Authentication Service geloggt wird, darf null sein"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetApplicationRoles.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetApplicationRoles.html",
    "title": "Method GetApplicationRoles",
    "keywords": "Method GetApplicationRoles GetApplicationRoles(Boolean) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. Declaration public List<string> GetApplicationRoles(bool reload) Parameters reload Boolean Mit true wird ein neues Laden der Rollen vom Authentication Service erzwungen. Returns List < String > GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. Declaration public List<string> GetApplicationRoles() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetPackages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetPackages.html",
    "title": "Method GetPackages",
    "keywords": "Method GetPackages GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. Declaration public List<AUHelper.PackageInfo> GetPackages() Returns List < AUHelper.PackageInfo > Remarks Das SystemPackage ist in der Liste nicht enthalten. Die Liste beginnt mit dem DefaultPackage und endet mit dem obersten CustomizingPackage. Die Klasse AUHelper.PackageInfo enthält über ein Package die Informationen ID, Name, Version und Hersteller (Manufacturer)."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleCaption.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleCaption.html",
    "title": "Method GetRoleCaption",
    "keywords": "Method GetRoleCaption GetRoleCaption(String) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. Declaration public string GetRoleCaption(string roleName) Parameters roleName String Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleDescription.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleDescription.html",
    "title": "Method GetRoleDescription",
    "keywords": "Method GetRoleDescription GetRoleDescription(String) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. Declaration public string GetRoleDescription(string roleName) Parameters roleName String Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserRoles.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserRoles.html",
    "title": "Method GetUserRoles",
    "keywords": "Method GetUserRoles GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. Declaration public List<string> GetUserRoles() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserUnits.html",
    "title": "Method GetUserUnits",
    "keywords": "Method GetUserUnits GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. Declaration public List<string> GetUserUnits() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Granted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Granted.html",
    "title": "Method Granted",
    "keywords": "Method Granted Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. Declaration public bool Granted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit type AUPermissionType Returns Boolean Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten. Prüft OnLicenseGranted(AccessUnit, AUPermissionType) , wenn die übergebene accessUnit erlaubt ist. Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1, AUPermissionType.Delete ) ) { //Delete granted } if ( this.Global.Granted(AUList.aufrmForm1, AUPermissionType.Insert) ) { //Insert granted } Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. Declaration public bool Granted(AccessUnit accessUnit) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList . Returns Boolean Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten. Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1 ) ) { //Access granted }"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.html",
    "title": "Class AUHelper",
    "keywords": "Class AUHelper Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. Inheritance Object AUHelper Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class AUHelper : ILicenseProvider Examples this.Global.AUHelper.ChangePassword( sOld, sNew ); Properties AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. LicenseVerifier Liefert den LicenseVerifier für die Verwaltung der ausgewerteten Lizenzen zurück. UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(String) ) angemeldet wurde. Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Methods ChangePassword(String, String) Ändert das Passwort des momentan angemeldeten Benutzers. ChangePasswordChecked(String, Byte[], String, out Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. ChangePasswordChecked(String, String, String, out Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetApplicationRoles(Boolean) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. GetRoleCaption(String) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetRoleDescription(String) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyDefaultUser(out Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyUnit(String) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. IdentifyUser(out Message, String, String, ref String, Boolean) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt Prüft OnLicenseGranted(AccessUnit, AUPermissionType) , wenn die übergebene accessUnit erlaubt ist. LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. Prüft OnLicenseGranted(AccessUnit, AUPermissionType) , wenn die übergebene accessUnit erlaubt ist. LicenseGrantedInFile(AccessUnit, AUPermissionType) Gibt zurück, ob die vorhandene Lizenz-Datei den Zugriff auf die übergebene AccessUnit erlaubt. OnLicenseGranted(AccessUnit, AUPermissionType) wird dabei nicht geprüft. RegisterUnits(IEnumerable<KeyValuePair<String, String>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyDefaultUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyDefaultUser.html",
    "title": "Method IdentifyDefaultUser",
    "keywords": "Method IdentifyDefaultUser IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyDefaultUser() Returns Boolean Gibt bei Erfolg true und bei einem Fehler false zurück. IdentifyDefaultUser(out Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyDefaultUser(out Message msg) Parameters msg AuthenticationService.Message Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. Returns Boolean Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUnit.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUnit.html",
    "title": "Method IdentifyUnit",
    "keywords": "Method IdentifyUnit IdentifyUnit(String) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. Declaration public void IdentifyUnit(string unitKey) Parameters unitKey String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUser.html",
    "title": "Method IdentifyUser",
    "keywords": "Method IdentifyUser IdentifyUser(out Message, String, String, ref String, Boolean) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyUser(out Message msg, string username, string password, ref string loginInfo, bool includeRolesInToken) Parameters msg AuthenticationService.Message Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. username String password String loginInfo String Der Parameter LoginIngo wird ausgelesen und vom Authentication Service geloggt. Zurückgegeben wird die zuletzt geloggte Information. includeRolesInToken Boolean Der letzte Parameter gibt an, ob die Rollen im Token kommuniziert werden sollen - Standardwert true Returns Boolean Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IsDefaultUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IsDefaultUser.html",
    "title": "Property IsDefaultUser",
    "keywords": "Property IsDefaultUser IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. Declaration public bool IsDefaultUser { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGranted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGranted.html",
    "title": "Method LicenseGranted",
    "keywords": "Method LicenseGranted LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. Prüft OnLicenseGranted(AccessUnit, AUPermissionType) , wenn die übergebene accessUnit erlaubt ist. Declaration public bool LicenseGranted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList . type AUPermissionType Eine AUPermissionType Returns Boolean Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt. Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access } LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt Prüft OnLicenseGranted(AccessUnit, AUPermissionType) , wenn die übergebene accessUnit erlaubt ist. Declaration public bool LicenseGranted(AccessUnit accessUnit) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList . Returns Boolean Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt. Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access }"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGrantedInFile.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGrantedInFile.html",
    "title": "Method LicenseGrantedInFile",
    "keywords": "Method LicenseGrantedInFile LicenseGrantedInFile(AccessUnit, AUPermissionType) Gibt zurück, ob die vorhandene Lizenz-Datei den Zugriff auf die übergebene AccessUnit erlaubt. OnLicenseGranted(AccessUnit, AUPermissionType) wird dabei nicht geprüft. Declaration public bool LicenseGrantedInFile(AccessUnit accessUnit, AUPermissionType type = AUPermissionType.Access) Parameters accessUnit AccessUnit type AUPermissionType Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseVerifier.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseVerifier.html",
    "title": "Property LicenseVerifier",
    "keywords": "Property LicenseVerifier LicenseVerifier Liefert den LicenseVerifier für die Verwaltung der ausgewerteten Lizenzen zurück. Declaration public LicenseVerifier LicenseVerifier { get; } Property Value FrameworkSystems.FrameworkBase.AccessControl.LicenseVerifier"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html",
    "title": "Field AssemblyPrefix",
    "keywords": "Field AssemblyPrefix Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string AssemblyPrefix Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.html",
    "title": "Class AUHelper.PackageInfo",
    "keywords": "Class AUHelper.PackageInfo Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden. Inheritance Object AUHelper.PackageInfo Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class PackageInfo Remarks Warning Die Klasse darf nicht im eigenen Code instanziiert werden. Fields AssemblyPrefix Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. ID Die eindeutige ID des Packages. LastCompileDate Zeitpunkt des letzten Compiles. Manufacturer Der im Package definierte Hersteller. Name Der Name des Packages. ProductName Der an der Package-Version definierte Product Name. PublicKey Der öffenliche Schlüssel des Packages. Version Die Version des Packages. WasLastCompileBugFix Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ID.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ID.html",
    "title": "Field ID",
    "keywords": "Field ID Die eindeutige ID des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly guid ID Returns Type Description guid"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.LastCompileDate.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.LastCompileDate.html",
    "title": "Field LastCompileDate",
    "keywords": "Field LastCompileDate Zeitpunkt des letzten Compiles. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly DateTime LastCompileDate Returns Type Description DateTime"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Manufacturer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Manufacturer.html",
    "title": "Field Manufacturer",
    "keywords": "Field Manufacturer Der im Package definierte Hersteller. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Manufacturer Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Name.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Name.html",
    "title": "Field Name",
    "keywords": "Field Name Der Name des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Name Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ProductName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ProductName.html",
    "title": "Field ProductName",
    "keywords": "Field ProductName Der an der Package-Version definierte Product Name. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string ProductName Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.PublicKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.PublicKey.html",
    "title": "Field PublicKey",
    "keywords": "Field PublicKey Der öffenliche Schlüssel des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly RSAKeyPair PublicKey Returns Type Description FrameworkSystems.FrameworkBase.License.RSAKeyPair"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Version.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Version.html",
    "title": "Field Version",
    "keywords": "Field Version Die Version des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Version Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html",
    "title": "Field WasLastCompileBugFix",
    "keywords": "Field WasLastCompileBugFix Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly bool WasLastCompileBugFix Returns Type Description Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.RegisterUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.RegisterUnits.html",
    "title": "Method RegisterUnits",
    "keywords": "Method RegisterUnits RegisterUnits(IEnumerable<KeyValuePair<String, String>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service. Declaration public void RegisterUnits(IEnumerable<KeyValuePair<string, string>> units) Parameters units IEnumerable < KeyValuePair < String , String >> Key = unit id / Value = unit name"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UnitKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UnitKey.html",
    "title": "Property UnitKey",
    "keywords": "Property UnitKey UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(String) ) angemeldet wurde. Declaration public string UnitKey { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Units.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Units.html",
    "title": "Property Units",
    "keywords": "Property Units Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. Declaration public IEnumerable<KeyValuePair<string, string>> Units { get; } Property Value IEnumerable < KeyValuePair < String , String >> Remarks KeyValuePair.Key = Schlüsselwert der Unit (Geschäftseinheit) KeyValuePair.Value = Name der Unit"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Username.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Username.html",
    "title": "Property Username",
    "keywords": "Property Username Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Declaration public string Username { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UserTokenAsString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UserTokenAsString.html",
    "title": "Property UserTokenAsString",
    "keywords": "Property UserTokenAsString UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Declaration public string UserTokenAsString { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.AccessControl",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.AccessControl Classes AccessUnit Die AccessUnit Klasse enthält die ID und Name einer AccessUnit. AUHelper Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. AUHelper.PackageInfo Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden. LicenseSerializer Die LicenseSerializer Klasse implementiert einen Serialisierter für die License und License2 Klassen."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.LicenseSerializer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.LicenseSerializer.html",
    "title": "Class LicenseSerializer",
    "keywords": "Class LicenseSerializer Die LicenseSerializer Klasse implementiert einen Serialisierter für die License und License2 Klassen. Inheritance Object LicenseSerializer Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class LicenseSerializer Examples // Allgemeine Lizenz Informationen reinschreiben License2 license = new License2(); license.LicenseID = guid.NewGuid(); license.LicenseName = \"Test License\"; license.LicenseType = LicenseTypes.Customer; license.Customer = \"NV\"; license.ValidFrom = DateTime.MinValue; license.ValidTo = new DateTime(2022, 12, 31); license.UserLimit = 25; license.Category = \"\"; license.Addition = \"\"; // Ein oder mehrere Packages hinzufügen license.Packages.Add(new LicensePackage { PackageID = new guid(\"fde6193cb96842aaaf0d5e005b1a0c8d\"), PackageName = \"FSDemo\", LabelID = new guid(\"59c39232d37c4107b99f423a2a56da8e\"), LabelName = \"4.3\", VersionFrom = null, VersionTo = new Version(4, 3), CustomInfos = new Dictionary<string, string> { { \"Key\", \"Value\" }, { \"Base64Data\", \"SGFsbG8gV2VsdA==\" }, } }); // Alle exklusiven AccessUnits mit ihren Ids hinzufügen foreach (guid exclusiveAccessUnitId in new guid[] { new guid(\"c8954266da5e4f0dbd0e2177393ee60c\") }) { license.ExclusiveAccessUnits.Add(exclusiveAccessUnitId); } // Alle berechtigten AccessUnits hinzufügen foreach (guid allowedAccessUnitId in new guid[] { new guid(\"AccessUnitRoot\"), new guid(\"36c417a410da4644bbfa5cc16fd0a4aa\") }) { license.AccessUnits.Set(allowedAccessUnitId, AUPermission.Allowed); } // PackageName / PrivateKey Repository, die PrivateKeys werden für die Signierung benötigt. Dictionary<string, RSAKeyPair> packageNamePrivateKeyRelation = new Dictionary<string, RSAKeyPair>(); packageNamePrivateKeyRelation.Add(\"FSDemo\", new RSAKeyPair()); // Hier wird in einen string geschrieben, möglich ist aber auch ein XDocument Objekt. string xmlText = LicenseSerializer.ToText(license, packageID => packageNamePrivateKeyRelation[packageID]); // Deserialisierung (ohne Verifikation) ILicense license = LicenseSerializer.FromText(xmlText);"
  },
  "api/FrameworkSystems.FrameworkBase.AUPermissionType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AUPermissionType.html",
    "title": "Enum AUPermissionType",
    "keywords": "Enum AUPermissionType Das AUPermissionType Enum kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public enum AUPermissionType Fields Name Description Access Is general access allowed? AccessDerived Is access of an AccessUnit, which is derived from this AccessUnit, possible? Delete Is deleting allowed? Insert Is inserting allowed? Update Is updating allowed?"
  },
  "api/FrameworkSystems.FrameworkBase.BarcodeFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BarcodeFormat.html",
    "title": "Enum BarcodeFormat",
    "keywords": "Enum BarcodeFormat Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Flags] public enum BarcodeFormat Fields Name Description ALL Es werden alle Barcode-Formate unterstützt. AZTEC CODABAR CODE_128 CODE_39 CODE_93 DATA_MATRIX EAN_13 EAN_8 ITF NONE Der Scan-Vorgang hat keinen Barcode ermittelt. PDF_417 QR_CODE UPC_A UPC_E"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.BROKER_TAG.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.BROKER_TAG.html",
    "title": "Field BROKER_TAG",
    "keywords": "Field BROKER_TAG Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string BROKER_TAG = \"fsbroker://\" Returns Type Description String Remarks Ressourcen mit fsbroker://RelativerPfad werden von dem Browser ausgewertet und durch den absoluten Pfad ersetzt."
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateArgument.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateArgument.html",
    "title": "Method CreateArgument",
    "keywords": "Method CreateArgument CreateArgument(String, Object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. Declaration public static KeyValuePair<string, string> CreateArgument(string key, object value) Parameters key String value Object Returns KeyValuePair < String , String > Remarks So können z.B. die FS-Datentypen wie in dem nachfolgenden Beispiel als Wert übergeben werden: string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); Die FrameworkOnLinkClickEventArgs bieten Methoden GetArgument -Methoden (z.B. GetArgumentFSlong ) um mit dem richtigen Schlüssel einen Wert im entsprechenden FSTyp wieder auszulesen. Auslesen der Argumente im Browser-Event OnLinkClick : if (e.IsCommand && e.Command == \"TestCommand\") { FSlong lngDocumentID = e.GetArgumentFSlong(\"Belegnummer\"); FSstring sDocumentType = e.GetArgumentFSstring(\"Belegart\"); FSDateTime dtDate = e.GetArgumentFSDateTime(\"Datum\"); }"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateCommand.html",
    "title": "Method CreateCommand",
    "keywords": "Method CreateCommand CreateCommand(String, IDictionary<String, String>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. Declaration public static string CreateCommand(string commandName, IDictionary<string, string> args = null) Parameters commandName String args IDictionary < String , String > Returns String Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando ( commandName ) und über eine beliebige Anzahl von Argumenten ( args ). Die Argumente bestehen immer aus einem Schlüssel ( Key ) und einem Wert ( Value ) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: //Command-Args erstellen Dictionary<string, string> linkCommandArgs = new Dictionary<string, string>(); linkCommandArgs.Add(\"Key1\", \"1235\"); linkCommandArgs.Add(\"Key2\", \"Test\"); linkCommandArgs.Add(\"Key3\", \"Test 1234\"); // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", linkCommandArgs); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\"; CreateCommand(String, KeyValuePair<String, String>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. Declaration public static string CreateCommand(string commandName, params KeyValuePair<string, string>[] args) Parameters commandName String args KeyValuePair < String , String >[] Returns String Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando ( commandName ) und über eine beliebige Anzahl von Argumenten ( args ). Die Argumente bestehen immer aus einem Schlüssel ( Key ) und einem Wert ( Value ) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die einzelnen Argumente können mit der Methode CreateArgument(String, Object) erzeugt werden, um die Konvertierung verschiedener Typen korrekt vorzunehmen. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", new KeyValuePair<string, string>(\"Key1\", \"Wert1\"), BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\";"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateRessourcesUrl.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateRessourcesUrl.html",
    "title": "Method CreateRessourcesUrl",
    "keywords": "Method CreateRessourcesUrl CreateRessourcesUrl(String) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. Declaration public static string CreateRessourcesUrl(string relativePath) Parameters relativePath String Returns String Remarks Diese Url kann dann, wie im nachfolgendem Beispiel, in Verbindung mit HTML z.B. als Link zu einer Datei verwendet warden: // Link zu einer CSS-Datei sStyle = \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + BrowserCommand.CreateRessourcesUrl(\"test.css\") + \"\\\" />\";"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.html",
    "title": "Class BrowserCommand",
    "keywords": "Class BrowserCommand Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. Inheritance Object BrowserCommand Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class BrowserCommand Fields BROKER_TAG Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Methods CreateArgument(String, Object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. CreateCommand(String, IDictionary<String, String>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateCommand(String, KeyValuePair<String, String>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateRessourcesUrl(String) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. TryParseCommand(String, out String, out Dictionary<String, String>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(String, IDictionary<String, String>) und extrahiert, falls es sich bei dem übergebenen Link ( url ) um ein Link-Kommando handelt, das Kommando ( commandName ) und die Argumente ( args ). Andernfalls wird false zurückgegeben."
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.TryParseCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.TryParseCommand.html",
    "title": "Method TryParseCommand",
    "keywords": "Method TryParseCommand TryParseCommand(String, out String, out Dictionary<String, String>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(String, IDictionary<String, String>) und extrahiert, falls es sich bei dem übergebenen Link ( url ) um ein Link-Kommando handelt, das Kommando ( commandName ) und die Argumente ( args ). Andernfalls wird false zurückgegeben. Declaration public static bool TryParseCommand(string url, out string commandName, out Dictionary<string, string> args) Parameters url String commandName String args Dictionary < String , String > Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.CameraSource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.CameraSource.html",
    "title": "Enum CameraSource",
    "keywords": "Enum CameraSource Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum CameraSource Fields Name Description CAMERA Öffnet auf dem Endgerät die Kamera zum erstellen eines neuen Fotos GALLERY Öffnet auf dem Endgerät die Bildergalerie zur Auswahl eines Fotos"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Configuration.Runtime",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Configuration.Runtime Classes RuntimeConfig Statische Klasse für den Einstieg in die Runtime-Konfiguration. RuntimeConfigExtensions Interfaces IRuntimeConfigProvider Managed die Runtime-Konfigurationen. Eine Instanz kann über das statische Property RuntimeConfig . Get abgerufen werden."
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServiceDescription.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServiceDescription.html",
    "title": "Property AppServiceDescription",
    "keywords": "Property AppServiceDescription AppServiceDescription Gibt die Beschreibung der Application zurück. Diese wird dem dem Authentication-Service migeteilt. Declaration string AppServiceDescription { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServiceId.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServiceId.html",
    "title": "Property AppServiceId",
    "keywords": "Property AppServiceId AppServiceId Gibt die ID zurück mit der sich die Application am Authentication-Service registriert. Declaration guid AppServiceId { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServiceName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServiceName.html",
    "title": "Property AppServiceName",
    "keywords": "Property AppServiceName AppServiceName Gibt den Namen der Application zurück. Dieser wird dem dem Authentication-Service migeteilt. Declaration string AppServiceName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServicePrivateKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServicePrivateKey.html",
    "title": "Property AppServicePrivateKey",
    "keywords": "Property AppServicePrivateKey AppServicePrivateKey Gibt den Private Key der Application als byte[] zurück. Der Authentication-Service besitzt den Public teil dieses Keys und validiert damit Nachrichten von der Application. Declaration byte[] AppServicePrivateKey { get; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServicePrivateKeyHex.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServicePrivateKeyHex.html",
    "title": "Property AppServicePrivateKeyHex",
    "keywords": "Property AppServicePrivateKeyHex AppServicePrivateKeyHex Gibt den Private Key der Application als Hex-String zurück. Der Authentication-Service besitzt den Public teil dieses Keys und validiert damit Nachrichten von der Application. Declaration string AppServicePrivateKeyHex { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServiceTitle.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AppServiceTitle.html",
    "title": "Property AppServiceTitle",
    "keywords": "Property AppServiceTitle AppServiceTitle Gibt den Titel der Application zurück. Dieser wird in der Titelleiste im Client angezeigt. Declaration string AppServiceTitle { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AuthServiceDefaultUserName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AuthServiceDefaultUserName.html",
    "title": "Property AuthServiceDefaultUserName",
    "keywords": "Property AuthServiceDefaultUserName AuthServiceDefaultUserName Gibt den Namen des Users zurück, mit dem sich defaultmäßig am Authentication Service angemeldet werden soll. Declaration string AuthServiceDefaultUserName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AuthServiceDefaultUserPassword.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AuthServiceDefaultUserPassword.html",
    "title": "Property AuthServiceDefaultUserPassword",
    "keywords": "Property AuthServiceDefaultUserPassword AuthServiceDefaultUserPassword Gibt das Password des Default-Users AuthServiceDefaultUserName zurück. Declaration string AuthServiceDefaultUserPassword { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AuthServicePublicKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AuthServicePublicKey.html",
    "title": "Property AuthServicePublicKey",
    "keywords": "Property AuthServicePublicKey AuthServicePublicKey Gibt den Public Key des Authentication-Service als byte[] zurück. Declaration byte[] AuthServicePublicKey { get; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AuthServicePublicKeyHex.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.AuthServicePublicKeyHex.html",
    "title": "Property AuthServicePublicKeyHex",
    "keywords": "Property AuthServicePublicKeyHex AuthServicePublicKeyHex Gibt den Public Key des Authentication-Service als Hex-String zurück. Declaration string AuthServicePublicKeyHex { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.BrokerIdentifier.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.BrokerIdentifier.html",
    "title": "Property BrokerIdentifier",
    "keywords": "Property BrokerIdentifier BrokerIdentifier Gibt den dem Tenant zugeordneten BrokerIdentifier zurück.. Wird nicht mit einem BrokerIdentifier gearbeitet, dann wird null zurückgegeben. Declaration string BrokerIdentifier { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.ExistsLicense.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.ExistsLicense.html",
    "title": "Property ExistsLicense",
    "keywords": "Property ExistsLicense ExistsLicense true , wenn eine Lizenz für den Tenant existiert. Declaration bool ExistsLicense { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.ExpirationState.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.ExpirationState.html",
    "title": "Property ExpirationState",
    "keywords": "Property ExpirationState ExpirationState Gibt den Gültigkeits-Status des Tenant zurück. Declaration TenantExpirationState ExpirationState { get; } Property Value FrameworkSystems.FrameworkBase.Configuration.Runtime.TenantExpirationState"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.GetConnectionString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.GetConnectionString.html",
    "title": "Method GetConnectionString",
    "keywords": "Method GetConnectionString GetConnectionString(String) Gibt den ConnectionString für eine Connection-Group zurück. Declaration string GetConnectionString(string connectionGroupName) Parameters connectionGroupName String Name der Connection-Group. Reservierter Name: \"RuntimeConnection\" Returns String Exceptions Type Condition ApplicationException Connection-String für die ConnectionGroup nicht gefunden See Also GetRuntimeConnectionString ( IRuntimeConfigProvider )"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.GetLicenseXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.GetLicenseXml.html",
    "title": "Method GetLicenseXml",
    "keywords": "Method GetLicenseXml GetLicenseXml(guid) Gibt das Lizenz-Xml für ein Package zurück. Declaration XElement GetLicenseXml(guid packageId) Parameters packageId guid Eindeutige ID des Packages Returns XElement Lizenz-Xml - der Knoten \"License\". Remarks Es wird bei jedem Aufruf eine neue Instanz des XML-Knoten zurückgegeben. Bei mehrfachen Zugriffen ist ein lokales Caching empfehlenswert. Exceptions Type Condition ApplicationException Es gibt keine Lizenz für das Package."
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.GetServiceHostEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.GetServiceHostEnabled.html",
    "title": "Method GetServiceHostEnabled",
    "keywords": "Method GetServiceHostEnabled GetServiceHostEnabled(String) Gibt die BaseAddress eines Service Hosts zurück. Declaration bool GetServiceHostEnabled(string hostFullName) Parameters hostFullName String Der FullName das FS Service Hosts. Returns Boolean true , wenn die Adresse angegeben ist."
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.html",
    "title": "Interface IRuntimeConfigProvider",
    "keywords": "Interface IRuntimeConfigProvider Managed die Runtime-Konfigurationen. Eine Instanz kann über das statische Property RuntimeConfig . Get abgerufen werden. Namespace : FrameworkSystems.FrameworkBase.Configuration.Runtime Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IRuntimeConfigProvider Properties AppServiceDescription Gibt die Beschreibung der Application zurück. Diese wird dem dem Authentication-Service migeteilt. AppServiceId Gibt die ID zurück mit der sich die Application am Authentication-Service registriert. AppServiceName Gibt den Namen der Application zurück. Dieser wird dem dem Authentication-Service migeteilt. AppServicePrivateKey Gibt den Private Key der Application als byte[] zurück. Der Authentication-Service besitzt den Public teil dieses Keys und validiert damit Nachrichten von der Application. AppServicePrivateKeyHex Gibt den Private Key der Application als Hex-String zurück. Der Authentication-Service besitzt den Public teil dieses Keys und validiert damit Nachrichten von der Application. AppServiceTitle Gibt den Titel der Application zurück. Dieser wird in der Titelleiste im Client angezeigt. AuthServiceDefaultUserName Gibt den Namen des Users zurück, mit dem sich defaultmäßig am Authentication Service angemeldet werden soll. AuthServiceDefaultUserPassword Gibt das Password des Default-Users AuthServiceDefaultUserName zurück. AuthServicePublicKey Gibt den Public Key des Authentication-Service als byte[] zurück. AuthServicePublicKeyHex Gibt den Public Key des Authentication-Service als Hex-String zurück. BrokerIdentifier Gibt den dem Tenant zugeordneten BrokerIdentifier zurück.. Wird nicht mit einem BrokerIdentifier gearbeitet, dann wird null zurückgegeben. ExistsLicense true , wenn eine Lizenz für den Tenant existiert. ExpirationState Gibt den Gültigkeits-Status des Tenant zurück. IsAuthenticationEnabled Gibt zurück, ob die Authentication aktiviert ist. IsReadonly Gibt an, ob die Konfigurations-Informationen geschrieben werden können. RuntimeSupervisorEnabled Gibt zurück, ob der Runtime-Supervisor aktiviert ist. RuntimeSupervisorUri Gibt die Url des Runtime Supervisor Tenant Gibt den Namen des Tanant zurück. Wird nicht mit Tenants gearbeitet, dann wird null zurückgegeben. Methods GetConnectionString(String) Gibt den ConnectionString für eine Connection-Group zurück. GetLicenseXml(guid) Gibt das Lizenz-Xml für ein Package zurück. GetServiceHostEnabled(String) Gibt die BaseAddress eines Service Hosts zurück. SetLicenseXml(guid, XElement) Schreibt die Lizenz-Information für ein Package. Diese Methode kann nur aufgerufen werden, wenn nicht IsReadonly . TryGetServiceProxyAddress(String, out String) Gibt die Adresse eines Service-Endpoints zurück. Extension Methods RuntimeConfigExtensions.GetRuntimeConnectionString(IRuntimeConfigProvider)"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.IsAuthenticationEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.IsAuthenticationEnabled.html",
    "title": "Property IsAuthenticationEnabled",
    "keywords": "Property IsAuthenticationEnabled IsAuthenticationEnabled Gibt zurück, ob die Authentication aktiviert ist. Declaration bool IsAuthenticationEnabled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.IsReadonly.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.IsReadonly.html",
    "title": "Property IsReadonly",
    "keywords": "Property IsReadonly IsReadonly Gibt an, ob die Konfigurations-Informationen geschrieben werden können. Declaration bool IsReadonly { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.RuntimeSupervisorEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.RuntimeSupervisorEnabled.html",
    "title": "Property RuntimeSupervisorEnabled",
    "keywords": "Property RuntimeSupervisorEnabled RuntimeSupervisorEnabled Gibt zurück, ob der Runtime-Supervisor aktiviert ist. Declaration bool RuntimeSupervisorEnabled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.RuntimeSupervisorUri.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.RuntimeSupervisorUri.html",
    "title": "Property RuntimeSupervisorUri",
    "keywords": "Property RuntimeSupervisorUri RuntimeSupervisorUri Gibt die Url des Runtime Supervisor Declaration Uri RuntimeSupervisorUri { get; } Property Value Uri"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.SetLicenseXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.SetLicenseXml.html",
    "title": "Method SetLicenseXml",
    "keywords": "Method SetLicenseXml SetLicenseXml(guid, XElement) Schreibt die Lizenz-Information für ein Package. Diese Methode kann nur aufgerufen werden, wenn nicht IsReadonly . Declaration void SetLicenseXml(guid packageId, XElement xeLicense) Parameters packageId guid xeLicense XElement Lizenz-Xml - der Knoten \"License\" Exceptions Type Condition InvalidOperationException Bei Aufruf trotz IsReadonly"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.Tenant.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.Tenant.html",
    "title": "Property Tenant",
    "keywords": "Property Tenant Tenant Gibt den Namen des Tanant zurück. Wird nicht mit Tenants gearbeitet, dann wird null zurückgegeben. Declaration string Tenant { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.TryGetServiceProxyAddress.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.IRuntimeConfigProvider.TryGetServiceProxyAddress.html",
    "title": "Method TryGetServiceProxyAddress",
    "keywords": "Method TryGetServiceProxyAddress TryGetServiceProxyAddress(String, out String) Gibt die Adresse eines Service-Endpoints zurück. Declaration bool TryGetServiceProxyAddress(string proxyFullName, out string address) Parameters proxyFullName String Der FullName das FS Service Proxy. address String Gibt die Addresse zurück, wenn diese angegeben ist. Returns Boolean true , wenn die Adresse angegeben ist."
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.RuntimeConfig.Get.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.RuntimeConfig.Get.html",
    "title": "Property Get",
    "keywords": "Property Get Get Liefert die aktuelle Instanz der Runtime-Konfiguration. Declaration public static IRuntimeConfigProvider Get { get; } Property Value IRuntimeConfigProvider"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.RuntimeConfig.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.RuntimeConfig.html",
    "title": "Class RuntimeConfig",
    "keywords": "Class RuntimeConfig Statische Klasse für den Einstieg in die Runtime-Konfiguration. Inheritance Object RuntimeConfig Namespace : FrameworkSystems.FrameworkBase.Configuration.Runtime Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static class RuntimeConfig Properties Get Liefert die aktuelle Instanz der Runtime-Konfiguration."
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.RuntimeConfigExtensions.GetRuntimeConnectionString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.RuntimeConfigExtensions.GetRuntimeConnectionString.html",
    "title": "Method GetRuntimeConnectionString",
    "keywords": "Method GetRuntimeConnectionString GetRuntimeConnectionString(IRuntimeConfigProvider) Gibt den ConnectionString für die \"RuntimeConnection\" zurück. Declaration public static string GetRuntimeConnectionString(this IRuntimeConfigProvider provider) Parameters provider IRuntimeConfigProvider Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.RuntimeConfigExtensions.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Configuration.Runtime.RuntimeConfigExtensions.html",
    "title": "Class RuntimeConfigExtensions",
    "keywords": "Class RuntimeConfigExtensions Inheritance Object RuntimeConfigExtensions Namespace : FrameworkSystems.FrameworkBase.Configuration.Runtime Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static class RuntimeConfigExtensions Methods GetRuntimeConnectionString(IRuntimeConfigProvider) Gibt den ConnectionString für die \"RuntimeConnection\" zurück."
  },
  "api/FrameworkSystems.FrameworkBase.Converter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Converter",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Converter Classes XmlConverter Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. Interfaces IXmlConverter<T> Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T ."
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.FromXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml FromXml(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T Declaration T FromXml(string xml) Parameters xml String Returns T"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.html",
    "title": "Interface IXmlConverter<T>",
    "keywords": "Interface IXmlConverter<T> Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T . Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IXmlConverter<T> Type Parameters Name Description T Methods FromXml(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. See Also XmlConverter"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.ToXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. Declaration string ToXml(T value) Parameters value T Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.DateTimeNumberFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.DateTimeNumberFormat.html",
    "title": "Field DateTimeNumberFormat",
    "keywords": "Field DateTimeNumberFormat Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static readonly CultureInfo DateTimeNumberFormat Returns Type Description CultureInfo"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.FromXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml FromXml<T>(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T . Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public T FromXml<T>(string xml) Parameters xml String Returns T Type Parameters Name Description T"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.Get.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.Get.html",
    "title": "Property Get",
    "keywords": "Property Get Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. Declaration public static XmlConverter Get { get; } Property Value XmlConverter"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.html",
    "title": "Class XmlConverter",
    "keywords": "Class XmlConverter Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. Inheritance Object XmlConverter Implements IXmlConverter < FSbool > IXmlConverter < FSbyte > IXmlConverter < FSbyteArray > IXmlConverter < FSDateTime > IXmlConverter < FSdecimal > IXmlConverter < FSdouble > IXmlConverter < FSfloat > IXmlConverter < FSint > IXmlConverter < FSlong > IXmlConverter < FSshort > IXmlConverter < FSstring > IXmlConverter < FSSystemGuid > IXmlConverter < Boolean > IXmlConverter < Byte > IXmlConverter < Byte []> IXmlConverter < DateTime > IXmlConverter < Decimal > IXmlConverter < Double > IXmlConverter < Single > IXmlConverter < Int32 > IXmlConverter < Int64 > IXmlConverter < Int16 > IXmlConverter < String > IXmlConverter < Guid > Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class XmlConverter : IXmlConverter<FSbool>, IXmlConverter<FSbyte>, IXmlConverter<FSbyteArray>, IXmlConverter<FSDateTime>, IXmlConverter<FSdecimal>, IXmlConverter<FSdouble>, IXmlConverter<FSfloat>, IXmlConverter<FSint>, IXmlConverter<FSlong>, IXmlConverter<FSshort>, IXmlConverter<FSstring>, IXmlConverter<FSSystemGuid>, IXmlConverter<bool>, IXmlConverter<byte>, IXmlConverter<byte[]>, IXmlConverter<DateTime>, IXmlConverter<decimal>, IXmlConverter<double>, IXmlConverter<float>, IXmlConverter<int>, IXmlConverter<long>, IXmlConverter<short>, IXmlConverter<string>, IXmlConverter<Guid> Remarks Ein Objekt dieser Klasse wird als Singleton-Instanz angeboten. Note Im Java-Client gibt es ein entsprechendes Gegenstück, die Klasse FrameworkSystems.FSJavaClient.UIWrapper.DotNetTypes , welche statische Methoden zum Umwandeln von Objekten in einen String und umgekehrt anbietet. Unterstützte Typen Die Klasse unterstützt die Konvertierung ausschließlich für die im Folgenden aufgeführten Typen und implementiert für jeden der Typen T das entsprechende Interface IXmlConverter<T> : FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring FSSystemGuid bool byte byte[] DateTime decimal double float int long short string Guid Fields DateTimeNumberFormat Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. XML_NULL Definiert die String-Repräsentation eines null-Wertes im Xml. XMLNumberFormat Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. Properties Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. Methods FromXml<T>(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T . Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . IsConvertible(String) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können ( Unterstützte Typen ). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long ) als auch deren .NET-Klassen (z.B. Int64 ), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können ( Unterstützte Typen ). ToXml(Object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException ."
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.IsConvertible.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.IsConvertible.html",
    "title": "Method IsConvertible",
    "keywords": "Method IsConvertible IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können ( Unterstützte Typen ). Declaration public bool IsConvertible(Type type) Parameters type Type Returns Boolean IsConvertible(String) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können ( Unterstützte Typen ). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long ) als auch deren .NET-Klassen (z.B. Int64 ), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. Declaration public bool IsConvertible(string typeName) Parameters typeName String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.ToXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public string ToXml<T>(T value) Parameters value T Returns String Type Parameters Name Description T ToXml(Object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public string ToXml(object value) Parameters value Object Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XML_NULL.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XML_NULL.html",
    "title": "Field XML_NULL",
    "keywords": "Field XML_NULL Definiert die String-Repräsentation eines null-Wertes im Xml. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string XML_NULL = \"\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XMLNumberFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XMLNumberFormat.html",
    "title": "Field XMLNumberFormat",
    "keywords": "Field XMLNumberFormat Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static readonly CultureInfo XMLNumberFormat Returns Type Description CultureInfo"
  },
  "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.DeferRecursiveSaves.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.DeferRecursiveSaves.html",
    "title": "Method DeferRecursiveSaves",
    "keywords": "Method DeferRecursiveSaves DeferRecursiveSaves() Gibt zurück, ob alle Save-Aufrufe an dieser Instanz, die während eines laufenden Save-Aufrufs an dieser Instanz erfolgen, direkt abgebrochen werden sollen und stattdessen nach dem initialen Save-Aufruf (innerhalb der Transaktion) ein weiterer Save-Aufruf erfolgen soll. Standardmäßig gibt die Methode \"false\" zurück. Der Mechanismus kann aktiviert werden, in dem die Methode mit \"return true;\" überschrieben wird. Declaration [HideForIntellisense] [HideForOverride(false)] protected virtual bool DeferRecursiveSaves() Returns Boolean Examples protected override bool DeferRecursiveSaves() { return true; }"
  },
  "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.html",
    "title": "Class DevFrameworkObject",
    "keywords": "Class DevFrameworkObject TODO! Basisklasse für alle Components die über das FrameworkStudio erzeugt werden. Inheritance Object FrameworkSystems.FrameworkBase.DevFrameworkBaseObject DevFrameworkObject cGlobalBase Implements IDevFrameworkObject IDevFrameworkBaseObject Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public abstract class DevFrameworkObject : DevFrameworkBaseObject, ICloneable, IFSRebind, IDevFrameworkObject, IDevFrameworkBaseObject, FrameworkDataTransaction.ISource, INotifyPropertyChanged, IGuidObject, IGuidObjectBase Properties State Siehe State in IDevFrameworkObject . Methods DeferRecursiveSaves() Gibt zurück, ob alle Save-Aufrufe an dieser Instanz, die während eines laufenden Save-Aufrufs an dieser Instanz erfolgen, direkt abgebrochen werden sollen und stattdessen nach dem initialen Save-Aufruf (innerhalb der Transaktion) ein weiterer Save-Aufruf erfolgen soll. Standardmäßig gibt die Methode \"false\" zurück. Der Mechanismus kann aktiviert werden, in dem die Methode mit \"return true;\" überschrieben wird."
  },
  "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.State.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.State.html",
    "title": "Property State",
    "keywords": "Property State State Siehe State in IDevFrameworkObject . Declaration public FrameworkComponentState State { get; set; } Property Value FrameworkComponentState Implements IDevFrameworkObject.State"
  },
  "api/FrameworkSystems.FrameworkBase.DevTextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevTextAlign.html",
    "title": "Enum DevTextAlign",
    "keywords": "Enum DevTextAlign Gibt die Ausrichtung des Textes an. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum DevTextAlign Fields Name Description Center Zentriert DatatypeDefault Inherit Erbt von Vater-Control Left Linksbündig Right Rechtsbündig"
  },
  "api/FrameworkSystems.FrameworkBase.DockPanelOrientation.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DockPanelOrientation.html",
    "title": "Enum DockPanelOrientation",
    "keywords": "Enum DockPanelOrientation Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [HideForIntellisense] public enum DockPanelOrientation Fields Name Description Horizontal HorizontalOrVertical Vertical"
  },
  "api/FrameworkSystems.FrameworkBase.DockPanelScrolling.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DockPanelScrolling.html",
    "title": "Enum DockPanelScrolling",
    "keywords": "Enum DockPanelScrolling Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [HideForIntellisense] public enum DockPanelScrolling Fields Name Description None Normal VerticalOverlay"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html",
    "title": "Method GetBestTextFlavorData",
    "keywords": "Method GetBestTextFlavorData GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat ( TextFlavorData ) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. Declaration public TextFlavorData GetBestTextFlavorData() Returns TextFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html",
    "title": "Method GetBestTextFlavorType",
    "keywords": "Method GetBestTextFlavorType GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. Declaration public string GetBestTextFlavorType() Returns String Remarks Zu dem Daten zur Verfügung gestellt werden: TextXml TextHtml TextUriList TextPlain Ein unbekanntes Textformat, soweit eines unterstützt wird null , falls gar kein Textformat unterstützt wird"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html",
    "title": "Method GetFileListFlavorData",
    "keywords": "Method GetFileListFlavorData GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste ( FileListFlavorData ) zurückgegeben, andernfalls null . Declaration public FileListFlavorData GetFileListFlavorData() Returns FileListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFlavorData.html",
    "title": "Method GetFlavorData",
    "keywords": "Method GetFlavorData GetFlavorData(String) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData ) zurückgegeben, andernfalls null . Declaration public FlavorData GetFlavorData(string flavorType) Parameters flavorType String Returns FlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html",
    "title": "Method GetImageFlavorData",
    "keywords": "Method GetImageFlavorData GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten ( ImageFlavorData ) zurückgegeben, andernfalls null . Declaration public ImageFlavorData GetImageFlavorData() Returns ImageFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html",
    "title": "Method GetSupportedFlavorTypes",
    "keywords": "Method GetSupportedFlavorTypes GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. Declaration public IEnumerable<string> GetSupportedFlavorTypes() Returns IEnumerable < String >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html",
    "title": "Method GetSupportedTextFlavorTypes",
    "keywords": "Method GetSupportedTextFlavorTypes GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. Declaration public IEnumerable<string> GetSupportedTextFlavorTypes() Returns IEnumerable < String >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html",
    "title": "Method GetTextFlavorData",
    "keywords": "Method GetTextFlavorData GetTextFlavorData(String) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null . Declaration public TextFlavorData GetTextFlavorData(string textFlavorType) Parameters textFlavorType String Returns TextFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html",
    "title": "Method GetUriListFlavorData",
    "keywords": "Method GetUriListFlavorData GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste ( UriListFlavorData ) zurückgegeben, ansonsten null . Declaration public UriListFlavorData GetUriListFlavorData() Returns UriListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.html",
    "title": "Class ExternalTransferObject",
    "keywords": "Class ExternalTransferObject Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. Inheritance Object ExternalTransferObject Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ExternalTransferObject Remarks Die Klasse bietet Methoden, mit denen ermittelt werden kann, welche FlavorTypes ( FlavorType ) unterstützt werden, also in welchen Formaten Daten zur Verfügung stehen. Außerdem können zu jedem FlavorType die entsprechenden Daten ( FlavorData ) abgefragt werden. In den Events OnCanDrop und OnDrop kann eindeutig erkannt werden, ob es sich um einen internen oder einen externen Drag&Drop-Vorgang handelt, indem überprüft wird, ob das TransferObject vom Typ ExternalTransferObject ist. Examples ExternalTransferObject oExternalTransferObject = e.TransferObject as ExternalTransferObject; if (oExternalTransferObject != null) { // Drag&Drop-Vorgang von außerhalb der Applikation } else { // Drag&Drop-Vorgang innerhalb der Applikation } Methods GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat ( TextFlavorData ) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste ( FileListFlavorData ) zurückgegeben, andernfalls null . GetFlavorData(String) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData ) zurückgegeben, andernfalls null . GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten ( ImageFlavorData ) zurückgegeben, andernfalls null . GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. GetTextFlavorData(String) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null . GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste ( UriListFlavorData ) zurückgegeben, ansonsten null . IsFlavorTypeSupported(String) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html",
    "title": "Method IsFlavorTypeSupported",
    "keywords": "Method IsFlavorTypeSupported IsFlavorTypeSupported(String) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können. Declaration public bool IsFlavorTypeSupported(string flavorType) Parameters flavorType String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Content.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Content.html",
    "title": "Property Content",
    "keywords": "Property Content Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. Declaration public byte[] Content { get; protected set; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FileType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FileType.html",
    "title": "Enum FileFlavorData.FileType",
    "keywords": "Enum FileFlavorData.FileType Der Dateityp, der Verzeichnis oder Datei ist. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FileType Fields Name Description Directory Ordner / Verzeichnis. File Datei."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FullName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FullName.html",
    "title": "Property FullName",
    "keywords": "Property FullName FullName Gibt den Dateinamen inklusive Pfad zurück. Declaration public string FullName { get; protected set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.html",
    "title": "Class FileFlavorData",
    "keywords": "Class FileFlavorData Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien ( FileListFlavorData ). Inheritance Object FileFlavorData Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FileFlavorData Properties Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. FullName Gibt den Dateinamen inklusive Pfad zurück. LastModified Gibt das letzte Änderungsdatum der Datei zurück. Name Gibt den Dateinamen (inkl. Dateiendung) zurück. Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. Type Gibt den Typ der Datei zurück."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.LastModified.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.LastModified.html",
    "title": "Property LastModified",
    "keywords": "Property LastModified LastModified Gibt das letzte Änderungsdatum der Datei zurück. Declaration public DateTime LastModified { get; protected set; } Property Value DateTime"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Name.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Name Gibt den Dateinamen (inkl. Dateiendung) zurück. Declaration public string Name { get; protected set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Size.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Size.html",
    "title": "Property Size",
    "keywords": "Property Size Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. Declaration public long Size { get; protected set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Type.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Type.html",
    "title": "Property Type",
    "keywords": "Property Type Type Gibt den Typ der Datei zurück. Declaration public FileFlavorData.FileType Type { get; protected set; } Property Value FileFlavorData.FileType Remarks Mögliche Werte sind : File : Datei Directory : Verzeichnis"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Count Gibt die Anzahl der enthaltenen Dateien zurück. Declaration public int Count { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.GetEnumerator.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück. Declaration public IEnumerator<FileFlavorData> GetEnumerator() Returns IEnumerator < FileFlavorData > Examples FileListFlavorData oFileListFlavorData = oExternalTransferObject.GetFileListFlavorData(); foreach (FileFlavorData oFileFlavorData in oFileListFlavorData) { String sFileName = oFileFlavorData.Name; // ... }"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.html",
    "title": "Class FileListFlavorData",
    "keywords": "Class FileListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar ( IEnumerator<FileFlavorData> ) und eine Spezialisierung von FlavorData . Inheritance Object FlavorData FileListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FileListFlavorData : FlavorData, IEnumerable<FileFlavorData>, IEnumerable Remarks Die Enumeration enthält (auch im Event OnCanDrop ) immer mindestens ein Objekt vom Typ FileFlavorData . Properties Count Gibt die Anzahl der enthaltenen Dateien zurück. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück. Extension Methods EnumarableExtensions.Chunk<T>(IEnumerable<T>, Int32) EnumarableExtensions.DistinctBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>) EnumarableExtensions.ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>, IEqualityComparer<TKey>) EnumarableExtensions.ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>) EnumarableExtensions.OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, Boolean) EnumarableExtensions.OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>, Boolean) EnumarableExtensions.OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, Boolean) EnumarableExtensions.OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, IEqualityComparer<TKey>, Boolean)"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.FillOnDrop.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.FillOnDrop.html",
    "title": "Method FillOnDrop",
    "keywords": "Method FillOnDrop FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. Declaration public virtual void FillOnDrop() Remarks Hintergrund: Einige Datenformate bringen unter Umständen sehr große Datenmengen mit sich. Beispielsweise können Dateien sehr groß sein. Daher werden beim ersten Request des Clients ( OnCanDrop ) nur Informationen wie der Speicherort, Name, Größe usw. übertragen und nur dann, wenn der Inhalt tatsächlich im OnDrop benötigt wird (und deshalb FillOnDrop() aufgerufen wurde), werden die ggf. großen Daten ausgelesen und übertragen."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.html",
    "title": "Class FlavorData",
    "keywords": "Class FlavorData Die Daten, welche am externen Transferobjekt ( ExternalTransferObject ) bei einem Drag&Drop-Vorgang in einem bestimmten Format ( FlavorType ) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. Inheritance Object FlavorData FileListFlavorData ImageFlavorData TextFlavorData Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public abstract class FlavorData Remarks Die Klasse bietet die Methode FillOnDrop() . Durch den Aufruf dieser Methode wird gesteuert, dass beim Drop-Vorgang alle Daten vollständig gefüllt werden sollen. Methods FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. See Also FileFlavorData FileListFlavorData ImageFlavorData TextFlavorData UriListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.FileList.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.FileList.html",
    "title": "Field FileList",
    "keywords": "Field FileList Stellt Dateien dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string FileList = \"application/x-java-file-list\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.html",
    "title": "Class FlavorType",
    "keywords": "Class FlavorType Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop ( Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject ( ExternalTransferObject ) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. Inheritance Object FlavorType Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static class FlavorType Remarks Diese Klasse stellt primär Konstanten für alle von Framework Studio bekannten Datenformate zur Verfügung. Die Konstanten sind vom Typ String. So kann das externe Transferobjekt grundsätzlich auch unbekannte Datenformate unterstützen. Fields FileList Stellt Dateien dar. Image Stellt ein Bild dar. TextHtml Stellt Text im HTML-Format dar. TextPlain Stellt unformatierten Text dar. TextRtf Stellt Text im RTF-Format dar. TextUriList Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. TextXml Stellt Text im XML-Format dar. Methods IsTextFlavor(String) Gibt zurück, ob das übergebene Format ein Textformat ist."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.Image.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.Image.html",
    "title": "Field Image",
    "keywords": "Field Image Stellt ein Bild dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string Image = \"image/x-java-image\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.IsTextFlavor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.IsTextFlavor.html",
    "title": "Method IsTextFlavor",
    "keywords": "Method IsTextFlavor IsTextFlavor(String) Gibt zurück, ob das übergebene Format ein Textformat ist. Declaration public static bool IsTextFlavor(string flavorType) Parameters flavorType String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextHtml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextHtml.html",
    "title": "Field TextHtml",
    "keywords": "Field TextHtml Stellt Text im HTML-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextHtml = \"text/html\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextPlain.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextPlain.html",
    "title": "Field TextPlain",
    "keywords": "Field TextPlain Stellt unformatierten Text dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextPlain = \"text/plain\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextRtf.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextRtf.html",
    "title": "Field TextRtf",
    "keywords": "Field TextRtf Stellt Text im RTF-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextRtf = \"text/rtf\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextUriList.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextUriList.html",
    "title": "Field TextUriList",
    "keywords": "Field TextUriList Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextUriList = \"text/uri-list\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextXml.html",
    "title": "Field TextXml",
    "keywords": "Field TextXml Stellt Text im XML-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextXml = \"text/xml\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.DragAndDrop",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.DragAndDrop Classes ExternalTransferObject Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. FileFlavorData Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien ( FileListFlavorData ). FileListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar ( IEnumerator<FileFlavorData> ) und eine Spezialisierung von FlavorData . FlavorData Die Daten, welche am externen Transferobjekt ( ExternalTransferObject ) bei einem Drag&Drop-Vorgang in einem bestimmten Format ( FlavorType ) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. FlavorType Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop ( Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject ( ExternalTransferObject ) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. ImageFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. TextFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. UriListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. Enums FileFlavorData.FileType Der Dateityp, der Verzeichnis oder Datei ist."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.html",
    "title": "Class ImageFlavorData",
    "keywords": "Class ImageFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. Inheritance Object FlavorData ImageFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ImageFlavorData : FlavorData Properties ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.ImageByteArray.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.ImageByteArray.html",
    "title": "Property ImageByteArray",
    "keywords": "Property ImageByteArray ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde. Declaration public byte[] ImageByteArray { get; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.html",
    "title": "Class TextFlavorData",
    "keywords": "Class TextFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. Inheritance Object FlavorData TextFlavorData UriListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class TextFlavorData : FlavorData Remarks In einem Drag&Drop-Vorgang können mehrere TextFlavorData Objekte (zu unterschiedlichen Textformaten) enthalten sein. Properties Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde. Declaration public virtual string Text { get; protected set; } Property Value String Remarks Lediglich die Texte in den Formaten TextPlain und TextUriList werden schon im OnCanDrop gefüllt."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Count Gibt die Anzahl der enthaltenen URIs zurück. Declaration public int Count { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.GetEnumerator.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück. Declaration public IEnumerator<string> GetEnumerator() Returns IEnumerator < String > Examples UriListFlavorData oUriListFlavorData = oExternalTransferObject.GetUriListFlavordata(); foreach (string sUri in oUriListFlavorData) { // ... }"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.html",
    "title": "Class UriListFlavorData",
    "keywords": "Class UriListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. Inheritance Object FlavorData TextFlavorData UriListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class UriListFlavorData : TextFlavorData, IEnumerable<string>, IEnumerable Remarks Die Klasse ist enumerierbar ( IEnumerator<String> ). Diese Klasse ist eine Spezialisierung von TextFlavorData , da der URI-Listen-Flavor ein spezieller Text-Flavor ist. Properties Count Gibt die Anzahl der enthaltenen URIs zurück. Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück. Extension Methods EnumarableExtensions.Chunk<T>(IEnumerable<T>, Int32) EnumarableExtensions.DistinctBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>) EnumarableExtensions.ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>, IEqualityComparer<TKey>) EnumarableExtensions.ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>) EnumarableExtensions.OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, Boolean) EnumarableExtensions.OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>, Boolean) EnumarableExtensions.OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, Boolean) EnumarableExtensions.OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, IEqualityComparer<TKey>, Boolean)"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. Declaration public override string Text { get; protected set; } Property Value String Overrides TextFlavorData.Text"
  },
  "api/FrameworkSystems.FrameworkBase.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkBase.EditorStyle.html",
    "title": "Enum EditorStyle",
    "keywords": "Enum EditorStyle Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum EditorStyle Fields Name Description CheckBox ComboBox Editfield MultilineEditfield"
  },
  "api/FrameworkSystems.FrameworkBase.ExtendedShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ExtendedShortcut.html",
    "title": "Enum ExtendedShortcut",
    "keywords": "Enum ExtendedShortcut ExtendedShortcut contains the same properties as the System.Windows.Forms.Shortcut enumeration. Furthermore it is extended by: Esc = 27 Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [HideForIntellisense] public enum ExtendedShortcut Fields Name Description Alt0 Alt1 Alt2 Alt3 Alt4 Alt5 Alt6 Alt7 Alt8 Alt9 AltBksp AltDownArrow AltF1 AltF10 AltF11 AltF12 AltF2 AltF3 AltF4 AltF5 AltF6 AltF7 AltF8 AltF9 AltLeftArrow AltRightArrow AltUpArrow Ctrl0 Ctrl1 Ctrl2 Ctrl3 Ctrl4 Ctrl5 Ctrl6 Ctrl7 Ctrl8 Ctrl9 CtrlA CtrlB CtrlC CtrlD CtrlDel CtrlE CtrlF CtrlF1 CtrlF10 CtrlF11 CtrlF12 CtrlF2 CtrlF3 CtrlF4 CtrlF5 CtrlF6 CtrlF7 CtrlF8 CtrlF9 CtrlG CtrlH CtrlI CtrlIns CtrlJ CtrlK CtrlL CtrlM CtrlN CtrlO CtrlP CtrlQ CtrlR CtrlS CtrlShift0 CtrlShift1 CtrlShift2 CtrlShift3 CtrlShift4 CtrlShift5 CtrlShift6 CtrlShift7 CtrlShift8 CtrlShift9 CtrlShiftA CtrlShiftB CtrlShiftC CtrlShiftD CtrlShiftE CtrlShiftF CtrlShiftF1 CtrlShiftF10 CtrlShiftF11 CtrlShiftF12 CtrlShiftF2 CtrlShiftF3 CtrlShiftF4 CtrlShiftF5 CtrlShiftF6 CtrlShiftF7 CtrlShiftF8 CtrlShiftF9 CtrlShiftG CtrlShiftH CtrlShiftI CtrlShiftJ CtrlShiftK CtrlShiftL CtrlShiftM CtrlShiftN CtrlShiftO CtrlShiftP CtrlShiftQ CtrlShiftR CtrlShiftS CtrlShiftT CtrlShiftU CtrlShiftV CtrlShiftW CtrlShiftX CtrlShiftY CtrlShiftZ CtrlT CtrlU CtrlV CtrlW CtrlX CtrlY CtrlZ Del Esc F1 F10 F11 F12 F2 F3 F4 F5 F6 F7 F8 F9 Ins None ShiftDel ShiftF1 ShiftF10 ShiftF11 ShiftF12 ShiftF2 ShiftF3 ShiftF4 ShiftF5 ShiftF6 ShiftF7 ShiftF8 ShiftF9 ShiftIns"
  },
  "api/FrameworkSystems.FrameworkBase.FieldRowLabelMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FieldRowLabelMode.html",
    "title": "Enum FieldRowLabelMode",
    "keywords": "Enum FieldRowLabelMode Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FieldRowLabelMode Fields Name Description Generated Generated_Merged None None_Aligned Das erste Control wird in die Label-Spalte platziert. None_Fill"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkComponentState.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkComponentState.html",
    "title": "Enum FrameworkComponentState",
    "keywords": "Enum FrameworkComponentState Status des Objektes. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FrameworkComponentState Fields Name Description Changed Das Objekt wurde verändert und die Änderungen wurden noch nicht gespeichert Deleted Das Objekt wurde gelöscht (und aus der Collection entfernt!) New Das Objekt wurde neu erzeugt, aber noch nicht gespeichert NewButDeleted Das Objekt wurde zwar neu erzeugt aber inzwischen schon wieder gelöscht (und aus der Collection entfernt!) Unchanged Das Objekt wurde seit dem Laden bzw. dem letzten Speichern nicht mehr verändert. UnchangedButDeleted Das Objekt wurde gelöscht und in der Datenbank gespeichert. So gilt er als Unchanged und Deleted"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkFormatMask.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkFormatMask.html",
    "title": "Enum FrameworkFormatMask",
    "keywords": "Enum FrameworkFormatMask TODO! (auch die einzelnen Formate mit Beispielen beschreiben) Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FrameworkFormatMask Fields Name Description DateOnlyLong DateOnlyMedium DateOnlyShort DateTimeLong DateTimeMedium DateTimeShort Decimal Integer LowerCase NegativeInteger None PositiveInteger TimeOnlyLong TimeOnlyMedium TimeOnlyShort UpperCase UserDefined"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.CanCancel.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.CanCancel.html",
    "title": "Property CanCancel",
    "keywords": "Property CanCancel CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true . Declaration public bool CanCancel { get; set; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Canceled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Canceled.html",
    "title": "Property Canceled",
    "keywords": "Property Canceled Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. Declaration public bool Canceled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.-ctor.html",
    "title": "Constructor FrameworkProgress",
    "keywords": "Constructor FrameworkProgress FrameworkProgress(IGlobalObjects) Der Konstruktor nimmt das Objekt this.Global ( IGlobalObjects ) entgegen, wodurch die aktuelle Client-Session zugeordnet werden kann. Declaration public FrameworkProgress(IGlobalObjects global) Parameters global IGlobalObjects"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.DetailText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.DetailText.html",
    "title": "Property DetailText",
    "keywords": "Property DetailText DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. Declaration public string DetailText { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Dispose.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Dispose.html",
    "title": "Method Dispose",
    "keywords": "Method Dispose Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client. Declaration public void Dispose()"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.html",
    "title": "Class FrameworkProgress",
    "keywords": "Class FrameworkProgress Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. Inheritance Object FrameworkProgress Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FrameworkProgress : IDisposable Remarks Es können auch mehrere FrameworkProgress Objekte zeitgleich verwendet werden. Die angezeigten Balken werden untereinander angeordnet. Examples using(FrameworkProgress progress = new FrameworkProgress(this.Global)) { // gibt an, ob der Cancel-Button überhaupt angezeigt werden soll progress.CanCancel = true; // sonstige Eigenschaften progress.Text = \"Fortschritt ...\"; progress.MaxValue = 1000; for(int i = 0; i <= progress.MaxValue; i++) { // breche ab, falls progress.Canceled = true if(progress.Canceled) { break; } progress.Value = i; progress.DetailText = \"i hat den Wert \" + i; // Aktion ... } } Anzeige auf dem Client: Constructors FrameworkProgress(IGlobalObjects) Der Konstruktor nimmt das Objekt this.Global ( IGlobalObjects ) entgegen, wodurch die aktuelle Client-Session zugeordnet werden kann. Properties CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true . Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. MaxValue Der Maximalwert des Fortschrittsbalken. Text Der Text, der über dem ProgressBar angezeigt werden soll. Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue . Methods Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client."
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Id.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Id.html",
    "title": "Property Id",
    "keywords": "Property Id Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. Declaration public guid Id { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.MaxValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.MaxValue.html",
    "title": "Property MaxValue",
    "keywords": "Property MaxValue MaxValue Der Maximalwert des Fortschrittsbalken. Declaration public long MaxValue { get; set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Der Text, der über dem ProgressBar angezeigt werden soll. Declaration public string Text { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue . Declaration public long Value { get; set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.CommandTimeout.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.CommandTimeout.html",
    "title": "Property CommandTimeout",
    "keywords": "Property CommandTimeout CommandTimeout Überschreibt für die Ausführung der Abfrage die Eigenschaft CommandTimeout . Declaration public int? CommandTimeout { get; set; } Property Value Nullable < Int32 > Exceptions Type Condition ArgumentException Der zugewiesene Wert ist kleiner als 0."
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.Condition.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.Condition.html",
    "title": "Property Condition",
    "keywords": "Property Condition Condition Zusätzliche zur in der Component-Query definierten Where-Klausel. Declaration public string Condition { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Count Maximale Anzahl der Datensätze die zurückgegeben werden. Declaration public int? Count { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.Having.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.Having.html",
    "title": "Property Having",
    "keywords": "Property Having Having Ersetzt die in der Component-Query definierte Having-Klausel. Declaration public string Having { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.html",
    "title": "Class FrameworkQueryOptions",
    "keywords": "Class FrameworkQueryOptions Inheritance Object FrameworkQueryOptions Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FrameworkQueryOptions Properties CommandTimeout Überschreibt für die Ausführung der Abfrage die Eigenschaft CommandTimeout . Condition Zusätzliche zur in der Component-Query definierten Where-Klausel. Count Maximale Anzahl der Datensätze die zurückgegeben werden. Having Ersetzt die in der Component-Query definierte Having-Klausel. Offset Anzahl der Datensätze die übersprungen werden sollen. Zusammen mit der Eigenschaft Count kann man ein Paging realisieren. OrderBy Ersetzt die in der Component-Query definierte OrderBy-Klausel."
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.Offset.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.Offset.html",
    "title": "Property Offset",
    "keywords": "Property Offset Offset Anzahl der Datensätze die übersprungen werden sollen. Zusammen mit der Eigenschaft Count kann man ein Paging realisieren. Declaration public int? Offset { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.OrderBy.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkQueryOptions.OrderBy.html",
    "title": "Property OrderBy",
    "keywords": "Property OrderBy OrderBy Ersetzt die in der Component-Query definierte OrderBy-Klausel. Declaration public string OrderBy { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.FromControlWrapperProcessedState.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FromControlWrapperProcessedState.html",
    "title": "Enum FromControlWrapperProcessedState",
    "keywords": "Enum FromControlWrapperProcessedState Verarbeitungsstatus der in einem Grid verwendeten Objekte Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FromControlWrapperProcessedState Fields Name Description ProcessedChanged ProcessedDeleted ProcessedNew ProcessedUnchanged Unprocessed"
  },
  "api/FrameworkSystems.FrameworkBase.FSVisibility.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FSVisibility.html",
    "title": "Enum FSVisibility",
    "keywords": "Enum FSVisibility Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FSVisibility Fields Name Description Collapsed Das Control wird komplett ausgeblendet und benötigt keinen Platz. Im Form-Designer ist das Control sichtbar und wird mit einem schwarzen Schleier dargestellt. Hidden Das Control wird nicht angezeigt, es reserviert aber trotzdem Platz. Im Form-Designer ist das Control sichtbar und wird mit einem weißen Schleier dargestellt. Visible Das Control ist sichtbar. ( Standardwert )"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.GlobalGetStaticCacheMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.GlobalGetStaticCacheMode.html",
    "title": "Method GlobalGetStaticCacheMode",
    "keywords": "Method GlobalGetStaticCacheMode GlobalGetStaticCacheMode(IDevFrameworkDataObject) Diese Methode wird pro Component-Typ einmalig mit einer Instanz der Component bei der ersten Benutzung des statischen Caches aufgerufen, um den gewünschten Arbeitsmodus des statischen Caches zu ermitteln. Standardwert ist Broker . Declaration protected virtual StaticCacheMode GlobalGetStaticCacheMode(IDevFrameworkDataObject oDevFrameworkDataObjectP) Parameters oDevFrameworkDataObjectP IDevFrameworkDataObject Eine Instanz des Component-Typs, für welchen der gewünschte Arbeitsmodus des statischen Caches ermittelt werden soll. Returns StaticCacheMode Gibt den Arbeitsmodus zurück, in dem der statische Cache arbeiten soll. Remarks Hilfreich ist dies z.B., wenn für bestimmte Typen (z.B. weil Tabellen-Filter definiert sind) das durchlaufen der Einsprungspunkte FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.GlobalOnBeforeLoad(FrameworkSystems.FrameworkBase.DevFrameworkObject,System.String@,System.String@,System.String@) und FrameworkSystems.FrameworkBase.FrameworkDataObject`2.OnBeforeLoad(System.String@,System.String@,System.String@,System.Boolean) dringend nötig ist und daher der Arbeitsmodus Session gewünscht ist. Der Arbeitsmodus Session ist außerdem dann relevant, wenn Einschränkungen auf Eigenschaften erfolgen sollen, die zwar als Datenbankspalte existieren, jedoch an der Component nicht als Property hinzugefügt wurden (z.B. bei distinct und groupBy Components)."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.GlobalWhereStaticCache.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.GlobalWhereStaticCache.html",
    "title": "Method GlobalWhereStaticCache",
    "keywords": "Method GlobalWhereStaticCache GlobalWhereStaticCache(IStaticCacheObject) Diese Methode wird von den Statischen Caches aufgerufen, um abhängig vom Global Datensätze generell filtern zu können. Dieser Einsprungpunkt wird nur durchlaufen, wenn die Methode GlobalGetStaticCacheMode(IDevFrameworkDataObject) für den entsprechenden IDevFrameworkDataObject-Typ den Wert Broker zurück gegeben hat.\"/> Declaration protected virtual bool GlobalWhereStaticCache(IStaticCacheObject oStaticCacheObjectP) Parameters oStaticCacheObjectP IStaticCacheObject Der Datensatz vom Typ IStaticCache , für das entschieden werden soll, ob er für dieses Global zurück gegeben werden soll.\"/> Returns Boolean Gibt zurück, ob der Datensatz von einem statischen Cache für dieses Global zurückgegeben werden soll. Remarks Hilfreich ist dies z.B., wenn mit Mandanten gearbeitet wird und nur die Datensätze zur aktuellen Geschäftseinheit vom Cache zurückgegeben werden sollen."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.html",
    "title": "Class cGlobalBase",
    "keywords": "Class cGlobalBase Basisklasse für das Property FrameworkSystems.FrameworkBase.GlobalObj.GlobalObjects.ocGlobal . Inheritance Object FrameworkSystems.FrameworkBase.DevFrameworkBaseObject DevFrameworkObject cGlobalBase Implements IDevFrameworkObject IDevFrameworkBaseObject IcGlobalBase Inherited Members DevFrameworkObject.DeferRecursiveSaves() DevFrameworkObject.State Namespace : FrameworkSystems.FrameworkBase.GlobalObj Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class cGlobalBase : DevFrameworkObject, ICloneable, IFSRebind, IDevFrameworkObject, IDevFrameworkBaseObject, FrameworkDataTransaction.ISource, INotifyPropertyChanged, IGuidObject, IGuidObjectBase, IcGlobalBase Methods GlobalGetStaticCacheMode(IDevFrameworkDataObject) Diese Methode wird pro Component-Typ einmalig mit einer Instanz der Component bei der ersten Benutzung des statischen Caches aufgerufen, um den gewünschten Arbeitsmodus des statischen Caches zu ermitteln. Standardwert ist Broker . GlobalWhereStaticCache(IStaticCacheObject) Diese Methode wird von den Statischen Caches aufgerufen, um abhängig vom Global Datensätze generell filtern zu können. Dieser Einsprungpunkt wird nur durchlaufen, wenn die Methode GlobalGetStaticCacheMode(IDevFrameworkDataObject) für den entsprechenden IDevFrameworkDataObject-Typ den Wert Broker zurück gegeben hat.\"/> OnLicenseGranted(AccessUnit, AUPermissionType)"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.OnLicenseGranted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.OnLicenseGranted.html",
    "title": "Method OnLicenseGranted",
    "keywords": "Method OnLicenseGranted OnLicenseGranted(AccessUnit, AUPermissionType) Declaration public virtual bool OnLicenseGranted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit type AUPermissionType Returns Boolean Implements IcGlobalBase.OnLicenseGranted(AccessUnit, AUPermissionType)"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.GlobalObj",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.GlobalObj Classes cGlobalBase Basisklasse für das Property FrameworkSystems.FrameworkBase.GlobalObj.GlobalObjects.ocGlobal . Interfaces IcGlobalBase Bereits im SystemPackage existiert im Namespace FSGeneral eine Component mit dem Namen cGlobal. Diese Component kann customized werden. Aus Forms oder Components heraus kann eine Instanz dieser Component mit this.Global. ocGlobal angesprochen werden. IGlobalObjects Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GetClientCulture.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GetClientCulture.html",
    "title": "Method GetClientCulture",
    "keywords": "Method GetClientCulture GetClientCulture() Liefert die Culture des Clients zurück. Diese Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration CultureInfo GetClientCulture() Returns CultureInfo Remarks Die FS-seitige Implementierung der Methode ermittelt die Culture anhand der ClientInfos am Global Object. Dabei greifen die folgenden Prioritäten Aus der Angabe \"Locale\" Aus den Angaben \"UserLanguage\" und \"UserCountry\" Die CurrentCulture , die in der Regel der Culture des Broker-Servers entspricht. Wird die Methode überschrieben, muss die ermittelte Culture ggf. in einem eigenen Property zwischengespeichert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalGetMLText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalGetMLText.html",
    "title": "Method GlobalGetMLText",
    "keywords": "Method GlobalGetMLText GlobalGetMLText(MLKey, String) Jedes mal, wenn aus einem MLKey einen Text erzeugt wird, wird diese Methode aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration string GlobalGetMLText(MLKey mlkey, string iso) Parameters mlkey MLKey iso String Returns String Remarks Die Sprach-Hierarchie der Session, welche am GlobalObject hinterlegt ist, wird außerhalb dieser Methode aufgelöst. Besteht die Hierarchie aus mehreren Fallbacks(z.B. fr, en, de ), wird diese Methode auch ggf.mehrfach nacheinander mit den unterschiedlichen Iso-Codes aufgerufen. Liefert die Methode einen Wert ungleich null oder String.Empty zurück, wird dieser als Text verwendet und es erfolgt kein weiterer Aufruf. Durch die Überschreibung dieser Methode ist es möglich die Ermittlung der Texte zu beeinflussen oder zu überwachen. Warning Diese Methode muss sehr performant gestaltet werden. Komplexe Logik kann die Performance der kompletten Anwendung sehr negativ beeinflussen. Der Basis-Aufruf muss sichergestellt werden. Ansonsten wird das komplette Wörterbuch ausgehebelt und es werden gar keine Texte mehr ermittelt."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalIsApplicationQuitAllowed.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalIsApplicationQuitAllowed.html",
    "title": "Method GlobalIsApplicationQuitAllowed",
    "keywords": "Method GlobalIsApplicationQuitAllowed GlobalIsApplicationQuitAllowed() Diese Methode wird vom Broker bei einem vom Client gesendeten QuitApplication-Request aufgerufen. Declaration bool GlobalIsApplicationQuitAllowed() Returns Boolean Eine Rückgabe von false verhindert das Beenden der Applikation."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnAfterHandleRequest.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnAfterHandleRequest.html",
    "title": "Method GlobalOnAfterHandleRequest",
    "keywords": "Method GlobalOnAfterHandleRequest GlobalOnAfterHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die eigentliche Brokerlogik (Eventauswertung) durchgeführt wurde, bevor die Daten an den Client übermittelt werden. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration void GlobalOnAfterHandleRequest() Remarks Warning Wird die Methode überschrieben, dann muss dafür gesorgt werden, dass der base-Aufruf in jedem Fall erfolgt!"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnAfterSaveAction.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnAfterSaveAction.html",
    "title": "Method GlobalOnAfterSaveAction",
    "keywords": "Method GlobalOnAfterSaveAction GlobalOnAfterSaveAction(DevFrameworkObject) Diese Methode wird nach jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration void GlobalOnAfterSaveAction(DevFrameworkObject obj) Parameters obj DevFrameworkObject"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeHandleRequest.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeHandleRequest.html",
    "title": "Method GlobalOnBeforeHandleRequest",
    "keywords": "Method GlobalOnBeforeHandleRequest GlobalOnBeforeHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die übertragenen Daten eingelesen wurden, bevor die eigentliche Brokerlogik (Eventauswertung) ausgeführt wird. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration void GlobalOnBeforeHandleRequest() Remarks Warning Wird die Methode überschrieben, dann muss dafür gesorgt werden, dass der base-Aufruf in jedem Fall erfolgt!"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeLoad.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeLoad.html",
    "title": "Method GlobalOnBeforeLoad",
    "keywords": "Method GlobalOnBeforeLoad GlobalOnBeforeLoad(DevFrameworkObject, ref String, ref String, ref String) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf ein Einzelobjekt aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. Declaration void GlobalOnBeforeLoad(DevFrameworkObject obj, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) Parameters obj DevFrameworkObject Component auf die der Load abgesetzt wurde. loadCondition String replacingHavingClause String replacingOrderClause String GlobalOnBeforeLoad(DevFrameworkObjectColl, ref String, ref String, ref String) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf eine Collection aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. Declaration void GlobalOnBeforeLoad(DevFrameworkObjectColl coll, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) Parameters coll FrameworkSystems.FrameworkBase.DevFrameworkObjectColl Collection auf der der Load abgesetzt wurde. loadCondition String replacingHavingClause String replacingOrderClause String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeSaveAction.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeSaveAction.html",
    "title": "Method GlobalOnBeforeSaveAction",
    "keywords": "Method GlobalOnBeforeSaveAction GlobalOnBeforeSaveAction(DevFrameworkObject) Diese Methode wird vor jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration void GlobalOnBeforeSaveAction(DevFrameworkObject obj) Parameters obj DevFrameworkObject"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnGetDynamicDragSource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnGetDynamicDragSource.html",
    "title": "Method GlobalOnGetDynamicDragSource",
    "keywords": "Method GlobalOnGetDynamicDragSource GlobalOnGetDynamicDragSource(MLContainer, String, Func<IDevFrameworkBaseObject>) Diese Methode wird aufgerufen, wenn für die Controls eines Forms ermittelt wird, ob eine Drag-Operation möglich ist und noch kein anderer DragSource oder ein OnDrag-Event am Control definiert wurde. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration Func<IDevFrameworkBaseObject, object> GlobalOnGetDynamicDragSource(MLContainer mdt, string propertyName, Func<IDevFrameworkBaseObject> objectGetter) Parameters mdt MLContainer Der Metadatentyp des Properties propertyName String Der Name des Properties objectGetter Func < IDevFrameworkBaseObject > Übergibt ein Delegate, welches das aktuelle im Datasource gesetzte Objekt zurückgibt. Returns Func < IDevFrameworkBaseObject , Object > Ein Delegate, welches das Objekt entgegennimmt aus welchem der DragSource ermittelt und zurückgegeben werden kann Remarks Innerhalb einer Sitzung erfolgt pro Metadatentyp nur ein Aufruf. Das zurückgegebene Delegate wird gecached. Am this.Global gibt es Methoden, um diesen Cache zu bearbeiten: ClearDynamicDragSources() SetDynamicDragSource(MLContainer, Func<IDevFrameworkBaseObject, Object>) RemoveDynamicDragSource(MLContainer)"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnHandleException.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnHandleException.html",
    "title": "Method GlobalOnHandleException",
    "keywords": "Method GlobalOnHandleException GlobalOnHandleException(Exception) Diese Methode wird vom Broker für alle Exceptions aufgerufen die er selber abfängt (ohne MsgBox-Exceptions!) Declaration void GlobalOnHandleException(Exception ex) Parameters ex Exception Remarks Evtl. auftauchende Fehler werden verschluckt!"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnHandlingException.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnHandlingException.html",
    "title": "Method GlobalOnHandlingException",
    "keywords": "Method GlobalOnHandlingException GlobalOnHandlingException(ref Exception) Declaration void GlobalOnHandlingException(ref Exception ex) Parameters ex Exception"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnIsDatabaseUpdateRequired.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnIsDatabaseUpdateRequired.html",
    "title": "Method GlobalOnIsDatabaseUpdateRequired",
    "keywords": "Method GlobalOnIsDatabaseUpdateRequired GlobalOnIsDatabaseUpdateRequired() Declaration int GlobalOnIsDatabaseUpdateRequired() Returns Int32"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnRegisterAuthServiceUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnRegisterAuthServiceUnits.html",
    "title": "Method GlobalOnRegisterAuthServiceUnits",
    "keywords": "Method GlobalOnRegisterAuthServiceUnits GlobalOnRegisterAuthServiceUnits() Diese Methode wird vom AUHelper aufgerufen, wenn mit Authentifizierung gearbeitet wird und (statisch einmalig) noch keine Registrierung der Units (Mandanten) am Auth Service erfolgt ist. Wird ein Enumerable zurückgegeben, so werden die angegebenen Units registriert. Wird \"null\" zurückgegeben, so wird keine Registrierung durchgeführt. Die Units werden durch KeyValuesPairs mit Key = ID (Primärschlüssel), Value = Name/Bezeichnung definiert. Declaration IEnumerable<KeyValuePair<string, string>> GlobalOnRegisterAuthServiceUnits() Returns IEnumerable < KeyValuePair < String , String >>"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.html",
    "title": "Interface IcGlobalBase",
    "keywords": "Interface IcGlobalBase Bereits im SystemPackage existiert im Namespace FSGeneral eine Component mit dem Namen cGlobal. Diese Component kann customized werden. Aus Forms oder Components heraus kann eine Instanz dieser Component mit this.Global. ocGlobal angesprochen werden. Namespace : FrameworkSystems.FrameworkBase.GlobalObj Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IcGlobalBase Methods GetClientCulture() Liefert die Culture des Clients zurück. Diese Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalGetMLText(MLKey, String) Jedes mal, wenn aus einem MLKey einen Text erzeugt wird, wird diese Methode aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalIsApplicationQuitAllowed() Diese Methode wird vom Broker bei einem vom Client gesendeten QuitApplication-Request aufgerufen. GlobalOnAfterHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die eigentliche Brokerlogik (Eventauswertung) durchgeführt wurde, bevor die Daten an den Client übermittelt werden. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnAfterSaveAction(DevFrameworkObject) Diese Methode wird nach jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnBeforeHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die übertragenen Daten eingelesen wurden, bevor die eigentliche Brokerlogik (Eventauswertung) ausgeführt wird. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnBeforeLoad(DevFrameworkObject, ref String, ref String, ref String) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf ein Einzelobjekt aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. GlobalOnBeforeLoad(DevFrameworkObjectColl, ref String, ref String, ref String) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf eine Collection aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. GlobalOnBeforeSaveAction(DevFrameworkObject) Diese Methode wird vor jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnGetDynamicDragSource(MLContainer, String, Func<IDevFrameworkBaseObject>) Diese Methode wird aufgerufen, wenn für die Controls eines Forms ermittelt wird, ob eine Drag-Operation möglich ist und noch kein anderer DragSource oder ein OnDrag-Event am Control definiert wurde. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnHandleException(Exception) Diese Methode wird vom Broker für alle Exceptions aufgerufen die er selber abfängt (ohne MsgBox-Exceptions!) GlobalOnHandlingException(ref Exception) GlobalOnIsDatabaseUpdateRequired() GlobalOnRegisterAuthServiceUnits() Diese Methode wird vom AUHelper aufgerufen, wenn mit Authentifizierung gearbeitet wird und (statisch einmalig) noch keine Registrierung der Units (Mandanten) am Auth Service erfolgt ist. Wird ein Enumerable zurückgegeben, so werden die angegebenen Units registriert. Wird \"null\" zurückgegeben, so wird keine Registrierung durchgeführt. Die Units werden durch KeyValuesPairs mit Key = ID (Primärschlüssel), Value = Name/Bezeichnung definiert. OnLicenseGranted(AccessUnit, AUPermissionType) Mit diesem EntryPoint kann eine Lizenz-Freigabe programmatisch eingeschränkt werden. Diese Methode wird aufgerufen, wenn LicenseGranted(AccessUnit) aufgerufen wird und die verwendete Lizenz-Datei den Zugriff auf die AccessUnit erlaubt."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.OnLicenseGranted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.OnLicenseGranted.html",
    "title": "Method OnLicenseGranted",
    "keywords": "Method OnLicenseGranted OnLicenseGranted(AccessUnit, AUPermissionType) Mit diesem EntryPoint kann eine Lizenz-Freigabe programmatisch eingeschränkt werden. Diese Methode wird aufgerufen, wenn LicenseGranted(AccessUnit) aufgerufen wird und die verwendete Lizenz-Datei den Zugriff auf die AccessUnit erlaubt. Declaration bool OnLicenseGranted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit type AUPermissionType Returns Boolean Remarks Die Methode wird nur aufgerufen, wenn die Lizenz den Zugriff erlaubt. Freischalten einer verbotenen Lizenz ist nicht möglich. Granted(AccessUnit) für die Rollen-Berechtigung mündet ebenfalls durch LicenseGranted(AccessUnit) in dieser Methode. Die Methode wird sehr oft aufgerufen. Eine Überschreibung sollte daher möglichst performant implementiert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AllLanguages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AllLanguages.html",
    "title": "Property AllLanguages",
    "keywords": "Property AllLanguages AllLanguages Gibt die Iso-Codes von allen gepflegten Sprachen zurück. Declaration IEnumerable<string> AllLanguages { get; } Property Value IEnumerable < String > Remarks Es ist entscheidend, dass in der jeweiligen Sprache mindestens ein Eintrag im Wörterbuch gepflegt ist und sich die Wörterbuch-Dateien im Broker-Verzeichnis befinden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AUHelper.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AUHelper.html",
    "title": "Property AUHelper",
    "keywords": "Property AUHelper AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. Declaration AUHelper AUHelper { get; } Property Value AUHelper"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ClearDynamicDragSources.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ClearDynamicDragSources.html",
    "title": "Method ClearDynamicDragSources",
    "keywords": "Method ClearDynamicDragSources ClearDynamicDragSources() Declaration void ClearDynamicDragSources()"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ClientInfos.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ClientInfos.html",
    "title": "Property ClientInfos",
    "keywords": "Property ClientInfos ClientInfos In diesem Dictionary sind Informationen abgelegt, die der Client beim Start der Anwendung an den Broker übertragen hat. Declaration Dictionary<string, string> ClientInfos { get; } Property Value Dictionary < String , String >"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CloseApplication.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CloseApplication.html",
    "title": "Method CloseApplication",
    "keywords": "Method CloseApplication CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. Declaration void CloseApplication() Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin . Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. Declaration void CloseApplication(FrameworkCloseMode closeMode) Parameters closeMode FrameworkCloseMode Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. CloseApplication(String) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. Declaration void CloseApplication(string message) Parameters message String Die Meldung die am Client angezeigt werden soll. Wird String.Empty übergeben, wird die Anwendung ohne Meldung beendet. Wird null übergeben, verhält sich die Methode wie die parameterlose CloseApplication() . Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CreateComponent.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CreateComponent.html",
    "title": "Method CreateComponent",
    "keywords": "Method CreateComponent CreateComponent(String) Erzeugt eine neue Component mit dem übergebenen Namen. Declaration object CreateComponent(string componentName) Parameters componentName String Returns Object Remarks Das zurückgegebene Objekt muss ggf. in einen anderen Typ umgewandelt werden, damit eine Weiterverarbeitung möglich ist. DevFrameworkObject oObject = this.Global.CreateComponent(\"Namespace.cdComponent\") as DevFrameworkObject; DevFrameworkObjectColl oColl = this.Global.CreateComponent(\"Namespace.cdComponentColl\") as DevFrameworkObjectColl; Der ComponentName entspricht dem FullName des Typs. Dieser kann auch zur Laufzeit ermittelt werden. sComponentName = oComponent.GetType().FullName; Warning Da der übergebene Parameter nicht kompiliert ist, sollte diese Funktion nur in Ausnahmefällen eingesetzt werden, um z.B. verallgemeinerte Logik umzusetzen."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.EndSafeInitialize.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.EndSafeInitialize.html",
    "title": "Method EndSafeInitialize",
    "keywords": "Method EndSafeInitialize EndSafeInitialize() Deaktiviert den SafeInitializing Modus. Declaration void EndSafeInitialize()"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.FormatMLKeyText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.FormatMLKeyText.html",
    "title": "Method FormatMLKeyText",
    "keywords": "Method FormatMLKeyText FormatMLKeyText(MLKey, Object[]) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die Client-Culture verwendet. Declaration MLKeyText FormatMLKeyText(MLKey mlkey, params object[] args) Parameters mlkey MLKey MLKey aus dem Wörterbuch. args Object [] Returns MLKeyText Examples Diese Methode wird z.B. für die Code-Messages benutzt: // FSCodeMessage: Please specify {0} throw new FrameworkApplicationException(this.Global.FormatMLKeyText(MLKeys.MSG_24979a3d247546318dc673c5501d3b15, this.sName), 0); See Also GetClientCulture() FormatMLKeyText(IFormatProvider, MLKey, Object[]) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die übergebene Culture verwendet. Declaration MLKeyText FormatMLKeyText(IFormatProvider culture, MLKey mlkey, params object[] args) Parameters culture IFormatProvider Die zu verwendende Culture. Bei null erfolgt ein Fallback auf die Client-Culture mlkey MLKey MLKey aus dem Wörterbuch. args Object [] Returns MLKeyText"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.FormatMLText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.FormatMLText.html",
    "title": "Method FormatMLText",
    "keywords": "Method FormatMLText FormatMLText(MLKey, Object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die Client-Culture verwendet. Declaration string FormatMLText(MLKey mlkey, params object[] args) Parameters mlkey MLKey MLKey aus dem Wörterbuch args Object [] Returns String Formatierter Text Examples FSstring sFormattedText = this.Global.FormatMLText( MLKeys.LBL_MitFormat, \"Text1\", lngAmount ); See Also GetClientCulture() FormatMLText(IFormatProvider, MLKey, Object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Arumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die übergebene Culture verwendet. Declaration string FormatMLText(IFormatProvider culture, MLKey mlkey, params object[] args) Parameters culture IFormatProvider Die zu verwendende Culture. Bei null erfolgt ein Fallback auf die Client-Culture mlkey MLKey MLKey aus dem Wörterbuch args Object [] Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetCodeDirectory.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetCodeDirectory.html",
    "title": "Method GetCodeDirectory",
    "keywords": "Method GetCodeDirectory GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft. Declaration string GetCodeDirectory() Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetMLKeyText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetMLKeyText.html",
    "title": "Method GetMLKeyText",
    "keywords": "Method GetMLKeyText GetMLKeyText(MLKey) Diese Methode gibt ein MLKeyText -Objekt zurück, welches neben dem Text auch den übergebenen MLKey beinhaltet. Das kann hilfreich sein, wenn der MLKey interessant ist, um ihn z.B. als Fehler-Code zu verwenden. Declaration MLKeyText GetMLKeyText(MLKey mlkey) Parameters mlkey MLKey Returns MLKeyText Examples Diese Methode wird z.B. für die Code-Messages benutzt: // FSCodeMessage: Please select only one article. throw new FrameworkApplicationException(this.Global.GetMLKeyText(MLKeys.MSG_1b6b9bea43304e2082d1162d75d9e317), 0);"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetMLText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetMLText.html",
    "title": "Method GetMLText",
    "keywords": "Method GetMLText GetMLText(MLKey) Ermittelt für den übergebenen MLKey den Text. Es wird die aktuell in der Session gesetzte Sprach-Hierarchie verwendet. Declaration string GetMLText(MLKey mlkey) Parameters mlkey MLKey Returns String Examples FSstring sArticleLabel = this.Global.GetMLText( MLKeys.LBL_Article ); GetMLText(MLKey, String) Diese Methode ermittelt für den übergebenen MLKey den Text für die übergebene Sprache. Es erfolgt kein Fallback auf eine andere Sprache. Declaration string GetMLText(MLKey mlkey, string iso) Parameters mlkey MLKey iso String Iso-Code der Sprache. Returns String Examples FSString sAmountEn = this.Global.GetMLText( MLKeys.LBL_Amount, \"en\" );"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.html",
    "title": "Interface IGlobalObjects",
    "keywords": "Interface IGlobalObjects Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten. Namespace : FrameworkSystems.FrameworkBase.GlobalObj Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IGlobalObjects : IFrameworkDBPerformanceCounter Properties AllLanguages Gibt die Iso-Codes von allen gepflegten Sprachen zurück. AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. ClientInfos In diesem Dictionary sind Informationen abgelegt, die der Client beim Start der Anwendung an den Broker übertragen hat. LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. Das sind die Sprachen in der Reihenfolge der Auswahl im Client Start. MLColumnLanguage Gibt den Iso-Code der Sprache zurück, die aktuell für die MLColumn-Properties verwendet wird. Normalerweise handelt es sich dabei um die SelectedLanguage . Mit der Methode UseMLColumnLanguage(String, Action) kann die Sprache vorrübergebend geändert werden. ocGlobal ReportingSoftware Welche Software beim Druck bevorzugt wird. SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. Methods ClearDynamicDragSources() CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin . Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. CloseApplication(String) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. CreateComponent(String) Erzeugt eine neue Component mit dem übergebenen Namen. EndSafeInitialize() Deaktiviert den SafeInitializing Modus. FormatMLKeyText(MLKey, Object[]) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die Client-Culture verwendet. FormatMLKeyText(IFormatProvider, MLKey, Object[]) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die übergebene Culture verwendet. FormatMLText(MLKey, Object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die Client-Culture verwendet. FormatMLText(IFormatProvider, MLKey, Object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Arumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die übergebene Culture verwendet. GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft. GetMLKeyText(MLKey) Diese Methode gibt ein MLKeyText -Objekt zurück, welches neben dem Text auch den übergebenen MLKey beinhaltet. Das kann hilfreich sein, wenn der MLKey interessant ist, um ihn z.B. als Fehler-Code zu verwenden. GetMLText(MLKey) Ermittelt für den übergebenen MLKey den Text. Es wird die aktuell in der Session gesetzte Sprach-Hierarchie verwendet. GetMLText(MLKey, String) Diese Methode ermittelt für den übergebenen MLKey den Text für die übergebene Sprache. Es erfolgt kein Fallback auf eine andere Sprache. RemoveDynamicDragSource(MLContainer) SetDynamicDragSource(MLContainer, Func<IDevFrameworkBaseObject, Object>) UseMLColumnLanguage(String, Action) Verwendet für MLColumn-Properties während der übergenenen Action die angegebene Sprache."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.LanguageHierarchy.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.LanguageHierarchy.html",
    "title": "Property LanguageHierarchy",
    "keywords": "Property LanguageHierarchy LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. Das sind die Sprachen in der Reihenfolge der Auswahl im Client Start. Declaration IEnumerable<string> LanguageHierarchy { get; set; } Property Value IEnumerable < String > Remarks Beim Setzen kann jeder Typ zugewiesen werden, der von IEnumerable<string> erbt. Es ist jedoch empfehlenswert, mit einer ReadOnlyCollection<string> zu arbeiten, um Manipulationen an dieser Liste zu verhindern. Diese kann zum Beispiel mit der Methode Liste<string>.AsReadOnly() erzeugt werden. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.MLColumnLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.MLColumnLanguage.html",
    "title": "Property MLColumnLanguage",
    "keywords": "Property MLColumnLanguage MLColumnLanguage Gibt den Iso-Code der Sprache zurück, die aktuell für die MLColumn-Properties verwendet wird. Normalerweise handelt es sich dabei um die SelectedLanguage . Mit der Methode UseMLColumnLanguage(String, Action) kann die Sprache vorrübergebend geändert werden. Declaration string MLColumnLanguage { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ocGlobal.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ocGlobal.html",
    "title": "Property ocGlobal",
    "keywords": "Property ocGlobal ocGlobal Declaration IcGlobalBase ocGlobal { get; } Property Value IcGlobalBase"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.RemoveDynamicDragSource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.RemoveDynamicDragSource.html",
    "title": "Method RemoveDynamicDragSource",
    "keywords": "Method RemoveDynamicDragSource RemoveDynamicDragSource(MLContainer) Declaration bool RemoveDynamicDragSource(MLContainer mdt) Parameters mdt MLContainer Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ReportingSoftware.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ReportingSoftware.html",
    "title": "Property ReportingSoftware",
    "keywords": "Property ReportingSoftware ReportingSoftware Welche Software beim Druck bevorzugt wird. Declaration ReportingSoftware ReportingSoftware { get; set; } Property Value ReportingSoftware Remarks Es muss entweder CrystalReports oder DevExpress angegeben werden. Eine Kombination oder ein anderer Wert sind nicht zulässig. Exceptions Type Condition ArgumentOutOfRangeException Es wurde ein ungültiger Wert übergeben."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SafeInitializing.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SafeInitializing.html",
    "title": "Property SafeInitializing",
    "keywords": "Property SafeInitializing SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. Declaration bool SafeInitializing { get; } Property Value Boolean Remarks Der Modus kann mithilfe der Methode EndSafeInitialize() zurückgesetzt werden. Wenn diese Methode einmal aufgerufen wurde, dann ist es nicht mehr möglich, den Modus wieder zu aktivieren. Wenn dieser Modus aktiv ist, dann können z.B. in einer Update-Sitation Exceptions unterbunden werden, die den Start der Anwendung verhindern würden. Examples try { [Aktion] } catch (Exception ex) { if (this.Global.SafeInitializing) { [Fehler behandeln] } else { // Exception weiter werfen. throw; } }"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SelectedLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SelectedLanguage.html",
    "title": "Property SelectedLanguage",
    "keywords": "Property SelectedLanguage SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. Declaration string SelectedLanguage { get; set; } Property Value String Remarks Beim Setzen der SelectedLanguage gibt es 2 Möglichkeiten: 1.) Es wird nur ein ISO-Code übergeben.Dieser wird an die erste Stelle der LanguageHierarchy gesetzt. Wenn dieser Code schon in der Hierarchie enthalten ist, dann wird dieser an die erste Stelle verschoben. 2.) Es wird eine Komma-separierte Liste von ISO-Codes übergeben.In diesem Fall wird aus dieser Liste eine neue LanguageHierarchy aufgebaut. Die Sprache wird beim Start im Client festgelegt. Der Broker wechselt beim Start der Anwendung ggf. auf die Default-Sprache der Anwendung, wenn die vom Client angefragte Sprache nicht zur Verfügung steht. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SetDynamicDragSource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SetDynamicDragSource.html",
    "title": "Method SetDynamicDragSource",
    "keywords": "Method SetDynamicDragSource SetDynamicDragSource(MLContainer, Func<IDevFrameworkBaseObject, Object>) Declaration void SetDynamicDragSource(MLContainer mdt, Func<IDevFrameworkBaseObject, object> getterDelegate) Parameters mdt MLContainer getterDelegate Func < IDevFrameworkBaseObject , Object >"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.UseMLColumnLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.UseMLColumnLanguage.html",
    "title": "Method UseMLColumnLanguage",
    "keywords": "Method UseMLColumnLanguage UseMLColumnLanguage(String, Action) Verwendet für MLColumn-Properties während der übergenenen Action die angegebene Sprache. Declaration void UseMLColumnLanguage(string iso, Action action) Parameters iso String action Action"
  },
  "api/FrameworkSystems.FrameworkBase.GridRowHeader.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GridRowHeader.html",
    "title": "Enum GridRowHeader",
    "keywords": "Enum GridRowHeader Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum GridRowHeader Fields Name Description DisplayRowNumber DisplayRowStatus DisplayRowStatusAndNumber Inherit"
  },
  "api/FrameworkSystems.FrameworkBase.HorizontalAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.HorizontalAlignment.html",
    "title": "Enum HorizontalAlignment",
    "keywords": "Enum HorizontalAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum HorizontalAlignment Fields Name Description Center Left Right Stretch"
  },
  "api/FrameworkSystems.FrameworkBase.html": {
    "href": "api/FrameworkSystems.FrameworkBase.html",
    "title": "Namespace FrameworkSystems.FrameworkBase",
    "keywords": "Namespace FrameworkSystems.FrameworkBase Classes BrowserCommand Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. DevFrameworkObject TODO! Basisklasse für alle Components die über das FrameworkStudio erzeugt werden. FrameworkProgress Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. FrameworkQueryOptions SelectedRowsCollection !TODO StaticCache Diese statische Klasse bietet Methoden zur Ermittlung eines untypisierten Caches über den Namen oder ein übergebenes IDevFrameworkDataObject, soweit dieser existiert. Interfaces IDevFrameworkBaseObject IDevFrameworkDataObject IDevFrameworkObject IDevFrameworkObjectMLString Repräsentiert den Eintrag einer TextCollection. IFrameworkBarcodeScanInfo Eine Instanz dieses Typs wird nach einem mit der Action ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) ausgelösten Scan-Vorgang der Callback-Methode übergeben. Sie beinhaltet die Ergebisse des Scan-Vorgangs. IFrameworkControlActionBase IFrameworkGeoLocationInfo Eine Instanz dieses Typs wird nach einem mit der Action GetGeoLocation(Action<IFrameworkGeoLocationInfo>) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet alle Informationen zum derzeitigen Standort des Endgeräts. IFrameworkPhotoInfo Eine Instanz dieses Typs wird nach einem mit der Action TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet die Bilddaten des neuen oder ausgewählten Bildes und Zusatzinformationen. IGridView Ein Grid zeigt immer Daten einer Collection an. Um mit den Daten zu arbeiten, muss auf die Collection zugegriffen werden, die an das entsprechende Grid gebunden ist. IStaticCache Schnittstelle eines statischen, untypisierten Caches für Elemente vom Typ IDevFrameworkObject, die über einen untypisierten Primärschlüssel eindeutig identifiziert werden können. Der Cache implementiert IEnumerable (untypisiert). IStaticCache<TObj, TPK> Schnittstelle eines statischen Caches für Elemente vom Typ TObj, die über den Primärschlüssel vom Typ TPK eindeutig identifiziert werden können. Der Cache implementiert IEnumerable<TObj>. Der Cache ist NICHT Thread-Save. Methoden dürfen nur aus dem Thread des übergebenen GlobalObjects heraus aufgerufen werden. IStaticCacheObject Stellt eine Schnittstelle zu einem Objekt im Cache dar. Über die Methode TryGetPropertyValue(String, out Object) kann der Wert von Datenbank-Properties abgefragt werden. Enums AUPermissionType Das AUPermissionType Enum kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden. BarcodeFormat CameraSource DevTextAlign Gibt die Ausrichtung des Textes an. DockPanelOrientation DockPanelScrolling EditorStyle ExtendedShortcut ExtendedShortcut contains the same properties as the System.Windows.Forms.Shortcut enumeration. Furthermore it is extended by: Esc = 27 FieldRowLabelMode FrameworkComponentState Status des Objektes. FrameworkFormatMask TODO! (auch die einzelnen Formate mit Beispielen beschreiben) FromControlWrapperProcessedState Verarbeitungsstatus der in einem Grid verwendeten Objekte FSVisibility GridRowHeader HorizontalAlignment ListSortOrder Sortierar ListViewHorizontalContentAlignment ListViewItemArrangement ListViewSelectionMode ListViewSelectorPosition ListViewTemplateVariableDataSourceOrigin ListViewVerticalContentAlignment PictureScaleMode used for Picture.ScaleMode SaveEntryPoints StackPanelHAlignment StackPanelOrientation StackPanelVAlignment StaticCacheMode Arbeitsmodus eines statischen Caches. Dieser kann im Einsprungpunkt GlobalGetStaticCacheMode(IDevFrameworkDataObject) pro Component-Typ festgelegt werden. TextEditorType Used for example by the Editbox control to specify the kind of text to be handled by the control. TreeViewDragDropMode VerticalAlignment WrapPanelHorizontalContentAlignment WrapPanelVerticalContentAlignment WrapPanelWrapArrangement"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.ComponentProperties.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.ComponentProperties.html",
    "title": "Property ComponentProperties",
    "keywords": "Property ComponentProperties ComponentProperties Gibt eine Liste mit den Namen aller public oder internal Properties zurück, die vom Entwickler in der IDE definiert wurden. RowID und RowVersion sind nicht enthalten. Declaration [Browsable(false)] StringCollection ComponentProperties { get; } Property Value StringCollection"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.GetProperty.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.GetProperty.html",
    "title": "Method GetProperty",
    "keywords": "Method GetProperty GetProperty(String) Gibt den Wert des Properties mit dem übergebenen propertyName zurück. Declaration object GetProperty(string propertyName) Parameters propertyName String Name des zu ermittelnden Properties. Returns Object Remarks Es darf nur auf public oder internal Properties zugegriffen werden. Beim zugriff auf protected oder private Properties wird eine PropertyNotFoundException geworfen. Existiert das Property nicht, dann wird eine PropertyNotFoundException geworfen. Exceptions Type Condition PropertyNotFoundException Das übergebene Property existiert nicht oder dessen Zugriffsmodifizierer erlaubt keinen Zugriff."
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.GetPropertyMdt.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.GetPropertyMdt.html",
    "title": "Method GetPropertyMdt",
    "keywords": "Method GetPropertyMdt GetPropertyMdt(String) Gibt den Metadatentyp des übergebenen Properties zurück Declaration MLContainer GetPropertyMdt(string propertyName) Parameters propertyName String Name des Properties Returns MLContainer"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.html",
    "title": "Interface IDevFrameworkBaseObject",
    "keywords": "Interface IDevFrameworkBaseObject Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IDevFrameworkBaseObject : FrameworkDataTransaction.ISource, INotifyPropertyChanged Properties ComponentProperties Gibt eine Liste mit den Namen aller public oder internal Properties zurück, die vom Entwickler in der IDE definiert wurden. RowID und RowVersion sind nicht enthalten. Methods GetProperty(String) Gibt den Wert des Properties mit dem übergebenen propertyName zurück. GetPropertyMdt(String) Gibt den Metadatentyp des übergebenen Properties zurück IsComponentProperty(String) Prüft, ob der übergebene PropertyName in ComponentProperties enthalten ist. SetProperty(String, Object) Setzt das Properties mit dem übergebenen propertyName auf den Wert value ."
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.IsComponentProperty.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.IsComponentProperty.html",
    "title": "Method IsComponentProperty",
    "keywords": "Method IsComponentProperty IsComponentProperty(String) Prüft, ob der übergebene PropertyName in ComponentProperties enthalten ist. Declaration bool IsComponentProperty(string propertyName) Parameters propertyName String Name des Properties Returns Boolean Remarks So kann man z.B. bei der Behandlung des Events PropertyChanged prüfen, ob das Property vom Entwickler angelgt wurde. Andernfalls handelt es sich ggf. um ein von Framework Studio bereitgestelltes Property wie z.B. State . Die Methode liefert true bei public oder internal Properties. Bei RowID und RowVersion wird false zurückgegeben."
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.SetProperty.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject.SetProperty.html",
    "title": "Method SetProperty",
    "keywords": "Method SetProperty SetProperty(String, Object) Setzt das Properties mit dem übergebenen propertyName auf den Wert value . Declaration void SetProperty(string propertyName, object value) Parameters propertyName String Name des zu setzenden Properties. value Object Zu setzender Wert. Remarks Existiert das Property nicht, dann wird eine MissingMemberException geworfen. Exceptions Type Condition MissingMemberException"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.Exists.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.Exists.html",
    "title": "Method Exists",
    "keywords": "Method Exists Exists(String) Declaration bool Exists(string condition) Parameters condition String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.GetFetchNext.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.GetFetchNext.html",
    "title": "Method GetFetchNext",
    "keywords": "Method GetFetchNext GetFetchNext() Declaration IEnumerable<IDevFrameworkDataObject> GetFetchNext() Returns IEnumerable < IDevFrameworkDataObject > GetFetchNext(FrameworkQueryOptions) Declaration IEnumerable<IDevFrameworkDataObject> GetFetchNext(FrameworkQueryOptions options) Parameters options FrameworkQueryOptions Returns IEnumerable < IDevFrameworkDataObject > GetFetchNext(String) Declaration IEnumerable<IDevFrameworkDataObject> GetFetchNext(string loadCondition) Parameters loadCondition String Returns IEnumerable < IDevFrameworkDataObject > GetFetchNext(String, String) Declaration IEnumerable<IDevFrameworkDataObject> GetFetchNext(string loadCondition, string replacingOrderByClause) Parameters loadCondition String replacingOrderByClause String Returns IEnumerable < IDevFrameworkDataObject > GetFetchNext(String, String, String) Declaration IEnumerable<IDevFrameworkDataObject> GetFetchNext(string loadCondition, string replacingHavingClause, string replacingOrderByClause) Parameters loadCondition String replacingHavingClause String replacingOrderByClause String Returns IEnumerable < IDevFrameworkDataObject >"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.HasDbChanged.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.HasDbChanged.html",
    "title": "Method HasDbChanged",
    "keywords": "Method HasDbChanged HasDbChanged() Declaration bool HasDbChanged() Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.html",
    "title": "Interface IDevFrameworkDataObject",
    "keywords": "Interface IDevFrameworkDataObject Inherited Members IDevFrameworkObject.ObjectRowID IDevFrameworkObject.State IDevFrameworkObject.StateBeforeUpdate IDevFrameworkObject.IsMarkedForDeletion IDevFrameworkBaseObject.GetPropertyMdt(String) IDevFrameworkBaseObject.GetProperty(String) IDevFrameworkBaseObject.SetProperty(String, Object) IDevFrameworkBaseObject.ComponentProperties IDevFrameworkBaseObject.IsComponentProperty(String) Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IDevFrameworkDataObject : IDevFrameworkObject, IDevFrameworkBaseObject, FrameworkDataTransaction.ISource, INotifyPropertyChanged Methods Exists(String) GetFetchNext() GetFetchNext(FrameworkQueryOptions) GetFetchNext(String) GetFetchNext(String, String) GetFetchNext(String, String, String) HasDbChanged() LoadCount(String)"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.LoadCount.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkDataObject.LoadCount.html",
    "title": "Method LoadCount",
    "keywords": "Method LoadCount LoadCount(String) Declaration int LoadCount(string condition) Parameters condition String Returns Int32"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.html",
    "title": "Interface IDevFrameworkObject",
    "keywords": "Interface IDevFrameworkObject Inherited Members IDevFrameworkBaseObject.GetPropertyMdt(String) IDevFrameworkBaseObject.GetProperty(String) IDevFrameworkBaseObject.SetProperty(String, Object) IDevFrameworkBaseObject.ComponentProperties IDevFrameworkBaseObject.IsComponentProperty(String) Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IDevFrameworkObject : IDevFrameworkBaseObject, FrameworkDataTransaction.ISource, INotifyPropertyChanged Remarks Alle Business-Objekte, die im Developement Framework verwendet werden sollen, müssen dieses Interface einbinden. Properties IsMarkedForDeletion Wenn true, ist das Objekt zum Löschen vorgemerkt. Vor einem Save wird an der Collection FrameworkSystems.FrameworkBase.DevFrameworkObjectColl.DeleteMarkedObjects aufgerufen und so dann an allen markierten Objekten Delete aufgerufen. Wenn FrameworkSystems.FrameworkBase.IDevFrameworkObject.Save direkt am Objekt aufgerufen wird, wird FrameworkSystems.FrameworkBase.IDevFrameworkObject.DeleteMarkedObject am Objekt aufgerufen. ObjectRowID Eindeutige ID vom Typ guid des Objektes. State Status des IDevFrameworkObjects vom Typ FrameworkComponentState StateBeforeUpdate !TODO"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.IsMarkedForDeletion.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.IsMarkedForDeletion.html",
    "title": "Property IsMarkedForDeletion",
    "keywords": "Property IsMarkedForDeletion IsMarkedForDeletion Wenn true, ist das Objekt zum Löschen vorgemerkt. Vor einem Save wird an der Collection FrameworkSystems.FrameworkBase.DevFrameworkObjectColl.DeleteMarkedObjects aufgerufen und so dann an allen markierten Objekten Delete aufgerufen. Wenn FrameworkSystems.FrameworkBase.IDevFrameworkObject.Save direkt am Objekt aufgerufen wird, wird FrameworkSystems.FrameworkBase.IDevFrameworkObject.DeleteMarkedObject am Objekt aufgerufen. Declaration [Browsable(false)] bool IsMarkedForDeletion { get; set; } Property Value Boolean Remarks Änderungen werden über das Event PropertyChanged gemeldet."
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.ObjectRowID.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.ObjectRowID.html",
    "title": "Property ObjectRowID",
    "keywords": "Property ObjectRowID ObjectRowID Eindeutige ID vom Typ guid des Objektes. Declaration [Browsable(false)] guid ObjectRowID { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.State.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.State.html",
    "title": "Property State",
    "keywords": "Property State State Status des IDevFrameworkObjects vom Typ FrameworkComponentState Declaration [Browsable(false)] FrameworkComponentState State { get; set; } Property Value FrameworkComponentState Remarks Änderungen werden über das Event PropertyChanged gemeldet."
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.StateBeforeUpdate.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.StateBeforeUpdate.html",
    "title": "Property StateBeforeUpdate",
    "keywords": "Property StateBeforeUpdate StateBeforeUpdate !TODO Declaration [Browsable(false)] FrameworkComponentState StateBeforeUpdate { get; set; } Property Value FrameworkComponentState"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.GetText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.GetText.html",
    "title": "Method GetText",
    "keywords": "Method GetText GetText(String) Liefert den Text in der übergebenen Sprache. Es erfolgt keine Fallback auf eine andere Sprache. Declaration string GetText(string iso) Parameters iso String 2-Zeichen iso-Code Returns String Remarks Wird der Text in der Sprache bzw. der Sprach-Hierarchie der aktuellen Sitzung benötigt, sollte das Property Text verwendet werden."
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.html",
    "title": "Interface IDevFrameworkObjectMLString",
    "keywords": "Interface IDevFrameworkObjectMLString Repräsentiert den Eintrag einer TextCollection. Inherited Members IDevFrameworkObject.ObjectRowID IDevFrameworkObject.State IDevFrameworkObject.StateBeforeUpdate IDevFrameworkObject.IsMarkedForDeletion IDevFrameworkBaseObject.GetPropertyMdt(String) IDevFrameworkBaseObject.GetProperty(String) IDevFrameworkBaseObject.SetProperty(String, Object) IDevFrameworkBaseObject.ComponentProperties IDevFrameworkBaseObject.IsComponentProperty(String) Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IDevFrameworkObjectMLString : IDevFrameworkObject, IDevFrameworkBaseObject, FrameworkDataTransaction.ISource, INotifyPropertyChanged Properties ID ID des TextCollection-Eintrages. Text Text in der aktuellen Sprache bzw. Sprach-Hierarchie. Value Der mehrsprachige Text des TextCollection-Eintrages. Methods GetText(String) Liefert den Text in der übergebenen Sprache. Es erfolgt keine Fallback auf eine andere Sprache."
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.ID.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.ID.html",
    "title": "Property ID",
    "keywords": "Property ID ID ID des TextCollection-Eintrages. Declaration int ID { get; set; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Text in der aktuellen Sprache bzw. Sprach-Hierarchie. Declaration string Text { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Value Der mehrsprachige Text des TextCollection-Eintrages. Declaration DevMLString Value { get; } Property Value DevMLString"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Cancelled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Cancelled.html",
    "title": "Property Cancelled",
    "keywords": "Property Cancelled Cancelled true wenn der Scanvorgang am Client abgebrochen wurde Declaration bool Cancelled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.ErrorMessage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.ErrorMessage.html",
    "title": "Property ErrorMessage",
    "keywords": "Property ErrorMessage ErrorMessage Fehlermeldung bei einem gescheiterten Scanvorgang Declaration string ErrorMessage { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Format.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Format Das Format des gescannten Barcodes. NONE , wenn kein Barcode gescannt wurde. Declaration BarcodeFormat Format { get; } Property Value BarcodeFormat"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.HasError.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.HasError.html",
    "title": "Property HasError",
    "keywords": "Property HasError HasError true wenn beim Scanvorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Declaration bool HasError { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.html",
    "title": "Interface IFrameworkBarcodeScanInfo",
    "keywords": "Interface IFrameworkBarcodeScanInfo Eine Instanz dieses Typs wird nach einem mit der Action ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) ausgelösten Scan-Vorgang der Callback-Methode übergeben. Sie beinhaltet die Ergebisse des Scan-Vorgangs. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IFrameworkBarcodeScanInfo Properties Cancelled true wenn der Scanvorgang am Client abgebrochen wurde ErrorMessage Fehlermeldung bei einem gescheiterten Scanvorgang Format Das Format des gescannten Barcodes. NONE , wenn kein Barcode gescannt wurde. HasError true wenn beim Scanvorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Identifier Der in der Action ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, String) übergebene Wert, sonst null . Value Der Wert des gescannten Barcodes"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Identifier.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Identifier.html",
    "title": "Property Identifier",
    "keywords": "Property Identifier Identifier Der in der Action ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, String) übergebene Wert, sonst null . Declaration string Identifier { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Value Der Wert des gescannten Barcodes Declaration string Value { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.ControlName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.ControlName.html",
    "title": "Property ControlName",
    "keywords": "Property ControlName ControlName Declaration string ControlName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.Form.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.Form.html",
    "title": "Property Form",
    "keywords": "Property Form Form Declaration IGeneratedForm Form { get; } Property Value FrameworkSystems.FrameworkBase.IGeneratedForm"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.html",
    "title": "Interface IFrameworkControlActionBase",
    "keywords": "Interface IFrameworkControlActionBase Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IFrameworkControlActionBase Properties ControlName Form"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Accuracy.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Accuracy.html",
    "title": "Property Accuracy",
    "keywords": "Property Accuracy Accuracy Genauigkeit für die Werte Latitude und Logitude in Metern Declaration int? Accuracy { get; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Altitude.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Altitude.html",
    "title": "Property Altitude",
    "keywords": "Property Altitude Altitude Höhe in Metern über dem Meeresspiegel Declaration int? Altitude { get; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.ErrorMessage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.ErrorMessage.html",
    "title": "Property ErrorMessage",
    "keywords": "Property ErrorMessage ErrorMessage Fehlermeldung, wenn der Standort nicht bestimmt werden konnte Declaration string ErrorMessage { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.HasError.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.HasError.html",
    "title": "Property HasError",
    "keywords": "Property HasError HasError true wenn beim Bestimmen des Standortes ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Declaration bool HasError { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Heading.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Heading.html",
    "title": "Property Heading",
    "keywords": "Property Heading Heading Bewegungsrichtung in Grad relativ zum Norden (im Uhrzeigersinn) Declaration int? Heading { get; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.html",
    "title": "Interface IFrameworkGeoLocationInfo",
    "keywords": "Interface IFrameworkGeoLocationInfo Eine Instanz dieses Typs wird nach einem mit der Action GetGeoLocation(Action<IFrameworkGeoLocationInfo>) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet alle Informationen zum derzeitigen Standort des Endgeräts. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IFrameworkGeoLocationInfo Properties Accuracy Genauigkeit für die Werte Latitude und Logitude in Metern Altitude Höhe in Metern über dem Meeresspiegel ErrorMessage Fehlermeldung, wenn der Standort nicht bestimmt werden konnte HasError true wenn beim Bestimmen des Standortes ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Heading Bewegungsrichtung in Grad relativ zum Norden (im Uhrzeigersinn) Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation(System.Action{FrameworkSystems.FrameworkBase.IFrameworGeoLocationInfo},System.String) übergebene Wert, sonst null . Latitude Breitengrad z.B. 47.8477500 Longitude Längengrad z.B. 9.0057000 Speed Geschwindigkeit des Getätes in m/s Timestamp Zeitstempel der Standortbestimmung"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Identifier.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Identifier.html",
    "title": "Property Identifier",
    "keywords": "Property Identifier Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation(System.Action{FrameworkSystems.FrameworkBase.IFrameworGeoLocationInfo},System.String) übergebene Wert, sonst null . Declaration string Identifier { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Latitude.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Latitude.html",
    "title": "Property Latitude",
    "keywords": "Property Latitude Latitude Breitengrad z.B. 47.8477500 Declaration double? Latitude { get; } Property Value Nullable < Double >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Longitude.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Longitude.html",
    "title": "Property Longitude",
    "keywords": "Property Longitude Longitude Längengrad z.B. 9.0057000 Declaration double? Longitude { get; } Property Value Nullable < Double >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Speed.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Speed.html",
    "title": "Property Speed",
    "keywords": "Property Speed Speed Geschwindigkeit des Getätes in m/s Declaration int? Speed { get; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Timestamp.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Timestamp.html",
    "title": "Property Timestamp",
    "keywords": "Property Timestamp Timestamp Zeitstempel der Standortbestimmung Declaration long? Timestamp { get; } Property Value Nullable < Int64 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ErrorMessage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ErrorMessage.html",
    "title": "Property ErrorMessage",
    "keywords": "Property ErrorMessage ErrorMessage Fehlermeldung bei einem gescheiterten Vorgang Declaration string ErrorMessage { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.HasError.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.HasError.html",
    "title": "Property HasError",
    "keywords": "Property HasError HasError true wenn beim Vorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Declaration bool HasError { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.html",
    "title": "Interface IFrameworkPhotoInfo",
    "keywords": "Interface IFrameworkPhotoInfo Eine Instanz dieses Typs wird nach einem mit der Action TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet die Bilddaten des neuen oder ausgewählten Bildes und Zusatzinformationen. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IFrameworkPhotoInfo Properties ErrorMessage Fehlermeldung bei einem gescheiterten Vorgang HasError true wenn beim Vorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto(System.Action{FrameworkSystems.FrameworkBase.IFrameworPhotoInfo},FrameworkSystems.FrameworkBase.CameraSource,System.String) übergebene Wert, sonst null . ImageBase64 Das Bild im JPG-Format encodiert als Base64-String ImageBytes Das Bild im JPG-Format als Byte-Array"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.Identifier.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.Identifier.html",
    "title": "Property Identifier",
    "keywords": "Property Identifier Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto(System.Action{FrameworkSystems.FrameworkBase.IFrameworPhotoInfo},FrameworkSystems.FrameworkBase.CameraSource,System.String) übergebene Wert, sonst null . Declaration string Identifier { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ImageBase64.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ImageBase64.html",
    "title": "Property ImageBase64",
    "keywords": "Property ImageBase64 ImageBase64 Das Bild im JPG-Format encodiert als Base64-String Declaration string ImageBase64 { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ImageBytes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ImageBytes.html",
    "title": "Property ImageBytes",
    "keywords": "Property ImageBytes ImageBytes Das Bild im JPG-Format als Byte-Array Declaration byte[] ImageBytes { get; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.IGridView.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IGridView.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Count Anzahl der Records. Declaration int Count { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkBase.IGridView.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IGridView.html",
    "title": "Interface IGridView",
    "keywords": "Interface IGridView Ein Grid zeigt immer Daten einer Collection an. Um mit den Daten zu arbeiten, muss auf die Collection zugegriffen werden, die an das entsprechende Grid gebunden ist. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IGridView : IEnumerable<DevFrameworkObject>, IEnumerable Remarks Wenn über den Client die Daten im Grid sortiert oder gefiltert werden, dann stimmt die Reihenfolge der Elemente in der Collection nicht mehr mit der Anzeige überein. Um auf die den Filterkriterien entsprechenden Elemente in der angezeigten Reihenfolge zugreifen zu können, stellt FrameworkStudio einen View zur Verfügung. Dieser kann am Grid mit der Funktion GetView() abgerufen werden: IGridView gridView = this.grdTableXyz.GetView(); IGridView kann zum einen enumeriert werden, also zum Beispiel mit foreach durchlaufen werden. Zum anderen kann über den Index gezielt auf das x-te Element der Collection zugegriffen werden. IGridView arbeitet mit der Basis-Klasse DevFrameworkObject. Ggf. müssen die ermittelten Elemente mit dem entsprechenden Cast in das gewünschte Format konvertiert werden. // Liste durchlaufen foreach(IcdCustomer oCustomer in gridView) { // Satz verarbeiten [...] } // gezielt einen Satz holen, Cast in entsprchenden Typ IcdCustomer oCustomer = (IcdCustomer) gridView[intIndex]; Properties Count Anzahl der Records. Item[guid] Gibt den Record mit der übergebenen ID zurück. Item[Int32] Gibt den Record zum angegebenen Index zurück. Methods IndexOf(IDevFrameworkObject) Liefert den Index des übergebenen Objektes im View. IndexOf(guid) Liefert den Index der übergebenen Objekt-ID im View. ObjectRowIDOf(Int32) Ermittelt die rowID des enthaltnenen Records zum dem angegebenen Index. RedoSortAndFilter() Wendet die Sortierung und die Filter erneut an - z.B. nachdem Änderungen an der Collection vorgenommen wurden. ResetSortAndFilter() Setzt die Sortierung und die Filter zurück. Extension Methods EnumarableExtensions.Chunk<T>(IEnumerable<T>, Int32) EnumarableExtensions.DistinctBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>) EnumarableExtensions.ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>, IEqualityComparer<TKey>) EnumarableExtensions.ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>) EnumarableExtensions.OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, Boolean) EnumarableExtensions.OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>, Boolean) EnumarableExtensions.OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, Boolean) EnumarableExtensions.OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, IEqualityComparer<TKey>, Boolean)"
  },
  "api/FrameworkSystems.FrameworkBase.IGridView.IndexOf.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IGridView.IndexOf.html",
    "title": "Method IndexOf",
    "keywords": "Method IndexOf IndexOf(IDevFrameworkObject) Liefert den Index des übergebenen Objektes im View. Declaration int IndexOf(IDevFrameworkObject obj) Parameters obj IDevFrameworkObject Returns Int32 Index; -1 wenn nicht gefunden IndexOf(guid) Liefert den Index der übergebenen Objekt-ID im View. Declaration int IndexOf(guid id) Parameters id guid Returns Int32 Index; -1 wenn nicht gefunden"
  },
  "api/FrameworkSystems.FrameworkBase.IGridView.Item.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IGridView.Item.html",
    "title": "Property Item",
    "keywords": "Property Item Item[Int32] Gibt den Record zum angegebenen Index zurück. Declaration DevFrameworkObject this[int index] { get; } Parameters index Int32 Property Value DevFrameworkObject Item[guid] Gibt den Record mit der übergebenen ID zurück. Declaration DevFrameworkObject this[guid id] { get; } Parameters id guid Property Value DevFrameworkObject null , wenn der Record nicht gefunden wurde."
  },
  "api/FrameworkSystems.FrameworkBase.IGridView.ObjectRowIDOf.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IGridView.ObjectRowIDOf.html",
    "title": "Method ObjectRowIDOf",
    "keywords": "Method ObjectRowIDOf ObjectRowIDOf(Int32) Ermittelt die rowID des enthaltnenen Records zum dem angegebenen Index. Declaration guid ObjectRowIDOf(int index) Parameters index Int32 Returns guid Remarks Der Record muss nicht aus der Datenbank gelesen werden, wenn er noch nicht bekannt ist."
  },
  "api/FrameworkSystems.FrameworkBase.IGridView.RedoSortAndFilter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IGridView.RedoSortAndFilter.html",
    "title": "Method RedoSortAndFilter",
    "keywords": "Method RedoSortAndFilter RedoSortAndFilter() Wendet die Sortierung und die Filter erneut an - z.B. nachdem Änderungen an der Collection vorgenommen wurden. Declaration void RedoSortAndFilter()"
  },
  "api/FrameworkSystems.FrameworkBase.IGridView.ResetSortAndFilter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IGridView.ResetSortAndFilter.html",
    "title": "Method ResetSortAndFilter",
    "keywords": "Method ResetSortAndFilter ResetSortAndFilter() Setzt die Sortierung und die Filter zurück. Declaration void ResetSortAndFilter()"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.ContainsKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.ContainsKey.html",
    "title": "Method ContainsKey",
    "keywords": "Method ContainsKey ContainsKey(Object) Liefert true, wenn der übergebene Schlüssel in dem Cache bereits existiert; andernfalls false. Declaration bool ContainsKey(object pk) Parameters pk Object Schlüssel Returns Boolean True, wenn existent; andernfalls false."
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.FillCollection.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.FillCollection.html",
    "title": "Method FillCollection",
    "keywords": "Method FillCollection FillCollection<TColl>(TColl) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. Declaration int FillCollection<TColl>(TColl value) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl Returns Int32 Type Parameters Name Description TColl FillCollection<TColl>(TColl, Func<IDevFrameworkObject, Boolean>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Where-Bedingung wird vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. Declaration int FillCollection<TColl>(TColl value, Func<IDevFrameworkObject, bool> where) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl where Func < IDevFrameworkObject , Boolean > Returns Int32 Type Parameters Name Description TColl FillCollection<TColl>(TColl, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache unter Berücksichtigung der angegebenen Sortierung. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Sortierung wird vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte durchgeführt. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. Declaration int FillCollection<TColl>(TColl value, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl orderBy Func < IEnumerable < IDevFrameworkObject >, IEnumerable < IDevFrameworkObject >> Returns Int32 Type Parameters Name Description TColl Examples cdCurrencyCache.Get(this.Global).FillCollection(this.oCurrencyColl, (currencies) => currencies.OrderBy(currency => currency.sName). FillCollection<TColl>(TColl, Func<IDevFrameworkObject, Boolean>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Leert und befüllt die übergebene Collection unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Where-Bedingung und die Sortierung werden vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. Declaration int FillCollection<TColl>(TColl value, Func<IDevFrameworkObject, bool> where, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl where Func < IDevFrameworkObject , Boolean > orderBy Func < IEnumerable < IDevFrameworkObject >, IEnumerable < IDevFrameworkObject >> Returns Int32 Type Parameters Name Description TColl"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.FillObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.FillObject.html",
    "title": "Method FillObject",
    "keywords": "Method FillObject FillObject(IDevFrameworkObject, Object) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. Declaration int FillObject(IDevFrameworkObject value, object pk) Parameters value IDevFrameworkObject pk Object Returns Int32 FillObject(IDevFrameworkObject, Object, Func<Object, Boolean>) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert und die übergebene Where-Einschränkung erfüllt, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. Declaration int FillObject(IDevFrameworkObject value, object pk, Func<object, bool> where) Parameters value IDevFrameworkObject pk Object where Func < Object , Boolean > Returns Int32 FillObject(IDevFrameworkObject, Func<IDevFrameworkObject, Boolean>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. Declaration int FillObject(IDevFrameworkObject value, Func<IDevFrameworkObject, bool> where) Parameters value IDevFrameworkObject where Func < IDevFrameworkObject , Boolean > Returns Int32 Remarks Hinweis: Wenn die Where-Einschränkung den PK enthält, sollte dieser explizit angegeben werden, also die Überladung dieser Methode mit PK genutzt werden, da diese performanter arbeiten kann. FillObject(IDevFrameworkObject, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Füllt das Objekt mit dem ersten Datensatz in der angegebenen Sortierung, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. Declaration int FillObject(IDevFrameworkObject value, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) Parameters value IDevFrameworkObject orderBy Func < IEnumerable < IDevFrameworkObject >, IEnumerable < IDevFrameworkObject >> Returns Int32 FillObject(IDevFrameworkObject, Func<IDevFrameworkObject, Boolean>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt (unter Berücksichtigung der angegebenen Sortierung), soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. Declaration int FillObject(IDevFrameworkObject value, Func<IDevFrameworkObject, bool> where, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) Parameters value IDevFrameworkObject where Func < IDevFrameworkObject , Boolean > orderBy Func < IEnumerable < IDevFrameworkObject >, IEnumerable < IDevFrameworkObject >> Returns Int32"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.Global.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.Global.html",
    "title": "Property Global",
    "keywords": "Property Global Global Declaration GlobalObjects Global { get; } Property Value FrameworkSystems.FrameworkBase.GlobalObj.GlobalObjects"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.html",
    "title": "Interface IStaticCache",
    "keywords": "Interface IStaticCache Schnittstelle eines statischen, untypisierten Caches für Elemente vom Typ IDevFrameworkObject, die über einen untypisierten Primärschlüssel eindeutig identifiziert werden können. Der Cache implementiert IEnumerable (untypisiert). Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IStaticCache : IEnumerable Properties Global Item[Object] Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird aus diesem ein Objekt erzeugt, daran die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen und das Objekt zurückgegeben, sonst null. lngMaxAgeSeconds Zeitraum seit dem letzten befüllen des Caches aus der Datenbank in Sekunden, nach deren Verstreichen der Cache als veraltet gilt und daher bei lesenden Anfragen zunächst seine Daten erneut aus der Datenbank befüllt. Methods ContainsKey(Object) Liefert true, wenn der übergebene Schlüssel in dem Cache bereits existiert; andernfalls false. FillCollection<TColl>(TColl) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<IDevFrameworkObject, Boolean>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Where-Bedingung wird vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<IDevFrameworkObject, Boolean>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Leert und befüllt die übergebene Collection unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Where-Bedingung und die Sortierung werden vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache unter Berücksichtigung der angegebenen Sortierung. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Sortierung wird vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte durchgeführt. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillObject(IDevFrameworkObject, Func<IDevFrameworkObject, Boolean>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(IDevFrameworkObject, Func<IDevFrameworkObject, Boolean>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt (unter Berücksichtigung der angegebenen Sortierung), soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(IDevFrameworkObject, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Füllt das Objekt mit dem ersten Datensatz in der angegebenen Sortierung, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(IDevFrameworkObject, Object) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. FillObject(IDevFrameworkObject, Object, Func<Object, Boolean>) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert und die übergebene Where-Einschränkung erfüllt, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. Invalidate() Markiert alle Daten des Caches als veraltet, sodass diese beim nächsten Zugriff neu von der Datenbank gelesen werden müssen. ToCollection<TColl>() Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<IDevFrameworkObject, Boolean>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<IDevFrameworkObject, Boolean>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TryGet(Object, out IDevFrameworkObject) Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird dazu ein Objekt erzeugt, daran die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen, das Objekt der out-Variable \"value\" zugeordnet und \"true\" zurück gegeben. Andernfalls ist \"value\" null und es wird \"false\" zurück gegeben."
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.Invalidate.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.Invalidate.html",
    "title": "Method Invalidate",
    "keywords": "Method Invalidate Invalidate() Markiert alle Daten des Caches als veraltet, sodass diese beim nächsten Zugriff neu von der Datenbank gelesen werden müssen. Declaration void Invalidate()"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.Item.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.Item.html",
    "title": "Property Item",
    "keywords": "Property Item Item[Object] Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird aus diesem ein Objekt erzeugt, daran die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen und das Objekt zurückgegeben, sonst null. Declaration IDevFrameworkObject this[object pk] { get; } Parameters pk Object Property Value IDevFrameworkObject"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.lngMaxAgeSeconds.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.lngMaxAgeSeconds.html",
    "title": "Property lngMaxAgeSeconds",
    "keywords": "Property lngMaxAgeSeconds lngMaxAgeSeconds Zeitraum seit dem letzten befüllen des Caches aus der Datenbank in Sekunden, nach deren Verstreichen der Cache als veraltet gilt und daher bei lesenden Anfragen zunächst seine Daten erneut aus der Datenbank befüllt. Declaration long lngMaxAgeSeconds { get; set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.ToCollection.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.ToCollection.html",
    "title": "Method ToCollection",
    "keywords": "Method ToCollection ToCollection<TColl>() Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. Declaration TColl ToCollection<TColl>() where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Returns TColl Type Parameters Name Description TColl ToCollection<TColl>(Func<IDevFrameworkObject, Boolean>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. Declaration TColl ToCollection<TColl>(Func<IDevFrameworkObject, bool> where) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters where Func < IDevFrameworkObject , Boolean > Returns TColl Type Parameters Name Description TColl ToCollection<TColl>(Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. Declaration TColl ToCollection<TColl>(Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters orderBy Func < IEnumerable < IDevFrameworkObject >, IEnumerable < IDevFrameworkObject >> Returns TColl Type Parameters Name Description TColl ToCollection<TColl>(Func<IDevFrameworkObject, Boolean>, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. Declaration TColl ToCollection<TColl>(Func<IDevFrameworkObject, bool> where, Func<IEnumerable<IDevFrameworkObject>, IEnumerable<IDevFrameworkObject>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters where Func < IDevFrameworkObject , Boolean > orderBy Func < IEnumerable < IDevFrameworkObject >, IEnumerable < IDevFrameworkObject >> Returns TColl Type Parameters Name Description TColl"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache.TryGet.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache.TryGet.html",
    "title": "Method TryGet",
    "keywords": "Method TryGet TryGet(Object, out IDevFrameworkObject) Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird dazu ein Objekt erzeugt, daran die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen, das Objekt der out-Variable \"value\" zugeordnet und \"true\" zurück gegeben. Andernfalls ist \"value\" null und es wird \"false\" zurück gegeben. Declaration bool TryGet(object pk, out IDevFrameworkObject value) Parameters pk Object value IDevFrameworkObject Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.ContainsKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.ContainsKey.html",
    "title": "Method ContainsKey",
    "keywords": "Method ContainsKey ContainsKey(TPK) Liefert true, wenn der übergebene Schlüssel in dem Cache bereits existiert; andernfalls false. Declaration bool ContainsKey(TPK pk) Parameters pk TPK Schlüssel Returns Boolean True, wenn existent; andernfalls false."
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.FillCollection.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.FillCollection.html",
    "title": "Method FillCollection",
    "keywords": "Method FillCollection FillCollection<TColl>(TColl) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. Declaration int FillCollection<TColl>(TColl value) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl Returns Int32 Type Parameters Name Description TColl FillCollection<TColl>(TColl, Func<TObj, Boolean>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Where-Bedingung wird vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. Declaration int FillCollection<TColl>(TColl value, Func<TObj, bool> where) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl where Func <TObj, Boolean > Returns Int32 Type Parameters Name Description TColl FillCollection<TColl>(TColl, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache unter Berücksichtigung der angegebenen Sortierung. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Sortierung wird vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte durchgeführt. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. Declaration int FillCollection<TColl>(TColl value, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl orderBy Func < IEnumerable <TObj>, IEnumerable <TObj>> Returns Int32 Type Parameters Name Description TColl Examples cdCurrencyCache.Get(this.Global).FillCollection(this.oCurrencyColl, (currencies) => currencies.OrderBy(currency => currency.sName). FillCollection<TColl>(TColl, Func<TObj, Boolean>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Leert und befüllt die übergebene Collection unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Where-Bedingung und die Sortierung werden vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. Declaration int FillCollection<TColl>(TColl value, Func<TObj, bool> where, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters value TColl where Func <TObj, Boolean > orderBy Func < IEnumerable <TObj>, IEnumerable <TObj>> Returns Int32 Type Parameters Name Description TColl"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.FillObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.FillObject.html",
    "title": "Method FillObject",
    "keywords": "Method FillObject FillObject(TObj, TPK) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. Declaration int FillObject(TObj value, TPK pk) Parameters value TObj pk TPK Returns Int32 FillObject(TObj, TPK, Func<TObj, Boolean>) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert und die übergebene Where-Einschränkung erfüllt, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. Declaration int FillObject(TObj value, TPK pk, Func<TObj, bool> where) Parameters value TObj pk TPK where Func <TObj, Boolean > Returns Int32 FillObject(TObj, Func<TObj, Boolean>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. Declaration int FillObject(TObj value, Func<TObj, bool> where) Parameters value TObj where Func <TObj, Boolean > Returns Int32 Remarks Hinweis: Wenn die Where-Einschränkung den PK enthält, sollte dieser explizit angegeben werden, also die Überladung dieser Methode mit PK genutzt werden, da diese performanter arbeiten kann. FillObject(TObj, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Füllt das Objekt mit dem ersten Datensatz in der angegebenen Sortierung, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. Declaration int FillObject(TObj value, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) Parameters value TObj orderBy Func < IEnumerable <TObj>, IEnumerable <TObj>> Returns Int32 FillObject(TObj, Func<TObj, Boolean>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt (unter Berücksichtigung der angegebenen Sortierung), soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. Declaration int FillObject(TObj value, Func<TObj, bool> where, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) Parameters value TObj where Func <TObj, Boolean > orderBy Func < IEnumerable <TObj>, IEnumerable <TObj>> Returns Int32"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.Global.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.Global.html",
    "title": "Property Global",
    "keywords": "Property Global Global Declaration GlobalObjects Global { get; } Property Value FrameworkSystems.FrameworkBase.GlobalObj.GlobalObjects"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.html",
    "title": "Interface IStaticCache<TObj, TPK>",
    "keywords": "Interface IStaticCache<TObj, TPK> Schnittstelle eines statischen Caches für Elemente vom Typ TObj, die über den Primärschlüssel vom Typ TPK eindeutig identifiziert werden können. Der Cache implementiert IEnumerable<TObj>. Der Cache ist NICHT Thread-Save. Methoden dürfen nur aus dem Thread des übergebenen GlobalObjects heraus aufgerufen werden. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IStaticCache<TObj, TPK> : IEnumerable<TObj>, IEnumerable where TObj : IDevFrameworkObject Type Parameters Name Description TObj Interface-Typ der Components, welche vom Cache verwaltet werden. TPK Typ des/der Primärschlüssel-Properties. Bei mehreren Properties ValueTuple der Properties in alphabetischer Reihenfolge. Properties Global Item[TPK] Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird aus diesem ein Objekt erzeugt, daran die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen und das Objekt zurückgegeben, sonst null. lngMaxAgeSeconds Zeitraum seit dem letzten befüllen des Caches aus der Datenbank in Sekunden, nach deren Verstreichen der Cache als veraltet gilt und daher bei lesenden Anfragen zunächst seine Daten erneut aus der Datenbank befüllt. Methods ContainsKey(TPK) Liefert true, wenn der übergebene Schlüssel in dem Cache bereits existiert; andernfalls false. FillCollection<TColl>(TColl) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<TObj, Boolean>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Where-Bedingung wird vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<TObj, Boolean>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Leert und befüllt die übergebene Collection unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Where-Bedingung und die Sortierung werden vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte ausgewertet. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillCollection<TColl>(TColl, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Leert und befüllt die übergebene Collection mit allen Datensätzen aus dem Cache unter Berücksichtigung der angegebenen Sortierung. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Die Sortierung wird vor dem Aufruf der Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad der Objekte durchgeführt. Die Collection muss für Objekte vom Typ TObj definiert sein. Die Methode gibt die Anzahl der Datensätze zurück. FillObject(TObj, TPK) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. FillObject(TObj, TPK, Func<TObj, Boolean>) Füllt das Objekt mit dem per Primärschlüssel referenzierten Datensatz, wenn dieser existiert und die übergebene Where-Einschränkung erfüllt, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn der Datensatz gefunden wurde, sonst 0. FillObject(TObj, Func<TObj, Boolean>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(TObj, Func<TObj, Boolean>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Füllt das Objekt mit dem ersten Datensatz, welcher die übergebene Where-Einschränkung erfüllt (unter Berücksichtigung der angegebenen Sortierung), soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. FillObject(TObj, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Füllt das Objekt mit dem ersten Datensatz in der angegebenen Sortierung, soweit einer existiert, sonst mit einem leeren Objekt. Die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad wird nur im ersten Fall aufgerufen. Die Methode gibt 1 zurück, wenn ein Datensatz gefunden wurde, sonst 0. Invalidate() Markiert alle Daten des Caches als veraltet, sodass diese beim nächsten Zugriff neu von der Datenbank gelesen werden müssen. ToCollection<TColl>() Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<TObj, Boolean>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<TObj, Boolean>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. ToCollection<TColl>(Func<IEnumerable<TObj>, IEnumerable<TObj>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. TryGet(TPK, out TObj) Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird dazu ein Objekt erzeugt, daran die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen, das Objekt der out-Variable \"value\" zugeordnet und \"true\" zurück gegeben. Andernfalls ist \"value\" null und es wird \"false\" zurück gegeben. Extension Methods EnumarableExtensions.Chunk<T>(IEnumerable<T>, Int32) EnumarableExtensions.DistinctBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>) EnumarableExtensions.ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>, IEqualityComparer<TKey>) EnumarableExtensions.ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>) EnumarableExtensions.OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, Boolean) EnumarableExtensions.OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>, Boolean) EnumarableExtensions.OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, Boolean) EnumarableExtensions.OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, IEqualityComparer<TKey>, Boolean)"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.Invalidate.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.Invalidate.html",
    "title": "Method Invalidate",
    "keywords": "Method Invalidate Invalidate() Markiert alle Daten des Caches als veraltet, sodass diese beim nächsten Zugriff neu von der Datenbank gelesen werden müssen. Declaration void Invalidate()"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.Item.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.Item.html",
    "title": "Property Item",
    "keywords": "Property Item Item[TPK] Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird aus diesem ein Objekt erzeugt, daran die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen und das Objekt zurückgegeben, sonst null. Declaration TObj this[TPK pk] { get; } Parameters pk TPK Property Value TObj"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.lngMaxAgeSeconds.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.lngMaxAgeSeconds.html",
    "title": "Property lngMaxAgeSeconds",
    "keywords": "Property lngMaxAgeSeconds lngMaxAgeSeconds Zeitraum seit dem letzten befüllen des Caches aus der Datenbank in Sekunden, nach deren Verstreichen der Cache als veraltet gilt und daher bei lesenden Anfragen zunächst seine Daten erneut aus der Datenbank befüllt. Declaration long lngMaxAgeSeconds { get; set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.ToCollection.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.ToCollection.html",
    "title": "Method ToCollection",
    "keywords": "Method ToCollection ToCollection<TColl>() Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. Declaration TColl ToCollection<TColl>() where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Returns TColl Type Parameters Name Description TColl ToCollection<TColl>(Func<TObj, Boolean>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. Declaration TColl ToCollection<TColl>(Func<TObj, bool> where) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters where Func <TObj, Boolean > Returns TColl Type Parameters Name Description TColl ToCollection<TColl>(Func<IEnumerable<TObj>, IEnumerable<TObj>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. Declaration TColl ToCollection<TColl>(Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters orderBy Func < IEnumerable <TObj>, IEnumerable <TObj>> Returns TColl Type Parameters Name Description TColl ToCollection<TColl>(Func<TObj, Boolean>, Func<IEnumerable<TObj>, IEnumerable<TObj>>) Erzeugt eine Collection vom angegebenen Typ TColl und befüllt diese, unter Berücksichtigung der angegebenen Sortierung, mit allen Datensätzen aus dem Cache, die der angegebenen Where-Bedingung entsprechen. Dabei wird an der Collection und an allen Objekten die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen. Der Typ TColl muss für Objekte vom Typ TObj definiert sein. Declaration TColl ToCollection<TColl>(Func<TObj, bool> where, Func<IEnumerable<TObj>, IEnumerable<TObj>> orderBy) where TColl : IDevFrameworkObjectColl, IDevFrameworkDataColl Parameters where Func <TObj, Boolean > orderBy Func < IEnumerable <TObj>, IEnumerable <TObj>> Returns TColl Type Parameters Name Description TColl"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCache-2.TryGet.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCache-2.TryGet.html",
    "title": "Method TryGet",
    "keywords": "Method TryGet TryGet(TPK, out TObj) Wenn der Cache zum angegebenen Primärschlüssel (pk) einen Datensatz enthält, wird dazu ein Objekt erzeugt, daran die Methode FrameworkSystems.FrameworkBase.DevFrameworkBaseObject.OnAfterLoad aufgerufen, das Objekt der out-Variable \"value\" zugeordnet und \"true\" zurück gegeben. Andernfalls ist \"value\" null und es wird \"false\" zurück gegeben. Declaration bool TryGet(TPK pk, out TObj value) Parameters pk TPK value TObj Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCacheObject.DummyComponent.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCacheObject.DummyComponent.html",
    "title": "Property DummyComponent",
    "keywords": "Property DummyComponent DummyComponent Gibt ein leeres Objekt des Typs zurück, welcher instanziiert wird, wenn der Cache aus diesem IStaticCacheObject ein Object erstellt. Dieses Objekt dient ausschließlich zum Abfragen von Typ-spezifischen Informationen (wie z.B. Tabellennamen). Das Objekt darf nicht geändert werden. Es wird insbesondere nicht als Prototyp bei der Erstellung neuer Objekte verwendet! Declaration IDevFrameworkDataObject DummyComponent { get; } Property Value IDevFrameworkDataObject"
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCacheObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCacheObject.html",
    "title": "Interface IStaticCacheObject",
    "keywords": "Interface IStaticCacheObject Stellt eine Schnittstelle zu einem Objekt im Cache dar. Über die Methode TryGetPropertyValue(String, out Object) kann der Wert von Datenbank-Properties abgefragt werden. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IStaticCacheObject Properties DummyComponent Gibt ein leeres Objekt des Typs zurück, welcher instanziiert wird, wenn der Cache aus diesem IStaticCacheObject ein Object erstellt. Dieses Objekt dient ausschließlich zum Abfragen von Typ-spezifischen Informationen (wie z.B. Tabellennamen). Das Objekt darf nicht geändert werden. Es wird insbesondere nicht als Prototyp bei der Erstellung neuer Objekte verwendet! Methods TryGetPropertyValue(String, out Object) Füllt die out-Variable \"value\" mit dem Wert des Properties \"name\" und gibt \"true\" zurück, wenn das Property existiert und einen Datenbankbezug hat. Andernfalls ist \"value\" null und die Methode gibt \"false\" zurück."
  },
  "api/FrameworkSystems.FrameworkBase.IStaticCacheObject.TryGetPropertyValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IStaticCacheObject.TryGetPropertyValue.html",
    "title": "Method TryGetPropertyValue",
    "keywords": "Method TryGetPropertyValue TryGetPropertyValue(String, out Object) Füllt die out-Variable \"value\" mit dem Wert des Properties \"name\" und gibt \"true\" zurück, wenn das Property existiert und einen Datenbankbezug hat. Andernfalls ist \"value\" null und die Methode gibt \"false\" zurück. Declaration bool TryGetPropertyValue(string name, out object value) Parameters name String Name des angefragten Datenbank-Properties value Object Ermittelter Wert des Properties Returns Boolean Existiert das Datenbank-Property"
  },
  "api/FrameworkSystems.FrameworkBase.ListSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListSortOrder.html",
    "title": "Enum ListSortOrder",
    "keywords": "Enum ListSortOrder Sortierar Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListSortOrder Fields Name Description Ascending Aufsteigend Descending Absteigend Inherit Erbt von Vater-Control Unsorted Unsortiert"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewHorizontalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewHorizontalContentAlignment.html",
    "title": "Enum ListViewHorizontalContentAlignment",
    "keywords": "Enum ListViewHorizontalContentAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewHorizontalContentAlignment Fields Name Description Center Fill Left Right"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewItemArrangement.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewItemArrangement.html",
    "title": "Enum ListViewItemArrangement",
    "keywords": "Enum ListViewItemArrangement Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewItemArrangement Fields Name Description List Wrap"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewSelectionMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewSelectionMode.html",
    "title": "Enum ListViewSelectionMode",
    "keywords": "Enum ListViewSelectionMode Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewSelectionMode Fields Name Description Multiple Es können mehrere ListItems gleichzeitig selektiert werden None ListItems können nicht selektiert werden. Single Es kann immer nur ein einziges ListItem gleichzeitig selektiert werden."
  },
  "api/FrameworkSystems.FrameworkBase.ListViewSelectorPosition.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewSelectorPosition.html",
    "title": "Enum ListViewSelectorPosition",
    "keywords": "Enum ListViewSelectorPosition Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewSelectorPosition Fields Name Description BottomLeft BottomRight MiddleLeft MiddleRight TopLeft TopRight"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewTemplateVariableDataSourceOrigin.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewTemplateVariableDataSourceOrigin.html",
    "title": "Enum ListViewTemplateVariableDataSourceOrigin",
    "keywords": "Enum ListViewTemplateVariableDataSourceOrigin Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewTemplateVariableDataSourceOrigin Fields Name Description Form ListItem"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewVerticalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewVerticalContentAlignment.html",
    "title": "Enum ListViewVerticalContentAlignment",
    "keywords": "Enum ListViewVerticalContentAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewVerticalContentAlignment Fields Name Description Bottom Fill Middle Top"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbool.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbool.html",
    "title": "Struct FSbool",
    "keywords": "Struct FSbool Summary description for FSbool. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbool : IFSbool, IFSType, IComparable, IConvertible Remarks TODO! Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyte.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyte.html",
    "title": "Struct FSbyte",
    "keywords": "Struct FSbyte TODO! Summary description for FSbyte. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbyte : IFSbyte, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyteArray.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyteArray.html",
    "title": "Struct FSbyteArray",
    "keywords": "Struct FSbyteArray TODO! Summary description for FSbyteArray. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbyteArray : IFSbyteArray, IFSType, IComparable Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.html",
    "title": "Struct FSDateTime",
    "keywords": "Struct FSDateTime TODO! Summary description for FSDateTime. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSDateTime : IFSDateTime, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen Properties Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.Now.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.Now.html",
    "title": "Property Now",
    "keywords": "Property Now Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time. Declaration public static FSDateTime Now { get; } Property Value FSDateTime"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdecimal.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdecimal.html",
    "title": "Struct FSdecimal",
    "keywords": "Struct FSdecimal TODO! Summary description for FSdecimal. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSdecimal : IFSdecimal, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdouble.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdouble.html",
    "title": "Struct FSdouble",
    "keywords": "Struct FSdouble TODO! Summary description for FSdouble. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSdouble : IFSdouble, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSfloat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSfloat.html",
    "title": "Struct FSfloat",
    "keywords": "Struct FSfloat TODO! Summary description for FSfloat. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSfloat : IFSfloat, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSint.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSint.html",
    "title": "Struct FSint",
    "keywords": "Struct FSint TODO! Summary description for FSint. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSint : IFSint, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSlong.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSlong.html",
    "title": "Struct FSlong",
    "keywords": "Struct FSlong TODO! Summary description for FSlong. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSlong : IFSlong, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSshort.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSshort.html",
    "title": "Struct FSshort",
    "keywords": "Struct FSshort TODO! Summary description for FSshort. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSshort : IFSshort, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSstring.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSstring.html",
    "title": "Struct FSstring",
    "keywords": "Struct FSstring TODO! Summary description for FSstring. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSstring : IFSstring, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSSystemGuid.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSSystemGuid.html",
    "title": "Struct FSSystemGuid",
    "keywords": "Struct FSSystemGuid TODO! Summary description for FSSystemGuid. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSSystemGuid : IFSSystemGuid, IFSType, IComparable Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Metadatatype",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Metadatatype Classes MLContainer TODO! Structs FSbool Summary description for FSbool. FSbyte TODO! Summary description for FSbyte. FSbyteArray TODO! Summary description for FSbyteArray. FSDateTime TODO! Summary description for FSDateTime. FSdecimal TODO! Summary description for FSdecimal. FSdouble TODO! Summary description for FSdouble. FSfloat TODO! Summary description for FSfloat. FSint TODO! Summary description for FSint. FSlong TODO! Summary description for FSlong. FSshort TODO! Summary description for FSshort. FSstring TODO! Summary description for FSstring. FSSystemGuid TODO! Summary description for FSSystemGuid. Nonable<T> Interfaces IFSType Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.DBValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.DBValue.html",
    "title": "Property DBValue",
    "keywords": "Property DBValue DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. Declaration object DBValue { get; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.EqualsValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.EqualsValue.html",
    "title": "Method EqualsValue",
    "keywords": "Method EqualsValue EqualsValue(String) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. Declaration bool EqualsValue(string value2) Parameters value2 String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.GetFromObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.GetFromObject.html",
    "title": "Method GetFromObject",
    "keywords": "Method GetFromObject GetFromObject(Object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter. Declaration IFSType GetFromObject(object val) Parameters val Object Returns IFSType"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.HasValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.HasValue.html",
    "title": "Property HasValue",
    "keywords": "Property HasValue HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. Declaration bool HasValue { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.html",
    "title": "Interface IFSType",
    "keywords": "Interface IFSType Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung. Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkDataProvider.dll Syntax public interface IFSType : IComparable Remarks Siehe auch: FS-Datentypen Properties DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. IsNull Gibt an, ob der Wert der Variable Null ist. ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. Methods EqualsValue(String) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. GetFromObject(Object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.IsNull.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.IsNull.html",
    "title": "Property IsNull",
    "keywords": "Property IsNull IsNull Gibt an, ob der Wert der Variable Null ist. Declaration bool IsNull { get; set; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.ValueAsObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.ValueAsObject.html",
    "title": "Property ValueAsObject",
    "keywords": "Property ValueAsObject ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. Declaration object ValueAsObject { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.MLContainer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.MLContainer.html",
    "title": "Class MLContainer",
    "keywords": "Class MLContainer TODO! Inheritance Object MLContainer Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class MLContainer"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.HasValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.HasValue.html",
    "title": "Property HasValue",
    "keywords": "Property HasValue HasValue Declaration public bool HasValue { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.html",
    "title": "Struct Nonable<T>",
    "keywords": "Struct Nonable<T> Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax public struct Nonable<T> : Nonable.INonable where T : struct Type Parameters Name Description T Properties HasValue IsNone Value"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.IsNone.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.IsNone.html",
    "title": "Property IsNone",
    "keywords": "Property IsNone IsNone Declaration public bool IsNone { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Value Declaration public T Value { get; } Property Value T"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetKey.html",
    "title": "Method GetKey",
    "keywords": "Method GetKey GetKey() Liefert den zugeordneten MLKey. Ist kein MLKey zgeordnet, dann wird null zurückgegeben. Declaration public MLKey GetKey() Returns MLKey"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetString.html",
    "title": "Method GetString",
    "keywords": "Method GetString GetString(IGlobalObjects, String) Ermittelt den Text in der übergebenen Sprache. Ist für diese Sprache kein Text vorhaden, wird string.Empty zurügkgegeben. Es erfolgt kein Fallback auf die Default-Sprache.. Declaration public string GetString(IGlobalObjects global, string iso) Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global iso String Der 2-stellige Sprach-Iso-Code - z.B. \"en\" Returns String Der gefundene Text oder string.Empty GetString(IGlobalObjects, IEnumerable<String>) Ermittelt den Text für die übergebene Sprach-Hierarchie. Dabei wird für jede Sprache eine Ermittlung wie in GetString(IGlobalObjects, String) vorgenommen und der erste gefundene Text zurückgegeben. Es erfolgt kein Fallback auf die Default-Sprache. Declaration public string GetString(IGlobalObjects global, IEnumerable<string> languageHierarchy) Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global languageHierarchy IEnumerable < String > Enumeration mit 2-Selligen Sprach-Iso-Codes. Returns String Der gefundene Text oder string.Empty GetString(IGlobalObjects) Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy ). Diese beinhaltet immer einen Fallback auf die Default-Sprache. Declaration public string GetString(IGlobalObjects global) Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global Returns String Der gefundene Text oder string.Empty"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.HasKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.HasKey.html",
    "title": "Property HasKey",
    "keywords": "Property HasKey HasKey Gibt zurück, ob dem DevMLString ein MLKey zugeordnet ist. Declaration public bool HasKey { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.html",
    "title": "Class DevMLString",
    "keywords": "Class DevMLString Diese Klasse beschreibt einen mehrsprachigen String. Darüber können die in den Designern und im Wörterbuch gesetzten Texte zur Laufzeit ermittelt werden. Inheritance Object DevMLString DevMLStringWithGlobal Namespace : FrameworkSystems.FrameworkBase.MultiLanguage Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class DevMLString : IDevMLStringCodeGeneration Properties HasKey Gibt zurück, ob dem DevMLString ein MLKey zugeordnet ist. Item[IGlobalObjects] Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy ). Diese beinhaltet immer einen Fallback auf die Default-Sprache. Methods GetKey() Liefert den zugeordneten MLKey. Ist kein MLKey zgeordnet, dann wird null zurückgegeben. GetString(IGlobalObjects) Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy ). Diese beinhaltet immer einen Fallback auf die Default-Sprache. GetString(IGlobalObjects, IEnumerable<String>) Ermittelt den Text für die übergebene Sprach-Hierarchie. Dabei wird für jede Sprache eine Ermittlung wie in GetString(IGlobalObjects, String) vorgenommen und der erste gefundene Text zurückgegeben. Es erfolgt kein Fallback auf die Default-Sprache. GetString(IGlobalObjects, String) Ermittelt den Text in der übergebenen Sprache. Ist für diese Sprache kein Text vorhaden, wird string.Empty zurügkgegeben. Es erfolgt kein Fallback auf die Default-Sprache.."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.Item.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.Item.html",
    "title": "Property Item",
    "keywords": "Property Item Item[IGlobalObjects] Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy ). Diese beinhaltet immer einen Fallback auf die Default-Sprache. Declaration public string this[IGlobalObjects global] { get; } Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global Property Value String Der gefundene Text oder string.Empty"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.GetString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.GetString.html",
    "title": "Method GetString",
    "keywords": "Method GetString GetString(String) Gibt den Text in der gewünschten Sprache zurück. Declaration public override string GetString(string iso) Parameters iso String Returns String Overrides FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetString(System.String) Remarks Note Ein Aufruf mit this.Global.SelectedLanguage ist zu vermeiden. Stattdessen sollte dafür GetString(IGlobalObjects) verwendet werden."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.html",
    "title": "Class DevMLStringWithGlobal",
    "keywords": "Class DevMLStringWithGlobal Eine Spezialisierung von DevMLString , die in in den TextCollection-Einträgen ( IDevFrameworkObjectMLString ) verwendet wird. Über den Eintrag besitzt diese Instanz das GlobalObject ( this.Global ). Inheritance Object DevMLString DevMLStringWithGlobal Inherited Members DevMLString.GetKey() DevMLString.HasKey DevMLString.GetString(IGlobalObjects, String) DevMLString.GetString(IGlobalObjects, IEnumerable<String>) DevMLString.GetString(IGlobalObjects) DevMLString.Item[IGlobalObjects] Namespace : FrameworkSystems.FrameworkBase.MultiLanguage Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class DevMLStringWithGlobal : DevMLString, IDevMLStringCodeGeneration Properties Item[String] Gibt den Text in der gewünschten Sprache zurück. Methods GetString(String) Gibt den Text in der gewünschten Sprache zurück."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.Item.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.Item.html",
    "title": "Property Item",
    "keywords": "Property Item Item[String] Gibt den Text in der gewünschten Sprache zurück. Declaration public override string this[string iso] { get; } Parameters iso String Property Value String Overrides FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.Item[System.String] Remarks Note Ein Aufruf mit this.Global.SelectedLanguage ist zu vermeiden. Stattdessen sollte dafür Item[IGlobalObjects] verwendet werden."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.MultiLanguage",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.MultiLanguage Classes DevMLString Diese Klasse beschreibt einen mehrsprachigen String. Darüber können die in den Designern und im Wörterbuch gesetzten Texte zur Laufzeit ermittelt werden. DevMLStringWithGlobal Eine Spezialisierung von DevMLString , die in in den TextCollection-Einträgen ( IDevFrameworkObjectMLString ) verwendet wird. Über den Eintrag besitzt diese Instanz das GlobalObject ( this.Global )."
  },
  "api/FrameworkSystems.FrameworkBase.PictureScaleMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.PictureScaleMode.html",
    "title": "Enum PictureScaleMode",
    "keywords": "Enum PictureScaleMode used for Picture.ScaleMode Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum PictureScaleMode Fields Name Description Center In der originalen Größe zentrieren. Inherit Use editor type from base, if base != null, otherwise default editor type Normal Bild oben links zeichnen (ohne Anpassung). ScaleDown ScaleDown Bild, wenn es zu groß ist, proportional herunter skalieren. Kleinere Bilder behalten ihre Größe. ScaleDownCenter Bild, wenn es zu groß ist, proportional herunter skalieren. Kleinere Bilder behalten ihre Größe. Bild in Control zentrieren. Stretch Bild mit beiden Achsen auf die Größe des Controls skalieren. Das ist das Standardverhalten. Zoom Bild proportional vergrößern oder verkleinern, so dass es gerade so in das Control passt. ZoomCenter ZoomCenter Bild proportional vergrößern oder verkleinern, so dass es gerade so in das Control passt und im Control zentrieren."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.ExportToDisk.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.ExportToDisk.html",
    "title": "Method ExportToDisk",
    "keywords": "Method ExportToDisk ExportToDisk(ExportFormat, String) Exportiert den Report ins gegebene Format und schreibt ihn in den angegebenen Pfad. Declaration public void ExportToDisk(ExportFormat format, string fileName) Parameters format ExportFormat Das Format, in dem der Report exportiert werden soll fileName String Der Pfad, in den der Report geschrieben werden soll"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.ExportToStream.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.ExportToStream.html",
    "title": "Method ExportToStream",
    "keywords": "Method ExportToStream ExportToStream(ExportFormat) Exportiert den Report ins gegebene Format Declaration public Stream ExportToStream(ExportFormat format) Parameters format ExportFormat Das Format, in dem der Report exportiert werden soll Returns Stream Ein Stream, der den exportierten report enthält"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.html",
    "title": "Class CrystalReport",
    "keywords": "Class CrystalReport Der direkte FS-Wrapper für interfacing mit einer CrystalDecisions.CrystalReports.Engine.ReportDocument -Datei. Greift direkt auf CrystalDecisions.CrystalReports -Methoden zu und sollte intern als logische Repräsentation eines physischen Crystal Reports betrachtet werden. Inheritance Object CrystalReport Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class CrystalReport Remarks Analog zu DevExpressReport . Properties PrintOptions Die CrystalDecisions.CrystalReports.Engine.PrintOptions , auf dessen Basis der Druck des Reports stattfindet Methods ExportToDisk(ExportFormat, String) Exportiert den Report ins gegebene Format und schreibt ihn in den angegebenen Pfad. ExportToStream(ExportFormat) Exportiert den Report ins gegebene Format Load(String) Lädt einen bestehenden Crystal Report aus dem angegebenen Pfad SetDatasource(DataSet) Setzt die Datenquelle des Reports"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.Load.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.Load.html",
    "title": "Method Load",
    "keywords": "Method Load Load(String) Lädt einen bestehenden Crystal Report aus dem angegebenen Pfad Declaration public void Load(string fileName) Parameters fileName String Der Pfad der Datei, aus der geladen werden soll"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.PrintOptions.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.PrintOptions.html",
    "title": "Property PrintOptions",
    "keywords": "Property PrintOptions PrintOptions Die CrystalDecisions.CrystalReports.Engine.PrintOptions , auf dessen Basis der Druck des Reports stattfindet Declaration public PrintOptions PrintOptions { get; } Property Value CrystalDecisions.CrystalReports.Engine.PrintOptions"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.SetDatasource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReport.SetDatasource.html",
    "title": "Method SetDatasource",
    "keywords": "Method SetDatasource SetDatasource(DataSet) Setzt die Datenquelle des Reports Declaration public void SetDatasource(DataSet ds) Parameters ds DataSet Das DataSet, das verwendet werden soll"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.Adapter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.Adapter.html",
    "title": "Field Adapter",
    "keywords": "Field Adapter Name des PrintService-Adapters. Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string Adapter = \"CRYSTAL\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.CrystalReportVersion.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.CrystalReportVersion.html",
    "title": "Property CrystalReportVersion",
    "keywords": "Property CrystalReportVersion CrystalReportVersion Gibt die Version des installierten Crystal Reports Runtime assembly an. Declaration public static string CrystalReportVersion { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.html",
    "title": "Class CrystalReportDocument",
    "keywords": "Class CrystalReportDocument Logische Repräsentation eines Crystal Reports im Code. Wrapped einen CrystalReport , welcher direktes interfacing mit der Runtime übernimmt. Inheritance Object FSReportDocument CrystalReportDocument Inherited Members FSReportDocument.Load(String) FSReportDocument.Load(Byte[]) FSReportDocument.ExportToBytes(ExportFormat) FSReportDocument.ExportToDisk(ExportFormat, String) Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class CrystalReportDocument : FSReportDocument, IDisposable Remarks Analog zu DevExpressReportDocument . Fields Adapter Name des PrintService-Adapters. Properties CrystalReportVersion Gibt die Version des installierten Crystal Reports Runtime assembly an. PaperOrientation Gibt die vom CrystalReport genutzte Orientation zurück. Methods Load(String, Boolean) Lädt eine CrystalReport -Datei von der Festplatte."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.Load.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.Load.html",
    "title": "Method Load",
    "keywords": "Method Load Load(String, Boolean) Lädt eine CrystalReport -Datei von der Festplatte. Declaration public override void Load(string filename, bool deleteOnDispose) Parameters filename String Der Name der zu ladenden Datei deleteOnDispose Boolean Ob die Datei filename beim FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.Dispose gelöscht werden soll. Overrides FSReportDocument.Load(String, Boolean) Remarks Um File-Konflikte zu verhindern, wird eventuell eine temporäre Datei generiert, aus der stattdessen geladen wird."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.PaperOrientation.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.CrystalReportDocument.PaperOrientation.html",
    "title": "Property PaperOrientation",
    "keywords": "Property PaperOrientation PaperOrientation Gibt die vom CrystalReport genutzte Orientation zurück. Declaration public override Orientation PaperOrientation { get; } Property Value Orientation Overrides FSReportDocument.PaperOrientation Remarks Wird möglicherweise aus der CrystalDecisions.Shared.PaperOrientation übersetzt."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.ExportToBytes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.ExportToBytes.html",
    "title": "Method ExportToBytes",
    "keywords": "Method ExportToBytes ExportToBytes(ExportFormat) Exportiert den Report ins gegebene Format. Declaration public byte[] ExportToBytes(ExportFormat format) Parameters format ExportFormat Das Format, in dem der Report exportiert werden soll. Returns Byte [] Die bytes des exportierten reports."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.ExportToDisk.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.ExportToDisk.html",
    "title": "Method ExportToDisk",
    "keywords": "Method ExportToDisk ExportToDisk(ExportFormat, String) Exportiert den Report ins gegebene Format und schreibt ihn in den angegebenen Pfad. Declaration public void ExportToDisk(ExportFormat format, string fileName) Parameters format ExportFormat Das Format, in dem der Report exportiert werden soll. fileName String Der Pfad, in den der Report geschrieben werden soll."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.html",
    "title": "Class DevExpressReport",
    "keywords": "Class DevExpressReport Der direkte FS-Wrapper für interfacing mit einer DevExpress.XtraReports.UI.XtraReport -Datei. Greift direkt auf XtraReport -Methoden zu und sollte intern als logische Repräsentation dessen betrachtet werden. Inheritance Object DevExpressReport Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class DevExpressReport Remarks Analog zu CrystalReport . Methods ExportToBytes(ExportFormat) Exportiert den Report ins gegebene Format. ExportToDisk(ExportFormat, String) Exportiert den Report ins gegebene Format und schreibt ihn in den angegebenen Pfad. Load(String) Lädt das layout eines reports aus einer Xml-Datei. SetDatasource(ReportDocument) Setzt die Datenquelle des Reports."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.Load.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.Load.html",
    "title": "Method Load",
    "keywords": "Method Load Load(String) Lädt das layout eines reports aus einer Xml-Datei. Declaration public void Load(string fileName) Parameters fileName String Der Pfad der Datei, die geladen werden soll."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.SetDatasource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReport.SetDatasource.html",
    "title": "Method SetDatasource",
    "keywords": "Method SetDatasource SetDatasource(ReportDocument) Setzt die Datenquelle des Reports. Declaration public void SetDatasource(ReportDocument reportWithData) Parameters reportWithData ReportDocument Das ReportDocument, das als Datenquelle genutzt werden soll."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.Adapter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.Adapter.html",
    "title": "Field Adapter",
    "keywords": "Field Adapter Name des PrintService-Adapters. Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string Adapter = \"DEVEXPRESS\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.ExportToBytes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.ExportToBytes.html",
    "title": "Method ExportToBytes",
    "keywords": "Method ExportToBytes ExportToBytes(ExportFormat) Exportiert den DevExpressReport ins gegebene Format. Declaration public override byte[] ExportToBytes(ExportFormat format) Parameters format ExportFormat Das ExportFormat , in dem der DevExpressReport exportiert werden soll. Returns Byte [] Die bytes des exportierten DevExpressReport . Overrides FSReportDocument.ExportToBytes(ExportFormat)"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.ExportToDisk.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.ExportToDisk.html",
    "title": "Method ExportToDisk",
    "keywords": "Method ExportToDisk ExportToDisk(ExportFormat, String) Exportiert den DevExpressReport und speichert die erzeugte Datei unter dem angegebenen Namen. Declaration public override void ExportToDisk(ExportFormat format, string filename) Parameters format ExportFormat Das ExportFormat , in das exportiert werden soll. filename String Der Dateiname, unter dem der exportierte DevExpressReport gespeichert werden soll. Overrides FSReportDocument.ExportToDisk(ExportFormat, String)"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.html",
    "title": "Class DevExpressReportDocument",
    "keywords": "Class DevExpressReportDocument Logische Repräsentation eines DevExpress XtraReports im Code. Wrapped einen DevExpressReport , welcher direktes interfacing mit der Runtime übernimmt. Inheritance Object FSReportDocument DevExpressReportDocument Inherited Members FSReportDocument.PaperOrientation FSReportDocument.CrystalReportVersion FSReportDocument.Load(String) FSReportDocument.Load(Byte[]) Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class DevExpressReportDocument : FSReportDocument, IDisposable Remarks Analog zu CrystalReportDocument . Fields Adapter Name des PrintService-Adapters. Methods ExportToBytes(ExportFormat) Exportiert den DevExpressReport ins gegebene Format. ExportToDisk(ExportFormat, String) Exportiert den DevExpressReport und speichert die erzeugte Datei unter dem angegebenen Namen. Load(String, Boolean) Lädt eine DevExpressReport -Datei von der Festplatte. SetDatasource(ReportDocument) Setzt die Datenquelle des DevExpressReport ."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.Load.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.Load.html",
    "title": "Method Load",
    "keywords": "Method Load Load(String, Boolean) Lädt eine DevExpressReport -Datei von der Festplatte. Declaration public override void Load(string filename, bool deleteOnDispose) Parameters filename String Der Name der zu ladenden Datei. deleteOnDispose Boolean Ob die Datei filename beim FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.Dispose gelöscht werden soll. Overrides FSReportDocument.Load(String, Boolean)"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.SetDatasource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.DevExpressReportDocument.SetDatasource.html",
    "title": "Method SetDatasource",
    "keywords": "Method SetDatasource SetDatasource(ReportDocument) Setzt die Datenquelle des DevExpressReport . Declaration public void SetDatasource(ReportDocument reportWithData) Parameters reportWithData ReportDocument Das ReportDocument , das als Datenquelle genutzt werden soll."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ExportFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ExportFormat.html",
    "title": "Enum ExportFormat",
    "keywords": "Enum ExportFormat Format für den Export eines ReportDocument . Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ExportFormat Fields Name Description Excel Html32 Html40 PDF ReportFileWithData Es wird eine Report-Datei inklusive Daten erzeugt. Je nach Ausgangs-Format wird eine Crystal-Report-Datei (.rpt) oder eine DevExpress-Report-Datei (.xrsx) erzeugt. RichText Word"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.CrystalReportVersion.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.CrystalReportVersion.html",
    "title": "Property CrystalReportVersion",
    "keywords": "Property CrystalReportVersion CrystalReportVersion Gibt die Version des installierten Crystal Reports Runtime assembly an. Declaration public static string CrystalReportVersion { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.ExportToBytes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.ExportToBytes.html",
    "title": "Method ExportToBytes",
    "keywords": "Method ExportToBytes ExportToBytes(ExportFormat) Exportiert den Report und gibt die erzeugte Datei als Byte-Array zurück. Declaration public abstract byte[] ExportToBytes(ExportFormat format) Parameters format ExportFormat Returns Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.ExportToDisk.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.ExportToDisk.html",
    "title": "Method ExportToDisk",
    "keywords": "Method ExportToDisk ExportToDisk(ExportFormat, String) Exportiert den Report und speichert die erzeugte Datei unter dem angegebenen Namen. Declaration public abstract void ExportToDisk(ExportFormat format, string filename) Parameters format ExportFormat Das ExportFormat , in das exportiert werden soll. filename String Der Dateiname, unter dem der exportierte Report gespeichert werden soll."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.html",
    "title": "Class FSReportDocument",
    "keywords": "Class FSReportDocument Eine Basis für Wrapper tatsächlicher Report-Dateien. Inheritance Object FSReportDocument CrystalReportDocument DevExpressReportDocument Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public abstract class FSReportDocument : IDisposable Properties CrystalReportVersion Gibt die Version des installierten Crystal Reports Runtime assembly an. PaperOrientation Die Orientation , in welcher der Report gedruckt werden soll. Methods ExportToBytes(ExportFormat) Exportiert den Report und gibt die erzeugte Datei als Byte-Array zurück. ExportToDisk(ExportFormat, String) Exportiert den Report und speichert die erzeugte Datei unter dem angegebenen Namen. Load(Byte[]) Lädt einen Report in Binärform in das ReportDocument. Load(String) Lädt eine Report-Datei von der Festplatte. Load(String, Boolean) Lädt eine Report-Datei von der Festplatte."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.Load.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.Load.html",
    "title": "Method Load",
    "keywords": "Method Load Load(String) Lädt eine Report-Datei von der Festplatte. Declaration public void Load(string filename) Parameters filename String Load(String, Boolean) Lädt eine Report-Datei von der Festplatte. Declaration public abstract void Load(string filename, bool deleteOnDispose) Parameters filename String Der Name der zu ladenden Datei. deleteOnDispose Boolean Ob die Datei filename beim FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.Dispose gelöscht werden soll. Load(Byte[]) Lädt einen Report in Binärform in das ReportDocument. Declaration public void Load(byte[] bytes) Parameters bytes Byte [] Die bytes des zu ladenden Reports. Remarks Um File-Konflikte zu verhindern, wird eventuell eine temporäre Datei generiert, aus der stattdessen geladen wird."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.PaperOrientation.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.FSReportDocument.PaperOrientation.html",
    "title": "Property PaperOrientation",
    "keywords": "Property PaperOrientation PaperOrientation Die Orientation , in welcher der Report gedruckt werden soll. Declaration public virtual Orientation PaperOrientation { get; } Property Value Orientation"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Reporting",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Reporting Classes CrystalReport Der direkte FS-Wrapper für interfacing mit einer CrystalDecisions.CrystalReports.Engine.ReportDocument -Datei. Greift direkt auf CrystalDecisions.CrystalReports -Methoden zu und sollte intern als logische Repräsentation eines physischen Crystal Reports betrachtet werden. CrystalReportDocument Logische Repräsentation eines Crystal Reports im Code. Wrapped einen CrystalReport , welcher direktes interfacing mit der Runtime übernimmt. DevExpressReport Der direkte FS-Wrapper für interfacing mit einer DevExpress.XtraReports.UI.XtraReport -Datei. Greift direkt auf XtraReport -Methoden zu und sollte intern als logische Repräsentation dessen betrachtet werden. DevExpressReportDocument Logische Repräsentation eines DevExpress XtraReports im Code. Wrapped einen DevExpressReport , welcher direktes interfacing mit der Runtime übernimmt. FSReportDocument Eine Basis für Wrapper tatsächlicher Report-Dateien. Printer Represents a Printer from a PrintServer. All Properties are filled with the Constructor. PrintQueue Diese Klasse bietet Methoden an, mit denen die Print-Queue ausgewertet und bearbeitet werden kann. PrintServer Diese Klasse dient dazu die bestehenden Print-Server zu ermitteln und Transaktionen an einem Print-Server zu steuern. ReportDesignSession Die ReportDesignSession Klasse erlaubt das Verwalten einer Report Designer Session. Die Klasse kann nur über CreateDesigner(ReportEnum) erzeugt werden. Über die Funktionen in der Klasse kann der Report Designer geöffnet werden, auf Veränderungen geprüft werden oder der geänderte Report zurückgeliefert werden. ReportDocument Diese Klasse ist die Basis-Klasse aller Report Document Types, die mit Framework-Studio entwickelt werden. ReportEnum Diese Klasse repräsentiert einen im Report Document Type definierten Crystal Report. Enums ExportFormat Format für den Export eines ReportDocument . Orientation ReportingSoftware"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.Orientation.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.Orientation.html",
    "title": "Enum Orientation",
    "keywords": "Enum Orientation Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum Orientation Fields Name Description Default Landscape Querformat Portrait Hochformat"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.Printer.Global.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.Printer.Global.html",
    "title": "Property Global",
    "keywords": "Property Global Global Global Object of the Application. Declaration public IGlobalObjects Global { get; } Property Value IGlobalObjects Remarks Filled with the Constructor."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.Printer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.Printer.html",
    "title": "Class Printer",
    "keywords": "Class Printer Represents a Printer from a PrintServer. All Properties are filled with the Constructor. Inheritance Object Printer Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class Printer Properties Global Global Object of the Application. Name The Name of the Printer. Path The physical path of the Printer from the view of the Server. PrinterId The UniqueId of the Printer. You can use that Id to print a Report to that Printer."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.Printer.Name.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.Printer.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Name The Name of the Printer. Declaration public string Name { get; } Property Value String Remarks Filled with the Constructor."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.Printer.Path.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.Printer.Path.html",
    "title": "Property Path",
    "keywords": "Property Path Path The physical path of the Printer from the view of the Server. Declaration public string Path { get; } Property Value String Remarks Filled with the Constructor."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.Printer.PrinterId.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.Printer.PrinterId.html",
    "title": "Property PrinterId",
    "keywords": "Property PrinterId PrinterId The UniqueId of the Printer. You can use that Id to print a Report to that Printer. Declaration public guid PrinterId { get; } Property Value guid Remarks Filled with the Constructor."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintQueue.Delete.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintQueue.Delete.html",
    "title": "Method Delete",
    "keywords": "Method Delete Delete(IGlobalObjects, guid) Diese Methode löscht den Datensatz aus der Print-Queue. Handelt es sich dabei um den letzten Eintrag für eine Transaktion wird diese ebenfalls mit gelöscht. Der Status des Print-Job muss 3 (grdruckt) oder 4 (Fehler) sein. Declaration public static void Delete(IGlobalObjects global, guid printJobId) Parameters global IGlobalObjects printJobId guid Examples if (PrintQueue.GetStatus(this.Global, guid(sPrintJobID)) == 3 ) { PrintQueue.Delete(this.Global, new guid(sPrintJobID)); }"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintQueue.GetDocumentOut.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintQueue.GetDocumentOut.html",
    "title": "Method GetDocumentOut",
    "keywords": "Method GetDocumentOut GetDocumentOut(IGlobalObjects, guid) Diese Methode liefert das herausgeschriebene Dokument. Dazu muss der Druck mit dem Kommando Out ausgeführt worden sein und der Status des Druck-Jobs muss 3 (Gedruckt) sein. Declaration public static byte[] GetDocumentOut(IGlobalObjects global, guid printJobId) Parameters global IGlobalObjects printJobId guid Returns Byte [] Examples byte[] pdfBytes = PrintQueue.GetDocumentOut(this.Global, new guid(sPrintJobID));"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintQueue.GetState.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintQueue.GetState.html",
    "title": "Method GetState",
    "keywords": "Method GetState GetState(IGlobalObjects, guid) Diese Methode liefert den Status des Druckauftrags mit der übergebenen PrintJobID zurück.Dabei wird der Status der den Druckauftrag umklammernden Transaktion zurückgegeben. Declaration public static int GetState(IGlobalObjects global, guid printJobId) Parameters global IGlobalObjects printJobId guid Eindeutige ID des Print-Jobs Returns Int32 -1 = PrintJob not found 0 = Transaktion ist offen. Es können weitere Druckaufträge zur Transaktion hinzugefügt werden. 1 = Transaktion ist bereit zu drucken. Alle Druckaufträge sind hinzugefügt und der Printserver kann mit dem Druck beginnen. 2 = Der Druck läuft gerade. 3 = Druckauftrag ist abgeschlossen. 4 = Der Druckauftrag wurde mit einem Fehler beendet. Examples int Status = PrintQueue.GetState(this.Global, new guid(sPrintJobID));"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintQueue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintQueue.html",
    "title": "Class PrintQueue",
    "keywords": "Class PrintQueue Diese Klasse bietet Methoden an, mit denen die Print-Queue ausgewertet und bearbeitet werden kann. Inheritance Object PrintQueue Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class PrintQueue Methods Delete(IGlobalObjects, guid) Diese Methode löscht den Datensatz aus der Print-Queue. Handelt es sich dabei um den letzten Eintrag für eine Transaktion wird diese ebenfalls mit gelöscht. Der Status des Print-Job muss 3 (grdruckt) oder 4 (Fehler) sein. GetDocumentOut(IGlobalObjects, guid) Diese Methode liefert das herausgeschriebene Dokument. Dazu muss der Druck mit dem Kommando Out ausgeführt worden sein und der Status des Druck-Jobs muss 3 (Gedruckt) sein. GetState(IGlobalObjects, guid) Diese Methode liefert den Status des Druckauftrags mit der übergebenen PrintJobID zurück.Dabei wird der Status der den Druckauftrag umklammernden Transaktion zurückgegeben."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.CommitTransaction.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.CommitTransaction.html",
    "title": "Method CommitTransaction",
    "keywords": "Method CommitTransaction CommitTransaction(guid) Bestätigt die Print-Transaktion. Declaration public void CommitTransaction(guid transactionId) Parameters transactionId guid ID der Print-Transaktion. See Also CreateTransaction()"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.CreateTransaction.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.CreateTransaction.html",
    "title": "Method CreateTransaction",
    "keywords": "Method CreateTransaction CreateTransaction() Erzeugt eine neue Print-Transaktion. Declaration public guid CreateTransaction() Returns guid Die ID der Transaktion. Diese muss in weitere Methoden übergeben werden. Examples guid transactionID = server.CreateTransaction(); try { // einer oder mehrere Ausdrucke // ... server.CommitTransaction(transactionID); } catch { server.RollbackTransaction(transactionID); See Also CommitTransaction(guid) RollbackTransaction(guid)"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.GetPrinters.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.GetPrinters.html",
    "title": "Method GetPrinters",
    "keywords": "Method GetPrinters GetPrinters(IGlobalObjects, guid) Liefert eine Liste mit Druckern des Print-Servers, die in der Runtime-Datenbank registriert sind. Als gelöscht markierte Drucker werden nicht zurückgegeben. Declaration public static List<Printer> GetPrinters(IGlobalObjects global, guid printServerId) Parameters global IGlobalObjects GlobalObject für die Verbinding zur Runtime-Datenbank. printServerId guid ID des PrintServers. Returns List < Printer > GetPrinters() Liefert eine Liste mit Druckern des Print-Servers, die in der Runtime-Datenbank registriert sind. Als gelöscht markierte Drucker werden nicht zurückgegeben. Declaration public List<Printer> GetPrinters() Returns List < Printer >"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.GetPrintServers.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.GetPrintServers.html",
    "title": "Method GetPrintServers",
    "keywords": "Method GetPrintServers GetPrintServers(IGlobalObjects) Liefert eine Liste der im Runtime-Datenbank registrierten Print-Server zurück. Declaration public static List<PrintServer> GetPrintServers(IGlobalObjects global) Parameters global IGlobalObjects GlobalObject für die Verbinding zur Runtime-Datenbank. Returns List < PrintServer > Remarks Bei jedem Aufruf dieser Methode wird eine neue Liste aus der Runtime-Datenbank gelesen."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.html",
    "title": "Class PrintServer",
    "keywords": "Class PrintServer Diese Klasse dient dazu die bestehenden Print-Server zu ermitteln und Transaktionen an einem Print-Server zu steuern. Inheritance Object PrintServer Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class PrintServer Methods CommitTransaction(guid) Bestätigt die Print-Transaktion. CreateTransaction() Erzeugt eine neue Print-Transaktion. GetPrinters() Liefert eine Liste mit Druckern des Print-Servers, die in der Runtime-Datenbank registriert sind. Als gelöscht markierte Drucker werden nicht zurückgegeben. GetPrinters(IGlobalObjects, guid) Liefert eine Liste mit Druckern des Print-Servers, die in der Runtime-Datenbank registriert sind. Als gelöscht markierte Drucker werden nicht zurückgegeben. GetPrintServers(IGlobalObjects) Liefert eine Liste der im Runtime-Datenbank registrierten Print-Server zurück. RollbackTransaction(guid) Rollt die Print-Transaktion zurück."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.RollbackTransaction.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.PrintServer.RollbackTransaction.html",
    "title": "Method RollbackTransaction",
    "keywords": "Method RollbackTransaction RollbackTransaction(guid) Rollt die Print-Transaktion zurück. Declaration public void RollbackTransaction(guid transactionId) Parameters transactionId guid ID der Print-Transaktion. See Also CreateTransaction()"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.DesignerUrl.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.DesignerUrl.html",
    "title": "Property DesignerUrl",
    "keywords": "Property DesignerUrl DesignerUrl Liefert die URL des Designers zurück. Declaration public string DesignerUrl { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.Dispose.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.Dispose.html",
    "title": "Method Dispose",
    "keywords": "Method Dispose Dispose() Verwirft die gespeicherten Session Informationen. Declaration public void Dispose()"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.GetBytes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.GetBytes.html",
    "title": "Method GetBytes",
    "keywords": "Method GetBytes GetBytes() Liefert den serialisierten Report zurück, dieser müssen anschließend selbst in das ReportBytes eingefügt werden. Declaration public byte[] GetBytes() Returns Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.html",
    "title": "Class ReportDesignSession",
    "keywords": "Class ReportDesignSession Die ReportDesignSession Klasse erlaubt das Verwalten einer Report Designer Session. Die Klasse kann nur über CreateDesigner(ReportEnum) erzeugt werden. Über die Funktionen in der Klasse kann der Report Designer geöffnet werden, auf Veränderungen geprüft werden oder der geänderte Report zurückgeliefert werden. Inheritance Object ReportDesignSession Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ReportDesignSession : IDisposable Properties DesignerUrl Liefert die URL des Designers zurück. Methods Dispose() Verwirft die gespeicherten Session Informationen. GetBytes() Liefert den serialisierten Report zurück, dieser müssen anschließend selbst in das ReportBytes eingefügt werden. IsModified() Liefert true, wenn der Benutzer den Report im Designer gespeichert hat; andernfalls false. ShowDesigner() Zeigt den Designer an, indem die DesignerUrl in einem Browser geöffnet wird."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.IsModified.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.IsModified.html",
    "title": "Method IsModified",
    "keywords": "Method IsModified IsModified() Liefert true, wenn der Benutzer den Report im Designer gespeichert hat; andernfalls false. Declaration public bool IsModified() Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.ShowDesigner.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession.ShowDesigner.html",
    "title": "Method ShowDesigner",
    "keywords": "Method ShowDesigner ShowDesigner() Zeigt den Designer an, indem die DesignerUrl in einem Browser geöffnet wird. Declaration public void ShowDesigner()"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.AddAdditionalReport.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.AddAdditionalReport.html",
    "title": "Method AddAdditionalReport",
    "keywords": "Method AddAdditionalReport AddAdditionalReport(ReportEnum) Fügt eine zusätzliche Report-Definition hinzu. So können individuelle Report-Dateien zur Laufzeit ergänzt werden. Declaration public void AddAdditionalReport(ReportEnum report) Parameters report ReportEnum"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ClearAdditionalReports.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ClearAdditionalReports.html",
    "title": "Method ClearAdditionalReports",
    "keywords": "Method ClearAdditionalReports ClearAdditionalReports() Setzt die Liste mit den zusätzlichen Report-Definitionen zurück. Declaration public void ClearAdditionalReports()"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ConvertFileNameToReportsEnum.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ConvertFileNameToReportsEnum.html",
    "title": "Method ConvertFileNameToReportsEnum",
    "keywords": "Method ConvertFileNameToReportsEnum ConvertFileNameToReportsEnum(String) Diese Methode kann verwendet werden, um einen ReportEnum mit einem bestimmten Datei-Namen zu finden. Es wird nach DevExpressFileName und CrystalFileName gesucht. Declaration public ReportEnum ConvertFileNameToReportsEnum(string fileName) Parameters fileName String Returns ReportEnum Der gefundene ReportEnum. null wenn kein ReportEnum gefunden wurde."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.CreateDesigner.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.CreateDesigner.html",
    "title": "Method CreateDesigner",
    "keywords": "Method CreateDesigner CreateDesigner(ReportEnum) Erstellt eine Session für den Report Designer und liefert das zugehörige Objekt zurück. Declaration public ReportDesignSession CreateDesigner(ReportEnum report = null) Parameters report ReportEnum Report oder null, wenn der SelectedReport verwendet werden soll. Returns ReportDesignSession"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.-ctor.html",
    "title": "Constructor ReportDocument",
    "keywords": "Constructor ReportDocument ReportDocument(IGlobalObjects, ExportFormat) Declaration public ReportDocument(IGlobalObjects globalObj, ExportFormat exportFormat) Parameters globalObj IGlobalObjects exportFormat ExportFormat ReportDocument(IGlobalObjects, ReportEnum, ExportFormat) Declaration public ReportDocument(IGlobalObjects globalObj, ReportEnum selectedReport, ExportFormat exportFormat) Parameters globalObj IGlobalObjects selectedReport ReportEnum exportFormat ExportFormat"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ExportFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ExportFormat.html",
    "title": "Property ExportFormat",
    "keywords": "Property ExportFormat ExportFormat Das Format, in dem der Report mit Print() ausgegeben werden soll. Diese Einstellung wird ignoriert, wenn der Report auf einem Drucker ausgegeben werden soll. Declaration [Browsable(false)] public ExportFormat ExportFormat { get; set; } Property Value ExportFormat Remarks Es gibt verschiedene Wege, das ExportFormat des Reports zu definieren: 1.) Über den Konstruktur: rptReport myRptReport = new rptReport(this.Global, rptReport.Reports.SpecialReport1, ExportFormat.PDF ); 2.) Durch setzen des Properties vor den Druck: myRptReport.ExportFormat = ExportFormat.Html40; 3.) Durch Angabe direkt in der Methode Print(ExportFormat) myRptReport.Print(ExportFormat.Rtf);"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ExportReport.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ExportReport.html",
    "title": "Method ExportReport",
    "keywords": "Method ExportReport ExportReport(ExportFormat) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. Declaration public byte[] ExportReport(ExportFormat format) Parameters format ExportFormat Returns Byte [] ExportReport(ExportFormat, guid) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. Declaration public byte[] ExportReport(ExportFormat format, guid printJobID) Parameters format ExportFormat printJobID guid wird zu Protokollierungs-Zwecken benötigt Returns Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.GetAdditionalReports.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.GetAdditionalReports.html",
    "title": "Method GetAdditionalReports",
    "keywords": "Method GetAdditionalReports GetAdditionalReports() Gibt eine Liste mit den zusätzlichen Report-Definitionen zurück. Declaration public List<ReportEnum> GetAdditionalReports() Returns List < ReportEnum > Remarks Es wird bei jedem Aufruf eine neue Liste zurückgegeben. Änderungen in dieser Liste haben keine Auswirkung auf die gespeicherten Report-Definitionen. Zum Bearbeiten der Report-Definitionen müssen die Methoden AddAdditionalReport(ReportEnum) und ClearAdditionalReports() verwendet werden."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.GetDatasource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.GetDatasource.html",
    "title": "Method GetDatasource",
    "keywords": "Method GetDatasource GetDatasource(String) Gibt den Wert eines bestimmten Datasources zurück. Declaration public virtual object GetDatasource(string dsName) Parameters dsName String Der Name des Datasources Returns Object Exceptions Type Condition PropertyNotFoundException Wird geworfen, wenn der Name des Datasources ungültig ist."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.GetDatasources.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.GetDatasources.html",
    "title": "Method GetDatasources",
    "keywords": "Method GetDatasources GetDatasources() Gibt die Namen der Datasources zurück. Declaration public StringCollection GetDatasources() Returns StringCollection"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.GetReportEnums.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.GetReportEnums.html",
    "title": "Method GetReportEnums",
    "keywords": "Method GetReportEnums GetReportEnums() Gibt eine Liste mit allen Report-Definitionen zurück. Es sind die mit AddAdditionalReport(ReportEnum) hinzugefügten Report-Definitionen enthalten. Declaration public List<ReportEnum> GetReportEnums() Returns List < ReportEnum > Eine Liste mit Reports. Es wird bei jedem Aufruf eine neue Instanz zurückgegeben. Remarks Die Liste beinhaltet je nach Angabe im ReportDocument ggf. auch die in der Basis definierten Reports. Existieren mehrere ReportEnums mit demselben ReportName dann wird jeweils nur eines davon zurückgegeben. Dabei gewinnt das ReportEnum, welches zuletzt mit AddAdditionalReport(ReportEnum) hinzugefügt wurde."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.html",
    "title": "Class ReportDocument",
    "keywords": "Class ReportDocument Diese Klasse ist die Basis-Klasse aller Report Document Types, die mit Framework-Studio entwickelt werden. Inheritance Object ReportDocument Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ReportDocument Constructors ReportDocument(IGlobalObjects, ExportFormat) ReportDocument(IGlobalObjects, ReportEnum, ExportFormat) Fields Reports Eine Instanz, die alle, im Report-Document-Type definierten Crystal Reports, als Properties beinhaltet. Properties ExportFormat Das Format, in dem der Report mit Print() ausgegeben werden soll. Diese Einstellung wird ignoriert, wenn der Report auf einem Drucker ausgegeben werden soll. ReportDir Gibt den Pfad des Dateiordners zurück, in dem die Crystal Reports abgelegt sind. SelectedReport Der aktuell ausgewählte Report. Die vorhandenen Reports können über das Statische Property Reports ermittelt werden. XSDFileName Gibt den Namen der XSD-Datei zurück, die verwendet wird. Methods AddAdditionalReport(ReportEnum) Fügt eine zusätzliche Report-Definition hinzu. So können individuelle Report-Dateien zur Laufzeit ergänzt werden. ClearAdditionalReports() Setzt die Liste mit den zusätzlichen Report-Definitionen zurück. ConvertFileNameToReportsEnum(String) Diese Methode kann verwendet werden, um einen ReportEnum mit einem bestimmten Datei-Namen zu finden. Es wird nach DevExpressFileName und CrystalFileName gesucht. CreateDesigner(ReportEnum) Erstellt eine Session für den Report Designer und liefert das zugehörige Objekt zurück. ExportReport(ExportFormat) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. ExportReport(ExportFormat, guid) Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet. GetAdditionalReports() Gibt eine Liste mit den zusätzlichen Report-Definitionen zurück. GetDatasource(String) Gibt den Wert eines bestimmten Datasources zurück. GetDatasources() Gibt die Namen der Datasources zurück. GetReportEnums() Gibt eine Liste mit allen Report-Definitionen zurück. Es sind die mit AddAdditionalReport(ReportEnum) hinzugefügten Report-Definitionen enthalten. Print() Erzeugt einen Druck für die Anzeige am Client. Print(ExportFormat) Erzeugt einen Druck für die Anzeige am Client. PrintToPrinter(Int32, Boolean, Int32, Int32, guid, guid) Druckt das Dokument über einen Drucker am Print-Server. Dieser Druck erzeugt eine Transaktion und schließt diese sofort. PrintToTransaction(Int32, Boolean, Int32, Int32, Int32, guid, guid) Druckt das Dokument in eine offene Transaktion. SetDatasource(String, Object) Setzt den Wert eines Datasources."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.Print.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.Print.html",
    "title": "Method Print",
    "keywords": "Method Print Print() Erzeugt einen Druck für die Anzeige am Client. Declaration public void Print() Print(ExportFormat) Erzeugt einen Druck für die Anzeige am Client. Declaration public void Print(ExportFormat export) Parameters export ExportFormat"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.PrintToPrinter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.PrintToPrinter.html",
    "title": "Method PrintToPrinter",
    "keywords": "Method PrintToPrinter PrintToPrinter(Int32, Boolean, Int32, Int32, guid, guid) Druckt das Dokument über einen Drucker am Print-Server. Dieser Druck erzeugt eine Transaktion und schließt diese sofort. Declaration public guid PrintToPrinter(int copies, bool isCollated, int startPage, int endPage, guid printServerId, guid printerId) Parameters copies Int32 Anzahl der Kopien. isCollated Boolean startPage Int32 0 = alle Seiten. endPage Int32 0 = alle Seiten. printServerId guid Eindutige ID des Print-Servers. printerId guid Eindeutige ID des Printers im Print-Server. Returns guid Die eindeutige ID des PrintJobs. Diese kann verwendet werden, um den Status des DruckJobs zu ermitteln. siehe PrintQueue. GetState(IGlobalObjects, guid) ."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.PrintToTransaction.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.PrintToTransaction.html",
    "title": "Method PrintToTransaction",
    "keywords": "Method PrintToTransaction PrintToTransaction(Int32, Boolean, Int32, Int32, Int32, guid, guid) Druckt das Dokument in eine offene Transaktion. Declaration public guid PrintToTransaction(int copies, bool isCollated, int startPage, int endPage, int orderID, guid printerId, guid transactionID) Parameters copies Int32 Anzahl der Kopien. isCollated Boolean startPage Int32 0 = alle Seiten. endPage Int32 0 = alle Seiten. orderID Int32 Laufende Nummer des Jobs in der Transaktion. Der PrintServer druckt alle jobs einer Transaction sortiert nach dieser OrderID. printerId guid Eideutige ID des Druckers. Diese kann mit PrintServer. GetPrinters() ermittelt werden. transactionID guid ID der Transaktion. Diese kann mit PrintServer. CreateTransaction() erzeugt werden. Returns guid Die eindeutige ID des PrintJobs. Diese kann verwendet werden, um den Status des DruckJobs zu ermitteln. siehe PrintQueue. GetState(IGlobalObjects, guid) ."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ReportDir.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ReportDir.html",
    "title": "Property ReportDir",
    "keywords": "Property ReportDir ReportDir Gibt den Pfad des Dateiordners zurück, in dem die Crystal Reports abgelegt sind. Declaration [Browsable(false)] public string ReportDir { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.Reports.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.Reports.html",
    "title": "Field Reports",
    "keywords": "Field Reports Eine Instanz, die alle, im Report-Document-Type definierten Crystal Reports, als Properties beinhaltet. Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static readonly ReportDocument.ReportEnumList Reports Returns Type Description FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ReportEnumList Remarks Verwenden dieses Properties: 1.) bei der Instanziierung des Reports rptReport myRptReport = new rptReport(this.Global, rptReport.Reports.SpecialReport1, ExportFormat.PDF ); 2.) Nachträglich setzen myRptReport.SelectedReport = rptReport.Reports.SpecialReport2; Mithilfe der Methode GetReportEnums() können alle verfügbaren Reports ermittelt werden."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.SelectedReport.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.SelectedReport.html",
    "title": "Property SelectedReport",
    "keywords": "Property SelectedReport SelectedReport Der aktuell ausgewählte Report. Die vorhandenen Reports können über das Statische Property Reports ermittelt werden. Declaration [Browsable(false)] public ReportEnum SelectedReport { get; set; } Property Value ReportEnum"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.SetDatasource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.SetDatasource.html",
    "title": "Method SetDatasource",
    "keywords": "Method SetDatasource SetDatasource(String, Object) Setzt den Wert eines Datasources. Declaration public virtual void SetDatasource(string dsName, object value) Parameters dsName String Der Name des Datasources value Object Der Wert, der gesetzt werden soll. Der Typ des Werts muss dem Typ des Datasources entsprechen oder eine Ableitung davon sein. Exceptions Type Condition PropertyNotFoundException Wird geworfen, wenn der Name des Datasources ungültig ist. InvalidCastException Wird geworfen, wenn der Typ des Values nicht zum Typ des Datasources passt."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.XSDFileName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportDocument.XSDFileName.html",
    "title": "Property XSDFileName",
    "keywords": "Property XSDFileName XSDFileName Gibt den Namen der XSD-Datei zurück, die verwendet wird. Declaration [Browsable(false)] public virtual string XSDFileName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Individuelle Beschriftung des Reports. Diese hat höhere Priorität als MLCaption . Wird für Custom Report-Definitionen verwendet. Declaration public string Caption { get; set; } Property Value String See Also GetCaption(IGlobalObjects)"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.CrystalFileName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.CrystalFileName.html",
    "title": "Property CrystalFileName",
    "keywords": "Property CrystalFileName CrystalFileName Liefert den Datei-Namen des Report für CrystalReports - ohne Pfad. Declaration public string CrystalFileName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.CrystalReportFileExtension.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.CrystalReportFileExtension.html",
    "title": "Field CrystalReportFileExtension",
    "keywords": "Field CrystalReportFileExtension Liefert die von CrystalReports genutzte Dateiendung für Report-Dateien. Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string CrystalReportFileExtension = \".rpt\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.-ctor.html",
    "title": "Constructor ReportEnum",
    "keywords": "Constructor ReportEnum ReportEnum(ReportDocument.ReportEnumList, guid, String, String, Orientation, DevMLString, ReportingSoftware) Dieser Konstruktor wird im generierten Code verwendet. Declaration public ReportEnum(ReportDocument.ReportEnumList enumList, guid id, string reportName, string crystalFileName, Orientation orientation, DevMLString mlCaption, ReportingSoftware software) Parameters enumList FrameworkSystems.FrameworkBase.Reporting.ReportDocument.ReportEnumList id guid reportName String crystalFileName String orientation Orientation mlCaption DevMLString software ReportingSoftware ReportEnum(guid, String, Byte[], String, Nullable<ReportingSoftware>) Erzeugt eine individuelle Report-Definition. Declaration public ReportEnum(guid id, string reportName, byte[] reportBytes, string caption, ReportingSoftware? software = default(ReportingSoftware? )) Parameters id guid Wird null übergeben, dann wird eine neue guid erzeugt. reportName String Name des Reports. Dieser wird als Dateiname verwendet. Ungültige Zeichen werden durch '_' ersetzt. Wird kein Name übergeben, dann wird die ID als Name verwendet. reportBytes Byte [] caption String software Nullable < ReportingSoftware > ReportEnum(guid, String, Byte[], String, Orientation, Nullable<ReportingSoftware>) Erzeugt eine individuelle Report-Definition. Declaration public ReportEnum(guid id, string reportName, byte[] reportBytes, string caption, Orientation orientation, ReportingSoftware? software = default(ReportingSoftware? )) Parameters id guid Wird null übergeben, dann wird eine neue guid erzeugt. reportName String Name des Reports. Dieser wird als Dateiname verwendet. Ungültige Zeichen werden durch '_' ersetzt. Wird kein Name übergeben, dann wird die ID als Name verwendet. reportBytes Byte [] caption String orientation Orientation software Nullable < ReportingSoftware >"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.DevExpressFileName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.DevExpressFileName.html",
    "title": "Property DevExpressFileName",
    "keywords": "Property DevExpressFileName DevExpressFileName Liefert den Datei-Namen des Report für DevExpress - ohne Pfad, aber mit qualifiziertem \\Report-Unterordner. Declaration public string DevExpressFileName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.DevExpressLayoutFileExtension.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.DevExpressLayoutFileExtension.html",
    "title": "Field DevExpressLayoutFileExtension",
    "keywords": "Field DevExpressLayoutFileExtension Liefert die von DevExpress genutzte Dateiendung für Report-Layout-Dateien (ohne Daten). Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string DevExpressLayoutFileExtension = \".repx\" Returns Type Description String Remarks Der Inhalt der Datei kann als xml oder C#-Code aufgebaut sein, ist aber immer in UTF-8 codiert."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.DevExpressWithDataFileExtension.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.DevExpressWithDataFileExtension.html",
    "title": "Field DevExpressWithDataFileExtension",
    "keywords": "Field DevExpressWithDataFileExtension Liefert die von DevExpress genutzte Dateiendung für Report-Dateien, die bereits mit Daten bestückt wurden und jetzt im reinen Binärformat sind. Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string DevExpressWithDataFileExtension = \".prnx\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.GetCaption.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.GetCaption.html",
    "title": "Method GetCaption",
    "keywords": "Method GetCaption GetCaption(IGlobalObjects) Gibt die Beschriftung des Reports zurück in der Sprache der aktuellen Session. Dabei gelten folgende Prioritäten: Caption MLCaption Declaration public string GetCaption(IGlobalObjects globalObj) Parameters globalObj IGlobalObjects Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.GetFileName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.GetFileName.html",
    "title": "Method GetFileName",
    "keywords": "Method GetFileName GetFileName(ReportingSoftware) Ermittelt den Dateinamen des Reports auf Basis der angegebenen ReportingSoftware . Declaration public string GetFileName(ReportingSoftware software) Parameters software ReportingSoftware Die ReportingSoftware , für die der Name der Report-Datei ermittelt werden soll. Returns String Den ermittelten Dateinamen. (ohne Pfad)"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.GetPreferredFileName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.GetPreferredFileName.html",
    "title": "Method GetPreferredFileName",
    "keywords": "Method GetPreferredFileName GetPreferredFileName(IGlobalObjects) Liefert die ReportingSoftware und den FileName abhängig von der in ReportingSoftware favorisierten ReportingSoftware. Ist die favorisierte ReportingSoftware nicht verfügbar, dann wird jeweils die andere zurückgegeben. Declaration public (ReportingSoftware software, string fileName) GetPreferredFileName(IGlobalObjects global) Parameters global IGlobalObjects Returns ValueTuple < ReportingSoftware , String >"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.html",
    "title": "Class ReportEnum",
    "keywords": "Class ReportEnum Diese Klasse repräsentiert einen im Report Document Type definierten Crystal Report. Inheritance Object ReportEnum Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ReportEnum Examples Beispiel für die Verwendung von ReportEnum: foreach( ReportEnum oReportEnum in rptDocumentP.GetReportEnums() ) { cPrintReportName oPrintReportName = new cPrintReportName(this.Global); oPrintReportName.sReportName = oReportEnum.ReportName; oPrintReportName.sReportCaption = oReportEnum.GetCaption( this.Global ); oPrintReportName.sReportFileName = rptDocumentP.ReportDir + \"\\\\\" + oReportEnum.ReportFileName; oPrintReportName.oReportName = oReportEnum; oPrintReportName.intPaperOrientaion = (int)oReportEnum.Orientation; this.Add(oPrintReportName); } Constructors ReportEnum(ReportDocument.ReportEnumList, guid, String, String, Orientation, DevMLString, ReportingSoftware) Dieser Konstruktor wird im generierten Code verwendet. ReportEnum(guid, String, Byte[], String, Orientation, Nullable<ReportingSoftware>) Erzeugt eine individuelle Report-Definition. ReportEnum(guid, String, Byte[], String, Nullable<ReportingSoftware>) Erzeugt eine individuelle Report-Definition. Fields CrystalReportFileExtension Liefert die von CrystalReports genutzte Dateiendung für Report-Dateien. DevExpressLayoutFileExtension Liefert die von DevExpress genutzte Dateiendung für Report-Layout-Dateien (ohne Daten). DevExpressWithDataFileExtension Liefert die von DevExpress genutzte Dateiendung für Report-Dateien, die bereits mit Daten bestückt wurden und jetzt im reinen Binärformat sind. Properties Caption Individuelle Beschriftung des Reports. Diese hat höhere Priorität als MLCaption . Wird für Custom Report-Definitionen verwendet. CrystalFileName Liefert den Datei-Namen des Report für CrystalReports - ohne Pfad. DevExpressFileName Liefert den Datei-Namen des Report für DevExpress - ohne Pfad, aber mit qualifiziertem \\Report-Unterordner. ID Eindeutige ID des Reports. Bei Reports, die in der IDE angelegt wurden, entspricht diese ID der internen ID. Bei Custom-Reports wird eine neue ID generiert. MLCaption Mehrsprachige Beschriftung des Reports. Orientation Die Orientierung des Reports. Wird bei der Code-Generierung aus der Crystal Report-Datei ermittelt. ReportBytes Binär-Daten einer rpt-Datei. Diese haben höhere Priorität als FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ReportFileName . Wird für Custom Report-Definitionen verwendet. ReportingSoftware Flags mit jeder nutzbarer Reporting-Software, mit der dieser Report gedruckt werden kann. ReportName Der Name des Reports. Methods GetCaption(IGlobalObjects) Gibt die Beschriftung des Reports zurück in der Sprache der aktuellen Session. Dabei gelten folgende Prioritäten: Caption MLCaption GetFileName(ReportingSoftware) Ermittelt den Dateinamen des Reports auf Basis der angegebenen ReportingSoftware . GetPreferredFileName(IGlobalObjects) Liefert die ReportingSoftware und den FileName abhängig von der in ReportingSoftware favorisierten ReportingSoftware. Ist die favorisierte ReportingSoftware nicht verfügbar, dann wird jeweils die andere zurückgegeben."
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ID.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ID.html",
    "title": "Property ID",
    "keywords": "Property ID ID Eindeutige ID des Reports. Bei Reports, die in der IDE angelegt wurden, entspricht diese ID der internen ID. Bei Custom-Reports wird eine neue ID generiert. Declaration public guid ID { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption MLCaption Mehrsprachige Beschriftung des Reports. Declaration public DevMLString MLCaption { get; } Property Value DevMLString See Also GetCaption(IGlobalObjects)"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.Orientation.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.Orientation.html",
    "title": "Property Orientation",
    "keywords": "Property Orientation Orientation Die Orientierung des Reports. Wird bei der Code-Generierung aus der Crystal Report-Datei ermittelt. Declaration public Orientation Orientation { get; } Property Value Orientation"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ReportBytes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ReportBytes.html",
    "title": "Property ReportBytes",
    "keywords": "Property ReportBytes ReportBytes Binär-Daten einer rpt-Datei. Diese haben höhere Priorität als FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ReportFileName . Wird für Custom Report-Definitionen verwendet. Declaration public byte[] ReportBytes { get; set; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ReportingSoftware.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ReportingSoftware.html",
    "title": "Property ReportingSoftware",
    "keywords": "Property ReportingSoftware ReportingSoftware Flags mit jeder nutzbarer Reporting-Software, mit der dieser Report gedruckt werden kann. Declaration public ReportingSoftware ReportingSoftware { get; } Property Value ReportingSoftware"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ReportName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportEnum.ReportName.html",
    "title": "Property ReportName",
    "keywords": "Property ReportName ReportName Der Name des Reports. Declaration public string ReportName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.Reporting.ReportingSoftware.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Reporting.ReportingSoftware.html",
    "title": "Enum ReportingSoftware",
    "keywords": "Enum ReportingSoftware Namespace : FrameworkSystems.FrameworkBase.Reporting Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Flags] public enum ReportingSoftware Fields Name Description CrystalReports Crystal Reports ist nutzbar DevExpress DevExpress' XtraReports ist nutzbar"
  },
  "api/FrameworkSystems.FrameworkBase.SaveEntryPoints.html": {
    "href": "api/FrameworkSystems.FrameworkBase.SaveEntryPoints.html",
    "title": "Enum SaveEntryPoints",
    "keywords": "Enum SaveEntryPoints Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum SaveEntryPoints Fields Name Description CallAllways CallOnlyIfChanged"
  },
  "api/FrameworkSystems.FrameworkBase.SelectedRowsCollection.html": {
    "href": "api/FrameworkSystems.FrameworkBase.SelectedRowsCollection.html",
    "title": "Class SelectedRowsCollection",
    "keywords": "Class SelectedRowsCollection !TODO Inheritance Object SelectedRowsCollection Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class SelectedRowsCollection : IList<guid>, ICollection<guid>, IEnumerable<guid>, IEnumerable, ICloneable"
  },
  "api/FrameworkSystems.FrameworkBase.StackPanelHAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.StackPanelHAlignment.html",
    "title": "Enum StackPanelHAlignment",
    "keywords": "Enum StackPanelHAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum StackPanelHAlignment Fields Name Description Center Left Right"
  },
  "api/FrameworkSystems.FrameworkBase.StackPanelOrientation.html": {
    "href": "api/FrameworkSystems.FrameworkBase.StackPanelOrientation.html",
    "title": "Enum StackPanelOrientation",
    "keywords": "Enum StackPanelOrientation Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum StackPanelOrientation Fields Name Description Horizontal Vertical"
  },
  "api/FrameworkSystems.FrameworkBase.StackPanelVAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.StackPanelVAlignment.html",
    "title": "Enum StackPanelVAlignment",
    "keywords": "Enum StackPanelVAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum StackPanelVAlignment Fields Name Description Bottom Center Top"
  },
  "api/FrameworkSystems.FrameworkBase.StaticCache.Get.html": {
    "href": "api/FrameworkSystems.FrameworkBase.StaticCache.Get.html",
    "title": "Method Get",
    "keywords": "Method Get Get(IGlobalObjects, String) Gibt den untypisierten statischen Cache zu dem angegebenen FullName für das angegebene Global zurück, falls dieser existiert, ansonsten null. Declaration public static IStaticCache Get(IGlobalObjects global, string cacheFullName) Parameters global IGlobalObjects cacheFullName String Returns IStaticCache Examples IStaticCache oCurrencyCache = StaticCache.Get(this.Global, \"cdCurrencyCache\"); Get(IDevFrameworkDataObject) Gibt den untypisierten statischen Cache zu dem angegebenen IDevFrameworkDataObject zurück, falls dieser existiert, ansonsten null. Declaration public static IStaticCache Get(IDevFrameworkDataObject devFrameworkDataObject) Parameters devFrameworkDataObject IDevFrameworkDataObject Returns IStaticCache Examples IStaticCache oCurrencyCache = StaticCache.Get(this.oCurrency);"
  },
  "api/FrameworkSystems.FrameworkBase.StaticCache.html": {
    "href": "api/FrameworkSystems.FrameworkBase.StaticCache.html",
    "title": "Class StaticCache",
    "keywords": "Class StaticCache Diese statische Klasse bietet Methoden zur Ermittlung eines untypisierten Caches über den Namen oder ein übergebenes IDevFrameworkDataObject, soweit dieser existiert. Inheritance Object StaticCache Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static class StaticCache Methods Get(IGlobalObjects, String) Gibt den untypisierten statischen Cache zu dem angegebenen FullName für das angegebene Global zurück, falls dieser existiert, ansonsten null. Get(IDevFrameworkDataObject) Gibt den untypisierten statischen Cache zu dem angegebenen IDevFrameworkDataObject zurück, falls dieser existiert, ansonsten null."
  },
  "api/FrameworkSystems.FrameworkBase.StaticCacheMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.StaticCacheMode.html",
    "title": "Enum StaticCacheMode",
    "keywords": "Enum StaticCacheMode Arbeitsmodus eines statischen Caches. Dieser kann im Einsprungpunkt GlobalGetStaticCacheMode(IDevFrameworkDataObject) pro Component-Typ festgelegt werden. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum StaticCacheMode Fields Name Description Broker Daten werden für alle Sessions zentral im Broker verwaltet. Der Einsprungpunkt GlobalWhereStaticCache(IStaticCacheObject) wird durchlaufen. Nicht durchlaufen werden die Einsprungpunkte FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.GlobalOnBeforeLoad(FrameworkSystems.FrameworkBase.DevFrameworkObject,System.String@,System.String@,System.String@) , FrameworkSystems.FrameworkBase.FrameworkDataObject`2.OnBeforeLoad(System.String@,System.String@,System.String@,System.Boolean) und FrameworkSystems.FrameworkBase.FrameworkDataColl`2.OnBeforeLoad(System.String@,System.String@,System.String@) . Session Daten werden pro Session verwaltet. Die Einsprungpunkte FrameworkSystems.FrameworkBase.GlobalObj.cGlobalBase.GlobalOnBeforeLoad(FrameworkSystems.FrameworkBase.DevFrameworkObject,System.String@,System.String@,System.String@) , FrameworkSystems.FrameworkBase.FrameworkDataObject`2.OnBeforeLoad(System.String@,System.String@,System.String@,System.Boolean) und FrameworkSystems.FrameworkBase.FrameworkDataColl`2.OnBeforeLoad(System.String@,System.String@,System.String@) werden durchlaufen. Nicht durchlaufen wird GlobalWhereStaticCache(IStaticCacheObject) ."
  },
  "api/FrameworkSystems.FrameworkBase.TextEditorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.TextEditorType.html",
    "title": "Enum TextEditorType",
    "keywords": "Enum TextEditorType Used for example by the Editbox control to specify the kind of text to be handled by the control. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum TextEditorType Fields Name Description HTML Der über den Datasource bereit gestellte Inhalt wird als Html interpretiert. Note Diese Einstellung ist nur bei mehrzeiligen Editfields möglich (Multiline=true). PlainText Es soll unformatierter Text dargestellt werden."
  },
  "api/FrameworkSystems.FrameworkBase.TreeViewDragDropMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.TreeViewDragDropMode.html",
    "title": "Enum TreeViewDragDropMode",
    "keywords": "Enum TreeViewDragDropMode Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [HideForIntellisense] public enum TreeViewDragDropMode Fields Name Description AllTreeViews Drop ist von allen TreeViews aus möglich. None Drop in diesen TreeView ist nicht erlaubt. OtherTreeViews Drop ist nur mit Knoten von anderen TreeViews möglich. ThisTreeView Drop ist nur mit Knoten desselben TreeViews möglich."
  },
  "api/FrameworkSystems.FrameworkBase.VerticalAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.VerticalAlignment.html",
    "title": "Enum VerticalAlignment",
    "keywords": "Enum VerticalAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum VerticalAlignment Fields Name Description Bottom Middle Stretch Top"
  },
  "api/FrameworkSystems.FrameworkBase.WrapPanelHorizontalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.WrapPanelHorizontalContentAlignment.html",
    "title": "Enum WrapPanelHorizontalContentAlignment",
    "keywords": "Enum WrapPanelHorizontalContentAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum WrapPanelHorizontalContentAlignment Fields Name Description Center Fill Left Right"
  },
  "api/FrameworkSystems.FrameworkBase.WrapPanelVerticalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.WrapPanelVerticalContentAlignment.html",
    "title": "Enum WrapPanelVerticalContentAlignment",
    "keywords": "Enum WrapPanelVerticalContentAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum WrapPanelVerticalContentAlignment Fields Name Description Bottom Fill Middle Top"
  },
  "api/FrameworkSystems.FrameworkBase.WrapPanelWrapArrangement.html": {
    "href": "api/FrameworkSystems.FrameworkBase.WrapPanelWrapArrangement.html",
    "title": "Enum WrapPanelWrapArrangement",
    "keywords": "Enum WrapPanelWrapArrangement Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum WrapPanelWrapArrangement Fields Name Description Horizontal Vertical"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.CancelLoading.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.CancelLoading.html",
    "title": "Method CancelLoading",
    "keywords": "Method CancelLoading CancelLoading() Sends an action to the client, which cancels the loading of the current page. Declaration public virtual void CancelLoading()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.GenerateSnapshot.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.GenerateSnapshot.html",
    "title": "Method GenerateSnapshot",
    "keywords": "Method GenerateSnapshot GenerateSnapshot() Erstellt einen Snapshot von der aktuellen Ansicht des Browser-Fensters. Declaration public virtual void GenerateSnapshot()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.html",
    "title": "Class BrowserControlAction",
    "keywords": "Class BrowserControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction BrowserControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class BrowserControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Methods CancelLoading() Sends an action to the client, which cancels the loading of the current page. GenerateSnapshot() Erstellt einen Snapshot von der aktuellen Ansicht des Browser-Fensters. ReloadPage() Aktuelle Seite erneut laden. SetZoomFactor(Double) Setzt den Zoom-Faktor für den Content des Browser-Controls. Ein Wert von 1.0 entspricht 100%. Dieser bezieht sich auf die im Client eingestellte Skalierung. Bei 100% wird die Skalierung verwendet. Der maximale Zoomfaktor liegt bei 2.5 und der minimale Zoomfaktor bei 0.5."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.ReloadPage.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.ReloadPage.html",
    "title": "Method ReloadPage",
    "keywords": "Method ReloadPage ReloadPage() Aktuelle Seite erneut laden. Declaration public virtual void ReloadPage()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.SetZoomFactor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.SetZoomFactor.html",
    "title": "Method SetZoomFactor",
    "keywords": "Method SetZoomFactor SetZoomFactor(Double) Setzt den Zoom-Faktor für den Content des Browser-Controls. Ein Wert von 1.0 entspricht 100%. Dieser bezieht sich auf die im Client eingestellte Skalierung. Bei 100% wird die Skalierung verwendet. Der maximale Zoomfaktor liegt bei 2.5 und der minimale Zoomfaktor bei 0.5. Declaration public virtual void SetZoomFactor(double zoomfactor) Parameters zoomfactor Double"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ButtonControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ButtonControlAction.html",
    "title": "Class ButtonControlAction",
    "keywords": "Class ButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Button angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ButtonControlAction ImageButtonControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ButtonControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also ButtonDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.CheckboxControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.CheckboxControlAction.html",
    "title": "Class CheckboxControlAction",
    "keywords": "Class CheckboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Checkbox angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction CheckboxControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class CheckboxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also CheckBoxDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ComboBoxControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ComboBoxControlAction.html",
    "title": "Class ComboBoxControlAction",
    "keywords": "Class ComboBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Combobox angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ComboBoxControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ComboBoxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also ComboboxDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.DashboardContainerControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.DashboardContainerControlAction.html",
    "title": "Class DashboardContainerControlAction",
    "keywords": "Class DashboardContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control DashboardContainer angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction DashboardContainerControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class DashboardContainerControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Methods SetEditable(Boolean) Schaltet den Bearbeitungsmodus des Steuerelements an( true ) oder aus( false ). Genau dann,wenn der Bearbeitungsmodus angeschalten ist, kann der Benutzer Layout Änderungen vornehmen.Die Features Maximieren/Wiederherstellen sowie Zu-/Aufklappen bleiben davon jedoch unberührt. See Also DashBoardContainerViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.DashboardContainerControlAction.SetEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.DashboardContainerControlAction.SetEditable.html",
    "title": "Method SetEditable",
    "keywords": "Method SetEditable SetEditable(Boolean) Schaltet den Bearbeitungsmodus des Steuerelements an( true ) oder aus( false ). Genau dann,wenn der Bearbeitungsmodus angeschalten ist, kann der Benutzer Layout Änderungen vornehmen.Die Features Maximieren/Wiederherstellen sowie Zu-/Aufklappen bleiben davon jedoch unberührt. Declaration public void SetEditable(bool isEditable) Parameters isEditable Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.DockPanelControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.DockPanelControlAction.html",
    "title": "Class DockPanelControlAction",
    "keywords": "Class DockPanelControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction DockPanelControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class DockPanelControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.html",
    "title": "Class EditableControlAction",
    "keywords": "Class EditableControlAction Summary description for EditableControlAction. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ButtonControlAction CheckboxControlAction ComboBoxControlAction DockPanelControlAction EditboxControlAction FieldPanelControlAction GridColumnControlAction GridControlAction ListBoxControlAction ListViewControlAction MainMenuControlAction PictureControlAction RadioButtonControlAction TabbedWindowControlAction TabPageControlAction TemplateControlAction TreeViewControlAction WrapPanelControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class EditableControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Methods SetEnabled(Nullable<Boolean>) Bestimmt, ob der Button reagiert, also gedrückt werden kann, oder nicht. SetFocus() Setzt den Fokus auf das entsprechende Control, an dem diese Action ausgeführt wird. Werden in einem Request an den Broker mehrere SetFocus-Actions ausgeführt, gewinnt die letzte."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.SetEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.SetEnabled.html",
    "title": "Method SetEnabled",
    "keywords": "Method SetEnabled SetEnabled(Nullable<Boolean>) Bestimmt, ob der Button reagiert, also gedrückt werden kann, oder nicht. Declaration public virtual void SetEnabled(bool? value) Parameters value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.SetFocus.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.SetFocus.html",
    "title": "Method SetFocus",
    "keywords": "Method SetFocus SetFocus() Setzt den Fokus auf das entsprechende Control, an dem diese Action ausgeführt wird. Werden in einem Request an den Broker mehrere SetFocus-Actions ausgeführt, gewinnt die letzte. Declaration public virtual void SetFocus()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.html",
    "title": "Class EditboxControlAction",
    "keywords": "Class EditboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control EditField angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction EditboxControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class EditboxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Methods PastePlainText(String) Diese Action fügt den angegebenen (unformatierten) Text in einem Editfield an die aktuelle Cursorposition ein. Wenn im Control Text markiert ist, wird dieser durch den angegebenen Text ersetzt. Dadurch kann insbesondere in mehrzeiligen Textfeldern Text durch die Businesslogik an der aktuellen Position eingefügt werden, ohne dass der neue Text unter Verwendung der Datasources SelectionStart und SelectionEnd manuell zusammengesetzt werden muss. SelectAllText() Diese Action selektiert den kompletten Text des Editfields. Sie ist gedacht für Multiline Editfields, weil diese im Gegensatz zu normalen Editfields nicht den Text selektieren, wenn im Java-Client der Fokus in das Feld gesetzt wird. Idealerweise erfolgt der Aufruf dieser Action im OnEnter- Event des Editfields. SetDisplayMaxLength(FSint) !TODO SetDisplayMaxLength(Nullable<Int32>) !TODO SetDisplayMaxLines(FSint) !TODO SetDisplayMinLength(FSint) !TODO SetDisplayMinLength(Nullable<Int32>) !TODO SetDisplayMinLines(FSint) !TODO SetDisplayMinLines(Nullable<Int32>) !TODO See Also EditboxDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.PastePlainText.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.PastePlainText.html",
    "title": "Method PastePlainText",
    "keywords": "Method PastePlainText PastePlainText(String) Diese Action fügt den angegebenen (unformatierten) Text in einem Editfield an die aktuelle Cursorposition ein. Wenn im Control Text markiert ist, wird dieser durch den angegebenen Text ersetzt. Dadurch kann insbesondere in mehrzeiligen Textfeldern Text durch die Businesslogik an der aktuellen Position eingefügt werden, ohne dass der neue Text unter Verwendung der Datasources SelectionStart und SelectionEnd manuell zusammengesetzt werden muss. Declaration public virtual void PastePlainText(string plainText) Parameters plainText String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SelectAllText.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SelectAllText.html",
    "title": "Method SelectAllText",
    "keywords": "Method SelectAllText SelectAllText() Diese Action selektiert den kompletten Text des Editfields. Sie ist gedacht für Multiline Editfields, weil diese im Gegensatz zu normalen Editfields nicht den Text selektieren, wenn im Java-Client der Fokus in das Feld gesetzt wird. Idealerweise erfolgt der Aufruf dieser Action im OnEnter- Event des Editfields. Declaration public virtual void SelectAllText()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMaxLength.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMaxLength.html",
    "title": "Method SetDisplayMaxLength",
    "keywords": "Method SetDisplayMaxLength SetDisplayMaxLength(FSint) !TODO Declaration public void SetDisplayMaxLength(FSint value) Parameters value FSint SetDisplayMaxLength(Nullable<Int32>) !TODO Declaration public void SetDisplayMaxLength(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMaxLines.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMaxLines.html",
    "title": "Method SetDisplayMaxLines",
    "keywords": "Method SetDisplayMaxLines SetDisplayMaxLines(FSint) !TODO Declaration public void SetDisplayMaxLines(FSint value) Parameters value FSint"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMinLength.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMinLength.html",
    "title": "Method SetDisplayMinLength",
    "keywords": "Method SetDisplayMinLength SetDisplayMinLength(FSint) !TODO Declaration public void SetDisplayMinLength(FSint value) Parameters value FSint SetDisplayMinLength(Nullable<Int32>) !TODO Declaration public void SetDisplayMinLength(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMinLines.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMinLines.html",
    "title": "Method SetDisplayMinLines",
    "keywords": "Method SetDisplayMinLines SetDisplayMinLines(FSint) !TODO Declaration public void SetDisplayMinLines(FSint value) Parameters value FSint SetDisplayMinLines(Nullable<Int32>) !TODO Declaration public void SetDisplayMinLines(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FieldPanelControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FieldPanelControlAction.html",
    "title": "Class FieldPanelControlAction",
    "keywords": "Class FieldPanelControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction FieldPanelControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class FieldPanelControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FieldRowControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FieldRowControlAction.html",
    "title": "Class FieldRowControlAction",
    "keywords": "Class FieldRowControlAction Inheritance Object FrameworkControlActionBase FieldRowControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class FieldRowControlAction : FrameworkControlActionBase, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FormContainerControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FormContainerControlAction.html",
    "title": "Class FormContainerControlAction",
    "keywords": "Class FormContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control FormCointainer angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction FormContainerControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class FormContainerControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable See Also FormContainerDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.GetDefaultLabel.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.GetDefaultLabel.html",
    "title": "Method GetDefaultLabel",
    "keywords": "Method GetDefaultLabel GetDefaultLabel() !TODO Declaration public virtual string GetDefaultLabel() Returns String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.html",
    "title": "Class FrameworkControlAction",
    "keywords": "Class FrameworkControlAction Summary description for FrameworkControlAction. Inheritance Object FrameworkControlActionBase FrameworkControlAction BrowserControlAction DashboardContainerControlAction EditableControlAction FormContainerControlAction LabelControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class FrameworkControlAction : FrameworkControlActionBase, IFrameworkControlActionBase, ISerializable Methods GetDefaultLabel() !TODO SetBackColor(Nullable<Color>) !TODO SetBorderColor(Nullable<Color>) !TODO SetCaption(String) !TODO SetFontBold(FSbool) !TODO SetFontBold(Nullable<Boolean>) !TODO SetFontFamily(String) !TODO SetFontItalic(FSbool) !TODO SetFontItalic(Nullable<Boolean>) !TODO SetFontSize(FSint) !TODO SetFontSize(Nullable<Int32>) !TODO SetFontUnderline(FSbool) !TODO SetFontUnderline(Nullable<Boolean>) !TODO SetForeColor(Nullable<Color>) Ermöglicht das Setzen der Control-Farbe zur Laufzeit. SetMaxHeight(FSint) !TODO SetMaxHeight(Nullable<Int32>) !TODO SetMaxWidth(FSint) !TODO SetMaxWidth(Nullable<Int32>) !TODO SetMinHeight(FSint) !TODO SetMinHeight(Nullable<Int32>) !TODO SetMinWidth(FSint) !TODO SetMinWidth(Nullable<Int32>) !TODO SetToolTip(String) !TODO"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetBackColor.html",
    "title": "Method SetBackColor",
    "keywords": "Method SetBackColor SetBackColor(Nullable<Color>) !TODO Declaration public virtual void SetBackColor(Color? color) Parameters color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetBorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetBorderColor.html",
    "title": "Method SetBorderColor",
    "keywords": "Method SetBorderColor SetBorderColor(Nullable<Color>) !TODO Declaration public virtual void SetBorderColor(Color? color) Parameters color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetCaption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetCaption.html",
    "title": "Method SetCaption",
    "keywords": "Method SetCaption SetCaption(String) !TODO Declaration public virtual void SetCaption(string caption) Parameters caption String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontBold.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontBold.html",
    "title": "Method SetFontBold",
    "keywords": "Method SetFontBold SetFontBold(FSbool) !TODO Declaration public virtual void SetFontBold(FSbool bold) Parameters bold FSbool SetFontBold(Nullable<Boolean>) !TODO Declaration public virtual void SetFontBold(bool? bold) Parameters bold Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontFamily.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontFamily.html",
    "title": "Method SetFontFamily",
    "keywords": "Method SetFontFamily SetFontFamily(String) !TODO Declaration public virtual void SetFontFamily(string family) Parameters family String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontItalic.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontItalic.html",
    "title": "Method SetFontItalic",
    "keywords": "Method SetFontItalic SetFontItalic(FSbool) !TODO Declaration public virtual void SetFontItalic(FSbool italic) Parameters italic FSbool SetFontItalic(Nullable<Boolean>) !TODO Declaration public virtual void SetFontItalic(bool? italic) Parameters italic Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontSize.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontSize.html",
    "title": "Method SetFontSize",
    "keywords": "Method SetFontSize SetFontSize(FSint) !TODO Declaration public virtual void SetFontSize(FSint size) Parameters size FSint SetFontSize(Nullable<Int32>) !TODO Declaration public virtual void SetFontSize(int? size) Parameters size Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontUnderline.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontUnderline.html",
    "title": "Method SetFontUnderline",
    "keywords": "Method SetFontUnderline SetFontUnderline(FSbool) !TODO Declaration public virtual void SetFontUnderline(FSbool underline) Parameters underline FSbool SetFontUnderline(Nullable<Boolean>) !TODO Declaration public virtual void SetFontUnderline(bool? underline) Parameters underline Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetForeColor.html",
    "title": "Method SetForeColor",
    "keywords": "Method SetForeColor SetForeColor(Nullable<Color>) Ermöglicht das Setzen der Control-Farbe zur Laufzeit. Declaration public virtual void SetForeColor(Color? color) Parameters color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMaxHeight.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMaxHeight.html",
    "title": "Method SetMaxHeight",
    "keywords": "Method SetMaxHeight SetMaxHeight(FSint) !TODO Declaration public virtual void SetMaxHeight(FSint value) Parameters value FSint SetMaxHeight(Nullable<Int32>) !TODO Declaration public virtual void SetMaxHeight(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMaxWidth.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMaxWidth.html",
    "title": "Method SetMaxWidth",
    "keywords": "Method SetMaxWidth SetMaxWidth(FSint) !TODO Declaration public virtual void SetMaxWidth(FSint value) Parameters value FSint SetMaxWidth(Nullable<Int32>) !TODO Declaration public virtual void SetMaxWidth(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMinHeight.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMinHeight.html",
    "title": "Method SetMinHeight",
    "keywords": "Method SetMinHeight SetMinHeight(FSint) !TODO Declaration public virtual void SetMinHeight(FSint value) Parameters value FSint SetMinHeight(Nullable<Int32>) !TODO Declaration public virtual void SetMinHeight(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMinWidth.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMinWidth.html",
    "title": "Method SetMinWidth",
    "keywords": "Method SetMinWidth SetMinWidth(FSint) !TODO Declaration public virtual void SetMinWidth(FSint value) Parameters value FSint SetMinWidth(Nullable<Int32>) !TODO Declaration public virtual void SetMinWidth(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetToolTip.html",
    "title": "Method SetToolTip",
    "keywords": "Method SetToolTip SetToolTip(String) !TODO Declaration public virtual void SetToolTip(string toolTipExtension) Parameters toolTipExtension String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.HidePermanent.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.HidePermanent.html",
    "title": "Method HidePermanent",
    "keywords": "Method HidePermanent HidePermanent() !TODO Declaration public virtual void HidePermanent()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.html",
    "title": "Class FrameworkControlActionBase",
    "keywords": "Class FrameworkControlActionBase Actions, die so ziemlich jedes Control besitzt. Inheritance Object FrameworkControlActionBase FieldRowControlAction FrameworkControlAction Implements IFrameworkControlActionBase Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class FrameworkControlActionBase : IFrameworkControlActionBase, ISerializable Methods HidePermanent() !TODO SetVisible(Boolean) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true , wird das Control eingeblendet und bei false ausgeblendet. SetVisible(Nullable<FSVisibility>) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true , wird das Control eingeblendet und bei false ausgeblendet."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.SetVisible.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.SetVisible.html",
    "title": "Method SetVisible",
    "keywords": "Method SetVisible SetVisible(Boolean) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true , wird das Control eingeblendet und bei false ausgeblendet. Declaration public virtual void SetVisible(bool value) Parameters value Boolean SetVisible(Nullable<FSVisibility>) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true , wird das Control eingeblendet und bei false ausgeblendet. Declaration public virtual void SetVisible(FSVisibility? value) Parameters value Nullable < FSVisibility >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.html",
    "title": "Class GridColumnControlAction",
    "keywords": "Class GridColumnControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid-Column angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction GridColumnControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class GridColumnControlAction : EditableControlAction, ISerializable, IGridColumnControlAction, IFrameworkControlActionBase Methods MoveAfter(IGridColumnControlAction) Verschiebt das aktuelle Grid-Column hinter das übergebene afterControl . MoveBefore(IGridColumnControlAction) Verschiebt das aktuelle Grid-Column vor das übergebene beforeControl . SetCell(guid) Setzt den Fokus auf ein Feld. SetCellBackColor(guid, Nullable<Color>) !TODO SetCellEditable(guid, Boolean) Setzt die Editierbarkeit einer Grid-Zelle. SetCellForeColor(guid, Nullable<Color>) !TODO See Also GridColDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.MoveAfter.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.MoveAfter.html",
    "title": "Method MoveAfter",
    "keywords": "Method MoveAfter MoveAfter(IGridColumnControlAction) Verschiebt das aktuelle Grid-Column hinter das übergebene afterControl . Declaration public virtual void MoveAfter(IGridColumnControlAction afterControl) Parameters afterControl FrameworkSystems.FrameworkStudio.DevFormBase.IGridColumnControlAction Examples Verschiebt das Column grd_sID hinter das Column grd_decPrice . this.grd_sID.MoveAfter(this.grd_decPrice);"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.MoveBefore.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.MoveBefore.html",
    "title": "Method MoveBefore",
    "keywords": "Method MoveBefore MoveBefore(IGridColumnControlAction) Verschiebt das aktuelle Grid-Column vor das übergebene beforeControl . Declaration public virtual void MoveBefore(IGridColumnControlAction beforeControl) Parameters beforeControl FrameworkSystems.FrameworkStudio.DevFormBase.IGridColumnControlAction Examples Verschiebt das Column grd_sID vor das Column grd_decPrice . this.grd_sID.MoveBefore(this.grd_decPrice);"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCell.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCell.html",
    "title": "Method SetCell",
    "keywords": "Method SetCell SetCell(guid) Setzt den Fokus auf ein Feld. Declaration public virtual void SetCell(guid rowID) Parameters rowID guid Gibt die GUID des Objekts an"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellBackColor.html",
    "title": "Method SetCellBackColor",
    "keywords": "Method SetCellBackColor SetCellBackColor(guid, Nullable<Color>) !TODO Declaration public virtual void SetCellBackColor(guid rowID, Color? color) Parameters rowID guid color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellEditable.html",
    "title": "Method SetCellEditable",
    "keywords": "Method SetCellEditable SetCellEditable(guid, Boolean) Setzt die Editierbarkeit einer Grid-Zelle. Declaration public virtual void SetCellEditable(guid rowID, bool isEditable) Parameters rowID guid Gibt die ObjectRowID des Objekts an. isEditable Boolean Gibt an, ob das Feld editierbar ist Remarks Wird als rowID der null übergeben, dann gilt die Einstellung für alle Zeilen des Grids. So ein Aufruf überschreibt aber nicht die Aufrufe, die für einzelne Zeilen getätigt wurden. Aufrufe mit einer bestimmten rowID haben höhere Priorität."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellForeColor.html",
    "title": "Method SetCellForeColor",
    "keywords": "Method SetCellForeColor SetCellForeColor(guid, Nullable<Color>) !TODO Declaration public virtual void SetCellForeColor(guid rowID, Color? color) Parameters rowID guid color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.AddColumn.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.AddColumn.html",
    "title": "Method AddColumn",
    "keywords": "Method AddColumn AddColumn(GridColumnDefinition) Fügt dem Grid eine neue Spalte hinzu. Sollte zu dem in der GridColumnDefinition angegebenen Property bereits eine Spalte existieren, so wird eine Exception ausgelöst. Declaration public GridColumnControlAction AddColumn(GridColumnDefinition columnDefinition) Parameters columnDefinition GridColumnDefinition Returns GridColumnControlAction"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.GetDynamicColumnAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.GetDynamicColumnAction.html",
    "title": "Method GetDynamicColumnAction",
    "keywords": "Method GetDynamicColumnAction GetDynamicColumnAction(String) Gibt die GridColumnControlAction der zur Laufzeit hinzugefügten Spalte (=dynamische Spalte) für das angegebene Property zurück. Wenn für das Property keine dynamische Spalte existiert, wird null zurück gegeben. Declaration public GridColumnControlAction GetDynamicColumnAction(string property) Parameters property String Returns GridColumnControlAction"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.GetView.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.GetView.html",
    "title": "Method GetView",
    "keywords": "Method GetView GetView() !TODO Declaration public IGridView GetView() Returns IGridView"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.html",
    "title": "Class GridControlAction",
    "keywords": "Class GridControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction GridControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class GridControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Methods AddColumn(GridColumnDefinition) Fügt dem Grid eine neue Spalte hinzu. Sollte zu dem in der GridColumnDefinition angegebenen Property bereits eine Spalte existieren, so wird eine Exception ausgelöst. GetDynamicColumnAction(String) Gibt die GridColumnControlAction der zur Laufzeit hinzugefügten Spalte (=dynamische Spalte) für das angegebene Property zurück. Wenn für das Property keine dynamische Spalte existiert, wird null zurück gegeben. GetView() !TODO InsertAfter(GridColumnControlAction, GridColumnControlAction[]) Verschiebt die Grid-Columns controlsToInsert hinter afterControl . InsertAfter(GridColumnControlAction, IEnumerable<GridColumnControlAction>) InsertBefore(GridColumnControlAction, GridColumnControlAction[]) Verschiebt die Grid-Columns controlsToInsert vor das beforeControl . InsertBefore(GridColumnControlAction, IEnumerable<GridColumnControlAction>) LoadGridLayout(String, Boolean) Sendet eine Action an den Client, die ein auf dem Client-Rechner gespeichertes Grid-Layout einliest. RedoSortAndFilter() !TODO RemoveAllDynamicColumns() Entfernt alle dynamischen Spalten. RemoveColumn(GridColumnControlAction) Entfernt die dynamische Spalte, falls sie existiert. RemoveColumn(GridColumnDefinition) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. RemoveColumn(String) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. ResetSortAndFilter() !TODO SaveGridLayout(String, Boolean) Sendet eine Action an den Client, die das Layout des Grids auf dem Client-Rechner speichert. ScrollTo(guid) !TODO ScrollTo(Int32) !TODO SetCell(guid, Int32) Diese Aktion setzt den Fokus in eine Zelle des Grids. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. SetCell(guid, String) Wie SetCell(guid, Int32) . Zusätzlich gibt es hier den Parameter SelectAll , mit dem angegeben werden kann, ob der gesamte Inhalt der Zelle markiert werden soll. Mit true wird der Inhalt markiert und kann direkt überschrieben werden. SetCellBackColor(guid, Int32, Color) !TODO SetCellBackColor(guid, String, Color) !TODO SetCellEditable(guid, Int32, Boolean) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. SetCellEditable(guid, String, Boolean) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. columnName ist der Name der Spalte. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. SetCellForeColor(guid, Int32, Color) !TODO SetCellForeColor(guid, String, Color) !TODO SetColumnCaption(Int32, String) Setzt die Spaltenüberschrift der Spalte Nummer ColumnPos auf den Wert value . SetColumnCaption(String, String) Setzt die Spaltenüberschrift der Spalte ColumnName auf den neuen Wert value . SetColumnToolTip(Int32, String) !TODO SetColumnToolTip(String, String) !TODO SetColumnVisible(Int32, Boolean) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. SetColumnVisible(Int32, Nullable<Boolean>) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. SetColumnVisible(String, Boolean) Legt fest, ob die Spalte ColumnName dargestellt werden soll. SetColumnVisible(String, Nullable<Boolean>) Legt fest, ob die Spalte ColumnName dargestellt werden soll. SetEditable(Boolean) !TODO SetGridColor(Color) !TODO SetGridRowHeight(Int32) Legt die Zeilenhöhe der einzelnen Zeilen im Grid fest. SetMultiselect(Boolean) Diese Methode ermöglicht es während der Laufzeit Mehrfachselektionen am GridControl zuzulassen oder zu verweigern. See Also GridDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.InsertAfter.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.InsertAfter.html",
    "title": "Method InsertAfter",
    "keywords": "Method InsertAfter InsertAfter(GridColumnControlAction, GridColumnControlAction[]) Verschiebt die Grid-Columns controlsToInsert hinter afterControl . Declaration public void InsertAfter(GridColumnControlAction afterControl, params GridColumnControlAction[] controlsToInsert) Parameters afterControl GridColumnControlAction controlsToInsert GridColumnControlAction [] Remarks Wenn afterControl null ist, werden die Grid-Columns controlsToInsert an das Ende des Grids verschoben. Examples Verschiebt das Column grd_sName hinter das Column grd_decPrice . this.grd.InsertAfter(this.grd_decPrice, this.grd_sName); InsertAfter(GridColumnControlAction, IEnumerable<GridColumnControlAction>) Declaration public void InsertAfter(GridColumnControlAction afterControl, IEnumerable<GridColumnControlAction> controlsToInsert) Parameters afterControl GridColumnControlAction controlsToInsert IEnumerable < GridColumnControlAction >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.InsertBefore.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.InsertBefore.html",
    "title": "Method InsertBefore",
    "keywords": "Method InsertBefore InsertBefore(GridColumnControlAction, GridColumnControlAction[]) Verschiebt die Grid-Columns controlsToInsert vor das beforeControl . Declaration public void InsertBefore(GridColumnControlAction beforeControl, params GridColumnControlAction[] controlsToInsert) Parameters beforeControl GridColumnControlAction controlsToInsert GridColumnControlAction [] Remarks Wenn beforeControl null ist, werden die Grid-Columns controlsToInsert an den Anfang des Grids verschoben. Examples Verschiebt die Columns grd_sName , grd_decPrice und grd_sID in der angegebenen Reihenfolge an den Anfang des Grids. this.grd.InsertBefore(null, this.grd_sName, this.grd_decPrice, this.grd_sID); Verschiebt die Columns grd_decPrice und grd_sID in der angegebenen Reihenfolge vor das Column grd_sName . this.grd.InsertBefore(this.grd_sName, this.grd_decPrice, this.grd_sID); InsertBefore(GridColumnControlAction, IEnumerable<GridColumnControlAction>) Declaration public void InsertBefore(GridColumnControlAction beforeControl, IEnumerable<GridColumnControlAction> controlsToInsert) Parameters beforeControl GridColumnControlAction controlsToInsert IEnumerable < GridColumnControlAction >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.LoadGridLayout.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.LoadGridLayout.html",
    "title": "Method LoadGridLayout",
    "keywords": "Method LoadGridLayout LoadGridLayout(String, Boolean) Sendet eine Action an den Client, die ein auf dem Client-Rechner gespeichertes Grid-Layout einliest. Declaration public virtual void LoadGridLayout(string fileName, bool displayErrorMsg) Parameters fileName String Relativer Dateipfad. displayErrorMsg Boolean Gibt an, ob im Fehlerfall eine Meldung angezeigt werden soll. See Also SaveGridLayout(String, Boolean)"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RedoSortAndFilter.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RedoSortAndFilter.html",
    "title": "Method RedoSortAndFilter",
    "keywords": "Method RedoSortAndFilter RedoSortAndFilter() !TODO Declaration public void RedoSortAndFilter()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RemoveAllDynamicColumns.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RemoveAllDynamicColumns.html",
    "title": "Method RemoveAllDynamicColumns",
    "keywords": "Method RemoveAllDynamicColumns RemoveAllDynamicColumns() Entfernt alle dynamischen Spalten. Declaration public void RemoveAllDynamicColumns()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RemoveColumn.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RemoveColumn.html",
    "title": "Method RemoveColumn",
    "keywords": "Method RemoveColumn RemoveColumn(GridColumnDefinition) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. Declaration public void RemoveColumn(GridColumnDefinition columnDefinition) Parameters columnDefinition GridColumnDefinition RemoveColumn(GridColumnControlAction) Entfernt die dynamische Spalte, falls sie existiert. Declaration public void RemoveColumn(GridColumnControlAction gridColumnControlAction) Parameters gridColumnControlAction GridColumnControlAction RemoveColumn(String) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. Declaration public void RemoveColumn(string property) Parameters property String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.ResetSortAndFilter.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.ResetSortAndFilter.html",
    "title": "Method ResetSortAndFilter",
    "keywords": "Method ResetSortAndFilter ResetSortAndFilter() !TODO Declaration public void ResetSortAndFilter()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SaveGridLayout.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SaveGridLayout.html",
    "title": "Method SaveGridLayout",
    "keywords": "Method SaveGridLayout SaveGridLayout(String, Boolean) Sendet eine Action an den Client, die das Layout des Grids auf dem Client-Rechner speichert. Declaration public virtual void SaveGridLayout(string fileName, bool displayErrorMsg) Parameters fileName String Relativer Dateipfad. displayErrorMsg Boolean Gibt an, ob im Fehlerfall eine Meldung angezeigt werden soll. Remarks Es muss ein relativer Dateipfad angegeben werden. Dieser wird unterhalb des Ordners %userprofile%\\FSJavaClient\\[Broker-Url]\\ gespeichert. In diesem Ordner werden auch die Layout-Einstellungen gespeichert. Werden Layout-Einstellungen mit ResetClientLayout() zurückgesetzt, dann wird der komplette Ordner gelöscht. Absolute Dateipfade werden vom Java-Client unterbunden. See Also LoadGridLayout(String, Boolean)"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.ScrollTo.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.ScrollTo.html",
    "title": "Method ScrollTo",
    "keywords": "Method ScrollTo ScrollTo(Int32) !TODO Declaration public virtual void ScrollTo(int row) Parameters row Int32 ScrollTo(guid) !TODO Declaration public virtual void ScrollTo(guid objectRowID) Parameters objectRowID guid"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCell.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCell.html",
    "title": "Method SetCell",
    "keywords": "Method SetCell SetCell(guid, Int32) Diese Aktion setzt den Fokus in eine Zelle des Grids. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. Declaration public virtual void SetCell(guid rowID, int columnPos) Parameters rowID guid columnPos Int32 SetCell(guid, String) Wie SetCell(guid, Int32) . Zusätzlich gibt es hier den Parameter SelectAll , mit dem angegeben werden kann, ob der gesamte Inhalt der Zelle markiert werden soll. Mit true wird der Inhalt markiert und kann direkt überschrieben werden. Declaration public virtual void SetCell(guid rowID, string columnName) Parameters rowID guid columnName String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellBackColor.html",
    "title": "Method SetCellBackColor",
    "keywords": "Method SetCellBackColor SetCellBackColor(guid, Int32, Color) !TODO Declaration public virtual void SetCellBackColor(guid rowID, int columnPos, Color color) Parameters rowID guid columnPos Int32 color Color SetCellBackColor(guid, String, Color) !TODO Declaration public virtual void SetCellBackColor(guid rowID, string columnName, Color color) Parameters rowID guid columnName String color Color"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellEditable.html",
    "title": "Method SetCellEditable",
    "keywords": "Method SetCellEditable SetCellEditable(guid, Int32, Boolean) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. Declaration public virtual void SetCellEditable(guid rowID, int columnPos, bool isEditable) Parameters rowID guid columnPos Int32 isEditable Boolean SetCellEditable(guid, String, Boolean) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. columnName ist der Name der Spalte. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. Declaration public virtual void SetCellEditable(guid rowID, string columnName, bool isEditable) Parameters rowID guid columnName String isEditable Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellForeColor.html",
    "title": "Method SetCellForeColor",
    "keywords": "Method SetCellForeColor SetCellForeColor(guid, Int32, Color) !TODO Declaration public virtual void SetCellForeColor(guid rowID, int columnPos, Color color) Parameters rowID guid columnPos Int32 color Color SetCellForeColor(guid, String, Color) !TODO Declaration public virtual void SetCellForeColor(guid rowID, string columnName, Color color) Parameters rowID guid columnName String color Color"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnCaption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnCaption.html",
    "title": "Method SetColumnCaption",
    "keywords": "Method SetColumnCaption SetColumnCaption(Int32, String) Setzt die Spaltenüberschrift der Spalte Nummer ColumnPos auf den Wert value . Declaration public virtual void SetColumnCaption(int columnPos, string value) Parameters columnPos Int32 value String SetColumnCaption(String, String) Setzt die Spaltenüberschrift der Spalte ColumnName auf den neuen Wert value . Declaration public virtual void SetColumnCaption(string columnName, string value) Parameters columnName String value String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnToolTip.html",
    "title": "Method SetColumnToolTip",
    "keywords": "Method SetColumnToolTip SetColumnToolTip(Int32, String) !TODO Declaration public virtual void SetColumnToolTip(int columnPos, string toolTipExtension) Parameters columnPos Int32 toolTipExtension String SetColumnToolTip(String, String) !TODO Declaration public virtual void SetColumnToolTip(string columnName, string toolTipExtension) Parameters columnName String toolTipExtension String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnVisible.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnVisible.html",
    "title": "Method SetColumnVisible",
    "keywords": "Method SetColumnVisible SetColumnVisible(Int32, Boolean) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. Declaration public virtual void SetColumnVisible(int columnPos, bool value) Parameters columnPos Int32 value Boolean SetColumnVisible(Int32, Nullable<Boolean>) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. Declaration public virtual void SetColumnVisible(int columnPos, bool? value) Parameters columnPos Int32 value Nullable < Boolean > SetColumnVisible(String, Boolean) Legt fest, ob die Spalte ColumnName dargestellt werden soll. Declaration public virtual void SetColumnVisible(string columnName, bool value) Parameters columnName String value Boolean SetColumnVisible(String, Nullable<Boolean>) Legt fest, ob die Spalte ColumnName dargestellt werden soll. Declaration public virtual void SetColumnVisible(string columnName, bool? value) Parameters columnName String value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetEditable.html",
    "title": "Method SetEditable",
    "keywords": "Method SetEditable SetEditable(Boolean) !TODO Declaration public void SetEditable(bool isEditable) Parameters isEditable Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetGridColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetGridColor.html",
    "title": "Method SetGridColor",
    "keywords": "Method SetGridColor SetGridColor(Color) !TODO Declaration public virtual void SetGridColor(Color color) Parameters color Color"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetGridRowHeight.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetGridRowHeight.html",
    "title": "Method SetGridRowHeight",
    "keywords": "Method SetGridRowHeight SetGridRowHeight(Int32) Legt die Zeilenhöhe der einzelnen Zeilen im Grid fest. Declaration public void SetGridRowHeight(int height) Parameters height Int32"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetMultiselect.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetMultiselect.html",
    "title": "Method SetMultiselect",
    "keywords": "Method SetMultiselect SetMultiselect(Boolean) Diese Methode ermöglicht es während der Laufzeit Mehrfachselektionen am GridControl zuzulassen oder zu verweigern. Declaration public void SetMultiselect(bool isMultiselectAllowed) Parameters isMultiselectAllowed Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.html",
    "title": "Namespace FrameworkSystems.FrameworkControls.Actions",
    "keywords": "Namespace FrameworkSystems.FrameworkControls.Actions Classes BrowserControlAction ButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Button angeboten. CheckboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Checkbox angeboten. ComboBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Combobox angeboten. DashboardContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control DashboardContainer angeboten. DockPanelControlAction EditableControlAction Summary description for EditableControlAction. EditboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control EditField angeboten. FieldPanelControlAction FieldRowControlAction FormContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control FormCointainer angeboten. FrameworkControlAction Summary description for FrameworkControlAction. FrameworkControlActionBase Actions, die so ziemlich jedes Control besitzt. GridColumnControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid-Column angeboten. GridControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid angeboten. ImageButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ImageButton angeboten. LabelControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Label angeboten. ListBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Listbox angeboten. ListViewControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ListView angeboten. MainMenuControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Menu-Item angeboten. PictureControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Picture angeboten. RadioButtonControlAction TabbedWindowControlAction TabPageControlAction TemplateControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Template Control angeboten. TreeViewControlAction WrapPanelControlAction"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ImageButtonControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ImageButtonControlAction.html",
    "title": "Class ImageButtonControlAction",
    "keywords": "Class ImageButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ImageButton angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ButtonControlAction ImageButtonControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ImageButtonControlAction : ButtonControlAction, IFrameworkControlActionBase, ISerializable Methods SetHighlighted(Boolean) TODO! Sends an action to the client, which sets the caption of the control. See Also ImageButtonDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ImageButtonControlAction.SetHighlighted.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ImageButtonControlAction.SetHighlighted.html",
    "title": "Method SetHighlighted",
    "keywords": "Method SetHighlighted SetHighlighted(Boolean) TODO! Sends an action to the client, which sets the caption of the control. Declaration public virtual void SetHighlighted(bool highlighted) Parameters highlighted Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.LabelControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.LabelControlAction.html",
    "title": "Class LabelControlAction",
    "keywords": "Class LabelControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Label angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction LabelControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class LabelControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable See Also LabelDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ListBoxControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ListBoxControlAction.html",
    "title": "Class ListBoxControlAction",
    "keywords": "Class ListBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Listbox angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ListBoxControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ListBoxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also ListboxDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ListViewControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ListViewControlAction.html",
    "title": "Class ListViewControlAction",
    "keywords": "Class ListViewControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ListView angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ListViewControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ListViewControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also ListViewDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.MainMenuControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.MainMenuControlAction.html",
    "title": "Class MainMenuControlAction",
    "keywords": "Class MainMenuControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Menu-Item angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction MainMenuControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class MainMenuControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also MainMenuDesignViewModel ContextMenuDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.PictureControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.PictureControlAction.html",
    "title": "Class PictureControlAction",
    "keywords": "Class PictureControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Picture angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction PictureControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class PictureControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also PictureDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.RadioButtonControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.RadioButtonControlAction.html",
    "title": "Class RadioButtonControlAction",
    "keywords": "Class RadioButtonControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction RadioButtonControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class RadioButtonControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TabbedWindowControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TabbedWindowControlAction.html",
    "title": "Class TabbedWindowControlAction",
    "keywords": "Class TabbedWindowControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction TabbedWindowControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class TabbedWindowControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TabPageControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TabPageControlAction.html",
    "title": "Class TabPageControlAction",
    "keywords": "Class TabPageControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction TabPageControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class TabPageControlAction : EditableControlAction, ISerializable, ITabPageControlAction, IFrameworkControlActionBase"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TemplateControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TemplateControlAction.html",
    "title": "Class TemplateControlAction",
    "keywords": "Class TemplateControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Template Control angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction TemplateControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class TemplateControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also TemplateControlDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.ExpandTreeView.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.ExpandTreeView.html",
    "title": "Method ExpandTreeView",
    "keywords": "Method ExpandTreeView ExpandTreeView() Expandiert den TreeView vollständig. Declaration public virtual void ExpandTreeView() ExpandTreeView(Int32) Expandiert den TreeView bis zu der Ebene, die mit dem Parameter level festgelegt wird. Declaration public virtual void ExpandTreeView(int level) Parameters level Int32 ExpandTreeView(String) Expandiert den Pfad im TreeView, der durch den Parameter path festgelegt wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll (Unterknoten des zuletzt genannten Knotens werden nicht angezeigt). Jeder Knoten wird durch einen Punkt (.) vom nächsten Knoten getrennt. Jeder Knoten wird durch ObjectRowID Semikolon und Name des TreeNodes angegeben. Declaration public virtual void ExpandTreeView(string path) Parameters path String Examples „3197;tndStructureElement.52f3;tndStructureElementChild.4f04a4;tndPhaseElement“ Die Namen der Nodes können auch durch “NN” ersetzt werden.Z.B: „3197; NN.52f3;NN.4f04a4;NN“ ExpandTreeView(IDevFrameworkObject[]) Expandiert den Pfad im TreeView, der durch die Objekte objectPath definiert wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll. Die Unterknoten des im Pfad zuletzt genannten Knotens werden also nicht angezeigt. Declaration public virtual void ExpandTreeView(IDevFrameworkObject[] objectPath) Parameters objectPath IDevFrameworkObject [] Remarks Intern wird ein Pfad aufgebaut. Der Pfad enthält - anstatt des korrekten Knotennamens - den Zusatz NN. Examples ExpandTreeView( new IDevFrameworkObject[ ]{ oObject.oParent.oParent, oObject.oParent, oObject} );"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.html",
    "title": "Class TreeViewControlAction",
    "keywords": "Class TreeViewControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction TreeViewControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class TreeViewControlAction : EditableControlAction, ISerializable, ITreeViewControlAction, IFrameworkControlActionBase Methods ExpandTreeView() Expandiert den TreeView vollständig. ExpandTreeView(IDevFrameworkObject[]) Expandiert den Pfad im TreeView, der durch die Objekte objectPath definiert wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll. Die Unterknoten des im Pfad zuletzt genannten Knotens werden also nicht angezeigt. ExpandTreeView(Int32) Expandiert den TreeView bis zu der Ebene, die mit dem Parameter level festgelegt wird. ExpandTreeView(String) Expandiert den Pfad im TreeView, der durch den Parameter path festgelegt wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll (Unterknoten des zuletzt genannten Knotens werden nicht angezeigt). Jeder Knoten wird durch einen Punkt (.) vom nächsten Knoten getrennt. Jeder Knoten wird durch ObjectRowID Semikolon und Name des TreeNodes angegeben. SelectTreeNode(IDevFrameworkObject[]) Diese Action dient zum Selektieren eines Knotens im TreeView. Sie ist an die ExpandTreeView() Action angelehnt und hat somit auch mehrere Aufrufmöglichkeiten. Entweder mit einem String, welcher einen Pfad zu einem Knoten über die RowID und Knotennamen beschreibt, oder durch eine Liste mit IDevFrameworkObjects."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.SelectTreeNode.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.SelectTreeNode.html",
    "title": "Method SelectTreeNode",
    "keywords": "Method SelectTreeNode SelectTreeNode(IDevFrameworkObject[]) Diese Action dient zum Selektieren eines Knotens im TreeView. Sie ist an die ExpandTreeView() Action angelehnt und hat somit auch mehrere Aufrufmöglichkeiten. Entweder mit einem String, welcher einen Pfad zu einem Knoten über die RowID und Knotennamen beschreibt, oder durch eine Liste mit IDevFrameworkObjects. Declaration public virtual void SelectTreeNode(IDevFrameworkObject[] objectPath) Parameters objectPath IDevFrameworkObject [] Remarks Hintergrund zum Objekt-Pfad: Der TreeView arbeitet mit LazyLoading – d.h.der Client liest Einträge bei Bedarf vom Broker nach.Dadurch ist der komplette Baum – der mitunter extrem komplex sein kann – im Client nicht bekannt.Ein einzelner Eintrag müsste sehr aufwendig im Baum gesucht werden, was im extremsten Fall bedeutet, dass der komplette Baum an den Client übertragen werden müsste. Bei einem Baum mit 5 Ebenen und jeweils 10 Knoten wären das 11.111 Requests und 111.110 Datensätze. Durch die Angabe des Pfades kann der Client ganz gezielt die benötigten Baum-Teile nachlesen. In diesem Beispiel wären das 5 Requests und nur 50 Datensätze."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.WrapPanelControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.WrapPanelControlAction.html",
    "title": "Class WrapPanelControlAction",
    "keywords": "Class WrapPanelControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction WrapPanelControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class WrapPanelControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ContainsNullEntry.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ContainsNullEntry.html",
    "title": "Property ContainsNullEntry",
    "keywords": "Property ContainsNullEntry ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null -Entrag enthalten soll. Declaration public bool? ContainsNullEntry { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.-ctor.html",
    "title": "Constructor ColumnListDataSource",
    "keywords": "Constructor ColumnListDataSource ColumnListDataSource() Declaration public ColumnListDataSource()"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. Declaration public string DataSource { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMdt.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMdt.html",
    "title": "Property DisplayMdt",
    "keywords": "Property DisplayMdt DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. Declaration public MLContainer DisplayMdt { get; set; } Property Value MLContainer"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMember.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMember.html",
    "title": "Property DisplayMember",
    "keywords": "Property DisplayMember DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. Declaration public string DisplayMember { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.html",
    "title": "Class ColumnListDataSource",
    "keywords": "Class ColumnListDataSource Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid ( List ). Inheritance Object ColumnListDataSource Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class ColumnListDataSource Constructors ColumnListDataSource() Properties ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null -Entrag enthalten soll. DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest."
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ValueMember.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ValueMember.html",
    "title": "Property ValueMember",
    "keywords": "Property ValueMember ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest. Declaration public string ValueMember { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation.html",
    "title": "Method GetGeoLocation",
    "keywords": "Method GetGeoLocation GetGeoLocation(Action<IFrameworkGeoLocationInfo>) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. Declaration public void GetGeoLocation(Action<IFrameworkGeoLocationInfo> callback) Parameters callback Action < IFrameworkGeoLocationInfo > Die Methode, die nach dem Vorgang aufgerufen werden soll. Remarks Siehe Standortbestimmung GetGeoLocation(Action<IFrameworkGeoLocationInfo>, String) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. Declaration public void GetGeoLocation(Action<IFrameworkGeoLocationInfo> callback, string identifier) Parameters callback Action < IFrameworkGeoLocationInfo > Die Methode, die nach dem Vorgang aufgerufen werden soll. identifier String Dieser string wird in IFrameworkGeoLocationInfo dem Callback übergeben. Wird dieselbe Callback-Methode für verschiedene Standortbestimmungen in einem Form verwendet, dann können diese mithlife des Identifiers auseinandergehalten werden. Remarks Siehe Standortbestimmung"
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.html",
    "title": "Class GeneratedForm",
    "keywords": "Class GeneratedForm Basisklasse eines vom FrameworkStudio generierten Formulars. An dieser Klasse werden die Actions auf Form-Ebene angeboten. Inheritance Object GeneratedForm Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public abstract class GeneratedForm : IGeneratedForm, IDisposable, INotifyPropertyChanged Methods GetGeoLocation(Action<IFrameworkGeoLocationInfo>) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. GetGeoLocation(Action<IFrameworkGeoLocationInfo>, String) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. ResetClientLayout() Weist den Client an, sämtliche gespeicherten Layout-Informationen zu verwerfen. ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, String) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. Diese Überladung bietet zusätzlich einen Identifier. TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) Über diese Action wird im Mobile-Client ein das erstellen eines Fotos auf dem Endgerät eingeleitet. ViewDocument(String) Sendet eine Action an den Client zum Öffnen eines Dokuments über eine URL"
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.ResetClientLayout.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.ResetClientLayout.html",
    "title": "Method ResetClientLayout",
    "keywords": "Method ResetClientLayout ResetClientLayout() Weist den Client an, sämtliche gespeicherten Layout-Informationen zu verwerfen. Declaration public void ResetClientLayout()"
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.ScanBarcode.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.ScanBarcode.html",
    "title": "Method ScanBarcode",
    "keywords": "Method ScanBarcode ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. Declaration public void ScanBarcode(Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat) Parameters callback Action < IFrameworkBarcodeScanInfo > Die Methode, die nach dem Scan-Vorgang aufgerufen werden soll. allowedFormat BarcodeFormat Ein oder mehrere zulässige Formate. Umso qualifizierter das Format eingschränkt wird, desto geringer ist die Anfälligkeit für Fehler. Mit ALL sind alle bekannten Formate zulässig. Remarks Siehe Barcode ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, String) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. Diese Überladung bietet zusätzlich einen Identifier. Declaration public void ScanBarcode(Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat, string identifier) Parameters callback Action < IFrameworkBarcodeScanInfo > Die Methode, die nach dem Scan-Vorgang aufgerufen werden soll. allowedFormat BarcodeFormat Ein oder mehrere zulässige Formate. Umso qualifizierter das Format eingschränkt wird, desto geringer ist die Anfälligkeit für Fehler. Mit ALL sind alle bekannten Formate zulässig. identifier String Dieser string wird in IFrameworkBarcodeScanInfo dem Callback übergeben. Wird dieselbe Callback-Methode für verschiedene Scan-Aufrufe in einem Form verwendet, dann können diese mithlife des Identifiers auseinandergehalten werden. Remarks Siehe Barcode"
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto.html",
    "title": "Method TakePhoto",
    "keywords": "Method TakePhoto TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) Über diese Action wird im Mobile-Client ein das erstellen eines Fotos auf dem Endgerät eingeleitet. Declaration public void TakePhoto(Action<IFrameworkPhotoInfo> callback, CameraSource source) Parameters callback Action < IFrameworkPhotoInfo > Die Methode, die nach dem Vorgang aufgerufen werden soll. source CameraSource Bestimmt, ob ein neues Foto mit der Kamera erstellt oder ein bestehendes Foto von der Bildergalerie ausgewählt werden soll. Remarks Siehe Kamera"
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.ViewDocument.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.ViewDocument.html",
    "title": "Method ViewDocument",
    "keywords": "Method ViewDocument ViewDocument(String) Sendet eine Action an den Client zum Öffnen eines Dokuments über eine URL Declaration protected void ViewDocument(string url) Parameters url String Remarks Bei Web-Adressen sollte in jedem Fall http:// bzw. https:// vorangestellt werden, ansonsten ist bei einem Java-Client unter Windows die Länge der URL auf ca. 260 Zeichen begrenzt. Auch muss es eine korrekt formatierte URL ohne Sonderzeichen und Leerzeichen sein. Wird die URL programmatisch erstellt, dann empfiehlt es sich, die Klasse UriBuilder zu verwenden. Einzelne Argumente können auch mit UrlEncode(String) korrekt codiert werden. Erkennt der Java-Client keine gültige URL, dann wird der Aufruf an das Betriebssystem weitergeleitet. So können auch lokale Dateien geöffnet werden. Die Arbeitsweise ist dann analog zum Befehl Ausführen unter Windows (Windows-Taste + R) Mit Hilfe des Schemas fsbroker:// kann die Broker eigene URL referenziert werden. Und damit bspw. Dateien über den Broker zur Verfügung stellen. Beispielweise könnte die folgende URL fsbroker://documents/legal.pdf in http://fsbroker/HOSTNAME_DEMO_user1/FSDemoApplication/documents/legal.pdf übersetzt werden."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. Declaration public string Caption { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnSortOrder.html",
    "title": "Enum GridColumnDefinition.ColumnSortOrder",
    "keywords": "Enum GridColumnDefinition.ColumnSortOrder Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public enum ColumnSortOrder Fields Name Description Ascending Descending Unsorted"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnTextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnTextAlign.html",
    "title": "Enum GridColumnDefinition.ColumnTextAlign",
    "keywords": "Enum GridColumnDefinition.ColumnTextAlign Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public enum ColumnTextAlign Fields Name Description Center Left Right"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ComponentType.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ComponentType.html",
    "title": "Property ComponentType",
    "keywords": "Property ComponentType ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. Declaration public Type ComponentType { get; set; } Property Value Type"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.-ctor.html",
    "title": "Constructor GridColumnDefinition",
    "keywords": "Constructor GridColumnDefinition GridColumnDefinition() Declaration public GridColumnDefinition()"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.DependsDataSourceOnRowData.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.DependsDataSourceOnRowData.html",
    "title": "Property DependsDataSourceOnRowData",
    "keywords": "Property DependsDataSourceOnRowData DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. Declaration public bool? DependsDataSourceOnRowData { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditorStyle.html",
    "title": "Property EditorStyle",
    "keywords": "Property EditorStyle EditorStyle Gibt den zu verwendenden Darstellungstyp ( Editfield , CheckBox , ...) zurück oder legt diesen fest. Declaration public EditorStyle? EditorStyle { get; set; } Property Value Nullable < EditorStyle >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle EditStyle Gibt den zu verwendenden Combobox-Typ ( FreeTextInput , ListValuesInput ) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. Declaration public ComboEditStyle? EditStyle { get; set; } Property Value Nullable < ComboEditStyle >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Format.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public FrameworkFormatMask? Format { get; set; } Property Value Nullable < FrameworkFormatMask >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public string FormatPattern { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.html",
    "title": "Class GridColumnDefinition",
    "keywords": "Class GridColumnDefinition Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. Inheritance Object GridColumnDefinition Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class GridColumnDefinition Constructors GridColumnDefinition() Properties Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. EditorStyle Gibt den zu verwendenden Darstellungstyp ( Editfield , CheckBox , ...) zurück oder legt diesen fest. EditStyle Gibt den zu verwendenden Combobox-Typ ( FreeTextInput , ListValuesInput ) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. Width Gibt die initiale Spaltenbreite zurück oder legt diese fest."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. Declaration public bool? IsEditable { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsVisible.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsVisible.html",
    "title": "Property IsVisible",
    "keywords": "Property IsVisible IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. Declaration public bool? IsVisible { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.List.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.List.html",
    "title": "Property List",
    "keywords": "Property List List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. Declaration public ColumnListDataSource List { get; set; } Property Value ColumnListDataSource"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ListSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ListSortOrder.html",
    "title": "Property ListSortOrder",
    "keywords": "Property ListSortOrder ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. Declaration public GridColumnDefinition.ColumnSortOrder ListSortOrder { get; set; } Property Value GridColumnDefinition.ColumnSortOrder"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxScale.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxScale.html",
    "title": "Property MaxScale",
    "keywords": "Property MaxScale MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public int? MaxScale { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public int? MaxSize { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. Declaration public DevMLString MLCaption { get; set; } Property Value DevMLString"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLToolTip.html",
    "title": "Property MLToolTip",
    "keywords": "Property MLToolTip MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. Declaration public DevMLString MLToolTip { get; set; } Property Value DevMLString"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Property.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Property.html",
    "title": "Property Property",
    "keywords": "Property Property Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Declaration public string Property { get; set; } Property Value String Examples Werden im Grid Elemente vom Typ cDynObj angezeigt, so bedeutet Property=\"oDevObj.sName\" , dass die Spalte Daten des Propertys sName des Unterobjekts oDevObj an cDynObj darstellt."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.PropertyMdt.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.PropertyMdt.html",
    "title": "Property PropertyMdt",
    "keywords": "Property PropertyMdt PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. Declaration public MLContainer PropertyMdt { get; set; } Property Value MLContainer Remarks Wenn die Eigenschaft ComponentType nicht gesetzt werden muss, muss diese Eigenschaft ebenfalls nicht gesetzt werden. Die Werte können dann automatisch über Reflection ermittelt werden."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. Declaration public GridColumnDefinition.ColumnTextAlign? TextAlign { get; set; } Property Value Nullable < GridColumnDefinition.ColumnTextAlign >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ToolTip.html",
    "title": "Property ToolTip",
    "keywords": "Property ToolTip ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. Declaration public string ToolTip { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Width.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Width.html",
    "title": "Property Width",
    "keywords": "Property Width Width Gibt die initiale Spaltenbreite zurück oder legt diese fest. Declaration public int? Width { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.html": {
    "href": "api/FrameworkSystems.FrameworkControls.html",
    "title": "Namespace FrameworkSystems.FrameworkControls",
    "keywords": "Namespace FrameworkSystems.FrameworkControls Classes ColumnListDataSource Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid ( List ). GeneratedForm Basisklasse eines vom FrameworkStudio generierten Formulars. An dieser Klasse werden die Actions auf Form-Ebene angeboten. GridColumnDefinition Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. Enums GridColumnDefinition.ColumnSortOrder GridColumnDefinition.ColumnTextAlign"
  },
  "api/FrameworkSystems.FrameworkDataClient.FrameworkDataCommand.CommandTimeout.html": {
    "href": "api/FrameworkSystems.FrameworkDataClient.FrameworkDataCommand.CommandTimeout.html",
    "title": "Property CommandTimeout",
    "keywords": "Property CommandTimeout CommandTimeout Timeout für das Command in Sekunden. Der Standard-Wert ist 300 Sekunden. Wird der Wert 0 angegeben, gibt es keinen Timeout. Declaration public int CommandTimeout { get; set; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkDataClient.FrameworkDataCommand.html": {
    "href": "api/FrameworkSystems.FrameworkDataClient.FrameworkDataCommand.html",
    "title": "Class FrameworkDataCommand",
    "keywords": "Class FrameworkDataCommand Klasse steht für SQL-Statements bzw. Stored Procedures die an einer FrameworkSystems.FrameworkDataClient.FrameworkDataConnection ausgeführt werden. Inheritance Object FrameworkDataCommand Namespace : FrameworkSystems.FrameworkDataClient Assembly : FrameworkSystems.FrameworkDataProvider.dll Syntax public class FrameworkDataCommand : IDbCommand, IDisposable Properties CommandTimeout Timeout für das Command in Sekunden. Der Standard-Wert ist 300 Sekunden. Wird der Wert 0 angegeben, gibt es keinen Timeout."
  },
  "api/FrameworkSystems.FrameworkDataClient.FrameworkDataConnectionStringBuilder.ConnectionStringDecoded.html": {
    "href": "api/FrameworkSystems.FrameworkDataClient.FrameworkDataConnectionStringBuilder.ConnectionStringDecoded.html",
    "title": "Property ConnectionStringDecoded",
    "keywords": "Property ConnectionStringDecoded ConnectionStringDecoded Gibt den Connection-String mit decodiertem Passwort zurück. Declaration public string ConnectionStringDecoded { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkDataClient.FrameworkDataConnectionStringBuilder.html": {
    "href": "api/FrameworkSystems.FrameworkDataClient.FrameworkDataConnectionStringBuilder.html",
    "title": "Class FrameworkDataConnectionStringBuilder",
    "keywords": "Class FrameworkDataConnectionStringBuilder Diese Klasse erzeugt einen String zur Instanziierung von FrameworkDataConnections. Über die Eigenschaft ProviderConnectionString kann ein Connection String abgefragt werden, mit dem die direkte Instanziierung der zu Grunde liegenden Provider Connection (z.B. SQLConnection) instanziiert werden kann. Mit der Eigenschaft FSProviderType wird der DBProvider (SQL Server, Oracle, ...) festgelegt. Der Connection String Builder schleift grundsätzlich unbekannte Schlüsselwerte durch. Im ProviderConnectionString werden aber nur Schlüsselworte erlaubt, die vom Provider gekannt werden (siehe InitProviderKeywords). Schlüsselwerte werden Case-Insensitiv ausgewertet. Inheritance Object DbConnectionStringBuilder FrameworkDataConnectionStringBuilder Namespace : FrameworkSystems.FrameworkDataClient Assembly : FrameworkSystems.FrameworkDataProvider.dll Syntax public class FrameworkDataConnectionStringBuilder : DbConnectionStringBuilder, IDictionary, ICollection, IEnumerable, ICustomTypeDescriptor Properties ConnectionStringDecoded Gibt den Connection-String mit decodiertem Passwort zurück."
  },
  "api/FrameworkSystems.FrameworkDataClient.html": {
    "href": "api/FrameworkSystems.FrameworkDataClient.html",
    "title": "Namespace FrameworkSystems.FrameworkDataClient",
    "keywords": "Namespace FrameworkSystems.FrameworkDataClient Classes FrameworkDataCommand Klasse steht für SQL-Statements bzw. Stored Procedures die an einer FrameworkSystems.FrameworkDataClient.FrameworkDataConnection ausgeführt werden. FrameworkDataConnectionStringBuilder Diese Klasse erzeugt einen String zur Instanziierung von FrameworkDataConnections. Über die Eigenschaft ProviderConnectionString kann ein Connection String abgefragt werden, mit dem die direkte Instanziierung der zu Grunde liegenden Provider Connection (z.B. SQLConnection) instanziiert werden kann. Mit der Eigenschaft FSProviderType wird der DBProvider (SQL Server, Oracle, ...) festgelegt. Der Connection String Builder schleift grundsätzlich unbekannte Schlüsselwerte durch. Im ProviderConnectionString werden aber nur Schlüsselworte erlaubt, die vom Provider gekannt werden (siehe InitProviderKeywords). Schlüsselwerte werden Case-Insensitiv ausgewertet."
  },
  "api/FrameworkSystems.FrameworkDataProvider.BaseObjects.guid.html": {
    "href": "api/FrameworkSystems.FrameworkDataProvider.BaseObjects.guid.html",
    "title": "Class guid",
    "keywords": "Class guid GUID als ID für ein BaseObject. Entspricht der .NET-Guid-Klasse, mit dem Unterschied, daß die GUID nicht auf 16 Byte beschränkt ist. Inheritance Object guid Namespace : FrameworkSystems.FrameworkDataProvider.BaseObjects Assembly : FrameworkSystems.FrameworkDataProvider.dll Syntax [Serializable] [TypeConverter(typeof(guidConverter))] public sealed class guid : IComparable, Iguid, IIndexEntryID"
  },
  "api/FrameworkSystems.FrameworkDataProvider.BaseObjects.html": {
    "href": "api/FrameworkSystems.FrameworkDataProvider.BaseObjects.html",
    "title": "Namespace FrameworkSystems.FrameworkDataProvider.BaseObjects",
    "keywords": "Namespace FrameworkSystems.FrameworkDataProvider.BaseObjects Classes guid GUID als ID für ein BaseObject. Entspricht der .NET-Guid-Klasse, mit dem Unterschied, daß die GUID nicht auf 16 Byte beschränkt ist."
  },
  "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.Chunk.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.Chunk.html",
    "title": "Method Chunk",
    "keywords": "Method Chunk Chunk<T>(IEnumerable<T>, Int32) Zerschneidet eine Enumeration in Portionen der übergebenen Größe. Declaration public static IEnumerable<IEnumerable<T>> Chunk<T>(this IEnumerable<T> source, int chunkSize) Parameters source IEnumerable <T> chunkSize Int32 Größe der Portionen Returns IEnumerable < IEnumerable <T>> Type Parameters Name Description T"
  },
  "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.DistinctBy.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.DistinctBy.html",
    "title": "Method DistinctBy",
    "keywords": "Method DistinctBy DistinctBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>) Gibt bezüglich der per keySelector ermittelten Schlüsselwerte unterschiedliche Elemente zurück. Zu gleichen Schlüsselwerten wird jeweils das erste Element zurückgegeben. Die Reihenfolge der Elemente bleibt erhalten. Declaration public static IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) Parameters source IEnumerable <TSource> keySelector Func <TSource, TKey> Returns IEnumerable <TSource> Type Parameters Name Description TSource TKey"
  },
  "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.html",
    "title": "Class EnumarableExtensions",
    "keywords": "Class EnumarableExtensions Inheritance Object EnumarableExtensions Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax public static class EnumarableExtensions Methods Chunk<T>(IEnumerable<T>, Int32) Zerschneidet eine Enumeration in Portionen der übergebenen Größe. DistinctBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>) Gibt bezüglich der per keySelector ermittelten Schlüsselwerte unterschiedliche Elemente zurück. Zu gleichen Schlüsselwerten wird jeweils das erste Element zurückgegeben. Die Reihenfolge der Elemente bleibt erhalten. OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, Boolean) Sortiert die Elemente der Enumeration nach der in sample übergebenen Reihenfolge. OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>, Boolean) Sortiert die Elemente der Enumeration nach der in sample übergebenen Reihenfolge. OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, Boolean) Sortiert die Elemente der Enumeration. Dabei wird das mit keySelector definierte Sortierkriterium nach der in sample übergebenen Reihenfolge sortiert. OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, IEqualityComparer<TKey>, Boolean) Sortiert die Elemente der Enumeration. Dabei wird das mit keySelector definierte Sortierkriterium nach der in sample übergebenen Reihenfolge sortiert. ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>) Erzeugt ein Dictionary. Bei doppelten Keys wird jeweils nur der erste Eintrag hinzugefügt. ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>, IEqualityComparer<TKey>) Erzeugt ein Dictionary. Bei doppelten Keys wird jeweils nur der erste Eintrag hinzugefügt."
  },
  "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.OrderBySample.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.OrderBySample.html",
    "title": "Method OrderBySample",
    "keywords": "Method OrderBySample OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, Boolean) Sortiert die Elemente der Enumeration nach der in sample übergebenen Reihenfolge. Declaration public static IOrderedEnumerable<TSource> OrderBySample<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> sample, bool unkownLast = true) Parameters source IEnumerable <TSource> sample IEnumerable <TSource> Definiert die Reihenfolge der Elemente unkownLast Boolean true , wenn Elemente, die in sample nicht definiert sind am Ende stehen sollen. Mit false stehen sie am Anfang. Returns IOrderedEnumerable <TSource> Type Parameters Name Description TSource Exceptions Type Condition ArgumentNullException Wenn der Parameter source null ist. OrderBySample<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>, Boolean) Sortiert die Elemente der Enumeration nach der in sample übergebenen Reihenfolge. Declaration public static IOrderedEnumerable<TSource> OrderBySample<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> sample, IEqualityComparer<TSource> comparer, bool unkownLast = true) Parameters source IEnumerable <TSource> sample IEnumerable <TSource> Definiert die Reihenfolge der Elemente comparer IEqualityComparer <TSource> Die Elmente werden mit diesem Comparer verglichen. unkownLast Boolean true , wenn Elemente, die in sample nicht definiert sind am Ende stehen sollen. Mit false stehen sie am Anfang. Returns IOrderedEnumerable <TSource> Type Parameters Name Description TSource Exceptions Type Condition ArgumentNullException Wenn der Parameter source null ist. OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, Boolean) Sortiert die Elemente der Enumeration. Dabei wird das mit keySelector definierte Sortierkriterium nach der in sample übergebenen Reihenfolge sortiert. Declaration public static IOrderedEnumerable<TSource> OrderBySample<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEnumerable<TKey> sample, bool unkownLast = true) Parameters source IEnumerable <TSource> keySelector Func <TSource, TKey> sample IEnumerable <TKey> Definiert die Reihenfolge der Elemente unkownLast Boolean true , wenn Keys, die in sample nicht definiert sind am Ende stehen sollen. Mit false stehen sie am Anfang. Returns IOrderedEnumerable <TSource> Type Parameters Name Description TSource TKey Exceptions Type Condition ArgumentNullException Wenn der Parameter source oder keySelector null ist. OrderBySample<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEnumerable<TKey>, IEqualityComparer<TKey>, Boolean) Sortiert die Elemente der Enumeration. Dabei wird das mit keySelector definierte Sortierkriterium nach der in sample übergebenen Reihenfolge sortiert. Declaration public static IOrderedEnumerable<TSource> OrderBySample<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEnumerable<TKey> sample, IEqualityComparer<TKey> comparer, bool unkownLast = true) Parameters source IEnumerable <TSource> keySelector Func <TSource, TKey> sample IEnumerable <TKey> Definiert die Reihenfolge der Elemente comparer IEqualityComparer <TKey> Die Sortierkriterien werden mit diesem Comparer verglichen. unkownLast Boolean true , wenn Keys, die in sample nicht definiert sind am Ende stehen sollen. Mit false stehen sie am Anfang. Returns IOrderedEnumerable <TSource> Type Parameters Name Description TSource TKey Exceptions Type Condition ArgumentNullException Wenn der Parameter source oder keySelector null ist."
  },
  "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.ToDictionaryChecked.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.EnumarableExtensions.ToDictionaryChecked.html",
    "title": "Method ToDictionaryChecked",
    "keywords": "Method ToDictionaryChecked ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>, IEqualityComparer<TKey>) Erzeugt ein Dictionary. Bei doppelten Keys wird jeweils nur der erste Eintrag hinzugefügt. Declaration public static Dictionary<TKey, TElement> ToDictionaryChecked<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer) Parameters source IEnumerable <TSource> keySelector Func <TSource, TKey> elementSelector Func <TSource, TElement> comparer IEqualityComparer <TKey> Returns Dictionary <TKey, TElement> Type Parameters Name Description TSource TKey TElement ToDictionaryChecked<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>) Erzeugt ein Dictionary. Bei doppelten Keys wird jeweils nur der erste Eintrag hinzugefügt. Declaration public static Dictionary<TKey, TElement> ToDictionaryChecked<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector) Parameters source IEnumerable <TSource> keySelector Func <TSource, TKey> elementSelector Func <TSource, TElement> Returns Dictionary <TKey, TElement> Type Parameters Name Description TSource TKey TElement"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.-ctor.html",
    "title": "Constructor FrameworkApplicationException",
    "keywords": "Constructor FrameworkApplicationException FrameworkApplicationException(String) Declaration public FrameworkApplicationException(string msg) Parameters msg String FrameworkApplicationException(String, Int32) Declaration public FrameworkApplicationException(string msg, int severity) Parameters msg String severity Int32 FrameworkApplicationException(String, Exception) Declaration public FrameworkApplicationException(string msg, Exception innerEx) Parameters msg String innerEx Exception FrameworkApplicationException(String, Int32, Exception) Declaration public FrameworkApplicationException(string msg, int severity, Exception innerEx) Parameters msg String severity Int32 innerEx Exception FrameworkApplicationException(MLKeyText) Declaration public FrameworkApplicationException(MLKeyText mlkeyText) Parameters mlkeyText MLKeyText FrameworkApplicationException(MLKeyText, Int32) Declaration public FrameworkApplicationException(MLKeyText mlkeyText, int severity) Parameters mlkeyText MLKeyText severity Int32 FrameworkApplicationException(MLKeyText, Exception) Declaration public FrameworkApplicationException(MLKeyText mlkeyText, Exception innerEx) Parameters mlkeyText MLKeyText innerEx Exception FrameworkApplicationException(MLKeyText, Int32, Exception) Declaration public FrameworkApplicationException(MLKeyText mlkeyText, int severity, Exception innerEx) Parameters mlkeyText MLKeyText severity Int32 innerEx Exception"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.html",
    "title": "Class FrameworkApplicationException",
    "keywords": "Class FrameworkApplicationException Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. Inheritance Object Exception ApplicationException FrameworkApplicationException Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Serializable] public class FrameworkApplicationException : ApplicationException, ISerializable, _Exception Constructors FrameworkApplicationException(MLKeyText) FrameworkApplicationException(MLKeyText, Exception) FrameworkApplicationException(MLKeyText, Int32) FrameworkApplicationException(MLKeyText, Int32, Exception) FrameworkApplicationException(String) FrameworkApplicationException(String, Exception) FrameworkApplicationException(String, Int32) FrameworkApplicationException(String, Int32, Exception) Properties MLKey Der mit dem MLKeyText übergebene MLKey. Severity Definiert den Schweregrad der Exception."
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.MLKey.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.MLKey.html",
    "title": "Property MLKey",
    "keywords": "Property MLKey MLKey Der mit dem MLKeyText übergebene MLKey. Declaration public MLKey MLKey { get; } Property Value MLKey"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.Severity.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.Severity.html",
    "title": "Property Severity",
    "keywords": "Property Severity Severity Definiert den Schweregrad der Exception. Declaration public int Severity { get; } Property Value Int32 Remarks Diese Information wird momentan nicht ausgewertet."
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkCloseMode.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkCloseMode.html",
    "title": "Enum FrameworkCloseMode",
    "keywords": "Enum FrameworkCloseMode Definiert den Modus mit dem die Application beendet werden soll. Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Flags] public enum FrameworkCloseMode Fields Name Description Close KeepUserLogin Restart"
  },
  "api/FrameworkSystems.FrameworkExceptions.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.html",
    "title": "Namespace FrameworkSystems.FrameworkExceptions",
    "keywords": "Namespace FrameworkSystems.FrameworkExceptions Classes EnumarableExtensions FrameworkApplicationException Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. PropertyNotFoundException Diese Exception wir geworfen, wenn bei einem Property-Zugriff über die Methode IDevFrameworkBaseObject.GetProperty() der Property-Name nicht gefunden wurde. RowVersionInvalidException Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen. Enums FrameworkCloseMode Definiert den Modus mit dem die Application beendet werden soll."
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.html",
    "title": "Namespace FrameworkSystems.FrameworkExceptions.MultiLanguage",
    "keywords": "Namespace FrameworkSystems.FrameworkExceptions.MultiLanguage Classes MLKey Diese Klasse verpackt einen MLKey. Der MLKey besteht aus einem String-Wert. MLKeyText Diese Klasse verpackt einen MLKey und den lokalisierten Text. So ist es möglich mit dem Text auch den MLKey zu transportieren. In der FrameworkApplicationException kann so der MLKey als \"Fehlercode\" verwendet werden."
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.-ctor.html",
    "title": "Constructor MLKey",
    "keywords": "Constructor MLKey MLKey(String) Declaration public MLKey(string value) Parameters value String"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.html",
    "title": "Class MLKey",
    "keywords": "Class MLKey Diese Klasse verpackt einen MLKey. Der MLKey besteht aus einem String-Wert. Inheritance Object MLKey Namespace : FrameworkSystems.FrameworkExceptions.MultiLanguage Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax public class MLKey Remarks Warning Bitte einen existierenden MLKey immer über MLKeys... verwenden. Diese Klasse sollte im eigenen Code nicht instanziiert werden. Alle im Wörterbuch enthaltenen MLKeys werden mit den Ressources in eine Klasse MLKeys genriert. über diese kann man im eigenen Code unterstützt durch Intellisense auf jedem MLKey zugreifen. FSstring sArticle = this.Global.GetMLText(MLKeys.LBL_Article); Constructors MLKey(String) Methods ToString() Liefert den String-Wert des MLKeys."
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.ToString.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.ToString.html",
    "title": "Method ToString",
    "keywords": "Method ToString ToString() Liefert den String-Wert des MLKeys. Declaration public override string ToString() Returns String Overrides Object.ToString()"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.-ctor.html",
    "title": "Constructor MLKeyText",
    "keywords": "Constructor MLKeyText MLKeyText(MLKey, String) Declaration public MLKeyText(MLKey mLKey, string text) Parameters mLKey MLKey text String"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.html",
    "title": "Class MLKeyText",
    "keywords": "Class MLKeyText Diese Klasse verpackt einen MLKey und den lokalisierten Text. So ist es möglich mit dem Text auch den MLKey zu transportieren. In der FrameworkApplicationException kann so der MLKey als \"Fehlercode\" verwendet werden. Inheritance Object MLKeyText Namespace : FrameworkSystems.FrameworkExceptions.MultiLanguage Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax public class MLKeyText Remarks Das GlobalObject bietet Methoden, um Texte in Form dieser Klasse zu erhalten: GetMLKeyText(MLKey) FormatMLKeyText(MLKey, Object[]) Constructors MLKeyText(MLKey, String) Properties Key Text"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.Key.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.Key.html",
    "title": "Property Key",
    "keywords": "Property Key Key Declaration public MLKey Key { get; } Property Value MLKey"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.Text.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Declaration public string Text { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkExceptions.PropertyNotFoundException.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.PropertyNotFoundException.-ctor.html",
    "title": "Constructor PropertyNotFoundException",
    "keywords": "Constructor PropertyNotFoundException PropertyNotFoundException(String) Exception wird ausgelöst, wenn ein Property angefordert wird, welches nicht existiert, z.B. über die Methode IDevFrameworkBaseObject.GetProperty(). Declaration public PropertyNotFoundException(string info) Parameters info String PropertyNotFoundException(String, Exception) Declaration public PropertyNotFoundException(string info, Exception ex) Parameters info String ex Exception"
  },
  "api/FrameworkSystems.FrameworkExceptions.PropertyNotFoundException.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.PropertyNotFoundException.html",
    "title": "Class PropertyNotFoundException",
    "keywords": "Class PropertyNotFoundException Diese Exception wir geworfen, wenn bei einem Property-Zugriff über die Methode IDevFrameworkBaseObject.GetProperty() der Property-Name nicht gefunden wurde. Inheritance Object Exception FrameworkSystems.FrameworkExceptions.FrameworkException PropertyNotFoundException Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Serializable] public class PropertyNotFoundException : FrameworkException, ISerializable, _Exception Constructors PropertyNotFoundException(String) Exception wird ausgelöst, wenn ein Property angefordert wird, welches nicht existiert, z.B. über die Methode IDevFrameworkBaseObject.GetProperty(). PropertyNotFoundException(String, Exception)"
  },
  "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.-ctor.html",
    "title": "Constructor RowVersionInvalidException",
    "keywords": "Constructor RowVersionInvalidException RowVersionInvalidException(String) Declaration public RowVersionInvalidException(string caption) Parameters caption String RowVersionInvalidException(String, Exception) Declaration public RowVersionInvalidException(string caption, Exception ex) Parameters caption String ex Exception"
  },
  "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.html",
    "title": "Class RowVersionInvalidException",
    "keywords": "Class RowVersionInvalidException Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen. Inheritance Object Exception FrameworkSystems.FrameworkExceptions.FrameworkException RowVersionInvalidException Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Serializable] public class RowVersionInvalidException : FrameworkException, ISerializable, _Exception Constructors RowVersionInvalidException(String) RowVersionInvalidException(String, Exception)"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.ComboEditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.ComboEditStyle.html",
    "title": "Enum ComboEditStyle",
    "keywords": "Enum ComboEditStyle TODO! Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.Data Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public enum ComboEditStyle Fields Name Description FreeTextInput ListValuesInput"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data Enums ComboEditStyle TODO! SearchCompareOperator"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.SearchCompareOperator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.SearchCompareOperator.html",
    "title": "Enum SearchCompareOperator",
    "keywords": "Enum SearchCompareOperator Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.Data Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public enum SearchCompareOperator Fields Name Description Equal A comparison for equality GreaterThan A comparison for greater than. GreaterThanEqual A comparison for greater than or equal to. LessThan A comparison for less than. LessThanEqual A comparison for less than or equal to. Like NotEqual"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings Classes ListDataSource Summary description for DataBinding."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ContainsNullEntry.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ContainsNullEntry.html",
    "title": "Property ContainsNullEntry",
    "keywords": "Property ContainsNullEntry ContainsNullEntry Gibt an, ob die Liste einen leeren Eintrag beinhalten soll.Bei True wird die Liste um einen leeren Eintrag ergänzt.Dieser Eintrag wird ausgewählt, wenn der Wert der Combobox auf kein Value aus der Liste zutrifft. Wird dieser Eintrag vom Benutzer ausgewählt, wird dem dahinterliegenden Property Null zugewiesen. Declaration [Browsable(true)] public bool? ContainsNullEntry { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.DisplayMember.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.DisplayMember.html",
    "title": "Property DisplayMember",
    "keywords": "Property DisplayMember DisplayMember Gibt an, welches Property des Datasources in der Liste angezeigt werden soll. Bei einer Textcollection ist das in der Regel Text . Declaration [Browsable(true)] [TypeConverter(typeof(ListDataSource.CollectionConverter))] public virtual IPropertyRecord DisplayMember { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IPropertyRecord"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.html",
    "title": "Class ListDataSource",
    "keywords": "Class ListDataSource Summary description for DataBinding. Inheritance Object ListDataSource Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax [Serializable] [TypeConverter(typeof(ExpandableObjectConverter))] public class ListDataSource : INVFrameworkList, ICloneable, ICustomTypeDescriptor Properties ContainsNullEntry Gibt an, ob die Liste einen leeren Eintrag beinhalten soll.Bei True wird die Liste um einen leeren Eintrag ergänzt.Dieser Eintrag wird ausgewählt, wenn der Wert der Combobox auf kein Value aus der Liste zutrifft. Wird dieser Eintrag vom Benutzer ausgewählt, wird dem dahinterliegenden Property Null zugewiesen. DisplayMember Gibt an, welches Property des Datasources in der Liste angezeigt werden soll. Bei einer Textcollection ist das in der Regel Text . ValueMember Gibt an, welches Property des Datasources den Wert eines Eintrags darstellt. Es ist immer der Eintrag ausgewählt, dessen Value gleich dem Wert der Combobox ist. Bei einer Textcollection ist das in der Regel ID ."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ValueMember.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ValueMember.html",
    "title": "Property ValueMember",
    "keywords": "Property ValueMember ValueMember Gibt an, welches Property des Datasources den Wert eines Eintrags darstellt. Es ist immer der Eintrag ausgewählt, dessen Value gleich dem Wert der Combobox ist. Bei einer Textcollection ist das in der Regel ID . Declaration [Browsable(true)] [TypeConverter(typeof(ListDataSource.CollectionConverter))] public IPropertyRecord ValueMember { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IPropertyRecord"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkButtonClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkButtonClickEventArgs.html",
    "title": "Class FrameworkButtonClickEventArgs",
    "keywords": "Class FrameworkButtonClickEventArgs Inheritance Object EventArgs FrameworkEventArgs FrameworkButtonClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkButtonClickEventArgs : FrameworkEventArgs"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.ColNum.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.ColNum.html",
    "title": "Property ColNum",
    "keywords": "Property ColNum ColNum !TODO Declaration public int ColNum { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.ColumnName.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.ColumnName.html",
    "title": "Property ColumnName",
    "keywords": "Property ColumnName ColumnName !TODO Declaration public string ColumnName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.html",
    "title": "Class FrameworkCellDoubleClickEventArgs",
    "keywords": "Class FrameworkCellDoubleClickEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnCellDoubleClickDefinition verknüpfte FormMethod kann somit auf das Property RowID zugreifen des Parameters der Methode zugreifen. Inheritance Object EventArgs FrameworkEventArgs FrameworkDoubleClickEventArgs FrameworkCellDoubleClickEventArgs FrameworkColumnChangedEventArgs Inherited Members FrameworkDoubleClickEventArgs.RowID FrameworkDoubleClickEventArgs.RowIndex Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkCellDoubleClickEventArgs : FrameworkDoubleClickEventArgs Examples private void MyDataGrid_DoubleClickEventHandler (FrameworkDoubleClickEventArgs e) { ArtikelObj = ArtikelColl[e.RowID]; } Properties ColNum !TODO ColumnName !TODO"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCheckBoxClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCheckBoxClickEventArgs.html",
    "title": "Class FrameworkCheckBoxClickEventArgs",
    "keywords": "Class FrameworkCheckBoxClickEventArgs Inheritance Object EventArgs FrameworkEventArgs FrameworkCheckBoxClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkCheckBoxClickEventArgs : FrameworkEventArgs Properties IsChecked"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCheckBoxClickEventArgs.IsChecked.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCheckBoxClickEventArgs.IsChecked.html",
    "title": "Property IsChecked",
    "keywords": "Property IsChecked IsChecked Declaration public bool IsChecked { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkColumnChangedEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkColumnChangedEventArgs.html",
    "title": "Class FrameworkColumnChangedEventArgs",
    "keywords": "Class FrameworkColumnChangedEventArgs !TODO Inheritance Object EventArgs FrameworkEventArgs FrameworkDoubleClickEventArgs FrameworkCellDoubleClickEventArgs FrameworkColumnChangedEventArgs Inherited Members FrameworkCellDoubleClickEventArgs.ColNum FrameworkCellDoubleClickEventArgs.ColumnName FrameworkDoubleClickEventArgs.RowID FrameworkDoubleClickEventArgs.RowIndex Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkColumnChangedEventArgs : FrameworkCellDoubleClickEventArgs"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.html",
    "title": "Class FrameworkDoubleClickEventArgs",
    "keywords": "Class FrameworkDoubleClickEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnRowDoubleClickDefinition verknüpfte FormMethod kann somit auf das Property RowID des Parameters der Methode zugreifen. Inheritance Object EventArgs FrameworkEventArgs FrameworkDoubleClickEventArgs FrameworkCellDoubleClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkDoubleClickEventArgs : FrameworkEventArgs Examples private void MyDataGrid_DoubleClickEventHandler (FrameworkDoubleClickEventArgs e) { ArtikelObj = ArtikelColl[e.RowID]; } Properties RowID GUID der Zeile, auf der ein Doppelklick erfolgt ist. RowIndex Zero-Based index of the row -1 if not valid."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.RowID.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.RowID.html",
    "title": "Property RowID",
    "keywords": "Property RowID RowID GUID der Zeile, auf der ein Doppelklick erfolgt ist. Declaration public guid RowID { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.RowIndex.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.RowIndex.html",
    "title": "Property RowIndex",
    "keywords": "Property RowIndex RowIndex Zero-Based index of the row -1 if not valid. Declaration public int RowIndex { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkEventArgs.html",
    "title": "Class FrameworkEventArgs",
    "keywords": "Class FrameworkEventArgs Alle FormMethod-EventHandler haben als (einziger) Parameter ein Objekt vom Typ FrameworkEventArgs (oder einer Ableitung). FrameworkEventArgs stellt selbst noch keine besondere Funktionalität bereit, dies kann aber von Ableitungen gemacht werden. So ist es möglich, dem EventHandler weitere Informationen zu übergeben. Siehe hierzu FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnRowDoubleClickDefinition . Inheritance Object EventArgs FrameworkEventArgs FrameworkButtonClickEventArgs FrameworkCheckBoxClickEventArgs FrameworkDoubleClickEventArgs FrameworkOnItemActivatedEventArgs FrameworkOnLeaveEventArgs FrameworkOnLinkClickEventArgs FrameworkOnReloadEventArgs FrameworkSelectionChangedEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkEventArgs : EventArgs"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.FadingEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.FadingEnabled.html",
    "title": "Property FadingEnabled",
    "keywords": "Property FadingEnabled FadingEnabled Genau dann true, wenn Steuerelemente, auf denen kein Drop möglich ist übermalt werden sollen. Declaration public bool FadingEnabled { get; set; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.html",
    "title": "Class FrameworkOnDragEventArgs",
    "keywords": "Class FrameworkOnDragEventArgs Spezialisierung von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCancelEventEventArgs . Inheritance Object EventArgs FrameworkEventArgs FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCancelEventEventArgs FrameworkOnDragEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnDragEventArgs : FrameworkCancelEventEventArgs Properties FadingEnabled Genau dann true, wenn Steuerelemente, auf denen kein Drop möglich ist übermalt werden sollen. Icon Der Pfad zu dem Icon, welches neben dem Mauszeiger erscheinen soll. SourceControl Gibt den ActionWrapper des Quell-Steuerelements zurück. SourceControlName Gibt den Namen des Quell-Steuerelements zurück. SourceLink Link, falls es sich bei dem Quell-Steuerelement um ein HTML-Formular handelt. SourceNode Gibt das Quell-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeNode in einem TreeView handelt. SourceNodeInfo Quell-Knotenpfad. SourceNodePath Gibt den Quell-Knotenpfad als Array von DevFrameworkObjects zurück. SourceRowID RowID, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. SourceRowIndex Zeilenindex, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. TransferObject Das hier zugewiesene objekt wird in die Drop-Aktion weitergereicht und kann dort mit FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDropEventArgs.TransferObject abgeholt werden."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.Icon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.Icon.html",
    "title": "Property Icon",
    "keywords": "Property Icon Icon Der Pfad zu dem Icon, welches neben dem Mauszeiger erscheinen soll. Declaration public string Icon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceControl.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceControl.html",
    "title": "Property SourceControl",
    "keywords": "Property SourceControl SourceControl Gibt den ActionWrapper des Quell-Steuerelements zurück. Declaration public IFrameworkControlActionBase SourceControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceControlName.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceControlName.html",
    "title": "Property SourceControlName",
    "keywords": "Property SourceControlName SourceControlName Gibt den Namen des Quell-Steuerelements zurück. Declaration public string SourceControlName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceLink.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceLink.html",
    "title": "Property SourceLink",
    "keywords": "Property SourceLink SourceLink Link, falls es sich bei dem Quell-Steuerelement um ein HTML-Formular handelt. Declaration public UrlLink SourceLink { get; } Property Value FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.UrlLink"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceNode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceNode.html",
    "title": "Property SourceNode",
    "keywords": "Property SourceNode SourceNode Gibt das Quell-Knotenobjekt zurück, falls es sich bei dem SourceControl um einen TreeNode in einem TreeView handelt. Declaration public DevFrameworkObject SourceNode { get; } Property Value DevFrameworkObject"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceNodeInfo.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceNodeInfo.html",
    "title": "Property SourceNodeInfo",
    "keywords": "Property SourceNodeInfo SourceNodeInfo Quell-Knotenpfad. Declaration public string SourceNodeInfo { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceNodePath.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceNodePath.html",
    "title": "Property SourceNodePath",
    "keywords": "Property SourceNodePath SourceNodePath Gibt den Quell-Knotenpfad als Array von DevFrameworkObjects zurück. Declaration public DevFrameworkObject[] SourceNodePath { get; } Property Value DevFrameworkObject []"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceRowID.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceRowID.html",
    "title": "Property SourceRowID",
    "keywords": "Property SourceRowID SourceRowID RowID, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. Declaration public guid SourceRowID { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceRowIndex.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.SourceRowIndex.html",
    "title": "Property SourceRowIndex",
    "keywords": "Property SourceRowIndex SourceRowIndex Zeilenindex, falls es sich bei dem Quell-Steuerelement um ein Grid handelt. Declaration public int SourceRowIndex { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.TransferObject.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs.TransferObject.html",
    "title": "Property TransferObject",
    "keywords": "Property TransferObject TransferObject Das hier zugewiesene objekt wird in die Drop-Aktion weitergereicht und kann dort mit FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDropEventArgs.TransferObject abgeholt werden. Declaration public object TransferObject { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.html",
    "title": "Class FrameworkOnItemActivatedEventArgs",
    "keywords": "Class FrameworkOnItemActivatedEventArgs Inheritance Object EventArgs FrameworkEventArgs FrameworkOnItemActivatedEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnItemActivatedEventArgs : FrameworkEventArgs Properties ItemId Die ID des aktivierten Objekts in der zu Grunde liegenden Collection. ItemIndex Der 0-basierte Index des aktivierten Objekts in der Collection."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.ItemId.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.ItemId.html",
    "title": "Property ItemId",
    "keywords": "Property ItemId ItemId Die ID des aktivierten Objekts in der zu Grunde liegenden Collection. Declaration public guid ItemId { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.ItemIndex.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.ItemIndex.html",
    "title": "Property ItemIndex",
    "keywords": "Property ItemIndex ItemIndex Der 0-basierte Index des aktivierten Objekts in der Collection. Declaration public int ItemIndex { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.Activator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.Activator.html",
    "title": "Property Activator",
    "keywords": "Property Activator Activator Gibt die Ursache des Events (Typ OnLeaveActivator ) an. Declaration public OnLeaveActivator Activator { get; } Property Value OnLeaveActivator"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.DefaultNextControl.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.DefaultNextControl.html",
    "title": "Property DefaultNextControl",
    "keywords": "Property DefaultNextControl DefaultNextControl Gibt das Control an, in welches der Focus als nächstes vom Client gesetzt wird bzw.gesetzt werden würde. Wenn der Focus in ein anderes Form wechselt, dann ist der Wert <null> . Declaration public IFrameworkControlActionBase DefaultNextControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.HasValueChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.HasValueChanged.html",
    "title": "Property HasValueChanged",
    "keywords": "Property HasValueChanged HasValueChanged Diese Eigenschaft gibt an, ob der Inhalt des Controls geändert wurde. So können Validierungsprüfungen in diesem Event behandelt werden. Declaration public bool HasValueChanged { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.html",
    "title": "Class FrameworkOnLeaveEventArgs",
    "keywords": "Class FrameworkOnLeaveEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnLeaveDefinition des Parameters der Methode zugreifen. Inheritance Object EventArgs FrameworkEventArgs FrameworkOnLeaveEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnLeaveEventArgs : FrameworkEventArgs Examples private void MyDataGrid_DoubleClickEventHandler (FrameworkDoubleClickEventArgs e) { ArtikelObj = ArtikelColl[e.RowID]; } Properties Activator Gibt die Ursache des Events (Typ OnLeaveActivator ) an. DefaultNextControl Gibt das Control an, in welches der Focus als nächstes vom Client gesetzt wird bzw.gesetzt werden würde. Wenn der Focus in ein anderes Form wechselt, dann ist der Wert <null> . HasValueChanged Diese Eigenschaft gibt an, ob der Inhalt des Controls geändert wurde. So können Validierungsprüfungen in diesem Event behandelt werden. NextControlAfterKeyboardEvent Diese Eigenschaft kann vom Programmierer geändert werden.Hier kann das Control angegeben werden, in das der Focus als nächstes gesetzt werden soll.Dadurch wird die Angabe in DefaultNextControl übersteuert. Diese Angabe funktioniert aber nur, wenn das OnLeave durch eine Tastatur-Eingabe ausgelöst wurde.Wenn der Benutzer mit der Maus gezielt in ein anderes Control klickt, dann hat das für den Client Priorität. SourceControl Gibt an, aus welchem Control das Event gefeuert wurde. Das ist hilfreich, wenn die EventArgs als Parameter in andere Logiken übergeben werden."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.NextControlAfterKeyboardEvent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.NextControlAfterKeyboardEvent.html",
    "title": "Property NextControlAfterKeyboardEvent",
    "keywords": "Property NextControlAfterKeyboardEvent NextControlAfterKeyboardEvent Diese Eigenschaft kann vom Programmierer geändert werden.Hier kann das Control angegeben werden, in das der Focus als nächstes gesetzt werden soll.Dadurch wird die Angabe in DefaultNextControl übersteuert. Diese Angabe funktioniert aber nur, wenn das OnLeave durch eine Tastatur-Eingabe ausgelöst wurde.Wenn der Benutzer mit der Maus gezielt in ein anderes Control klickt, dann hat das für den Client Priorität. Declaration public IFrameworkControlActionBase NextControlAfterKeyboardEvent { get; set; } Property Value IFrameworkControlActionBase Examples protected virtual void FE_edt3_OnLeave(FrameworkOnLeaveEventArgs e) { // Ausgabe der Informationen this.sInfo = \"edt3_OnLeave\" + \"\\r\\n Activator: \" + e.Activator + \"\\r\\n DefaultNextControl: \" + (e.DefaultNextControl == null ? \"<null>\" : e.DefaultNextControl.ControlName); // vorwärts >> Focus in das nächste Control setzen if (e.Activator == OnLeaveActivator.KeyboardEnter || e.Activator == OnLeaveActivator.KeyboardTabForward) { e.NextControlAfterKeyboardEvent = this.edt2; } // rückwärts >> Focus in das vorherige Control setzen else if (e.Activator == OnLeaveActivator.KeyboardTabBackward) { e.NextControlAfterKeyboardEvent = this.edtsInfo; } }"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.SourceControl.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.SourceControl.html",
    "title": "Property SourceControl",
    "keywords": "Property SourceControl SourceControl Gibt an, aus welchem Control das Event gefeuert wurde. Das ist hilfreich, wenn die EventArgs als Parameter in andere Logiken übergeben werden. Declaration public IFrameworkControlActionBase SourceControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html",
    "title": "Method GetArgumentFSlong",
    "keywords": "Method GetArgumentFSlong GetArgumentFSlong(String) Declaration public FSlong GetArgumentFSlong(string key) Parameters key String Returns FSlong"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.html",
    "title": "Class FrameworkOnLinkClickEventArgs",
    "keywords": "Class FrameworkOnLinkClickEventArgs TODO: muss noch genauer beschrieben werden Inheritance Object EventArgs FrameworkEventArgs FrameworkOnLinkClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnLinkClickEventArgs : FrameworkEventArgs Methods GetArgumentFSlong(String)"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.html",
    "title": "Class FrameworkOnReloadEventArgs",
    "keywords": "Class FrameworkOnReloadEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnReloadDefinition verknüpfte FormMethod kann somit auf die RowList zugreifen Inheritance Object EventArgs FrameworkEventArgs FrameworkOnReloadEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnReloadEventArgs : FrameworkEventArgs Properties RowIDList Diese Liste enthält die ObjectRowIDs der betroffenen Datensätze. Mit diesen kann der Datensatz direkt aus der Collection ermittelt werden (oMyColl[rowID]). RowList Diese Liste enthält die Zeilennummern der betroffenen Datensätze."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.RowIDList.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.RowIDList.html",
    "title": "Property RowIDList",
    "keywords": "Property RowIDList RowIDList Diese Liste enthält die ObjectRowIDs der betroffenen Datensätze. Mit diesen kann der Datensatz direkt aus der Collection ermittelt werden (oMyColl[rowID]). Declaration public List<guid> RowIDList { get; } Property Value List < guid >"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.RowList.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.RowList.html",
    "title": "Property RowList",
    "keywords": "Property RowList RowList Diese Liste enthält die Zeilennummern der betroffenen Datensätze. Declaration public List<int> RowList { get; } Property Value List < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkSelectionChangedEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkSelectionChangedEventArgs.html",
    "title": "Class FrameworkSelectionChangedEventArgs",
    "keywords": "Class FrameworkSelectionChangedEventArgs Inheritance Object EventArgs FrameworkEventArgs FrameworkSelectionChangedEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkSelectionChangedEventArgs : FrameworkEventArgs"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.EventTab",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Classes FrameworkButtonClickEventArgs FrameworkCellDoubleClickEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnCellDoubleClickDefinition verknüpfte FormMethod kann somit auf das Property RowID zugreifen des Parameters der Methode zugreifen. FrameworkCheckBoxClickEventArgs FrameworkColumnChangedEventArgs !TODO FrameworkDoubleClickEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnRowDoubleClickDefinition verknüpfte FormMethod kann somit auf das Property RowID des Parameters der Methode zugreifen. FrameworkEventArgs Alle FormMethod-EventHandler haben als (einziger) Parameter ein Objekt vom Typ FrameworkEventArgs (oder einer Ableitung). FrameworkEventArgs stellt selbst noch keine besondere Funktionalität bereit, dies kann aber von Ableitungen gemacht werden. So ist es möglich, dem EventHandler weitere Informationen zu übergeben. Siehe hierzu FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnRowDoubleClickDefinition . FrameworkOnDragEventArgs Spezialisierung von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCancelEventEventArgs . FrameworkOnItemActivatedEventArgs FrameworkOnLeaveEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnLeaveDefinition des Parameters der Methode zugreifen. FrameworkOnLinkClickEventArgs TODO: muss noch genauer beschrieben werden FrameworkOnReloadEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnReloadDefinition verknüpfte FormMethod kann somit auf die RowList zugreifen FrameworkSelectionChangedEventArgs Enums OnLeaveActivator"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.OnLeaveActivator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.OnLeaveActivator.html",
    "title": "Enum OnLeaveActivator",
    "keywords": "Enum OnLeaveActivator Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public enum OnLeaveActivator Fields Name Description Action OnLeaveActivator.Action Durch eine Action wie z.B. setFocus() KeyboardDown KeyboardEnter Drücken der Enter-Taste KeyboardF2 Drücken von F2 KeyboardTabBackward Drücken von Shift+Tab KeyboardTabForward Drücken der Tab-Taste KeyboardUp Mouse Mit der Maus wurde in ein anderes Control geklickt. Undefined"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Equals.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Equals.html",
    "title": "Method Equals",
    "keywords": "Method Equals Equals(Object) Declaration public override bool Equals(object obj) Parameters obj Object Returns Boolean Overrides Object.Equals(Object)"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.FromString.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.FromString.html",
    "title": "Method FromString",
    "keywords": "Method FromString FromString(String) Declaration public static Alignment<H, V> FromString(string value) Parameters value String Returns Alignment <H, V>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.GetHashCode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.GetHashCode.html",
    "title": "Method GetHashCode",
    "keywords": "Method GetHashCode GetHashCode() Declaration public override int GetHashCode() Returns Int32 Overrides Object.GetHashCode()"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Horizontal.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Horizontal.html",
    "title": "Property Horizontal",
    "keywords": "Property Horizontal Horizontal Declaration public H? Horizontal { get; set; } Property Value Nullable <H>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.html",
    "title": "Class Alignment<H, V>",
    "keywords": "Class Alignment<H, V> Inheritance Object Alignment<H, V> Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class Alignment<H, V> where H : struct where V : struct Type Parameters Name Description H V Properties Horizontal Vertical Methods Equals(Object) FromString(String) GetHashCode() SetFrom(Alignment<H, V>) ShoudldSerialize() ShouldSerializeHorizontal() ShouldSerializeVertical() ToString()"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.SetFrom.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.SetFrom.html",
    "title": "Method SetFrom",
    "keywords": "Method SetFrom SetFrom(Alignment<H, V>) Declaration public void SetFrom(Alignment<H, V> value) Parameters value Alignment <H, V>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShoudldSerialize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShoudldSerialize.html",
    "title": "Method ShoudldSerialize",
    "keywords": "Method ShoudldSerialize ShoudldSerialize() Declaration public bool ShoudldSerialize() Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeHorizontal.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeHorizontal.html",
    "title": "Method ShouldSerializeHorizontal",
    "keywords": "Method ShouldSerializeHorizontal ShouldSerializeHorizontal() Declaration public bool ShouldSerializeHorizontal() Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeVertical.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeVertical.html",
    "title": "Method ShouldSerializeVertical",
    "keywords": "Method ShouldSerializeVertical ShouldSerializeVertical() Declaration public bool ShouldSerializeVertical() Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ToString.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ToString.html",
    "title": "Method ToString",
    "keywords": "Method ToString ToString() Declaration public override string ToString() Returns String Overrides Object.ToString()"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Vertical.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Vertical.html",
    "title": "Property Vertical",
    "keywords": "Property Vertical Vertical Declaration public V? Vertical { get; set; } Property Value Nullable <V>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomLeft.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomLeft.html",
    "title": "Property BottomLeft",
    "keywords": "Property BottomLeft BottomLeft Declaration public int? BottomLeft { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomRight.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomRight.html",
    "title": "Property BottomRight",
    "keywords": "Property BottomRight BottomRight Declaration public int? BottomRight { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.html",
    "title": "Class BorderRadius",
    "keywords": "Class BorderRadius Inheritance Object BorderRadius Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(BorderRadiusTypeConverter))] public class BorderRadius Properties BottomLeft BottomRight TopLeft TopRight"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopLeft.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopLeft.html",
    "title": "Property TopLeft",
    "keywords": "Property TopLeft TopLeft Declaration public int? TopLeft { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopRight.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopRight.html",
    "title": "Property TopRight",
    "keywords": "Property TopRight TopRight Declaration public int? TopRight { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Bottom.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Bottom.html",
    "title": "Property Bottom",
    "keywords": "Property Bottom Bottom Declaration public int? Bottom { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.html",
    "title": "Class Bounds",
    "keywords": "Class Bounds TODO Inheritance Object Bounds Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(ControlBoundsTypeConverter))] public class Bounds Properties Bottom Left Right Top"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Left.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Left.html",
    "title": "Property Left",
    "keywords": "Property Left Left Declaration public int? Left { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Right.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Right.html",
    "title": "Property Right",
    "keywords": "Property Right Right Declaration public int? Right { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Top.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Top.html",
    "title": "Property Top",
    "keywords": "Property Top Top Declaration public int? Top { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Bold.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Bold.html",
    "title": "Property Bold",
    "keywords": "Property Bold Bold Declaration public bool? Bold { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Family.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Family.html",
    "title": "Property Family",
    "keywords": "Property Family Family Declaration [TypeConverter(typeof(FontFamilyConverter))] public string Family { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.html",
    "title": "Class ControlFont",
    "keywords": "Class ControlFont Inheritance Object ControlFont Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(ControlFontTypeConverter))] public class ControlFont Properties Bold Family Italic Size Underline"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Italic.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Italic.html",
    "title": "Property Italic",
    "keywords": "Property Italic Italic Declaration public bool? Italic { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Size.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Size.html",
    "title": "Property Size",
    "keywords": "Property Size Size Declaration public int? Size { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Underline.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Underline.html",
    "title": "Property Underline",
    "keywords": "Property Underline Underline Declaration public bool? Underline { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.html",
    "title": "Class ControlLabelTemplate",
    "keywords": "Class ControlLabelTemplate TODO ControlLabelTemplate Inheritance Object FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataBase FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataStyleBase ControlLabelTemplateBase ControlLabelTemplate Inherited Members ControlLabelTemplateBase.BackColor ControlLabelTemplateBase.ForeColor ControlLabelTemplateBase.Font ControlLabelTemplateBase.TextAlign ControlLabelTemplateBase.Padding ControlLabelTemplateBase.Margin ControlLabelTemplateBase.MinSize ControlLabelTemplateBase.MaxSize Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ControlLabelTemplate : ControlLabelTemplateBase, INotifyPropertyChanged, IFsXmlSerializable Properties IsVisible"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.IsVisible.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.IsVisible.html",
    "title": "Property IsVisible",
    "keywords": "Property IsVisible IsVisible Declaration [Browsable(true)] [ControlStylesBrowsable(false)] public bool? IsVisible { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor BackColor Declaration [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Font.html",
    "title": "Property Font",
    "keywords": "Property Font Font Declaration public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor ForeColor Declaration [TypeConverter(typeof(ColorTypeConverter))] public Color ForeColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.html",
    "title": "Class ControlLabelTemplateBase",
    "keywords": "Class ControlLabelTemplateBase Inheritance Object FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataBase FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataStyleBase ControlLabelTemplateBase ControlLabelTemplate RowLabelTemplate Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(ControlLabelTemplateConverter))] public abstract class ControlLabelTemplateBase : DevDataStyleBase, INotifyPropertyChanged, IFsXmlSerializable Properties BackColor Font ForeColor Margin MaxSize MinSize Padding TextAlign"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Margin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Margin.html",
    "title": "Property Margin",
    "keywords": "Property Margin Margin Declaration public Bounds Margin { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize MaxSize Declaration public NonableSize MaxSize { get; set; } Property Value NonableSize"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MinSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MinSize.html",
    "title": "Property MinSize",
    "keywords": "Property MinSize MinSize Declaration public NonableSize MinSize { get; set; } Property Value NonableSize"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding Padding Declaration public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign TextAlign Declaration public DevTextAlign? TextAlign { get; set; } Property Value Nullable < DevTextAlign >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Classes Alignment<H, V> BorderRadius Bounds TODO ControlFont ControlLabelTemplate TODO ControlLabelTemplate ControlLabelTemplateBase NonableSize RowLabelTemplate TabTemplate TODO"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Height.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Height.html",
    "title": "Property Height",
    "keywords": "Property Height Height Declaration [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] [ControlStylesBrowsable(true)] public Nonable<int>? Height { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.html",
    "title": "Class NonableSize",
    "keywords": "Class NonableSize Inheritance Object NonableSize Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(NonableSizeObjectConverter))] public class NonableSize Properties Height Width"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Width.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Width.html",
    "title": "Property Width",
    "keywords": "Property Width Width Declaration [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] [ControlStylesBrowsable(true)] public Nonable<int>? Width { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor BackColor Declaration [Browsable(true)] public Color BackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Font.html",
    "title": "Property Font",
    "keywords": "Property Font Font Declaration [Browsable(true)] public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor ForeColor Declaration [Browsable(true)] public Color ForeColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.html",
    "title": "Class RowLabelTemplate",
    "keywords": "Class RowLabelTemplate Inheritance Object FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataBase FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataStyleBase ControlLabelTemplateBase RowLabelTemplate Inherited Members ControlLabelTemplateBase.TextAlign ControlLabelTemplateBase.MinSize ControlLabelTemplateBase.MaxSize Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class RowLabelTemplate : ControlLabelTemplateBase, INotifyPropertyChanged, IFsXmlSerializable Properties BackColor Font ForeColor Margin Padding"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Margin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Margin.html",
    "title": "Property Margin",
    "keywords": "Property Margin Margin Declaration [Browsable(true)] public Bounds Margin { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding Padding Declaration [Browsable(true)] public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor BackColor Declaration [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderColor.html",
    "title": "Property BorderColor",
    "keywords": "Property BorderColor BorderColor Declaration [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color BorderColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderRadius.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderRadius.html",
    "title": "Property BorderRadius",
    "keywords": "Property BorderRadius BorderRadius Declaration public BorderRadius BorderRadius { get; set; } Property Value BorderRadius"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderThickness.html",
    "title": "Property BorderThickness",
    "keywords": "Property BorderThickness BorderThickness Declaration public Bounds BorderThickness { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Font.html",
    "title": "Property Font",
    "keywords": "Property Font Font Declaration public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor ForeColor Declaration [TypeConverter(typeof(ColorTypeConverter))] public Color ForeColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.html",
    "title": "Class TabTemplate",
    "keywords": "Class TabTemplate TODO Inheritance Object FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataBase FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataStyleBase TabTemplate Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(TabTemplateConverter))] public class TabTemplate : DevDataStyleBase, INotifyPropertyChanged, IFsXmlSerializable Properties BackColor BorderColor BorderRadius BorderThickness Font ForeColor IconPadding Padding"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.IconPadding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.IconPadding.html",
    "title": "Property IconPadding",
    "keywords": "Property IconPadding IconPadding Declaration public Bounds IconPadding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding Padding Declaration public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.html",
    "title": "Class ControlTreeNode",
    "keywords": "Class ControlTreeNode Inheritance Object ControlTreeNode ControlDesignViewModel Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ControlTreeNode : INotifyPropertyChanged, IDisposable, INamedRecord Properties Name Gibt den Namen des Controls an. Über diesen Namen kann in den Form-Methoden auf das Control zugegriffen werden.Einige Controls bieten die Möglichkeit, dynamisch Properties zu verändern.In einer Form-Methode kann so z.B. this.btnCalculate.SetVisible(false); aufgerufen werden, um ein Control auszublenden. Wird für ein Control ein Name vergeben, sollte dieser gut überlegt sein, damit er nicht mehr nachträglich geändert werden muss.Denn werden dem Control Events zugeordnet, orientiert sich deren Name am Namen des Controls. Beispiel: wird für einen Button btnStart eine Form- Methode hinterlegt, bekommt Sie den Namen FE_btnStart_OnClick( ) ."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.Name.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Name Gibt den Namen des Controls an. Über diesen Namen kann in den Form-Methoden auf das Control zugegriffen werden.Einige Controls bieten die Möglichkeit, dynamisch Properties zu verändern.In einer Form-Methode kann so z.B. this.btnCalculate.SetVisible(false); aufgerufen werden, um ein Control auszublenden. Wird für ein Control ein Name vergeben, sollte dieser gut überlegt sein, damit er nicht mehr nachträglich geändert werden muss.Denn werden dem Control Events zugeordnet, orientiert sich deren Name am Namen des Controls. Beispiel: wird für einen Button btnStart eine Form- Methode hinterlegt, bekommt Sie den Namen FE_btnStart_OnClick( ) . Declaration [Browsable(true)] public virtual string Name { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer Classes ControlTreeNode"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonIcon.html",
    "title": "Property BackwardButtonIcon",
    "keywords": "Property BackwardButtonIcon BackwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string BackwardButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonShortcut.html",
    "title": "Property BackwardButtonShortcut",
    "keywords": "Property BackwardButtonShortcut BackwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? BackwardButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonTooltip.html",
    "title": "Property BackwardButtonTooltip",
    "keywords": "Property BackwardButtonTooltip BackwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString BackwardButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BrowserMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BrowserMode.html",
    "title": "Property BrowserMode",
    "keywords": "Property BrowserMode BrowserMode Gibt an, ob der Browser-Mode ausgewählt wurde. Der Browser-Mode ist zur Anzeige von Webseiten geeignet und verfügt über eine Adresszeile. Die in die Adresszeile eingegebene URL wird durch den LoadPageButton geladen.Das Laden der Seite kann durch den CancelButton abgebrochen und über den ReloadPageButton neu gestartet werden. Außerdem verfügt der Browser-Mode über Buttons, mit denen eine Vorwärts- und Rückwärtsnavigation möglich ist. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? BrowserMode { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonIcon.html",
    "title": "Property CancelButtonIcon",
    "keywords": "Property CancelButtonIcon CancelButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string CancelButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonTooltip.html",
    "title": "Property CancelButtonTooltip",
    "keywords": "Property CancelButtonTooltip CancelButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString CancelButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Content.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Content.html",
    "title": "Property Content",
    "keywords": "Property Content Content Über den Datasource Content können Inhalte wie z.B. HTML-Content oder der Pfad zu einer Datei, die im Browser angezeigt werden soll, an den Client übertragen werden. Der Datasource ist unidirektional(nur von Broker zu Client) und hat höhere Priorität als Url. Ressourcen können mit fsbroker://RelativerPfad angezeigt oder verwendet werden. Mit der Funktion CreateRessourcesUrl( ) der Klasse BrowserCommand kann eine Broker-Url erstellt werden. Diese Url kann dann, wie in dem nachfolgenden Beispiel, in Verbindung mit HTML als Link zu einer Datei verwendet warden: Declaration [Browsable(true)] [ControlStylesBrowsable(false)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource Content { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.EnableJavaScript.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.EnableJavaScript.html",
    "title": "Property EnableJavaScript",
    "keywords": "Property EnableJavaScript EnableJavaScript Gibt an, ob JavaScript im Browser aktiviert ist. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? EnableJavaScript { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonIcon.html",
    "title": "Property ForwardButtonIcon",
    "keywords": "Property ForwardButtonIcon ForwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ForwardButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonShortcut.html",
    "title": "Property ForwardButtonShortcut",
    "keywords": "Property ForwardButtonShortcut ForwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ForwardButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonTooltip.html",
    "title": "Property ForwardButtonTooltip",
    "keywords": "Property ForwardButtonTooltip ForwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ForwardButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.html",
    "title": "Class BrowserDesignViewModel",
    "keywords": "Class BrowserDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel BrowserDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class BrowserDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties BackwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button BackwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. BackwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. BrowserMode Gibt an, ob der Browser-Mode ausgewählt wurde. Der Browser-Mode ist zur Anzeige von Webseiten geeignet und verfügt über eine Adresszeile. Die in die Adresszeile eingegebene URL wird durch den LoadPageButton geladen.Das Laden der Seite kann durch den CancelButton abgebrochen und über den ReloadPageButton neu gestartet werden. Außerdem verfügt der Browser-Mode über Buttons, mit denen eine Vorwärts- und Rückwärtsnavigation möglich ist. CancelButtonIcon Pfad zu einem Icon, das für den jeweiligen Button CancelButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Content Über den Datasource Content können Inhalte wie z.B. HTML-Content oder der Pfad zu einer Datei, die im Browser angezeigt werden soll, an den Client übertragen werden. Der Datasource ist unidirektional(nur von Broker zu Client) und hat höhere Priorität als Url. Ressourcen können mit fsbroker://RelativerPfad angezeigt oder verwendet werden. Mit der Funktion CreateRessourcesUrl( ) der Klasse BrowserCommand kann eine Broker-Url erstellt werden. Diese Url kann dann, wie in dem nachfolgenden Beispiel, in Verbindung mit HTML als Link zu einer Datei verwendet warden: EnableJavaScript Gibt an, ob JavaScript im Browser aktiviert ist. ForwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ForwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ForwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. LoadPageButtonIcon Pfad zu einem Icon, das für den jeweiligen Button LoadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. ReloadButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ReloadButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ReloadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. ShowStatusBar Gibt an, ob die Statusleiste (Ladestatus der aktuellen Seite + MouseOver Link) angezeigt wird. Die Statusleiste wird nur in Verbindung mit dem BrowserMode angezeigt. ShowZoomBar Gibt an, ob die Leiste zur Änderung der Größe des Inhalts im Browser angezeigt wird. Url Mit dem Datasource Url können Webseiten, die im Browser angezeigt werden sollen, an den Client übertragen werden. Der Datasource ist unidirektional (nur von Broker zu Client). ZoomInButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ZoomInButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ZoomInButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. ZoomOutButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ZoomOutButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. ZoomResetButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ZoomResetButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ZoomResetButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Events OnLinkClick Tritt ein, wenn ein Html-Link mit der Maus angeklickt wurde. Um eine Client-seitige Navigation zu unterbinden, werden alle Links an den Event-Args konsumiert und müssen, falls gewünscht, wieder manuell über einen der Datasources zum Client geschickt werden. OnPageError Tritt ein falls beim Laden der Seite ein Fehler aufgetreten ist Über das Event Argument können folgende Informationen über die Fehlermeldung ausgelesen werden: • Url: Gibt die Url zurück zu der navigiert werden sollte • Message: Gibt den Fehlergrund zurück OnPageLoaded Tritt ein, wenn die aktuelle Seite vom Browser fertig geladen ist. Das Event-Argument stellt die Adresse (url) und den Titel (title) der geladenen Seite zur Verfügung. OnSnapshotGenerated Tritt ein, wenn der Snapshot von der Action GenerateSnapshot erstellt wurde. • Snapshot: Gibt den Snapshot als Byte-Array im PNG Format zurück"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonIcon.html",
    "title": "Property LoadPageButtonIcon",
    "keywords": "Property LoadPageButtonIcon LoadPageButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string LoadPageButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonTooltip.html",
    "title": "Property LoadPageButtonTooltip",
    "keywords": "Property LoadPageButtonTooltip LoadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString LoadPageButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnLinkClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnLinkClick.html",
    "title": "Event OnLinkClick",
    "keywords": "Event OnLinkClick Tritt ein, wenn ein Html-Link mit der Maus angeklickt wurde. Um eine Client-seitige Navigation zu unterbinden, werden alle Links an den Event-Args konsumiert und müssen, falls gewünscht, wieder manuell über einen der Datasources zum Client geschickt werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLinkClickEventArgs> OnLinkClick Returns Type Description EventHandler < FrameworkOnLinkClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageError.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageError.html",
    "title": "Event OnPageError",
    "keywords": "Event OnPageError Tritt ein falls beim Laden der Seite ein Fehler aufgetreten ist Über das Event Argument können folgende Informationen über die Fehlermeldung ausgelesen werden: • Url: Gibt die Url zurück zu der navigiert werden sollte • Message: Gibt den Fehlergrund zurück Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLinkClickEventArgs> OnPageError Returns Type Description EventHandler < FrameworkOnLinkClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageLoaded.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageLoaded.html",
    "title": "Event OnPageLoaded",
    "keywords": "Event OnPageLoaded Tritt ein, wenn die aktuelle Seite vom Browser fertig geladen ist. Das Event-Argument stellt die Adresse (url) und den Titel (title) der geladenen Seite zur Verfügung. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLinkClickEventArgs> OnPageLoaded Returns Type Description EventHandler < FrameworkOnLinkClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnSnapshotGenerated.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnSnapshotGenerated.html",
    "title": "Event OnSnapshotGenerated",
    "keywords": "Event OnSnapshotGenerated Tritt ein, wenn der Snapshot von der Action GenerateSnapshot erstellt wurde. • Snapshot: Gibt den Snapshot als Byte-Array im PNG Format zurück Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLinkClickEventArgs> OnSnapshotGenerated Returns Type Description EventHandler < FrameworkOnLinkClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonIcon.html",
    "title": "Property ReloadButtonIcon",
    "keywords": "Property ReloadButtonIcon ReloadButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ReloadButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonShortcut.html",
    "title": "Property ReloadButtonShortcut",
    "keywords": "Property ReloadButtonShortcut ReloadButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ReloadButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadPageButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadPageButtonTooltip.html",
    "title": "Property ReloadPageButtonTooltip",
    "keywords": "Property ReloadPageButtonTooltip ReloadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ReloadPageButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowStatusBar.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowStatusBar.html",
    "title": "Property ShowStatusBar",
    "keywords": "Property ShowStatusBar ShowStatusBar Gibt an, ob die Statusleiste (Ladestatus der aktuellen Seite + MouseOver Link) angezeigt wird. Die Statusleiste wird nur in Verbindung mit dem BrowserMode angezeigt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowStatusBar { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowZoomBar.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowZoomBar.html",
    "title": "Property ShowZoomBar",
    "keywords": "Property ShowZoomBar ShowZoomBar Gibt an, ob die Leiste zur Änderung der Größe des Inhalts im Browser angezeigt wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowZoomBar { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Url.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Url.html",
    "title": "Property Url",
    "keywords": "Property Url Url Mit dem Datasource Url können Webseiten, die im Browser angezeigt werden sollen, an den Client übertragen werden. Der Datasource ist unidirektional (nur von Broker zu Client). Declaration [Browsable(true)] [ControlStylesBrowsable(false)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource Url { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonIcon.html",
    "title": "Property ZoomInButtonIcon",
    "keywords": "Property ZoomInButtonIcon ZoomInButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ZoomInButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonShortcut.html",
    "title": "Property ZoomInButtonShortcut",
    "keywords": "Property ZoomInButtonShortcut ZoomInButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ZoomInButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonTooltip.html",
    "title": "Property ZoomInButtonTooltip",
    "keywords": "Property ZoomInButtonTooltip ZoomInButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ZoomInButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonShortcut.html",
    "title": "Property ZoomOutButtonShortcut",
    "keywords": "Property ZoomOutButtonShortcut ZoomOutButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ZoomOutButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonTooltip.html",
    "title": "Property ZoomOutButtonTooltip",
    "keywords": "Property ZoomOutButtonTooltip ZoomOutButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ZoomOutButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonIcon.html",
    "title": "Property ZoomResetButtonIcon",
    "keywords": "Property ZoomResetButtonIcon ZoomResetButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ZoomResetButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonShortcut.html",
    "title": "Property ZoomResetButtonShortcut",
    "keywords": "Property ZoomResetButtonShortcut ZoomResetButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ZoomResetButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonTooltip.html",
    "title": "Property ZoomResetButtonTooltip",
    "keywords": "Property ZoomResetButtonTooltip ZoomResetButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ZoomResetButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Gibt die Beschriftung des Buttons in den definierten Sprachen an. Siehe auch Caption in ControlDesignViewModel Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ContextMenu.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ContextMenu.html",
    "title": "Property ContextMenu",
    "keywords": "Property ContextMenu ContextMenu Gibt an, welches Kontextmenü geöffnet werden soll, wenn der Button betätigt wird. Ist ein Kontextmenü zugeordnet, so wird das Event OnClick nicht ausgelöst Declaration [Browsable(true)] [TypeConverter(typeof(RecordsConverter))] public DevControlMainMenuRecord ContextMenu { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.DevControlMainMenuRecord See Also ContextMenuDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.html",
    "title": "Class ButtonBaseDesignViewModel",
    "keywords": "Class ButtonBaseDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ButtonBaseDesignViewModel ButtonDesignViewModel ImageButtonDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public abstract class ButtonBaseDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Gibt die Beschriftung des Buttons in den definierten Sprachen an. Siehe auch Caption in ControlDesignViewModel ContextMenu Gibt an, welches Kontextmenü geöffnet werden soll, wenn der Button betätigt wird. Ist ein Kontextmenü zugeordnet, so wird das Event OnClick nicht ausgelöst IsSearchButton Gibt an, ob es sich bei dem Button um einen Such-Button handelt. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) LoadAtComponent Gibt die Component an, an welcher der Load ausgeführt werden soll (dies kann auch eine Collection sein). (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) MapEnterToTabAction !TODO SearchValuesComponent Gibt die Component an, aus der die Load-Condition erzeugt werden soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Shortcut Legt ein Tastenkürzel(Tastenkombination) für den schnellen Zugriff auf den Button fest.Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, so wird das OnClick-Event des Buttons ausgelöst. Inherited(Bei der Auswahl dieses Wertes wird die Einstellung gelöscht und der Wert aus der Basis-Klasse oder den Default Control Styles gezogen) None(keine zugeordnet) ShowCaption !TODO Events OnClick Wird bei einem Klick auf das Control ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.IsSearchButton.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.IsSearchButton.html",
    "title": "Property IsSearchButton",
    "keywords": "Property IsSearchButton IsSearchButton Gibt an, ob es sich bei dem Button um einen Such-Button handelt. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [Browsable(true)] public bool? IsSearchButton { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.LoadAtComponent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.LoadAtComponent.html",
    "title": "Property LoadAtComponent",
    "keywords": "Property LoadAtComponent LoadAtComponent Gibt die Component an, an welcher der Load ausgeführt werden soll (dies kann auch eine Collection sein). (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [DevBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource LoadAtComponent { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.MapEnterToTabAction.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.MapEnterToTabAction.html",
    "title": "Property MapEnterToTabAction",
    "keywords": "Property MapEnterToTabAction MapEnterToTabAction !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? MapEnterToTabAction { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird bei einem Klick auf das Control ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkButtonClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkButtonClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.SearchValuesComponent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.SearchValuesComponent.html",
    "title": "Property SearchValuesComponent",
    "keywords": "Property SearchValuesComponent SearchValuesComponent Gibt die Component an, aus der die Load-Condition erzeugt werden soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [DevBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SearchValuesComponent { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut Shortcut Legt ein Tastenkürzel(Tastenkombination) für den schnellen Zugriff auf den Button fest.Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, so wird das OnClick-Event des Buttons ausgelöst. Inherited(Bei der Auswahl dieses Wertes wird die Einstellung gelöscht und der Wert aus der Basis-Klasse oder den Default Control Styles gezogen) None(keine zugeordnet) Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? Shortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ShowCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ShowCaption.html",
    "title": "Property ShowCaption",
    "keywords": "Property ShowCaption ShowCaption !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowCaption { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.html",
    "title": "Class ButtonDesignViewModel",
    "keywords": "Class ButtonDesignViewModel Diese Klasse repräsentiert das Control Button . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ButtonBaseDesignViewModel ButtonDesignViewModel Inherited Members ButtonBaseDesignViewModel.Caption ButtonBaseDesignViewModel.MapEnterToTabAction ButtonBaseDesignViewModel.Shortcut ButtonBaseDesignViewModel.ShowCaption ButtonBaseDesignViewModel.IsSearchButton ButtonBaseDesignViewModel.LoadAtComponent ButtonBaseDesignViewModel.SearchValuesComponent ButtonBaseDesignViewModel.ContextMenu ButtonBaseDesignViewModel.OnClick ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ButtonDesignViewModel : ButtonBaseDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties TypeName !TODO See Also ButtonControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.TypeName.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.TypeName.html",
    "title": "Property TypeName",
    "keywords": "Property TypeName TypeName !TODO Declaration public override string TypeName { get; } Property Value String Overrides FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.TypeName"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.html",
    "title": "Class CheckBoxDesignViewModel",
    "keywords": "Class CheckBoxDesignViewModel Diese Klasse repräsentiert das Control CheckBox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel CheckBoxDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class CheckBoxDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ShowCaption Events OnClick Wird bei einem Klick auf das Control ausgelöst. See Also CheckboxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird bei einem Klick auf das Control ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkCheckBoxClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkCheckBoxClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.ShowCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.ShowCaption.html",
    "title": "Property ShowCaption",
    "keywords": "Property ShowCaption ShowCaption Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowCaption { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle EditStyle TODO Declaration [Browsable(true)] public ComboEditStyle? EditStyle { get; set; } Property Value Nullable < ComboEditStyle >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.html",
    "title": "Class ComboboxDesignViewModel",
    "keywords": "Class ComboboxDesignViewModel Diese Klasse repräsentiert das Control Combobox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ListBaseDesignViewModel ComboboxDesignViewModel Inherited Members ListBaseDesignViewModel.List ListBaseDesignViewModel.ListSortOrder ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ComboboxDesignViewModel : ListBaseDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties EditStyle TODO MaxDropDownSize TODO Events OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. See Also ComboBoxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.MaxDropDownSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.MaxDropDownSize.html",
    "title": "Property MaxDropDownSize",
    "keywords": "Property MaxDropDownSize MaxDropDownSize TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public virtual Size MaxDropDownSize { get; set; } Property Value Size"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.OnSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.OnSelectionChanged.html",
    "title": "Event OnSelectionChanged",
    "keywords": "Event OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkSelectionChangedEventArgs> OnSelectionChanged Returns Type Description EventHandler < FrameworkSelectionChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.GenerateDocSection.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.GenerateDocSection.html",
    "title": "Property GenerateDocSection",
    "keywords": "Property GenerateDocSection GenerateDocSection Gibt an, ob in der Dokumentation für den Container ein separates Kapitel generiert werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? GenerateDocSection { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.html",
    "title": "Class ContainerDesignViewModel",
    "keywords": "Class ContainerDesignViewModel TODO Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FieldRowDesignViewModel GridDesignViewModel MainMenuDesignViewModel TabbedWindowDesignViewModel TabPageDesignViewModel TreeNodeDesignViewModel TreeViewDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public abstract class ContainerDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties GenerateDocSection Gibt an, ob in der Dokumentation für den Container ein separates Kapitel generiert werden soll."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Dient lediglich der Bezeichnung in der generierten Dokumentation. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides MainMenuDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Ohne Funktion. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides MainMenuDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.html",
    "title": "Class ContextMenuDesignViewModel",
    "keywords": "Class ContextMenuDesignViewModel Diese Klasse repräsentiert das Control ContextMenu . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel MainMenuDesignViewModel ContextMenuDesignViewModel Inherited Members MainMenuDesignViewModel.Checked MainMenuDesignViewModel.Shortcut MainMenuDesignViewModel.Image MainMenuDesignViewModel.OnClick MainMenuDesignViewModel.OnEnter MainMenuDesignViewModel.OnLeave MainMenuDesignViewModel.OnCanDrop MainMenuDesignViewModel.OnDrag ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ContextMenuDesignViewModel : MainMenuDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Dient lediglich der Bezeichnung in der generierten Dokumentation. DataSource Ohne Funktion. See Also MainMenuControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Alignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Alignment.html",
    "title": "Property Alignment",
    "keywords": "Property Alignment Alignment Gibt an, wie sich das Control in seinem Container ausrichten soll. Standardwerte sind Stretch und Stretch Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(AlignmentObjectConverter<HorizontalAlignment, VerticalAlignment>))] public Alignment<HorizontalAlignment, VerticalAlignment> Alignment { get; set; } Property Value Alignment < HorizontalAlignment , VerticalAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor BackColor Gibt die Hintergrund-Farbe des Controls an. Über den Alpha-Kanal (Transparenz-Wert) der Farbe kann die Transparenz des Controls gesteuert werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? BackColor { get; set; } Property Value Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderColor.html",
    "title": "Property BorderColor",
    "keywords": "Property BorderColor BorderColor Gibt die Farbe des Rands um das Control herum an. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? BorderColor { get; set; } Property Value Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderRadius.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderRadius.html",
    "title": "Property BorderRadius",
    "keywords": "Property BorderRadius BorderRadius Gibt den Radius für die Rundung des Randes an. Die Unter-Eigenschaften TopLeft , TopRight , BottomRight und BottomLeft können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public BorderRadius BorderRadius { get; set; } Property Value BorderRadius"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderThickness.html",
    "title": "Property BorderThickness",
    "keywords": "Property BorderThickness BorderThickness Gibt die Dicke des Rands um das Control herum an.Der Rand wird in die Größe des Controls hineingerechnet.Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public virtual Bounds BorderThickness { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Gibt eine mehrsprachige Beschriftung des Controls an. Je nach Control wird diese entweder selber vom Control angezeigt (z.B. Button, ImageButton, Label) oder es wird durch das [FieldPanel](!TODO LINK) ein Label mit dieser Beschriftung generiert (z.B. Editfield, Combobox). Declaration [Browsable(true)] [ControlStylesBrowsable] public virtual IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Remarks Auch wenn die Beschriftung nicht direkt in der Oberfläche angezeigt wird, kann es dennoch sinnvoll sein, sie anzugeben. Sie wird dann z.B. in der Dokumentation benutzt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CaptionAsPlaceholder.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CaptionAsPlaceholder.html",
    "title": "Property CaptionAsPlaceholder",
    "keywords": "Property CaptionAsPlaceholder CaptionAsPlaceholder Gibt an, ob die Caption des Controls als Placeholder angezeigt werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable] public virtual bool? CaptionAsPlaceholder { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ControlEvents.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ControlEvents.html",
    "title": "Property ControlEvents",
    "keywords": "Property ControlEvents ControlEvents Dieses Property dient dazu, den Editor für die Events anzuzeigen. Es selber selber keinen relevanten Wert. (siehe Events ) Declaration [Browsable(true)] public object ControlEvents { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CtrlStyleName.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CtrlStyleName.html",
    "title": "Property CtrlStyleName",
    "keywords": "Property CtrlStyleName CtrlStyleName Declaration [Browsable(true)] public string CtrlStyleName { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Declaration [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public virtual IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DisabledBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DisabledBackColor.html",
    "title": "Property DisabledBackColor",
    "keywords": "Property DisabledBackColor DisabledBackColor Definiert die Hintergrundfarbe, wenn das Control deaktiviert ist. Diese Einstellung kann für ComboboxDesignViewModel und EditboxDesignViewModel gesetzt werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? DisabledBackColor { get; set; } Property Value Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Documentation.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Documentation.html",
    "title": "Property Documentation",
    "keywords": "Property Documentation Documentation Öffnet den Dokumentations-Editor (siehe Editor ) Declaration [Browsable(true)] public object Documentation { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Font.html",
    "title": "Property Font",
    "keywords": "Property Font Font Hier kann die Schrift des Controls eingestellt werden. Die Unter-Properties Family , Size , Bold , Italic und Underline können jeweils getrennt voneinander überschrieben werden. Die Size definiert, wieviel Pixel Platz die Schrift insgesamt bei einer Skalierung von 100% verbraucht.Somit ergibt sich aus Summe der Size und den Properties Padding, BorderThickness und Margin die tatsächliche Höhe des Controls. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor ForeColor Schriftfarbe. Über die Action SetForeColor(Nullable<Color>) kann die Farbe zur Laufzeit geändert werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? ForeColor { get; set; } Property Value Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.FullTextSearch.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.FullTextSearch.html",
    "title": "Property FullTextSearch",
    "keywords": "Property FullTextSearch FullTextSearch Unter den folgenden Bedingungen: FullTextSearch und IsSearchField aktiviert und SearchOperator ist 'Like' wird für das Control in die automatisch generierte Load-Condition ein zusätzlicher %-Wildcard vor das Control hinzugefügt und somit eine FullText Suche aktiviert. Generierter Code Beispiel: ((\"like\", \"%\" + form.Control + \"%\") Declaration [Browsable(true)] public bool? FullTextSearch { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.HideInDocumentation.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.HideInDocumentation.html",
    "title": "Property HideInDocumentation",
    "keywords": "Property HideInDocumentation HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? HideInDocumentation { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.html",
    "title": "Class ControlDesignViewModel",
    "keywords": "Class ControlDesignViewModel TODO Inheritance Object ControlTreeNode ControlDesignViewModel BrowserDesignViewModel ButtonBaseDesignViewModel CheckBoxDesignViewModel ContainerDesignViewModel DashBoardContainerViewModel EditboxDesignViewModel FormContainerDesignViewModel GridColDesignViewModel LabelDesignViewModel ListBaseDesignViewModel ListViewDesignViewModel PictureDesignViewModel RadioButtonDesignViewModel TemplateControlDesignViewModel Inherited Members ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public abstract class ControlDesignViewModel : ControlTreeNode, INotifyPropertyChanged, IDisposable, INamedRecord Properties Alignment Gibt an, wie sich das Control in seinem Container ausrichten soll. Standardwerte sind Stretch und Stretch BackColor Gibt die Hintergrund-Farbe des Controls an. Über den Alpha-Kanal (Transparenz-Wert) der Farbe kann die Transparenz des Controls gesteuert werden. BorderColor Gibt die Farbe des Rands um das Control herum an. BorderRadius Gibt den Radius für die Rundung des Randes an. Die Unter-Eigenschaften TopLeft , TopRight , BottomRight und BottomLeft können getrennt voneinander angegeben oder überschrieben werden. BorderThickness Gibt die Dicke des Rands um das Control herum an.Der Rand wird in die Größe des Controls hineingerechnet.Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. Caption Gibt eine mehrsprachige Beschriftung des Controls an. Je nach Control wird diese entweder selber vom Control angezeigt (z.B. Button, ImageButton, Label) oder es wird durch das [FieldPanel](!TODO LINK) ein Label mit dieser Beschriftung generiert (z.B. Editfield, Combobox). CaptionAsPlaceholder Gibt an, ob die Caption des Controls als Placeholder angezeigt werden soll. ControlEvents Dieses Property dient dazu, den Editor für die Events anzuzeigen. Es selber selber keinen relevanten Wert. (siehe Events ) CtrlStyleName DataSource DisabledBackColor Definiert die Hintergrundfarbe, wenn das Control deaktiviert ist. Diese Einstellung kann für ComboboxDesignViewModel und EditboxDesignViewModel gesetzt werden. Documentation Öffnet den Dokumentations-Editor (siehe Editor ) Font Hier kann die Schrift des Controls eingestellt werden. Die Unter-Properties Family , Size , Bold , Italic und Underline können jeweils getrennt voneinander überschrieben werden. Die Size definiert, wieviel Pixel Platz die Schrift insgesamt bei einer Skalierung von 100% verbraucht.Somit ergibt sich aus Summe der Size und den Properties Padding, BorderThickness und Margin die tatsächliche Höhe des Controls. ForeColor Schriftfarbe. Über die Action SetForeColor(Nullable<Color>) kann die Farbe zur Laufzeit geändert werden. FullTextSearch Unter den folgenden Bedingungen: FullTextSearch und IsSearchField aktiviert und SearchOperator ist 'Like' wird für das Control in die automatisch generierte Load-Condition ein zusätzlicher %-Wildcard vor das Control hinzugefügt und somit eine FullText Suche aktiviert. Generierter Code Beispiel: ((\"like\", \"%\" + form.Control + \"%\") HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. IsEditable Wenn hier true gesetzt ist, ist das Control editierbar. Ansonsten ist das Control für Eingaben gesperrt. Über die Action SetEnabled(Nullable<Boolean>) kann das Control zur Laufzeit gesperrt werden. IsEditableAU Das IsEditable Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU ) IsSearchField Soll sich das Control in die automatisch generierte Load-Condition eintragen, muss dieses Property auf True gesetzt werden. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) IsVisibleAU Das IsVisible Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU ) LabelTemplate Margin Gibt den äußeren Rand um das Control herum an. Der Margin wird nicht in die Größe des Controls hineingerechnet. Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. MaxSize Gibt die maximale Größe des Controls an. Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin. Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. MinSize Gibt die minimale Größe des Controls an.Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin.Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. Padding Gibt den inneren Rand des Controls – also den Abstand des Control-Inhalts zur Border an.Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. SearchOperator Gibt an, mit welchem Operator sich das Control in die Load-Condition eintragen soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) TabStop Wenn dieses Property den Wert true besitzt, wird das Steuerelement bei der Fokustraversierung mittels Tastatur erfasst. Ist es auf false , so wird das Steuerelement bei der Tab-Reihenfolge überspringen. Der Standardwert für die Eigenschaft ist true . TooltipText Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Control, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Visibility Steuert die Sichtbarkeit des Controls. Über die Control-Action SetVisible(Nullable<FSVisibility>) kann die Eigenschaft zur Laufzeit geändert werden. Events OnCanDrop !TODO OnDrag !TODO OnEnter Wird beim setzen des Fokus auf ein Control ausgelöst. OnLeave Wird beim Entfernen des Fokus von einem Control ausgelöst. Wenn sich der Wert des Controls geändert hat, wird vor diesem Event das Event OnValidated ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable IsEditable Wenn hier true gesetzt ist, ist das Control editierbar. Ansonsten ist das Control für Eingaben gesperrt. Über die Action SetEnabled(Nullable<Boolean>) kann das Control zur Laufzeit gesperrt werden. Declaration [Browsable(true)] public virtual bool? IsEditable { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditableAU.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditableAU.html",
    "title": "Property IsEditableAU",
    "keywords": "Property IsEditableAU IsEditableAU Das IsEditable Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU ) Declaration [Browsable(true)] public virtual AccessUnitList IsEditableAU { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.AUList.AccessUnitList"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsSearchField.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsSearchField.html",
    "title": "Property IsSearchField",
    "keywords": "Property IsSearchField IsSearchField Soll sich das Control in die automatisch generierte Load-Condition eintragen, muss dieses Property auf True gesetzt werden. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [Browsable(true)] public bool? IsSearchField { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsVisibleAU.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsVisibleAU.html",
    "title": "Property IsVisibleAU",
    "keywords": "Property IsVisibleAU IsVisibleAU Das IsVisible Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU ) Declaration [Browsable(true)] public virtual AccessUnitList IsVisibleAU { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.AUList.AccessUnitList"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.LabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.LabelTemplate.html",
    "title": "Property LabelTemplate",
    "keywords": "Property LabelTemplate LabelTemplate Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ControlLabelTemplate LabelTemplate { get; set; } Property Value ControlLabelTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Margin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Margin.html",
    "title": "Property Margin",
    "keywords": "Property Margin Margin Gibt den äußeren Rand um das Control herum an. Der Margin wird nicht in die Größe des Controls hineingerechnet. Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Bounds Margin { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize MaxSize Gibt die maximale Größe des Controls an. Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin. Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public NonableSize MaxSize { get; set; } Property Value NonableSize Remarks Der spezielle Wert None definiert keine Angabe der Größe. Er muss vom Wert 0 unterschieden werden – damit wird das Control nicht angezeigt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MinSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MinSize.html",
    "title": "Property MinSize",
    "keywords": "Property MinSize MinSize Gibt die minimale Größe des Controls an.Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin.Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public NonableSize MinSize { get; set; } Property Value NonableSize Remarks Der spezielle Wert None definiert keine Angabe der Größe.Er muss vom Wert 0 unterschieden werden."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnCanDrop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnCanDrop.html",
    "title": "Event OnCanDrop",
    "keywords": "Event OnCanDrop !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnCanDropEventArgs> OnCanDrop Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnCanDropEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnDrag.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnDrag.html",
    "title": "Event OnDrag",
    "keywords": "Event OnDrag !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnDragEventArgs> OnDrag Returns Type Description EventHandler < FrameworkOnDragEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnEnter.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnEnter.html",
    "title": "Event OnEnter",
    "keywords": "Event OnEnter Wird beim setzen des Fokus auf ein Control ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnEnter Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnLeave.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnLeave.html",
    "title": "Event OnLeave",
    "keywords": "Event OnLeave Wird beim Entfernen des Fokus von einem Control ausgelöst. Wenn sich der Wert des Controls geändert hat, wird vor diesem Event das Event OnValidated ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLeaveEventArgs> OnLeave Returns Type Description EventHandler < FrameworkOnLeaveEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding Padding Gibt den inneren Rand des Controls – also den Abstand des Control-Inhalts zur Border an.Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.SearchOperator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.SearchOperator.html",
    "title": "Property SearchOperator",
    "keywords": "Property SearchOperator SearchOperator Gibt an, mit welchem Operator sich das Control in die Load-Condition eintragen soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [Browsable(true)] public SearchCompareOperator? SearchOperator { get; set; } Property Value Nullable < SearchCompareOperator >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TabStop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TabStop.html",
    "title": "Property TabStop",
    "keywords": "Property TabStop TabStop Wenn dieses Property den Wert true besitzt, wird das Steuerelement bei der Fokustraversierung mittels Tastatur erfasst. Ist es auf false , so wird das Steuerelement bei der Tab-Reihenfolge überspringen. Der Standardwert für die Eigenschaft ist true . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? TabStop { get; set; } Property Value Nullable < Boolean > Remarks Sie ist nicht Theme-fähig und kann an allen Steuerelementen mit Ausnahme der folgenden gesetzt werden: Alle Container-Steuerelemente Grid Columns Labels Pictures Tree View Columns Tree View Nodes Menus Custom Controls"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TooltipText.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TooltipText.html",
    "title": "Property TooltipText",
    "keywords": "Property TooltipText TooltipText Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Control, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [ControlStylesBrowsable(true)] public IMLString TooltipText { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Visibility.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Visibility.html",
    "title": "Property Visibility",
    "keywords": "Property Visibility Visibility Steuert die Sichtbarkeit des Controls. Über die Control-Action SetVisible(Nullable<FSVisibility>) kann die Eigenschaft zur Laufzeit geändert werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public FSVisibility? Visibility { get; set; } Property Value Nullable < FSVisibility >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.BorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.BorderThickness.html",
    "title": "Property BorderThickness",
    "keywords": "Property BorderThickness BorderThickness Dieses Property weicht zu den allgemeinen Properties ab. Die Border wird, wie beim TabbedWindow, um die Tab-Pages des Dash-Boards gezeichnet. (Siehe BorderThickness ) Declaration public override Bounds BorderThickness { get; set; } Property Value Bounds Overrides ControlDesignViewModel.BorderThickness"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.Columns.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.Columns.html",
    "title": "Property Columns",
    "keywords": "Property Columns Columns !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? Columns { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentBackColor.html",
    "title": "Property ContentBackColor",
    "keywords": "Property ContentBackColor ContentBackColor Die Hintergrund-Farbe in den Tab-Pages des Dash-Boards. Das Property BackColor hingegen zieht außerhalb der Tab-Pages - u.a. in dem Bereich um die Registerkarte-Karten. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Color ContentBackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentPadding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentPadding.html",
    "title": "Property ContentPadding",
    "keywords": "Property ContentPadding ContentPadding Der Abstand der Dash-Items zum Rand der Tab-Page. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Bounds ContentPadding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.html",
    "title": "Class DashBoardContainerViewModel",
    "keywords": "Class DashBoardContainerViewModel Diese Klasse repräsentiert das Control DashboardContainer . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel DashBoardContainerViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class DashBoardContainerViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties BorderThickness Dieses Property weicht zu den allgemeinen Properties ab. Die Border wird, wie beim TabbedWindow, um die Tab-Pages des Dash-Boards gezeichnet. (Siehe BorderThickness ) Columns !TODO ContentBackColor Die Hintergrund-Farbe in den Tab-Pages des Dash-Boards. Das Property BackColor hingegen zieht außerhalb der Tab-Pages - u.a. in dem Bereich um die Registerkarte-Karten. ContentPadding Der Abstand der Dash-Items zum Rand der Tab-Page. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin . ItemBorderColor Gibt die Farbe des Rahmens um die Dash-Items an. Diese Eigenschaft kann im Default-Control-Style theme-spezifisch angegeben werden. ItemBorderMargin Gibt die Dicke des (transparenten) Randes für jedes Dash-Item an. Dieser wird außerhalb des colorierten Rahmen angezeigt. Der Standard-Wert ist 2 . ItemBorderThickness Gibt die Dicke des farbigen Rahmens um jedes Dash-Item an. Zum Ausblenden des Rahmens kann der Wert 0 angegeben werden. Der Standard-Wert ist 3 . ItemGap Gibt den horizontalen und vertikalen Abstand zwischen den Dash-Items an. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin . Standard-Wert und bisheriges Verhalten ist 0 TabTemplateActive Hier werden die Layout-Einstellungen der aktiven Registerkarte vorgenommen. TabTemplateInactive Hier werden die Layout-Einstellungen der inaktiven Registerkarte vorgenommen. TooltipAddColumn !TODO TooltipAddPage !TODO TooltipCloseDashItem !TODO TooltipClosePage !TODO TooltipCollapseDashItem !TODO TooltipExpandDashItem !TODO TooltipMaximzeDashItem !TODO TooltipMoveDashItem !TODO TooltipRemoveColumn !TODO TooltipRestoreDashItem !TODO Events OnLayoutChanged !TODO See Also DashboardContainerControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderColor.html",
    "title": "Property ItemBorderColor",
    "keywords": "Property ItemBorderColor ItemBorderColor Gibt die Farbe des Rahmens um die Dash-Items an. Diese Eigenschaft kann im Default-Control-Style theme-spezifisch angegeben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Color ItemBorderColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderMargin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderMargin.html",
    "title": "Property ItemBorderMargin",
    "keywords": "Property ItemBorderMargin ItemBorderMargin Gibt die Dicke des (transparenten) Randes für jedes Dash-Item an. Dieser wird außerhalb des colorierten Rahmen angezeigt. Der Standard-Wert ist 2 . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? ItemBorderMargin { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderThickness.html",
    "title": "Property ItemBorderThickness",
    "keywords": "Property ItemBorderThickness ItemBorderThickness Gibt die Dicke des farbigen Rahmens um jedes Dash-Item an. Zum Ausblenden des Rahmens kann der Wert 0 angegeben werden. Der Standard-Wert ist 3 . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? ItemBorderThickness { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemGap.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemGap.html",
    "title": "Property ItemGap",
    "keywords": "Property ItemGap ItemGap Gibt den horizontalen und vertikalen Abstand zwischen den Dash-Items an. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin . Standard-Wert und bisheriges Verhalten ist 0 Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? ItemGap { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.OnLayoutChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.OnLayoutChanged.html",
    "title": "Event OnLayoutChanged",
    "keywords": "Event OnLayoutChanged !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnLayoutChanged Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateActive.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateActive.html",
    "title": "Property TabTemplateActive",
    "keywords": "Property TabTemplateActive TabTemplateActive Hier werden die Layout-Einstellungen der aktiven Registerkarte vorgenommen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TabTemplate TabTemplateActive { get; } Property Value TabTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateInactive.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateInactive.html",
    "title": "Property TabTemplateInactive",
    "keywords": "Property TabTemplateInactive TabTemplateInactive Hier werden die Layout-Einstellungen der inaktiven Registerkarte vorgenommen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TabTemplate TabTemplateInactive { get; } Property Value TabTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipAddColumn.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipAddColumn.html",
    "title": "Property TooltipAddColumn",
    "keywords": "Property TooltipAddColumn TooltipAddColumn !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipAddColumn { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipAddPage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipAddPage.html",
    "title": "Property TooltipAddPage",
    "keywords": "Property TooltipAddPage TooltipAddPage !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipAddPage { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipCloseDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipCloseDashItem.html",
    "title": "Property TooltipCloseDashItem",
    "keywords": "Property TooltipCloseDashItem TooltipCloseDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipCloseDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipClosePage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipClosePage.html",
    "title": "Property TooltipClosePage",
    "keywords": "Property TooltipClosePage TooltipClosePage !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipClosePage { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipCollapseDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipCollapseDashItem.html",
    "title": "Property TooltipCollapseDashItem",
    "keywords": "Property TooltipCollapseDashItem TooltipCollapseDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipCollapseDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipExpandDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipExpandDashItem.html",
    "title": "Property TooltipExpandDashItem",
    "keywords": "Property TooltipExpandDashItem TooltipExpandDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipExpandDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipMaximzeDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipMaximzeDashItem.html",
    "title": "Property TooltipMaximzeDashItem",
    "keywords": "Property TooltipMaximzeDashItem TooltipMaximzeDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipMaximzeDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipMoveDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipMoveDashItem.html",
    "title": "Property TooltipMoveDashItem",
    "keywords": "Property TooltipMoveDashItem TooltipMoveDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipMoveDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipRemoveColumn.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipRemoveColumn.html",
    "title": "Property TooltipRemoveColumn",
    "keywords": "Property TooltipRemoveColumn TooltipRemoveColumn !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipRemoveColumn { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipRestoreDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipRestoreDashItem.html",
    "title": "Property TooltipRestoreDashItem",
    "keywords": "Property TooltipRestoreDashItem TooltipRestoreDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipRestoreDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.DockPanelOrientation.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.DockPanelOrientation.html",
    "title": "Property DockPanelOrientation",
    "keywords": "Property DockPanelOrientation DockPanelOrientation Horizontal: Die Controls werden nebeneinander platziert. Vertical: Die Controls werden übereinander platziert. HorizontalOrVertical: Die Controls werden nebeneinander platziert. Reicht der Platz nicht aus, „klappt“ das DockPanel auf die Seite und die Controls werden übereinander platziert. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public DockPanelOrientation? DockPanelOrientation { get; set; } Property Value Nullable < DockPanelOrientation >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.html",
    "title": "Class DockPanelDesignViewModel",
    "keywords": "Class DockPanelDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LayoutContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.SpaceableContainerDesignViewModel DockPanelDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class DockPanelDesignViewModel : SpaceableContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties DockPanelOrientation Horizontal: Die Controls werden nebeneinander platziert. Vertical: Die Controls werden übereinander platziert. HorizontalOrVertical: Die Controls werden nebeneinander platziert. Reicht der Platz nicht aus, „klappt“ das DockPanel auf die Seite und die Controls werden übereinander platziert."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Gibt an, mit welcher Membervariable oder welchem Property das Editfield verbunden werden soll. Handelt es sich beim Datasource um ein schreibgeschütztes Property, wird das Property IsEditable auf False gesetzt und lässt sich nicht mehr ändern. Es sind Membervariablen oder Properties vom Typ String, Number (int, short, long...), Date, Boolean möglich. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Editor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Editor.html",
    "title": "Property Editor",
    "keywords": "Property Editor Editor !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TextEditorType? Editor { get; set; } Property Value Nullable < TextEditorType >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Format.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Format !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public FrameworkFormatMask? Format { get; set; } Property Value Nullable < FrameworkFormatMask >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern FormatPattern !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string FormatPattern { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.html",
    "title": "Class EditboxDesignViewModel",
    "keywords": "Class EditboxDesignViewModel Diese Klasse repräsentiert das Control EditField . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel EditboxDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class EditboxDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties DataSource Gibt an, mit welcher Membervariable oder welchem Property das Editfield verbunden werden soll. Handelt es sich beim Datasource um ein schreibgeschütztes Property, wird das Property IsEditable auf False gesetzt und lässt sich nicht mehr ändern. Es sind Membervariablen oder Properties vom Typ String, Number (int, short, long...), Date, Boolean möglich. Editor !TODO Format !TODO FormatPattern !TODO Multiline Gibt an, ob es sich bei dem Editfield um ein Multiline-Field handelt. Wenn ja, sind mehrzeilige Texteingaben und -anzeigen möglich. PasswordChar Hier kann ein Zeichen angegeben werden, das bei einer Passworteingabe als Platzhalter angezeigt werden soll, z.B. *. ScrollBars Gibt an, ob in dem Editfield Scrollbars angezeigt werden sollen. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. SelectionEnd Die Endposition der Textauswahl SelectionStart Die Startposition der Textauswahl TextAlign Gibt an, wie der Text im Editfield ausgerichtet sein soll. Bei Inherit wird die Angabe aus dem Default-Style gezogen. Bei DatatypeDefault werden Strings links und Datum und Nummern rechts ausgerichtet. WordWrap Gibt an, ob der automatische Zeilenumbruch aktiviert werden soll. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. Events OnValidated Tritt ein, wenn der Fokus von dem Editfeld genommen wird und der Wert geändert wurde. Nach diesem Event wird das OnLeave Event mit Parameter HasValueChanged = true ausgelöst. See Also EditboxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Multiline.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Multiline.html",
    "title": "Property Multiline",
    "keywords": "Property Multiline Multiline Gibt an, ob es sich bei dem Editfield um ein Multiline-Field handelt. Wenn ja, sind mehrzeilige Texteingaben und -anzeigen möglich. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? Multiline { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.OnValidated.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.OnValidated.html",
    "title": "Event OnValidated",
    "keywords": "Event OnValidated Tritt ein, wenn der Fokus von dem Editfeld genommen wird und der Wert geändert wurde. Nach diesem Event wird das OnLeave Event mit Parameter HasValueChanged = true ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnValidated Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.PasswordChar.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.PasswordChar.html",
    "title": "Property PasswordChar",
    "keywords": "Property PasswordChar PasswordChar Hier kann ein Zeichen angegeben werden, das bei einer Passworteingabe als Platzhalter angezeigt werden soll, z.B. *. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public char PasswordChar { get; set; } Property Value Char"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.ScrollBars.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.ScrollBars.html",
    "title": "Property ScrollBars",
    "keywords": "Property ScrollBars ScrollBars Gibt an, ob in dem Editfield Scrollbars angezeigt werden sollen. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [DevBrowsable(true)] public ScrollBars? ScrollBars { get; set; } Property Value Nullable < ScrollBars >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionEnd.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionEnd.html",
    "title": "Property SelectionEnd",
    "keywords": "Property SelectionEnd SelectionEnd Die Endposition der Textauswahl Declaration [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectionEnd { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionStart.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionStart.html",
    "title": "Property SelectionStart",
    "keywords": "Property SelectionStart SelectionStart Die Startposition der Textauswahl Declaration [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectionStart { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign TextAlign Gibt an, wie der Text im Editfield ausgerichtet sein soll. Bei Inherit wird die Angabe aus dem Default-Style gezogen. Bei DatatypeDefault werden Strings links und Datum und Nummern rechts ausgerichtet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public DevTextAlign? TextAlign { get; set; } Property Value Nullable < DevTextAlign >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.WordWrap.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.WordWrap.html",
    "title": "Property WordWrap",
    "keywords": "Property WordWrap WordWrap Gibt an, ob der automatische Zeilenumbruch aktiviert werden soll. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? WordWrap { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.html",
    "title": "Class FieldPanelDesignViewModel",
    "keywords": "Class FieldPanelDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LayoutContainerDesignViewModel FieldPanelDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class FieldPanelDesignViewModel : LayoutContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties RowLabelTemplate Jede FieldRow besitzt als erstes Control einen “RowLabel-Container”. In ihm wird das erste Control-Label(bzw.beim LabelMode NoneAligned das erste Control der FieldRow) platziert. Hier werden die Einstellungen für diesen RowLabel-Container vorgenommen.Die Einstellungen für die Control-Labels werden an den LabelTemplates der jeweiligen Controls vorgenommen. Mit MinSize und MaxSize kann die Größe des RowLabel-Containers definiert werden.So können die Labels ausgerichtet werden. Beim LabelMode GeneratedMerged werden alle Control-Labels nebeneinander in dem Container platziert.Zwischen den Labels wird ein Separator in Form eines Slash “/” angezeigt.Dessen Layout kann über die Separator-Eigenschaften des RowLabelTemplates gesteuert werden. SynchronizeColumns Ist dieser Schalter gesetzt, dann werden die Controls in den FieldRows in Form einer Tabelle angeordnet. Dabei belegen jedes Control und jedes Control-Label genau eine Zelle dieser Tabelle."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.RowLabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.RowLabelTemplate.html",
    "title": "Property RowLabelTemplate",
    "keywords": "Property RowLabelTemplate RowLabelTemplate Jede FieldRow besitzt als erstes Control einen “RowLabel-Container”. In ihm wird das erste Control-Label(bzw.beim LabelMode NoneAligned das erste Control der FieldRow) platziert. Hier werden die Einstellungen für diesen RowLabel-Container vorgenommen.Die Einstellungen für die Control-Labels werden an den LabelTemplates der jeweiligen Controls vorgenommen. Mit MinSize und MaxSize kann die Größe des RowLabel-Containers definiert werden.So können die Labels ausgerichtet werden. Beim LabelMode GeneratedMerged werden alle Control-Labels nebeneinander in dem Container platziert.Zwischen den Labels wird ein Separator in Form eines Slash “/” angezeigt.Dessen Layout kann über die Separator-Eigenschaften des RowLabelTemplates gesteuert werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public RowLabelTemplate RowLabelTemplate { get; set; } Property Value RowLabelTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.SynchronizeColumns.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.SynchronizeColumns.html",
    "title": "Property SynchronizeColumns",
    "keywords": "Property SynchronizeColumns SynchronizeColumns Ist dieser Schalter gesetzt, dann werden die Controls in den FieldRows in Form einer Tabelle angeordnet. Dabei belegen jedes Control und jedes Control-Label genau eine Zelle dieser Tabelle. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? SynchronizeColumns { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.FieldRowSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.FieldRowSize.html",
    "title": "Property FieldRowSize",
    "keywords": "Property FieldRowSize FieldRowSize Wird das FieldPanel vertikal gestretched, dann kann über die FieldRowSize das Verhältnis angegeben warden, mit dem sich die einzelnen FieldRows vergrößern sollen. Bei der Angabe von None wird die FieldRow mit ihrer minimalen Höhe dargestellt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] public Nonable<int>? FieldRowSize { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.html",
    "title": "Class FieldRowDesignViewModel",
    "keywords": "Class FieldRowDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FieldRowDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class FieldRowDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties FieldRowSize Wird das FieldPanel vertikal gestretched, dann kann über die FieldRowSize das Verhältnis angegeben warden, mit dem sich die einzelnen FieldRows vergrößern sollen. Bei der Angabe von None wird die FieldRow mit ihrer minimalen Höhe dargestellt. LabelMode Über die Eigenschaft LabelMode können Sie einstellen, wie für die Controls die Labels generiert werden sollen. OptimizeGeneratedLabels Über diese Eigenschaft können von mehreren Labels redundante Worte zusammengefasst werden. Diese Einstelllung funktioniert sowohl im LabelMode Generated als auch GeneratedMerged ."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.LabelMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.LabelMode.html",
    "title": "Property LabelMode",
    "keywords": "Property LabelMode LabelMode Über die Eigenschaft LabelMode können Sie einstellen, wie für die Controls die Labels generiert werden sollen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public FieldRowLabelMode? LabelMode { get; set; } Property Value Nullable < FieldRowLabelMode >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.OptimizeGeneratedLabels.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.OptimizeGeneratedLabels.html",
    "title": "Property OptimizeGeneratedLabels",
    "keywords": "Property OptimizeGeneratedLabels OptimizeGeneratedLabels Über diese Eigenschaft können von mehreren Labels redundante Worte zusammengefasst werden. Diese Einstelllung funktioniert sowohl im LabelMode Generated als auch GeneratedMerged . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? OptimizeGeneratedLabels { get; set; } Property Value Nullable < Boolean > Examples • Artikelnr von; Artikelnr bis -> Artikelnr von / bis • von Datum; bis Datum -> von / bis Datum"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FormContainerDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FormContainerDesignViewModel.html",
    "title": "Class FormContainerDesignViewModel",
    "keywords": "Class FormContainerDesignViewModel Diese Klasse repräsentiert das Control FormContainer . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel FormContainerDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class FormContainerDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord See Also FormContainerControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Gibt das Label der Spalte in den definierten Sprachen an. Die Caption wird über das Property ermittelt und kann überschrieben werden. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.DependsDataSourceOnRowData.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.DependsDataSourceOnRowData.html",
    "title": "Property DependsDataSourceOnRowData",
    "keywords": "Property DependsDataSourceOnRowData DependsDataSourceOnRowData Ist als EditorStyle Combobox ausgewählt, können Sie im Property List einen DataSource für die Liste angeben. Dieses Property gibt an, ob sich die Liste auf ein Property des Collection-Objekts beziehen soll ( True ) oder nicht ( False ). Wenn True angegeben wird, werden unter List die Properties des Collection-Objekts angeboten. In diesem Fall wird für jede Zeile des Grids eine eigene Liste erstellt. Wenn False angegeben wurde, werden in List die Membervariablen des Forms angeboten. Es wird eine Liste für alle Zeilen des Grids erstellt. Declaration public bool? DependsDataSourceOnRowData { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditorStyle.html",
    "title": "Property EditorStyle",
    "keywords": "Property EditorStyle EditorStyle Bei Editfield wird die Spalte als ganz normales Eingabefeld dargestellt. Bei Checkbox wird in der Spalte eine Checkbox dargestellt. Ist der Wert der Spalte true oder 1 , wird die Checkbox gesetzt. Ist der Wert false oder 0 , wird die Checkbox nicht gesetzt. Bei Combobox wird die Spalte als Combobox dargestellt. Es müssen dazu noch weitere Einstellungen bei den Properties DependsDataSourceOnRowData und List vorgenommen werden. Declaration [ControlStylesBrowsable(true)] public EditorStyle? EditorStyle { get; set; } Property Value Nullable < EditorStyle >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle EditStyle !TODO Declaration [Browsable(true)] public ComboEditStyle? EditStyle { get; set; } Property Value Nullable < ComboEditStyle >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Format.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Format Eingabedatentyp. Wird hier ein Format angegeben, lassen die Felder nur die Eingabe von Zeichen zu, die diesem Format entsprechen. Declaration [ControlStylesBrowsable(true)] public FrameworkFormatMask? Format { get; set; } Property Value Nullable < FrameworkFormatMask >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern FormatPattern !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string FormatPattern { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.html",
    "title": "Class GridColDesignViewModel",
    "keywords": "Class GridColDesignViewModel Diese Klasse repräsentiert das Control Grid-Column . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel GridColDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class GridColDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Gibt das Label der Spalte in den definierten Sprachen an. Die Caption wird über das Property ermittelt und kann überschrieben werden. DependsDataSourceOnRowData Ist als EditorStyle Combobox ausgewählt, können Sie im Property List einen DataSource für die Liste angeben. Dieses Property gibt an, ob sich die Liste auf ein Property des Collection-Objekts beziehen soll ( True ) oder nicht ( False ). Wenn True angegeben wird, werden unter List die Properties des Collection-Objekts angeboten. In diesem Fall wird für jede Zeile des Grids eine eigene Liste erstellt. Wenn False angegeben wurde, werden in List die Membervariablen des Forms angeboten. Es wird eine Liste für alle Zeilen des Grids erstellt. EditorStyle Bei Editfield wird die Spalte als ganz normales Eingabefeld dargestellt. Bei Checkbox wird in der Spalte eine Checkbox dargestellt. Ist der Wert der Spalte true oder 1 , wird die Checkbox gesetzt. Ist der Wert false oder 0 , wird die Checkbox nicht gesetzt. Bei Combobox wird die Spalte als Combobox dargestellt. Es müssen dazu noch weitere Einstellungen bei den Properties DependsDataSourceOnRowData und List vorgenommen werden. EditStyle !TODO Format Eingabedatentyp. Wird hier ein Format angegeben, lassen die Felder nur die Eingabe von Zeichen zu, die diesem Format entsprechen. FormatPattern !TODO List Macht nur Sinn, wenn als EditorStyle Combobox ausgewählt ist. Gibt den Datasource an, aus welchem die Daten für die Liste gezogen werden sollen (analog zur Combobox ). MaxDropDownSize !TODO Gibt an, die maximale Höre der DropDown-Listes. MaxWidth Maximale Breite der Column in Pixel. MinWidth Minimale Breite der Column in Pixel. Name Zeigt den Namen der Column an. Der Name wird generiert und kann nicht geändert werden. Er setzt sich zusammen aus der Bezeichnung des Grids und des Property-Namen, der die Spalte repräsentiert, verbunden durch einen Unterstrich _ . Heißt das Grid grdCustomer würde die Column lngCustomerID z.B. grdCustomer_lngCustomerID heißen. ( schreibgeschützt ) Property !TODO TextAlign Gibt an, wie der Text in der Column ausgerichtet werden soll (links, rechts oder zentriert). Ist DatatypeDefault angegeben, werden Zahlen und Daten rechts und Text links ausgerichtet. Events OnCellValidate !TODO OnEditingStarting Dieses Ereignis wird ausgelöst, sobald eine Zelle vom Nutzer bearbeitet wird. Bei der Verarbeitung dieses Events dürfen keine Dialoge geöffnet werden. OnEditingStopped Dieses Ereignis ist das Gegenstück zu OnEditingStarting. Es tritt auf, wenn der Benutzer die Bearbeitung einer Zelle beendet. Auch hier sollten keine Dialoge geöffnet werden. See Also GridColumnControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.List.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.List.html",
    "title": "Property List",
    "keywords": "Property List List Macht nur Sinn, wenn als EditorStyle Combobox ausgewählt ist. Gibt den Datasource an, aus welchem die Daten für die Liste gezogen werden sollen (analog zur Combobox ). Declaration [DevBrowsable(true)] [TypeConverter(typeof(DataBindingConverter))] public ListDataSource List { get; set; } Property Value ListDataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxDropDownSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxDropDownSize.html",
    "title": "Property MaxDropDownSize",
    "keywords": "Property MaxDropDownSize MaxDropDownSize !TODO Gibt an, die maximale Höre der DropDown-Listes. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Size? MaxDropDownSize { get; set; } Property Value Nullable < Size >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxWidth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxWidth.html",
    "title": "Property MaxWidth",
    "keywords": "Property MaxWidth MaxWidth Maximale Breite der Column in Pixel. Declaration [ControlStylesBrowsable(true)] [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] public Nonable<int>? MaxWidth { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MinWidth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MinWidth.html",
    "title": "Property MinWidth",
    "keywords": "Property MinWidth MinWidth Minimale Breite der Column in Pixel. Declaration [ControlStylesBrowsable(true)] [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] public Nonable<int>? MinWidth { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Name.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Name Zeigt den Namen der Column an. Der Name wird generiert und kann nicht geändert werden. Er setzt sich zusammen aus der Bezeichnung des Grids und des Property-Namen, der die Spalte repräsentiert, verbunden durch einen Unterstrich _ . Heißt das Grid grdCustomer würde die Column lngCustomerID z.B. grdCustomer_lngCustomerID heißen. ( schreibgeschützt ) Declaration public override string Name { get; set; } Property Value String Overrides ControlTreeNode.Name"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnCellValidate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnCellValidate.html",
    "title": "Event OnCellValidate",
    "keywords": "Event OnCellValidate !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnCellValidateEventArgs> OnCellValidate Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnCellValidateEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStarting.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStarting.html",
    "title": "Event OnEditingStarting",
    "keywords": "Event OnEditingStarting Dieses Ereignis wird ausgelöst, sobald eine Zelle vom Nutzer bearbeitet wird. Bei der Verarbeitung dieses Events dürfen keine Dialoge geöffnet werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkCellCancelEventArgs> OnEditingStarting Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellCancelEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStopped.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStopped.html",
    "title": "Event OnEditingStopped",
    "keywords": "Event OnEditingStopped Dieses Ereignis ist das Gegenstück zu OnEditingStarting. Es tritt auf, wenn der Benutzer die Bearbeitung einer Zelle beendet. Auch hier sollten keine Dialoge geöffnet werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkCellEventArgs> OnEditingStopped Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Property.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Property.html",
    "title": "Property Property",
    "keywords": "Property Property Property !TODO Declaration [Browsable(true)] [TypeConverter(typeof(GridColRecordsConverter))] public PropertiesRecord Property { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Component.Properties.PropertiesRecord"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign TextAlign Gibt an, wie der Text in der Column ausgerichtet werden soll (links, rechts oder zentriert). Ist DatatypeDefault angegeben, werden Zahlen und Daten rechts und Text links ausgerichtet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public DevTextAlign? TextAlign { get; set; } Property Value Nullable < DevTextAlign >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.BackColor2.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.BackColor2.html",
    "title": "Property BackColor2",
    "keywords": "Property BackColor2 BackColor2 Bestimmt die zeilenweise alternierende Hintergrundfarbe einer Tabelle. Für den Hintergrund der Grid-Zeilen wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Grid-Zeilen die BackColor verwendet Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor2 { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Gibt den Datasource an, dessen Daten im Grid angezeigt werden sollen. Es ist wichtig, dass Sie hier eine Collection angeben. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridColor.html",
    "title": "Property GridColor",
    "keywords": "Property GridColor GridColor !TODO Farbe der Tabellenteiler Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color GridColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridRowHeight.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridRowHeight.html",
    "title": "Property GridRowHeight",
    "keywords": "Property GridRowHeight GridRowHeight Definiert die Höhe einer Zeile. Die Angabe erfolgt in Pixeln. Wenn kein Wert angegeben ist, dann berechnet der Client die Höhe der Zeile anhand der Schriftart. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? GridRowHeight { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.HeaderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.HeaderColor.html",
    "title": "Property HeaderColor",
    "keywords": "Property HeaderColor HeaderColor !TODO Gibt an, die Hintergrundfarbe der Tabellenüberschrift. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color HeaderColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.html",
    "title": "Class GridDesignViewModel",
    "keywords": "Class GridDesignViewModel Diese Klasse repräsentiert das Control Grid . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel GridDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class GridDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties BackColor2 Bestimmt die zeilenweise alternierende Hintergrundfarbe einer Tabelle. Für den Hintergrund der Grid-Zeilen wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Grid-Zeilen die BackColor verwendet DataSource Gibt den Datasource an, dessen Daten im Grid angezeigt werden sollen. Es ist wichtig, dass Sie hier eine Collection angeben. GridColor !TODO Farbe der Tabellenteiler GridRowHeight Definiert die Höhe einer Zeile. Die Angabe erfolgt in Pixeln. Wenn kein Wert angegeben ist, dann berechnet der Client die Höhe der Zeile anhand der Schriftart. HeaderColor !TODO Gibt an, die Hintergrundfarbe der Tabellenüberschrift. IsEditable Gibt an, ob am Grid Daten geändert werden dürfen. Ist IsEditable auf False gesetzt, wirkt sichdas auf alle Columns aus – egal, was dort angegeben ist. MainMemorySortingThreshold Grids bieten grundsätzlich die Möglichkeit, die dargestellten Daten nach einer Spalte zu sortieren oder zu filtern. Dazu stehen zwei Mechanismen ( Datenbanksortierung und Hauptspeichersortierung ) zur Verfügung. Multiselect Gibt an, ob mehrere Zeilen ausgewählt werden können. Bei False kann nur maximal eine Zeile ausgewählt werden. Bei True ist die Auswahl mehrerer Zeilen möglich. Welche Zeilen ausgewählt sind, lässt sich in der SelectRowsCollection auswerten und setzen (siehe Property SelectedRows ). NewRowIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile neu hinzugefügt wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert New hat. RowChangedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile geändert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert Changed hat. RowDeletedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile zum Löschen markiert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property StateBeforeUpdate den Wert true hat. RowHeader Bestimmt, ob im Row-Header die Zeilennummer oder der Status des Rows angezeigt wird. RowHeaderWidth Höhe der Spalten. SelectedRows Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Zeilen im Grid markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. ShowHorizontalLines Gibt an, ob die horizontalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. ShowVerticalLines Gibt an, ob die vertikalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. TransferReloadRowCount Definiert, wie viele Zeilen nachgelesen werden, wenn in der Tabelle in den entsprechenden Bereich gescrollt wurde. Bei 0 werden alle Zeilen zurückgegeben. TransferStartupRowCount Definiert, wie viele Zeilen bei einem Load zunächst an den Client zurückgegeben werden. Bei 0 werden alle Zeilen zurückgegeben. Es wird nicht empfohlen, sich standardmäßig alle Zeilen zurückgeben zu lassen, da dies bei großen Datenmengen zu starker Belastung des Clients und des Webservers kommt. Es ist deshalb besser, sich zunächst einen Block zurückgeben zu lassen und bei Bedarf die Daten dynamisch nachlesen zu lassen. Events OnAppendNewRow Dieser Vorgang wird ausgelöst, wenn in der letzten Zeile im letzten editierbaren Feld die Tab-Taste gedrückt wird. OnCellDoubleClick Tritt auf, wenn doppelt in eine Gridzelle (nicht RowHeader und nicht ColumnHeader) geklickt wurde. Das Event Argument stellt Spaltennummer ( ColNum ) und Datensatznummer ( RowID ) zur Verfügung. OnColumnChanged Wird ausgelöst, wenn sich der Inhalt einer Spalte geändert hat. Sie können über das EventArg e.RowID das Objekt ermitteln, bei dem das Event aufgetreten ist. OnGridCornerClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte in die linke, obere Ecke geklickt wurde. OnGridCornerDoubleClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte doppelt in die linke, obere Ecke geklickt wurde. OnRowClick Tritt auf, wenn auf die Zeile geklickt wurde. OnRowDoubleClick Tritt auf, wenn auf die Zeile doppelt geklickt wurde. OnRowSelectionChanged Tritt auf, wenn sich die Selektion im Grid ändert - auch bei Deselektion von Datensätzen. Wenn dem Grid eine SelectedRowsCollection zugeordnet ist, wird diese durch das Event aktualisiert. OnRowsReloadEntry Tritt auf, wenn Grid-Zeilen erstmalig an den Client übertragen werden, sowohl bei der initialien Übertragung als auch beim Nachladen von Zeilen. OnTableValidate !TODO See Also GridControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable IsEditable Gibt an, ob am Grid Daten geändert werden dürfen. Ist IsEditable auf False gesetzt, wirkt sichdas auf alle Columns aus – egal, was dort angegeben ist. Declaration public override bool? IsEditable { get; set; } Property Value Nullable < Boolean > Overrides ControlDesignViewModel.IsEditable"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.MainMemorySortingThreshold.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.MainMemorySortingThreshold.html",
    "title": "Property MainMemorySortingThreshold",
    "keywords": "Property MainMemorySortingThreshold MainMemorySortingThreshold Grids bieten grundsätzlich die Möglichkeit, die dargestellten Daten nach einer Spalte zu sortieren oder zu filtern. Dazu stehen zwei Mechanismen ( Datenbanksortierung und Hauptspeichersortierung ) zur Verfügung. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? MainMemorySortingThreshold { get; set; } Property Value Nullable < Int32 > Remarks Hauptspeichersortierung: Vorteil: Schnell Es kann nach allen Eigenschaften sortiert werden Jederzeit möglich. Nachteil: Hoher Arbeitsspeicherverbrauch. Sortierung auf der Datenbank (Datenbanksortierung): Vorteil: Geringer Arbeitsspeicherverbrauch auch bei großen Datenmengen. Nachteil: Es kann nur nach Datenbankeigenschaften sortiert werden Etwas Langsamer Daten müssen in die Datenbank gespeichert worden sein Um die Vorteile beider Mechanismen nutzen zu können, verwendet Framework Studio beide Mechanismen, abhängig von der Menge der dargestellten Daten. Die Eigenschaft MainMemorySortingThreshold gibt den Grenzwert an, wieviele Datensätze die an das Grid gebundene Collection maximal enthalten darf, damit Hauptspeichersortierung verwendet wird. Werden Datensätze mit der Methode Add der Collection hinzugefügt, so wird der Grenzwert automatisch um die Anzahl hinzugefügter Datensätze erhöht. Wird die Eigenschaft nicht an einem Form Control geändert sondern direkt an einem Control Style, so müssen anschließend die Global Objects kompiliert werden, damit die Änderung wirksam wird."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.Multiselect.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.Multiselect.html",
    "title": "Property Multiselect",
    "keywords": "Property Multiselect Multiselect Gibt an, ob mehrere Zeilen ausgewählt werden können. Bei False kann nur maximal eine Zeile ausgewählt werden. Bei True ist die Auswahl mehrerer Zeilen möglich. Welche Zeilen ausgewählt sind, lässt sich in der SelectRowsCollection auswerten und setzen (siehe Property SelectedRows ). Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? Multiselect { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.NewRowIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.NewRowIcon.html",
    "title": "Property NewRowIcon",
    "keywords": "Property NewRowIcon NewRowIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile neu hinzugefügt wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert New hat. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string NewRowIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnAppendNewRow.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnAppendNewRow.html",
    "title": "Event OnAppendNewRow",
    "keywords": "Event OnAppendNewRow Dieser Vorgang wird ausgelöst, wenn in der letzten Zeile im letzten editierbaren Feld die Tab-Taste gedrückt wird. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnAppendNewRow Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnCellDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnCellDoubleClick.html",
    "title": "Event OnCellDoubleClick",
    "keywords": "Event OnCellDoubleClick Tritt auf, wenn doppelt in eine Gridzelle (nicht RowHeader und nicht ColumnHeader) geklickt wurde. Das Event Argument stellt Spaltennummer ( ColNum ) und Datensatznummer ( RowID ) zur Verfügung. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkCellDoubleClickEventArgs> OnCellDoubleClick Returns Type Description EventHandler < FrameworkCellDoubleClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnColumnChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnColumnChanged.html",
    "title": "Event OnColumnChanged",
    "keywords": "Event OnColumnChanged Wird ausgelöst, wenn sich der Inhalt einer Spalte geändert hat. Sie können über das EventArg e.RowID das Objekt ermitteln, bei dem das Event aufgetreten ist. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkColumnChangedEventArgs> OnColumnChanged Returns Type Description EventHandler < FrameworkColumnChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerClick.html",
    "title": "Event OnGridCornerClick",
    "keywords": "Event OnGridCornerClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte in die linke, obere Ecke geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnGridCornerClick Returns Type Description EventHandler < FrameworkEventArgs > Examples"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerDoubleClick.html",
    "title": "Event OnGridCornerDoubleClick",
    "keywords": "Event OnGridCornerDoubleClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte doppelt in die linke, obere Ecke geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnGridCornerDoubleClick Returns Type Description EventHandler < FrameworkEventArgs > Examples"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowClick.html",
    "title": "Event OnRowClick",
    "keywords": "Event OnRowClick Tritt auf, wenn auf die Zeile geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkDoubleClickEventArgs> OnRowClick Returns Type Description EventHandler < FrameworkDoubleClickEventArgs > Remarks Wenn eine Zeile einmal geklickt und dadurch selektiert wurde, wird bei einem erneuten Klick auf dieselbe Zeile kein weiteres OnRowClick-Event ausgelöst. So wird verhindert, dass das OnRowClick-Event für ein und dieselbe Zeile mehrfach hintereinander ausgelöst wird. Wenn dem Grid eine SelectedRowsCollection zugeordnet ist und auf Server-Seite die Selektion auf die zuletzt geklickte Zeile entfernt wird, dann wird bei einem erneuten Klick das Event wieder ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowDoubleClick.html",
    "title": "Event OnRowDoubleClick",
    "keywords": "Event OnRowDoubleClick Tritt auf, wenn auf die Zeile doppelt geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkDoubleClickEventArgs> OnRowDoubleClick Returns Type Description EventHandler < FrameworkDoubleClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowSelectionChanged.html",
    "title": "Event OnRowSelectionChanged",
    "keywords": "Event OnRowSelectionChanged Tritt auf, wenn sich die Selektion im Grid ändert - auch bei Deselektion von Datensätzen. Wenn dem Grid eine SelectedRowsCollection zugeordnet ist, wird diese durch das Event aktualisiert. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkSelectionChangedEventArgs> OnRowSelectionChanged Returns Type Description EventHandler < FrameworkSelectionChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowsReloadEntry.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowsReloadEntry.html",
    "title": "Event OnRowsReloadEntry",
    "keywords": "Event OnRowsReloadEntry Tritt auf, wenn Grid-Zeilen erstmalig an den Client übertragen werden, sowohl bei der initialien Übertragung als auch beim Nachladen von Zeilen. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnReloadEventArgs> OnRowsReloadEntry Returns Type Description EventHandler < FrameworkOnReloadEventArgs > Remarks Das Event Argument stellt zwei Listen zur Verfügung: RowList : Diese Liste enthält die Zeilennummern der betroffenen Datensätze. RowIDList : Diese Liste enthält die ObjectRowIDs der betroffenen Datensätze. Mit diesen kann der Datensatz direkt aus der Collection ermittelt werden (oMyColl[rowID]). Warning In diesem Event dürfen keine Daten manipuliert werden! Es eignet sich insbesondere für die Färbung oder das Deaktivieren von Gridzellen, abhängig von den dargestellten Daten."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnTableValidate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnTableValidate.html",
    "title": "Event OnTableValidate",
    "keywords": "Event OnTableValidate !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnTableValidateEventArgs> OnTableValidate Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnTableValidateEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowChangedIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowChangedIcon.html",
    "title": "Property RowChangedIcon",
    "keywords": "Property RowChangedIcon RowChangedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile geändert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert Changed hat. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string RowChangedIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowDeletedIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowDeletedIcon.html",
    "title": "Property RowDeletedIcon",
    "keywords": "Property RowDeletedIcon RowDeletedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile zum Löschen markiert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property StateBeforeUpdate den Wert true hat. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string RowDeletedIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeader.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeader.html",
    "title": "Property RowHeader",
    "keywords": "Property RowHeader RowHeader Bestimmt, ob im Row-Header die Zeilennummer oder der Status des Rows angezeigt wird. Declaration [DevBrowsable(true)] [Browsable(true)] [ControlStylesBrowsable(true)] public GridRowHeader? RowHeader { get; set; } Property Value Nullable < GridRowHeader >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeaderWidth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeaderWidth.html",
    "title": "Property RowHeaderWidth",
    "keywords": "Property RowHeaderWidth RowHeaderWidth Höhe der Spalten. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? RowHeaderWidth { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.SelectedRows.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.SelectedRows.html",
    "title": "Property SelectedRows",
    "keywords": "Property SelectedRows SelectedRows Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Zeilen im Grid markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. Declaration [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectedRows { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Remarks Eine Collection ist eine Sammlung von mehreren Objekten. Um Objekte in dieser Collection anzusprechen, gibt es verschiedene Möglichkeiten. Sie können einerseits über die ID an ein Objekt herankommen ( Collection[ID] ), andererseits können Sie auch über die guid Objekte ansprechen ( Collection[ guid ] ). So können Sie direkt mit den guids aus der SelectedRowsCollection die entsprechenden Objekte aus dem Datasource ansprechen: // SelectedRowsCollection im Form-Event auswerten (oMyColl ist Datasource des Grids) foreach ( guid guidrow in oSelectedRowsColl ) { oMyColl[guidrow].MyFunction( ); } Es ist auch ganz einfach selbst dafür zu sorgen, welche Zeilen ausgewählt werden: // Manuell Zeilen in einem Grid markieren (oMyColl ist Datasource des Grids) // SelectedRowsCollection leeren (keine Zeile ausgewählt) oSelectedRowsColl.Clear( ); // Wenn eine bestimmte Bedingung erfüllt ist, entsprechende Zeilen selektieren foreach (cMyComponent oMyObjectTemp in oMyColl) { if MyObjectTemp.MyProperty > 10 oSelectedRowsColl.Add( MyObjectTemp ); }"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowHorizontalLines.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowHorizontalLines.html",
    "title": "Property ShowHorizontalLines",
    "keywords": "Property ShowHorizontalLines ShowHorizontalLines Gibt an, ob die horizontalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowHorizontalLines { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowVerticalLines.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowVerticalLines.html",
    "title": "Property ShowVerticalLines",
    "keywords": "Property ShowVerticalLines ShowVerticalLines Gibt an, ob die vertikalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowVerticalLines { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferReloadRowCount.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferReloadRowCount.html",
    "title": "Property TransferReloadRowCount",
    "keywords": "Property TransferReloadRowCount TransferReloadRowCount Definiert, wie viele Zeilen nachgelesen werden, wenn in der Tabelle in den entsprechenden Bereich gescrollt wurde. Bei 0 werden alle Zeilen zurückgegeben. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? TransferReloadRowCount { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferStartupRowCount.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferStartupRowCount.html",
    "title": "Property TransferStartupRowCount",
    "keywords": "Property TransferStartupRowCount TransferStartupRowCount Definiert, wie viele Zeilen bei einem Load zunächst an den Client zurückgegeben werden. Bei 0 werden alle Zeilen zurückgegeben. Es wird nicht empfohlen, sich standardmäßig alle Zeilen zurückgeben zu lassen, da dies bei großen Datenmengen zu starker Belastung des Clients und des Webservers kommt. Es ist deshalb besser, sich zunächst einen Block zurückgeben zu lassen und bei Bedarf die Daten dynamisch nachlesen zu lassen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? TransferStartupRowCount { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Classes BrowserDesignViewModel ButtonBaseDesignViewModel ButtonDesignViewModel Diese Klasse repräsentiert das Control Button . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. CheckBoxDesignViewModel Diese Klasse repräsentiert das Control CheckBox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ComboboxDesignViewModel Diese Klasse repräsentiert das Control Combobox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ContainerDesignViewModel TODO ContextMenuDesignViewModel Diese Klasse repräsentiert das Control ContextMenu . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ControlDesignViewModel TODO DashBoardContainerViewModel Diese Klasse repräsentiert das Control DashboardContainer . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. DockPanelDesignViewModel EditboxDesignViewModel Diese Klasse repräsentiert das Control EditField . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. FieldPanelDesignViewModel FieldRowDesignViewModel FormContainerDesignViewModel Diese Klasse repräsentiert das Control FormContainer . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. GridColDesignViewModel Diese Klasse repräsentiert das Control Grid-Column . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. GridDesignViewModel Diese Klasse repräsentiert das Control Grid . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ImageButtonDesignViewModel Diese Klasse repräsentiert das Control ImageButton . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. LabelDesignViewModel Diese Klasse repräsentiert das Control Label . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ListBaseDesignViewModel ListboxDesignViewModel Diese Klasse repräsentiert das Control Listbox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ListViewDesignViewModel Diese Klasse repräsentiert das Control ListView . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. MainMenuDesignViewModel Diese Klasse repräsentiert das Control Menu-Item . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. PictureDesignViewModel Diese Klasse repräsentiert das Control Picture . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. RadioButtonDesignViewModel TabbedWindowDesignViewModel TabPageDesignViewModel TemplateControlDesignViewModel Diese Klasse repräsentiert das Control TemplateControl . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. TreeNodeDesignViewModel TreeViewDesignViewModel WrapPanelDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Die Caption wird auf das Bild geblendet, und zwar an der Position, die Sie unter CaptionAlign angegeben haben. Ist ihre Grafik selbsterklärend, können Sie die Caption frei lassen. Soll ein Und-Zeichen (&) dargestellt werden, müssen zwei Und-Zeichen (&&) angegeben werden. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ButtonBaseDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.CaptionAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.CaptionAlign.html",
    "title": "Property CaptionAlign",
    "keywords": "Property CaptionAlign CaptionAlign Ausrichtung des Textes auf dem Image-Button. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ContentAlignment? CaptionAlign { get; set; } Property Value Nullable < ContentAlignment > Remarks"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.DisabledImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.DisabledImage.html",
    "title": "Property DisabledImage",
    "keywords": "Property DisabledImage DisabledImage Gibt das Bild an, das angezeigt werden soll, wenn der Button disabled ist. Die URL kann einen relativen (zum Applikations-Verzeichnis) oder einen absoluten Pfad darstellen. Über die Drop- Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string DisabledImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.html",
    "title": "Class ImageButtonDesignViewModel",
    "keywords": "Class ImageButtonDesignViewModel Diese Klasse repräsentiert das Control ImageButton . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ButtonBaseDesignViewModel ImageButtonDesignViewModel Inherited Members ButtonBaseDesignViewModel.MapEnterToTabAction ButtonBaseDesignViewModel.Shortcut ButtonBaseDesignViewModel.ShowCaption ButtonBaseDesignViewModel.IsSearchButton ButtonBaseDesignViewModel.LoadAtComponent ButtonBaseDesignViewModel.SearchValuesComponent ButtonBaseDesignViewModel.ContextMenu ButtonBaseDesignViewModel.OnClick ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ImageButtonDesignViewModel : ButtonBaseDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Die Caption wird auf das Bild geblendet, und zwar an der Position, die Sie unter CaptionAlign angegeben haben. Ist ihre Grafik selbsterklärend, können Sie die Caption frei lassen. Soll ein Und-Zeichen (&) dargestellt werden, müssen zwei Und-Zeichen (&&) angegeben werden. CaptionAlign Ausrichtung des Textes auf dem Image-Button. DisabledImage Gibt das Bild an, das angezeigt werden soll, wenn der Button disabled ist. Die URL kann einen relativen (zum Applikations-Verzeichnis) oder einen absoluten Pfad darstellen. Über die Drop- Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Image Gibt das Bild an, das im Normalzustand angezeigt werden soll. MouseOverImage Gibt das Bild an, das angezeigt werden soll, wenn der Mauszeiger sich über dem Image-Button befindet. PressedImage Gibt das Bild an, das angezeigt werden soll, wenn der Image-Button gedrückt wird. See Also ImageButtonControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Image.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Image.html",
    "title": "Property Image",
    "keywords": "Property Image Image Gibt das Bild an, das im Normalzustand angezeigt werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string Image { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.MouseOverImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.MouseOverImage.html",
    "title": "Property MouseOverImage",
    "keywords": "Property MouseOverImage MouseOverImage Gibt das Bild an, das angezeigt werden soll, wenn der Mauszeiger sich über dem Image-Button befindet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string MouseOverImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.PressedImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.PressedImage.html",
    "title": "Property PressedImage",
    "keywords": "Property PressedImage PressedImage Gibt das Bild an, das angezeigt werden soll, wenn der Image-Button gedrückt wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string PressedImage { get; set; } Property Value String Remarks Warning In der Regel ist es sinnvoll, Image-Buttons im Default Control Style-Editor zu definieren und nur inSonderfällen von dieser Definition abzuweichen( Default Control Styles )."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Hier geben Sie mehrsprachig den Text ein, den das Label anzeigen soll. Wenn der Text des Default-Labels wiederhergestellt werden soll, muss der Inhalt aus Caption nur gelöscht werden. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption Remarks Es ist die Eingabe von Plaintext und HTML-Text möglich. HTML-Text muss mit beginnen und mit enden. Soll ein Und-Zeichen (&) dargestellt werden, müssen zwei Und-Zeichen (&&) angegeben werden. Ist auf dem Label ein DataSource hinterlegt, wird der Text, der hier unter Caption eingetragen wurde, nicht mehr angezeigt. Der Datasource hat dann höhere Priorität."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Gibt das Property an, dessen Inhalt in dem Label angezeigt werden soll. Ist ein Datasource angegeben, wird der Text aus Caption nicht angezeigt. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.html",
    "title": "Class LabelDesignViewModel",
    "keywords": "Class LabelDesignViewModel Diese Klasse repräsentiert das Control Label . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel LabelDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class LabelDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Hier geben Sie mehrsprachig den Text ein, den das Label anzeigen soll. Wenn der Text des Default-Labels wiederhergestellt werden soll, muss der Inhalt aus Caption nur gelöscht werden. DataSource Gibt das Property an, dessen Inhalt in dem Label angezeigt werden soll. Ist ein Datasource angegeben, wird der Text aus Caption nicht angezeigt. TextAlign Ausrichtung des Textes innerhalb des Labels. See Also LabelControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign TextAlign Ausrichtung des Textes innerhalb des Labels. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public DevTextAlign? TextAlign { get; set; } Property Value Nullable < DevTextAlign >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.html",
    "title": "Class ListBaseDesignViewModel",
    "keywords": "Class ListBaseDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ListBaseDesignViewModel ComboboxDesignViewModel ListboxDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public abstract class ListBaseDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties List Gibt den Datasource für die Liste der Einträge der Combobox an. Es können Collections und TextCollections ausgewählt werden. ListSortOrder Gibt an, ob und wie die Einträge der Liste sortiert werden sollen.Für die Sortierung ist das DisplayMember ausschlaggebend.Ist Unsorted eingestellt, werden die Einträge in der Reihenfolge angezeigt, wie sie in der Collection stehen.Den Collections kann beim Load() eine SortOrder mitgegeben werden und TextCollections sind immer aufsteigend nach ID sortiert."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.List.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.List.html",
    "title": "Property List",
    "keywords": "Property List List Gibt den Datasource für die Liste der Einträge der Combobox an. Es können Collections und TextCollections ausgewählt werden. Declaration [Browsable(true)] [TypeConverter(typeof(DataBindingConverter))] public ListDataSource List { get; set; } Property Value ListDataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.ListSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.ListSortOrder.html",
    "title": "Property ListSortOrder",
    "keywords": "Property ListSortOrder ListSortOrder Gibt an, ob und wie die Einträge der Liste sortiert werden sollen.Für die Sortierung ist das DisplayMember ausschlaggebend.Ist Unsorted eingestellt, werden die Einträge in der Reihenfolge angezeigt, wie sie in der Collection stehen.Den Collections kann beim Load() eine SortOrder mitgegeben werden und TextCollections sind immer aufsteigend nach ID sortiert. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ListSortOrder? ListSortOrder { get; set; } Property Value Nullable < ListSortOrder >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.html",
    "title": "Class ListboxDesignViewModel",
    "keywords": "Class ListboxDesignViewModel Diese Klasse repräsentiert das Control Listbox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ListBaseDesignViewModel ListboxDesignViewModel Inherited Members ListBaseDesignViewModel.List ListBaseDesignViewModel.ListSortOrder ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ListboxDesignViewModel : ListBaseDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Multiselect Wenn grundsätzlich mehrere Einträge ausgewählt werden können sollen, muss dieses Property auf True gesetzt werden. Ist es auf False gesetzt, kann nur genau ein Eintrag ausgewählt werden. SelectedEntries Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Einträge in der Listbox markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. Events OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. See Also ListBoxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.Multiselect.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.Multiselect.html",
    "title": "Property Multiselect",
    "keywords": "Property Multiselect Multiselect Wenn grundsätzlich mehrere Einträge ausgewählt werden können sollen, muss dieses Property auf True gesetzt werden. Ist es auf False gesetzt, kann nur genau ein Eintrag ausgewählt werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? Multiselect { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.OnSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.OnSelectionChanged.html",
    "title": "Event OnSelectionChanged",
    "keywords": "Event OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnSelectionChanged Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.SelectedEntries.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.SelectedEntries.html",
    "title": "Property SelectedEntries",
    "keywords": "Property SelectedEntries SelectedEntries Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Einträge in der Listbox markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectedEntries { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Remarks Eine Collection ist eine Sammlung von mehreren Objekten. Um Objekte in dieser Collection anzusprechen, gibt es verschiedene Möglichkeiten. Sie können einerseits über die ID an ein Objekt herankommen ( Collection[ID] ), andererseits können Sie auch über die guid Objekte ansprechen (Collection[guid]). So können Sie direkt mit den guids aus der SelectedRowsCollection die entsprechenden Objekte aus dem Datasource ansprechen: Beispiel: // SelectedRowsCollection im Form-Event auswerten (oMyColl ist Datasource der Listbox) foreach ( guid guidrow in oSelectedRowsColl ) { oMyColl[guidrow].MyFunction( ); } Es ist auch ganz einfach selbst dafür zu sorgen, welche Einträge ausgewählt werden: Beispiel: // Manuell Einträge in einer Listbox markieren (oMyColl ist Datasource der Listbox) // SelectedRowsCollection leeren (keine Einträge ausgewählt) oSelectedRowsColl.Clear( ); // Wenn eine bestimmte Bedingung erfüllt ist, entsprechende Einträge selektieren foreach (cMyComponent oMyObjectTemp in oMyColl) { if MyObjectTemp.MyProperty > 10 oSelectedRowsColl.Add( MyObjectTemp ); }"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Membervariable oder Property, welches an die ListView gebunden werden soll. Muss vom Typ FrameworkSystems.FrameworkBase.IDevFrameworkObjectColl sein. Bildet auch die Datengrundlage für das ListItem Template . Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.html",
    "title": "Class ListViewDesignViewModel",
    "keywords": "Class ListViewDesignViewModel Diese Klasse repräsentiert das Control ListView . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ListViewDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ListViewDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties DataSource Membervariable oder Property, welches an die ListView gebunden werden soll. Muss vom Typ FrameworkSystems.FrameworkBase.IDevFrameworkObjectColl sein. Bildet auch die Datengrundlage für das ListItem Template . ItemArrangement Definiert die Anordnung der ListItems abhängig von der Größe der ListView. ItemSize Gibt die Größe eines ListItems an. Hierbei gilt die Width als Mindestbreite. Abhängig vom ItemArrangement werden ListItems gestreckt, um den vorhandenen Platz optimal auszunutzen. Die angegebene Height wird im Gegensatz zur Width nicht an die Größe der ListView angepasst und bleibt stabil. SelectedItems Membervariable oder Property, welches die selektierten ListItems beinhaltet. Muss von Typ SelectedRowsCollection sein. SelectionMode Gibt an, ob und wie ListItems in einer ListView selektiert werden können. SelectorPosition Der Selector ist ein kleines Häkchen, welches am ListItem anzeigt, ob es selektiert ist oder nicht. Abhängig vom individuellen Design des ListItems kann definiert werden, an welcher Stelle der Selector über dem ListItem angezeigt wird. Spacing Gibt den horizontalen und vertikalen Abstang zwischen den ListItems an. Template Öffnet den ListView Template Editor . Events OnItemActivated Dieses Event wird gefeuert, wenn ein ListItem angeklickt oder auf einem mobilen Gerät mit dem Finger angetippt wird. OnItemSelectionChanged Dieses Event wird gefeuert, wenn sich die Anzahl der selektierten ListItems ändert. Die derzeit selektierten ListItems können über das an der ListView gebundene Property SelectedItems ausgelesen werden. See Also ListViewControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemArrangement.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemArrangement.html",
    "title": "Property ItemArrangement",
    "keywords": "Property ItemArrangement ItemArrangement Definiert die Anordnung der ListItems abhängig von der Größe der ListView. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ListViewItemArrangement? ItemArrangement { get; set; } Property Value Nullable < ListViewItemArrangement > Remarks Es stehen zwei Optionen zur Verfügung: List Die ListItems werden untereinander angeordnet. Dabei werden diese horizontal auf die gesamte Breite der ListView gestreckt. Die unter ItemSize . Width eingegebene Breite gilt als Mindestbreite. Die Höhe ( ItemSize . Height ) ist fix. Wrap Die ListItems werden abhängig von der ItemSize . Width und der Breite der ListView umgebrochen. Es werden pro Zeile so viele ListItems wie möglich angezeigt. Die ItemSize . Width gibt dabei die Mindestbreite eines ListItems an. Die Höhe ( ItemSize . Height ) ist fix. Die ListItems werden gleichmäßig gestreckt, um die gesamte Breite der ListView auszunutzen."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemSize.html",
    "title": "Property ItemSize",
    "keywords": "Property ItemSize ItemSize Gibt die Größe eines ListItems an. Hierbei gilt die Width als Mindestbreite. Abhängig vom ItemArrangement werden ListItems gestreckt, um den vorhandenen Platz optimal auszunutzen. Die angegebene Height wird im Gegensatz zur Width nicht an die Größe der ListView angepasst und bleibt stabil. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public NonableSize ItemSize { get; set; } Property Value NonableSize"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemActivated.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemActivated.html",
    "title": "Event OnItemActivated",
    "keywords": "Event OnItemActivated Dieses Event wird gefeuert, wenn ein ListItem angeklickt oder auf einem mobilen Gerät mit dem Finger angetippt wird. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnItemActivatedEventArgs> OnItemActivated Returns Type Description EventHandler < FrameworkOnItemActivatedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemSelectionChanged.html",
    "title": "Event OnItemSelectionChanged",
    "keywords": "Event OnItemSelectionChanged Dieses Event wird gefeuert, wenn sich die Anzahl der selektierten ListItems ändert. Die derzeit selektierten ListItems können über das an der ListView gebundene Property SelectedItems ausgelesen werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkSelectionChangedEventArgs> OnItemSelectionChanged Returns Type Description EventHandler < FrameworkSelectionChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectedItems.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectedItems.html",
    "title": "Property SelectedItems",
    "keywords": "Property SelectedItems SelectedItems Membervariable oder Property, welches die selektierten ListItems beinhaltet. Muss von Typ SelectedRowsCollection sein. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectedItems { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectionMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectionMode.html",
    "title": "Property SelectionMode",
    "keywords": "Property SelectionMode SelectionMode Gibt an, ob und wie ListItems in einer ListView selektiert werden können. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ListViewSelectionMode? SelectionMode { get; set; } Property Value Nullable < ListViewSelectionMode >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectorPosition.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectorPosition.html",
    "title": "Property SelectorPosition",
    "keywords": "Property SelectorPosition SelectorPosition Der Selector ist ein kleines Häkchen, welches am ListItem anzeigt, ob es selektiert ist oder nicht. Abhängig vom individuellen Design des ListItems kann definiert werden, an welcher Stelle der Selector über dem ListItem angezeigt wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ListViewSelectorPosition? SelectorPosition { get; set; } Property Value Nullable < ListViewSelectorPosition > Remarks Das folgende Bild zeigt die möglichen Positionen:"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Spacing.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Spacing.html",
    "title": "Property Spacing",
    "keywords": "Property Spacing Spacing Gibt den horizontalen und vertikalen Abstang zwischen den ListItems an. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ControlSpacing Spacing { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlSpacing"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Template.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Template.html",
    "title": "Property Template",
    "keywords": "Property Template Template Öffnet den ListView Template Editor . Declaration [Browsable(true)] public object Template { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Hinterlegen Sie hier mehrsprachig die Bezeichnung, die für den Menüeintrag angezeigt werden soll. Soll ein Und-Zeichen(&) dargestellt werden, müssen zwei Und-Zeichen(&&) angegeben werden. Ist auf dem Label ein Datasource hinterlegt, wird der Text, der hier unter Caption eingetragen wurde, nicht mehr angezeigt. Der DataSource hat dann höhere Priorität. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Checked.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Checked.html",
    "title": "Property Checked",
    "keywords": "Property Checked Checked Ist ein Property hinterlegt, welches als boolescher Wert ausgewertet werden kann (bool, FSbool , FSshort ,…), so wird vor der Bezeichnung des Menüeintrags ein Haken dargestellt, wenn das hinterlegte Property den Wert true repräsentiert. Declaration [Browsable(true)] [ControlStylesBrowsable(false)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource Checked { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Remarks Warning Wenn die Eigenschaft Image gesetzt ist, übersteuert diese die Checked Darstellung."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Ist ein Datasource hinterlegt, wird die Caption wie bei einem Label durch den Inhalt überschrieben. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.html",
    "title": "Class MainMenuDesignViewModel",
    "keywords": "Class MainMenuDesignViewModel Diese Klasse repräsentiert das Control Menu-Item . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel MainMenuDesignViewModel ContextMenuDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class MainMenuDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Hinterlegen Sie hier mehrsprachig die Bezeichnung, die für den Menüeintrag angezeigt werden soll. Soll ein Und-Zeichen(&) dargestellt werden, müssen zwei Und-Zeichen(&&) angegeben werden. Ist auf dem Label ein Datasource hinterlegt, wird der Text, der hier unter Caption eingetragen wurde, nicht mehr angezeigt. Der DataSource hat dann höhere Priorität. Checked Ist ein Property hinterlegt, welches als boolescher Wert ausgewertet werden kann (bool, FSbool , FSshort ,…), so wird vor der Bezeichnung des Menüeintrags ein Haken dargestellt, wenn das hinterlegte Property den Wert true repräsentiert. DataSource Ist ein Datasource hinterlegt, wird die Caption wie bei einem Label durch den Inhalt überschrieben. Image Gibt das Bild an, das vor der Bezeichnung des Menüeintrags angezeigt werden soll. Die URL kann einen zum Applikations-Verzeichnis relativen Pfad oder einen absoluten Pfad darstellen. Über die Drop-Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Ist die Eigenschaft Checked ebenfalls zugewiesen, so wird die Darstellung des Checked-Status durch das Image übersteuert. Shortcut Zur Anwahl des Menüeintrags über einen ShortCut, wird einfach die entsprechende Tastenkombination aus der Combobox ausgewählt. Events OnCanDrop Dieses Event wird nicht unterstützt. OnClick Wird bei einem Klick auf das Control ausgelöst. OnDrag Dieses Event wird nicht unterstützt. OnEnter Dieses Event wird nicht unterstützt. OnLeave Dieses Event wird nicht unterstützt. See Also MainMenuControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Image.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Image.html",
    "title": "Property Image",
    "keywords": "Property Image Image Gibt das Bild an, das vor der Bezeichnung des Menüeintrags angezeigt werden soll. Die URL kann einen zum Applikations-Verzeichnis relativen Pfad oder einen absoluten Pfad darstellen. Über die Drop-Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Ist die Eigenschaft Checked ebenfalls zugewiesen, so wird die Darstellung des Checked-Status durch das Image übersteuert. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string Image { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnCanDrop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnCanDrop.html",
    "title": "Event OnCanDrop",
    "keywords": "Event OnCanDrop Dieses Event wird nicht unterstützt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnCanDrop Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird bei einem Klick auf das Control ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkButtonClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkButtonClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnDrag.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnDrag.html",
    "title": "Event OnDrag",
    "keywords": "Event OnDrag Dieses Event wird nicht unterstützt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnDrag Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnEnter.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnEnter.html",
    "title": "Event OnEnter",
    "keywords": "Event OnEnter Dieses Event wird nicht unterstützt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnEnter Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnLeave.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnLeave.html",
    "title": "Event OnLeave",
    "keywords": "Event OnLeave Dieses Event wird nicht unterstützt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnLeave Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut Shortcut Zur Anwahl des Menüeintrags über einen ShortCut, wird einfach die entsprechende Tastenkombination aus der Combobox ausgewählt. Declaration [Browsable(true)] [DevBrowsable(true)] public ExtendedShortcut? Shortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Hinterlegen Sie hier mehrsprachig die Caption des Bildes. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.CaptionAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.CaptionAlign.html",
    "title": "Property CaptionAlign",
    "keywords": "Property CaptionAlign CaptionAlign Wenn das Bild eine Caption anzeigen soll, können Sie hier bestimmen, wo dies arrangiert ist. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ContentAlignment? CaptionAlign { get; set; } Property Value Nullable < ContentAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Hier kann eine Datenquelle angegeben werden, aus der das Bild zur Laufzeit ermittelt wird. Zur Auswahl stehen alle Properties des Forms (und deren Unter-Properties). Gültige Typen für den Datasource sind String und FSstring sowie Byte [] und FSbyteArray . Dabei gilt für die String Datentypen, dass der Inhalt eine URL zu dem Bild enthält, das dargestellt werden soll. Ist der Typ des Datasources ein Byte Array, so muss dieses Byte Array das Bild in einem der folgenden Formate darstellen: GIF, JPG oder PNG. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.html",
    "title": "Class PictureDesignViewModel",
    "keywords": "Class PictureDesignViewModel Diese Klasse repräsentiert das Control Picture . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel PictureDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class PictureDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Hinterlegen Sie hier mehrsprachig die Caption des Bildes. CaptionAlign Wenn das Bild eine Caption anzeigen soll, können Sie hier bestimmen, wo dies arrangiert ist. DataSource Hier kann eine Datenquelle angegeben werden, aus der das Bild zur Laufzeit ermittelt wird. Zur Auswahl stehen alle Properties des Forms (und deren Unter-Properties). Gültige Typen für den Datasource sind String und FSstring sowie Byte [] und FSbyteArray . Dabei gilt für die String Datentypen, dass der Inhalt eine URL zu dem Bild enthält, das dargestellt werden soll. Ist der Typ des Datasources ein Byte Array, so muss dieses Byte Array das Bild in einem der folgenden Formate darstellen: GIF, JPG oder PNG. Image URL zu dem Bild, das angezeigt werden soll. Zum Anwendungsverzeichnis relative und absolute Pfade sind zulässig. ScaleMode Diese Eigenschaft gibt an, wie ein Bild skaliert werden soll. ShowCaption Gibt an, ob das Caption angezeigt wird oder nicht. Events OnClick Wird ausgelöst, wenn der Benutzer auf das Bild klickt. See Also PictureControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Image.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Image.html",
    "title": "Property Image",
    "keywords": "Property Image Image URL zu dem Bild, das angezeigt werden soll. Zum Anwendungsverzeichnis relative und absolute Pfade sind zulässig. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string Image { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird ausgelöst, wenn der Benutzer auf das Bild klickt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkButtonClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkButtonClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ScaleMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ScaleMode.html",
    "title": "Property ScaleMode",
    "keywords": "Property ScaleMode ScaleMode Diese Eigenschaft gibt an, wie ein Bild skaliert werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public PictureScaleMode? ScaleMode { get; set; } Property Value Nullable < PictureScaleMode > Remarks Wenn ein PictureControl durch Angabe von Anchors dynamisch vergrößert wird, dann ziehen die oben beschriebenen Einstellungen auch. Note Einschränkung: Die Modi funktionieren bei Bildern, die per Datasource als FSbyteArray an das Control übergeben werden. Bei Bildern, die über eine URL gelesen werden, funktionieren nur die Modi Normal und Stretch. Wenn ein anderer Mode angegeben ist, dann zieht Stretch ."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ShowCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ShowCaption.html",
    "title": "Property ShowCaption",
    "keywords": "Property ShowCaption ShowCaption Gibt an, ob das Caption angezeigt wird oder nicht. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowCaption { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Beschriftung des Radio-Buttons. Wird rechts neben dem Radio-Button angezeigt. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.DatasourceOnValue.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.DatasourceOnValue.html",
    "title": "Property DatasourceOnValue",
    "keywords": "Property DatasourceOnValue DatasourceOnValue Wert, bei dem der Radio-Button aktiv ist. Declaration [Browsable(true)] public int? DatasourceOnValue { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.html",
    "title": "Class RadioButtonDesignViewModel",
    "keywords": "Class RadioButtonDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel RadioButtonDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class RadioButtonDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Beschriftung des Radio-Buttons. Wird rechts neben dem Radio-Button angezeigt. DatasourceOnValue Wert, bei dem der Radio-Button aktiv ist. Events OnClick Wird bei einem Click auf den Radio-Button ausgelöst. Der Button GroupDataSource des übergeordneten Panels wird auf den DataSourceOnValue-Wert gestellt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird bei einem Click auf den Radio-Button ausgelöst. Der Button GroupDataSource des übergeordneten Panels wird auf den DataSourceOnValue-Wert gestellt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkRadioButtonClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkRadioButtonClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.ActiveImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.ActiveImage.html",
    "title": "Property ActiveImage",
    "keywords": "Property ActiveImage ActiveImage Sie können für die Registerkarten-Bezeichnung Grafiken hinterlegen, welche im Viewer statt des normalen Graus angezeigt werden. Die aktuell ausgewählte Registerkarte zeigt die hier hinterlegte Grafik an. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ActiveImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Der hinterlegte Datasource erhält einen Wert vom Typ Int, in dem zurückgegeben wird, welches Tab aktiv ist (mit 0 beginnend). Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.html",
    "title": "Class TabbedWindowDesignViewModel",
    "keywords": "Class TabbedWindowDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TabbedWindowDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TabbedWindowDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ActiveImage Sie können für die Registerkarten-Bezeichnung Grafiken hinterlegen, welche im Viewer statt des normalen Graus angezeigt werden. Die aktuell ausgewählte Registerkarte zeigt die hier hinterlegte Grafik an. DataSource Der hinterlegte Datasource erhält einen Wert vom Typ Int, in dem zurückgegeben wird, welches Tab aktiv ist (mit 0 beginnend). InactiveImage Die Grafik wird auf allen Tabs angezeigt, die nicht aktiv sind. TabAlignment Bestimmt, an welcher Stelle der Registerkarte die Bezeichnung/der Name der Registerkarte (der \"Reiter\", hier als Beispiel „Seite“) dargestellt wird. Events OnSelectedTabPageChange Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar bevor das Programm auf das neue Tab gewechselt ist. Soll z.B. der Wechsel auf ein anderes Tab unterbunden werden, kann hier entsprechend eine Anweisung an den Datasource hinterlegt werden. OnSelectedTabPageChanged Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar nachdem das Programm auf das neue Tab gewechselt ist."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.InactiveImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.InactiveImage.html",
    "title": "Property InactiveImage",
    "keywords": "Property InactiveImage InactiveImage Die Grafik wird auf allen Tabs angezeigt, die nicht aktiv sind. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string InactiveImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChange.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChange.html",
    "title": "Event OnSelectedTabPageChange",
    "keywords": "Event OnSelectedTabPageChange Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar bevor das Programm auf das neue Tab gewechselt ist. Soll z.B. der Wechsel auf ein anderes Tab unterbunden werden, kann hier entsprechend eine Anweisung an den Datasource hinterlegt werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnSelectedTabChangeEventArgs> OnSelectedTabPageChange Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnSelectedTabChangeEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChanged.html",
    "title": "Event OnSelectedTabPageChanged",
    "keywords": "Event OnSelectedTabPageChanged Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar nachdem das Programm auf das neue Tab gewechselt ist. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnSelectedTabChangedEventArgs> OnSelectedTabPageChanged Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnSelectedTabChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.TabAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.TabAlignment.html",
    "title": "Property TabAlignment",
    "keywords": "Property TabAlignment TabAlignment Bestimmt, an welcher Stelle der Registerkarte die Bezeichnung/der Name der Registerkarte (der \"Reiter\", hier als Beispiel „Seite“) dargestellt wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TabAlignment? TabAlignment { get; set; } Property Value Nullable < TabAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.ActiveImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.ActiveImage.html",
    "title": "Property ActiveImage",
    "keywords": "Property ActiveImage ActiveImage Für die TabPage kann ein Header-Image hinterlegt, bzw. das auf Tabbed Window Ebene hinterlegte überschrieben werden. Das Image wird angezeigt, wenn das Tabbed Window aktiviert wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ActiveImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.html",
    "title": "Class TabPageDesignViewModel",
    "keywords": "Class TabPageDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TabPageDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TabPageDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ActiveImage Für die TabPage kann ein Header-Image hinterlegt, bzw. das auf Tabbed Window Ebene hinterlegte überschrieben werden. Das Image wird angezeigt, wenn das Tabbed Window aktiviert wird. Shortcut Definiert die Tastenkombination, mit der die TabPage ausgewählt werden kann. Der Shortcut wird in der Anwendung als Tooltip angezeigt, wenn sich die Maus über der TabPage befindet."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut Shortcut Definiert die Tastenkombination, mit der die TabPage ausgewählt werden kann. Der Shortcut wird in der Anwendung als Tooltip angezeigt, wenn sich die Maus über der TabPage befindet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [DevBrowsable(true)] public ExtendedShortcut? Shortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.html",
    "title": "Class TemplateControlDesignViewModel",
    "keywords": "Class TemplateControlDesignViewModel Diese Klasse repräsentiert das Control TemplateControl . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel TemplateControlDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TemplateControlDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Template Öffnet den ListView Template Editor . See Also TemplateControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.Template.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.Template.html",
    "title": "Property Template",
    "keywords": "Property Template Template Öffnet den ListView Template Editor . Declaration [Browsable(true)] public object Template { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ClosedIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ClosedIcon.html",
    "title": "Property ClosedIcon",
    "keywords": "Property ClosedIcon ClosedIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist und benötigt das Property des NodeDataSource-Objekts. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public string ClosedIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ContinueEquivalent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ContinueEquivalent.html",
    "title": "Property ContinueEquivalent",
    "keywords": "Property ContinueEquivalent ContinueEquivalent Um eine Rekursion aufzubauen, wählen Sie hier den eigenen TreeNode als ContinueEquivalent aus. Für Elemente der ersten Ebene ist null default, für Elemente der zweiten Ebene der TreeNode der ersten Ebene. Declaration [Browsable(true)] [DevBrowsable(true)] [TypeConverter(typeof(DevControlTreeNodeConverter))] public guid ContinueEquivalent { get; set; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.html",
    "title": "Class TreeNodeDesignViewModel",
    "keywords": "Class TreeNodeDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TreeNodeDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TreeNodeDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ClosedIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist und benötigt das Property des NodeDataSource-Objekts. ContinueEquivalent Um eine Rekursion aufzubauen, wählen Sie hier den eigenen TreeNode als ContinueEquivalent aus. Für Elemente der ersten Ebene ist null default, für Elemente der zweiten Ebene der TreeNode der ersten Ebene. NodeDataSource DataSource des TreeNodes. Collections oder Textcollections sind möglich. OpenIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist. Benötigt das Property des NodeDataSource-Objekts. Events OnAfterSelect Tritt ein, wenn ein Knoten ausgewählt wurde. OnDoubleClick Tritt ein, wenn auf einen Knoten doppelt geklickt wurde. OnDragDrop Tritt ein, wenn ein Tree-Node per Drag and Drop innerhalb eines TreeViews oder (aus einem anderen TreeView) in einen TreeView verschoben wird."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.NodeDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.NodeDataSource.html",
    "title": "Property NodeDataSource",
    "keywords": "Property NodeDataSource NodeDataSource DataSource des TreeNodes. Collections oder Textcollections sind möglich. Declaration [Browsable(true)] [DevBrowsable(true)] [TypeConverter(typeof(DataBindingConverter))] public NodeListDataSource NodeDataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.NodeListDataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnAfterSelect.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnAfterSelect.html",
    "title": "Event OnAfterSelect",
    "keywords": "Event OnAfterSelect Tritt ein, wenn ein Knoten ausgewählt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<DevEventHandlerOnTreeNodeSelectedEventArgs> OnAfterSelect Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnTreeNodeSelectedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDoubleClick.html",
    "title": "Event OnDoubleClick",
    "keywords": "Event OnDoubleClick Tritt ein, wenn auf einen Knoten doppelt geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<DevEventHandlerOnTreeNodeSelectedEventArgs> OnDoubleClick Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnTreeNodeSelectedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDragDrop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDragDrop.html",
    "title": "Event OnDragDrop",
    "keywords": "Event OnDragDrop Tritt ein, wenn ein Tree-Node per Drag and Drop innerhalb eines TreeViews oder (aus einem anderen TreeView) in einen TreeView verschoben wird. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<DevEventHandlerOnTreeNodeDragDropEventArgs> OnDragDrop Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnTreeNodeDragDropEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OpenIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OpenIcon.html",
    "title": "Property OpenIcon",
    "keywords": "Property OpenIcon OpenIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist. Benötigt das Property des NodeDataSource-Objekts. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public string OpenIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.BackColor2.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.BackColor2.html",
    "title": "Property BackColor2",
    "keywords": "Property BackColor2 BackColor2 Gibt die alternierende Hintergrundfarbe für die TreeView an. Für den Hintergrund der Tree-Nodes wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Nodes die BackColor verwendet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor2 { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.DragDropMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.DragDropMode.html",
    "title": "Property DragDropMode",
    "keywords": "Property DragDropMode DragDropMode Gibt an, von welchen Controls aus in den aktuellen Tree-View Drag and Drop ausgeführt werden Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TreeViewDragDropMode? DragDropMode { get; set; } Property Value Nullable < TreeViewDragDropMode >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.html",
    "title": "Class TreeViewDesignViewModel",
    "keywords": "Class TreeViewDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TreeViewDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TreeViewDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties BackColor2 Gibt die alternierende Hintergrundfarbe für die TreeView an. Für den Hintergrund der Tree-Nodes wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Nodes die BackColor verwendet. DragDropMode Gibt an, von welchen Controls aus in den aktuellen Tree-View Drag and Drop ausgeführt werden InitialDepth Gibt an, bis zu welcher Ebene Daten vom TreeView an den Anzeige-Client übertragen werden. Hat ein Tree z.B. 5 Ebenen und InitialDepth ist mit 2 definiert, werden erst beim Aufklappen der 3. Ebene im Client die neuen Daten übertragen. IsBorderVisible Gibt an, ob der Rahmen angezeigt werden soll. IsFirstLevelExpandIconVisible Mit diesem Property kann gesteuert werden, ob in der ersten Ebene des TreeViews das ExpandIcon („+“ Symbol zum Aufklappen) angezeigt werden soll oder nicht. ShowLines Gibt an, ob die Linien der Baum-Struktur vor den Tree-Nodes angezeigt werden sollen."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.InitialDepth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.InitialDepth.html",
    "title": "Property InitialDepth",
    "keywords": "Property InitialDepth InitialDepth Gibt an, bis zu welcher Ebene Daten vom TreeView an den Anzeige-Client übertragen werden. Hat ein Tree z.B. 5 Ebenen und InitialDepth ist mit 2 definiert, werden erst beim Aufklappen der 3. Ebene im Client die neuen Daten übertragen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public byte? InitialDepth { get; set; } Property Value Nullable < Byte >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsBorderVisible.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsBorderVisible.html",
    "title": "Property IsBorderVisible",
    "keywords": "Property IsBorderVisible IsBorderVisible Gibt an, ob der Rahmen angezeigt werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? IsBorderVisible { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsFirstLevelExpandIconVisible.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsFirstLevelExpandIconVisible.html",
    "title": "Property IsFirstLevelExpandIconVisible",
    "keywords": "Property IsFirstLevelExpandIconVisible IsFirstLevelExpandIconVisible Mit diesem Property kann gesteuert werden, ob in der ersten Ebene des TreeViews das ExpandIcon („+“ Symbol zum Aufklappen) angezeigt werden soll oder nicht. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? IsFirstLevelExpandIconVisible { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.ShowLines.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.ShowLines.html",
    "title": "Property ShowLines",
    "keywords": "Property ShowLines ShowLines Gibt an, ob die Linien der Baum-Struktur vor den Tree-Nodes angezeigt werden sollen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowLines { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.ContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.ContentAlignment.html",
    "title": "Property ContentAlignment",
    "keywords": "Property ContentAlignment ContentAlignment Definiert, wie der Inhalt ausgerichtet werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(AlignmentObjectConverter<WrapPanelHorizontalContentAlignment, WrapPanelVerticalContentAlignment>))] public Alignment<WrapPanelHorizontalContentAlignment, WrapPanelVerticalContentAlignment> ContentAlignment { get; set; } Property Value Alignment < WrapPanelHorizontalContentAlignment , WrapPanelVerticalContentAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.HorizontalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.HorizontalContentAlignment.html",
    "title": "Property HorizontalContentAlignment",
    "keywords": "Property HorizontalContentAlignment HorizontalContentAlignment Die Controls werden zeilenweise angeordnet und brechen um, wenn der Platz in der Breite nicht ausreicht. Declaration [Browsable(false)] [ControlStylesBrowsable(true)] public WrapPanelHorizontalContentAlignment? HorizontalContentAlignment { get; set; } Property Value Nullable < WrapPanelHorizontalContentAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.html",
    "title": "Class WrapPanelDesignViewModel",
    "keywords": "Class WrapPanelDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LayoutContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.SpaceableContainerDesignViewModel WrapPanelDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.DisabledBackColor ControlDesignViewModel.Caption ControlDesignViewModel.CaptionAsPlaceholder ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class WrapPanelDesignViewModel : SpaceableContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ContentAlignment Definiert, wie der Inhalt ausgerichtet werden soll. HorizontalContentAlignment Die Controls werden zeilenweise angeordnet und brechen um, wenn der Platz in der Breite nicht ausreicht. InvertFlowDirection Die Controls werden in umgekehrter Reihenfolge im WrapPanel platziert. Die Tab-Order wird dabei auch verdreht, sodass in der Anwendung die Tab-Order wieder von „vorne“ nach „hinten“ läuft. Diese Einstellung kann nützlich sein, wenn neu hinzugefügte Controls standardmäßig am Anfang platziert werden sollen – z.B. bei rechts ausgerichteten Button-Leisten. VerticalContentAlignment Die Controls werden spaltenweise angeordnet, wobei das WrapPanel die Anonrdnung mit der geringsten Höhe sucht. Bei einer gegebenen Breite werden so viele Spalten wie möglich angezeigt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.InvertFlowDirection.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.InvertFlowDirection.html",
    "title": "Property InvertFlowDirection",
    "keywords": "Property InvertFlowDirection InvertFlowDirection Die Controls werden in umgekehrter Reihenfolge im WrapPanel platziert. Die Tab-Order wird dabei auch verdreht, sodass in der Anwendung die Tab-Order wieder von „vorne“ nach „hinten“ läuft. Diese Einstellung kann nützlich sein, wenn neu hinzugefügte Controls standardmäßig am Anfang platziert werden sollen – z.B. bei rechts ausgerichteten Button-Leisten. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? InvertFlowDirection { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.VerticalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.VerticalContentAlignment.html",
    "title": "Property VerticalContentAlignment",
    "keywords": "Property VerticalContentAlignment VerticalContentAlignment Die Controls werden spaltenweise angeordnet, wobei das WrapPanel die Anonrdnung mit der geringsten Höhe sucht. Bei einer gegebenen Breite werden so viele Spalten wie möglich angezeigt. Declaration [Browsable(false)] [ControlStylesBrowsable(true)] public WrapPanelVerticalContentAlignment? VerticalContentAlignment { get; set; } Property Value Nullable < WrapPanelVerticalContentAlignment >"
  },
  "articles/aktuelle-pakete.html": {
    "href": "articles/aktuelle-pakete.html",
    "title": "Aktuelle Installations-Pakete",
    "keywords": "Aktuelle Installations-Pakete In dieser Liste sind alle aktuellen verfügbaren Installations-Pakete aufgeführt. Paket Version Name der Zip-Datei Framework Studio IDE 4.4 .3 FS_4.4.3_Setup_x64 Requirements-Paket 64 Bit 4.4 .0 FS_4.4.0_Requirements_x64 Runtime Administration 4.2 .0 FS_4.2.0_RuntimeAdministration Authentication-Service 4.2 .20 FS4.2.20_AuthService Print-Service 4.4 .0 FS4.4.0_PrintService FSClient Launcher 32 Bit 4.4 .0 FSCL_4.4.0_Setup_x86 FSClient Launcher 64 Bit 4.4 .0 FSCL_4.4.0_Setup_x64 FSClient Launcher 32 Bit MSI-Installer 4.4 .0 FSCL_4.4.0_Setup_Msi_x86 FSClient Launcher 64 Bit MSI-Installer 4.4 .0 FSCL_4.4.0_Setup_Msi_x64 Runtime Supervisor 4.0 .14 RS_4.0.14_Setup_x64"
  },
  "articles/knowledge/dottrace-performance.html": {
    "href": "articles/knowledge/dottrace-performance.html",
    "title": "Performance-Analyse mit dotTrace",
    "keywords": "Performance-Analyse mit dotTrace dotTrace von der Firma JetBrains ist ein kostenpflichtiges Werkzeug zur Analyse der Performance von .NET-Anwendungen. Aufzeichnen mit Console-Werkzeug Für die Aufzeichnung von Sitzungen bietet JetBrains eine kostenlose Konsole-Anwendung ( zur Download-Seite ). Diese Aufzeichnung können mit der dotTrace-Anwendung analysiert werden. Development-Broker aufzeichnen Als erstes bauen Sie den Command-Line Befehl für die Aufzeichnung mit der dottrace.exe zusammen. Dazu verwenden sie am besten einen Text-Editor. Wichtig ist, dass alle Argumente ohne Zeilen-Umbruch zusammengefügt werden müssen. Folgende Argumente werden benötigt: start Es soll eine Anwendung gestartet werden --service-input=stdin Die Aufzeichnung wird über die Console gesteuert. Weitere Erklärungen folgen unten. --profiling-type=Tracing Dieser Aufzeichnungs-Modus protokolliert einzelne Methoden-Aufrufe und ermöglicht eine sehr detaillierte Auswertung sowohl über die Dauer als auch die Anzahl von Methoden-Aufrufen. --save-to=C:\\temp\\Profile\\MyProfiling.dtp Dort werden die Snapshots gespeichert. Werden mehrere Snapshots erzeugt erhalten diese den Dateinamen MyProfiling-2.dtp usw. Bei einer neuen Session muss ein abweichender Dateiname angegeben werden. \"--work-dir=C:\\Program Files\\Framework Systems\\Framework Studio 4.3\" Das Programm-Verzeichnis von Framework Studio. Bitte auf die \"Gänsefüßchen\" achten. Die sind notwendig wegen der Leerzeichen im Pfad. \"C:\\Program Files\\Framework Systems\\Framework Studio 4.3\\FrameworkBrokerHostDev.exe\" - Exe-Datei für den Development-Broker -- Dieser Trenner muss zwingend vor die jetzt folgenden Argumente gepackt werden, weil diese ebenfalls -- enthalten. --devbroker -RepositoryName \"FSDemoCustomize 4.3\" -ApplicationPath ... Das sind die Argumente des Development-Brokers. Diese erhalten sie folgendermaßen: Aus der Framework Studio heraus die Application starten. Im System Tray wird das Icon für den Development-Broker angezeigt. Klicken Sie auf dieses Icon und rufen Sie den Menü-Punkt Copy Command Line Arguments auf. Fügen Sie alle Argumente aus der Zwischen-Ablage ein - bis auf das erste Argument - das ist der Name der Exe-Datei. Beenden sie die Application wieder, ansonsten funktioniert der anschließende Start nicht. Ein kompletter Aufruf sieht dann z.B. so aus: dottrace.exe start --service-input=stdin --profiling-type=Tracing --save-to=C:\\temp\\ProfileTest\\MySnapshot.dtp \"--work-dir=C:\\FS\\Framework Studio 4.3.0.0\" \"C:\\FS\\Framework Studio 4.3.0.0\\FrameworkBrokerHostDev.exe\" -- --devbroker -RepositoryName \"FSDemoCustomize 4.3\" -ApplicationPath \"C:\\FS\\Compile43\\NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1\" -ApplicationBinPath \"C:\\FS\\Compile43\\NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1\\bin\" -ApplicationName \"FSDemoApplication\" -ApplicationConfig \"C:\\FS\\Compile43\\NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1\\FSDemoApplication.config\" -Endpoint \"http://localhost:8080/Dev/NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1/FSDemoApplication/\" -StartPageAddress \"http://localhost:8080/Dev/NV281_1_FSDemo_43_FSDemoCustomize_4.3_user1/FSDemoApplication/start\" -LoggingMode \"3\" -LoggingDir \"C:\\FS\\Logging\\*\" -LoggingRequestFileName \"% ? Request.xml\" -LoggingResponseFileName \"% ? Response.xml\" Starten Sie die Console im dotTrace Ordner. Führen Sie den gerade zusammengestellten Befehl aus. Dabei wird der Application-Broker gestartet. Klicken Sie auf das System-Tray-Icon der Application und rufen Sie den Menüpunkt Open Client Start Page auf. Es wird die Start-Page angezeigt über die sie Application starten können. DotTrace läuft jetzt in der Console und zeichnet den aktuellen Application-Broker auf. Sie können die Aufzeichnung durch Eingabe der folgenden Befehle steuern. Ein Befehl muss mit Enter bestätigt werden. ##dotTrace[\"drop\"] Stoppt die aktuelle Aufzeichnung ohne diese zu speichern. Vor allem direkt nach dem Start ist das sinnvoll, bis man sich an der gewünschten Stelle im Programm befindet. ##dotTrace[\"start\"] Startet die Aufzeichnung ##dotTrace[\"get-snapshot\"] Stoppt die Aufzeichnung und speichert diese ab. Während einer Session können mehrere Snapshots erzeugt werden. Diese werden mit fortlaufenden Nummern gespeichert. Sind alle Aufzeichnungen fertig, dann kann die Anwendung beendet werden. Beenden sie den Application-Broker über das System-Tray-Icon. Läuft gerade eine Aufzeichnung, dann speichert dotTrace diese automatisch ab. Der Java-Client muss manuell beendet werden. Die erzeugten Snapshots können jetzt inkl. der erzeugten .dtp.000 , .dtp.001 ... Dateien für die Analyse verpackt werden."
  },
  "articles/knowledge/merhfacher-package-owner.html": {
    "href": "articles/knowledge/merhfacher-package-owner.html",
    "title": "Package-Owner in mehreren Repositories",
    "keywords": "Package-Owner in mehreren Repositories Framework Studio ist dafür konzipiert, dass ein Package über seine komplette Lebensdauer in genau einem Repository entwickelt wird - man darf also grundsätzlich nur in einem einzigen Repository der Owner sein. Insbesondere gilt das für Funktions-Packages, die exportiert werden und in einem Ziel-Repository zum Einsatz kommen. Caution Wird ein Funktions-Package in mehreren Repositories gleichzeitig entwickelt - ist man also Owner in mehreren Repositories , dann erzeugt das Kollisionen im Ziel-Repository . Werden Versionen desselben Packages aus mehreren Quell-Repositories in ein Ziel-Repository importiert, vermischen sich dabei die Änderungen aus beiden Repositories und verursachen Kollisionen. Besonders problematisch ist, solche Kollisionen erst nach dem Package-Import im Ziel-Repository auftreten. Im besten Fall führen sie dort unmittelbar beim Compile zu Fehlermeldungen und können so relativ schnell erkannt werden. Je nach Situation kann es auch passieren, dass solche Probleme erst zur Laufzeit in der Anwendung zutage treten und dort z.B. durch einen fehlerhaften Methoden-Inhalt zu Fehlverhalten führen. Solche Kollisionen können unmittelbar auftreten - sie treten eventuell aber auch erst zu einem viel späteren Zeitpunkt auf. Diese Kollisionen können sich z.B. folgendermaßen auswirken: Es existieren Unter-Elemente (z.B. Component-Properties) die dort nicht hingehören. Eine Methode hat den falschen Inhalt (aus der anderen Package-Version) Es fehlen Unter-Elemente (weil sie in der anderen Package-Version gelöscht wurden) ... Technischer Hintergrund In Framework Studio werden die Elemente mit einem fortlaufenden Zähler versioniert. Bei einem Check-Out wird die neue Versions-Nummer des Elementes mit Max+1 ermittelt. Dabei teilen sich alle Versionen eines Packages denselben Nummernkreis der Versions-Nummern. Beispiel: Wird in der Package-Version \"2.0\" ein Element ausgecheckt erhält es die Versions-Nummer 7, wird im Anschluss in der Package-Version \"3.0\" dasselbe Element ausgecheckt erhält es die Versions-Nummer 8. Wird diese Aktion in 2 jedoch verschiedenen Repositories durchgeführt, dann erhalten die Elemente in beiden Package-Versionen \"2.0\" und \"3.0\" dieselbe Versions-Nummer 7. Alle z.B. neu angelegten Component-Properties erhalten ebenfalls die Versions-Nummer 7. Importiert man diese beiden Package-Versionen \"2.0\" und \"3.0\" in dasselbe Ziel-Repository, dann ist dort die Versions-Nummer 7 ein Mix aus den Änderungen in beiden Package-Versionen. Spielregeln bei mehreren Repositories Grundsätzlich darf es nur ein Repository geben, indem man Owner ist. Wird von dieser Regel abgewichen, dann bedeutet das einen erhöhten organisatorischen Aufwand und es müssen einige Spielregeln beachtet werden. Wird von diesen Regeln abgewichen hat das Kollisionen zur Folge, die nur mit enormen Aufwand zu bereinigen sind. Versions-Nummern separieren Die Kreise der Versions-Nummern müssen voneinander separiert werden. Das erfolgt, indem in einem der beiden Repositories - idealerweise dem \"neueren\" - alle Versions-Nummern um den Wert 5000 erhöht werden. Es gibt dafür eine Funktion im Package-Manager: In der Datei FrameworkStudio.exe.config im Programm-Verzeichnis den folgenden Config-Schalter ergänzen: <?xml version=\"1.0\"?> <configuration> <appSettings> <!-- Aktivate PackageManager - Menu Tools / Lift Element Versions --> <add key=\"VersionLiftActive\" value=\"true\" /> ... Den Package-Manager starten und am \"neuen\" Repository anmelden Das gewünschte Package auswählen Menü Tools / Lift Element Versions (increase all Versions with 5000) ausführen. Im alten Repository keine Package-Version löschen Im alten Repository dürfen keine Package-Versionen mehr gelöscht werden, weil dies erneut Kollisionen im Ziel-Repository verursacht. Package-Versionen sollten statt dessen mit einem entsprechenden Kommentar durch Lock für eine weitere Bearbeitung gesperrt werden. Beim Löschen einer Package-Version werden die Versions-Nummern ebenfalls angehoben. Das ist notwendig, weil bei der Lösch-Aktion ggf. Versions-Nummern gelöscht werden, die bei einem späteren Check-Out in einer anderen Version des Packages erneut verwendet werden und so Kollisionen erzeugen. Wird also im \"alten\" Repository eine Package-Version gelöscht, dann werden die Versions-Nummern auf denselben Wert angehoben wie im neuen Repository. Das produziert in der Folge Kollisionen. Kollision bereinigen Ist in einem Ziel-Repository ein Kollision aufgetreten, muss diese behoben werden. Wird die Kollision sehr schnell erkannt, sollte man darüber nachdenken, ggf. eine Sicherung des Repositories zurückzuspielen. Anschließend muss dann eine korrigierte Variante der Package-Version importiert werden. Ist das zurückspielen der Sicherung keine Option, weil z.b. im eigenen Package Änderungen vorgenommen wurden, dann kann dies auf die Folgende Weise behoben werden: In den Quell-Repositories die Versions-Nummern separieren und die Package-Versionen neu exportieren Im Ziel-Repository alle Versionen des betroffenden Packages löschen. Saubere Stände der Package-Versionen neu importieren."
  },
  "articles/knowledge/snapshot-isolation.html": {
    "href": "articles/knowledge/snapshot-isolation.html",
    "title": "Zeilenversionierung im SQL-Server",
    "keywords": "Zeilenversionierung im SQL-Server Alle Microsoft SQL-Server Datenbanken, welche von Framework Studio genutzt werden, müssen mit aktivierter Zeilenversionierung arbeiten. Andernfalls können insbesondere längere Transaktionen unnötige Blockierungen auf Select-Statements zur Folge haben. Mit folgendem Statement kann die Einstellung überprüft werden. Dabei muss AdventureWorks durch den Namen der Datenbank ersetzt werden: SELECT snapshot_isolation_state_desc AS [READ_COMMITTED_SNAPSHOT], is_read_committed_snapshot_on AS [ALLOW_SNAPSHOT_ISOLATION] FROM sys.databases WHERE NAME = 'AdventureWorks' GO Das Ergebnis sollte ON, 1 sein. Mit folgenden Statements können die Einstellungen korrekt gesetzt werden. Dabei muss AdventureWorks durch den Namen der Datenbank ersetzt werden: ALTER DATABASE [AdventureWorks] SET READ_COMMITTED_SNAPSHOT ON GO ALTER DATABASE [AdventureWorks] SET ALLOW_SNAPSHOT_ISOLATION ON GO Beim Ausführen dieser Statements darf niemand angemeldet sein (auch keine Services) da exklusiver Zugriff auf die Datenbank benötigt wird. Framework Studio aktiviert die Zeilenversionierung beim Anlegen von Datenbanken automatisch."
  },
  "articles/knowledge/stackoverflow-analysieren.html": {
    "href": "articles/knowledge/stackoverflow-analysieren.html",
    "title": "StackOverflow Analysieren",
    "keywords": "StackOverflow Analysieren Wenn in einem .NET-Programm eine StackOverflowException ausgelöst wird, dann crashed der komplette Prozess. Für den Programmierer gibt es leider absolut keine Möglichkeit, dies abzufangen. Es gibt die Möglichkeit, sich mit dem Visual Studio Debugger vorher an den Prozess zu hängen. Wenn die Exception aufschlägt, zeigt der Debugger den Call-Stack an. Man benötigt dafür aber Visual Studio und es kann hin und wieder passieren, dass dies auch mal nicht funktioniert. Im folgenden wird eine alternative Vorgehensweise beschrieben, die deutlich zuverlässiger zum Ergebnis führt. Es wird mithilfe des Werkzeug ProcDump beim Auftreten dieser Exception ein Dump-File erstellt. Dieses wird anschließend mit windbg analysiert und der Call-Stack ermittelt. Ist es ein StackOverflow? zuerst stellt sich die Frage ob der Absturz eines Brokers tatsächlich durch einen StackOverflow ausgelöst wird. Das kann an den folgenden Symptomen festgestellt werden: 1.) Alle Benutzer die auf dem Broker arbeiten erhalten die Meldung: Session has been terminated! SessionID is unknown. 2.) Im Event-Log des Broker-Servers ist folgender Eintrag zu finden: Quelle: Application Error Ereignis-ID: 1000 Detail-Text: Name der fehlerhaften Anwendung: w3wp.exe Ausnahmecode: 0xc00000fd Fehler reproduzieren Wenn nicht bekannt ist, wie genau der Fehler entsteht, dann ist es empfehlenswert dies herauszufinden. Denn so kann man gezielt einen Broker starten, den Fehler auslösen und ein Dump-File erzeugen. Um das einzugrenzen kann das SessionTrace verwendet werden. Dazu gibt man in der web.config die folgenden Informationen an: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <appSettings> <add key=\"SessionTraceFolder\" value=\"C:\\temp\\sessiontrace\" /> <add key=\"SessionTraceCaching\" value=\"false\"/> ... Warning Das Ändern der Datei startet den Broker neu Den SessionTraceFolder kann man auch im Publish-Wizard angeben. Das SessionTraceCaching muss aber manuell auf \"false\" gesetzt werden, damit Anfang und Ende eines Requests getrennt protokolliert werden. Das ist entscheidend für die Analyse des Fehlers. Wurden die Dateien erzeugt und es ist mind. ein Absturz aufgetreten, dann kann man den SessionTrace-Ordner in das Werkzeug FSSessionTraceAnalyzer.exe einlesen (dieses befindet sich im Framework Studio Programmverzeichnis). Auf der Registerkarte \"Session Map\" gibt es unten einen Link \"Show open Requests\". Dieser zeigt eine Liste aller Requests an, zu denen keine Ende protokolliert wurde. Das können potentielle Kandidaten sein, aber ggf. auch Requests die unverschuldet mit abgebrochen wurden. Gut ist es daher, wenn mehrere Abstürze aufgetreten sind, so lässt sich der entscheidende Kandidat besser finden. Gibt die gewonnene Info noch keine Aufschluss über die Ursache, dann ist der nächste Schritt das Erstellen eines Dump-Files. Dump-File erstellen Vorbereitungen Das freie Werkzeug ProcDump herunterladen https://docs.microsoft.com/en-us/sysinternals/downloads/procdump Die Zip-Datei entpacken z.B. in den Ordner C:\\ProcDump Dump erzeugen Der betroffene Prozess muss bereits laufen. ProcDump beobachtet den laufenden Prozess und erzeugt im Falle eines StackOverflow den gewünschten Dump. Eingabeaufforderung starten. Ggf. als Administrator erforderlich um sich an einen Windows Dienst hängen zu können. In den Ordner des ProcDump-Programms navigieren C:\\> cd C:\\ProcDump Das Programm starten C:\\ProcDump> procdump64.exe -accepteula -e 1 -f C00000FD.STACK_OVERFLOW -g -ma <PID> %temp% <PID> ist die ID des Processes. Diese kann über den Task-Manager in Erfahrung gebracht werden. Es kann auch der Name des Prozesses - z.B. w3wp.exe oder NV.ERP.Base.JobServer.Host.JobServerHost.WindowsService.exe angegeben werden. Dies funktioniert aber nicht, wenn der Prozess mehrfach mit dem selben Namen ausgeführt wird (bsp. w3wp.exe mehrfach gestartet wird). Die Eingabeaufforderung offen und am Server den Windows-Benutzer angemeldet lassen. Wenn jetzt eine StackOverflowException auftritt, erzeugt dieses Programm einen Dump, bevor das Programm im Anschluss endgültig crashed. Die Dump-Datei wird in den Temp-Ordner gepackt. Sie heißt NameDesProcesses_Datum_Uhrzeit.dmp . Diese Datei kann im nächsten Schritt mit windbg analysiert werden. Die Datei kann ggf. mehrere GB groß sein, denn sie enthält ein komplettes Hauptspeicher-Abbild des Prozesses. Erfolgt eine Analyse bei N&V, dann sollte die Datei als 7-Zip gepackt und per ftp bereitgestellt werden. Analyse mit windbg.exe Vorbereitungen Note Ist auf dem Rechner Visual Studio installiert, dann ist windbg evtl. bereits verfügbar. Die Installation ist in diesem Fall nicht nötig. Das Windows 10 SDK herunterladen https://developer.microsoft.com/de-de/windows/downloads/windows-10-sdk Button \"INSTALLER HERUNTERLADEN\" Die Installations-Routine winsdksetup.exe starten. Alles Haken außer \"Debugging Tools for Windows\" entfernen. Installieren. Analyse Die windbg.exe (x64-Variante) starten. Einfach im Startmenü \"windbg\" eintippen. Die Dump-Datei einlesen Menü File -> Open Crash Dump Unten in die Text-Zeile die folgenden Befehle eingeben: 0:000> .loadby sos clr 0:000> !analyze Jetzt den Callstack anzeigen mit folgendem Befehl: 0:000> !clrstack Dies kann eine ganze Weile gehen - einfach abwarten :-) Links https://msdn.microsoft.com/de-de/library/system.stackoverflowexception(v=vs.110).aspx https://www.thebestcsharpprogrammerintheworld.com/2017/12/12/capture-a-stackoverflowexception-and-make-a-dump-0xc00000fd/ https://stackify.com/using-windbg-to-analyze-net-crash-dumps-async-crash/"
  },
  "articles/neuheiten-4-2.html": {
    "href": "articles/neuheiten-4-2.html",
    "title": "Neuheiten Framework Studio 4.2",
    "keywords": "Neuheiten Framework Studio 4.2 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen . Neue Systemvoraussetzungen In dieser Version gibt es einige Anpassungen bei den Systemvoraussetzungen . Im folgenden sind die wichtigsten Änderungen aufgeführt. Datenbank-Server Es wird der Oracle Server 12.2 oder höher (18c, 19c, ...) unterstützt. Ältere Versionen werden nicht mehr unterstützt. Es wird der SQL-Server 2012 oder höher unterstützt. Ältere Version (z.B. SQL-Server 2008) werden nicht mehr unterstützt. Important Ein Betrieb mit einer älteren Datenbank-Version ist nicht möglich. Ein Connect auf so einen Datenbank-Server führt unmittelbar zu einer entsprechenden Fehlermeldung. Oracle Client Es wird nur noch der Oracle Managed Provider unterstützt. Der Oracle ODP Provider wird nicht mehr unterstützt. Framework Studio benötigt damit keinen separaten Oracle-Client mehr. 64 Bit Die folgenden Programme können nur noch auf 64-Bit Systemen installiert werden. Eine 32-Bit Installations-Routine wird nicht mehr angeboten: Framework Studio IDE / Package Manager Publish / Publish2Go Anwendungs-Broker Framework Studio Services 32-Bit wird weiterhin unterstützt für: Client-Rechner Print-Server .NET Framework 4.8 Framework Studio setzt auf das .NET Framework 4.8 auf. Der Installer ist im Requirements-Paket enthalten und muss ggf. vor der Installation von Framework Studio ausgeführt werden. Alternativ kann der Installer auch direkt bei Microsoft heruntergeladen werden: https://dotnet.microsoft.com/download/dotnet-framework/net48 Betriebssysteme Mit dem Umstieg auf das .NET Framework 4.8 können einige ältere Windows Betriebssysteme nicht mehr unterstütz werden. Es werden aktuell folgende Betriebssysteme unterstützt: Server Windows Server 2012 R2 - oder höher Client / Entwicklungs-Rechner Windows 10 (Version 18.03 - oder höher) Windows 8.1 Für die Endanwender-Rechner bzw. Terminal-Server gelten weiter die bisherigen Anforderungen. C# 7 Mit dem Update auf das .net Framework 4.8 unterstützt Framework Studio auch die C# Sprach-Features bis zur Version 7.3. Eine Übersicht der Features bietet die Web-Seite: https://docs.microsoft.com/dotnet/csharp/whats-new/csharp-7 In der folgenden Liste werden einige Features genannt, die seit C# 6 hinzugekommen sind. Der Einsatz dieses Features ist in Framework-Studio empfehlenswert: out variables - inline-Deklaration (C# 7.0) Folgende Features können ggf. sinnvoll sein: Tuples (C# 7.0) - nur innerhalb von Methoden-Code (z.B. bei Linq-Queries), nicht als Parameter oder Rückgabe-Typ von Methoden Inferred tuple element names (C# 7.1) Tuples support == and != (C# 7.3) Pattern matching (C# 7.0) Local functions (C# 7.0) - aber nur sehr gut überlegt!! MLKey Wörterbuch Eine zentrale Neuerung in der Version 4.2 betrifft das Handling der fremdsprachigen Texte. Diese werden jetzt in einem zentralen Wörterbuch verwaltet. Bisher wurden alle Texte am jeweiligen Element (z.B. Metadatentyp, ComponentProperty, FormControl) gepflegt. Jetzt werden an allen diesen Stellen Schlüssel (MLKeys) angegeben, die auf das zentrale Wörterbuch verweisen. Dadurch hat man erst einmal etwas mehr organisatorischen Aufwand, aber auf längerer Sicht betrachtet bringt diese Vorgensweise viele Vorteile: Redundanzen werden vermieden, weil existierende Texte wiederverwendet werden können und sollen. Dadurch erhält man zudem in der kompletten Anwendung durchgängige und einheitliche Bezeichnungen. Die fremdsprachigen Übersetzungen können sehr einfach und zentral gepflegt werden. Besonders im Customizing-Package ist das von großem Vorteil, weil jetzt nicht mehr die einzelnen Elemente ausgecheckt werden müssen. Das Wörterbuch kann auch im Service-Release bearbeitet werden. Der Export und Import von Texten ist sehr einfach. Es wird das standardisierte TMX-Format verwendet. Texte können so zwischen verschiedenen Packages und Versionen ausgetauscht werden. Auch eine Übersetzung durch Werkzeuge oder externe Dienstleister ist dadurch deutlich einfacher als bisher. Eine detailliert Beschreibung der Funktionalität finden sie im Kapitel MLKey . Es ist sinnvoll, die Texte des eigenen Packages in das Wörterbuch zu überführen. Bitte beachten sie dazu die Hinweise und Anleitungen für die Migration . Fremdsprachen im Customizing-Package Sprachen werden jetzt an der Package-Version organisiert und können somit in Customizing-Packages ergänzt werden. Code-Messages überarbeitet Die vom Exception- und MessageBox-Wizard generierten Code-Messages wurden überarbeitet. Das bisherige Konstrukt mit #region wurde durch eine Variante mit einem einfachen eingefärbten Kommentar // FSCodeMessage: ersetzt. Das macht den Quellcode kompakter und leserlicher – ohne extra aufklappen zu müssen. Der XML-Teil, welcher bisher die Informationen für die Wizard-Dialoge beinhaltet hat, entfällt. In der Vergangenheit konnte es sein, dass die XML-Informationen vom Code abwichen. Der Wizard hat dann den Code ignoriert und einfach ersetzt. Dadurch konnten wichtige Infos – wie z.B. ein MessageBox EventHandler – verloren gehen. Die Informationen werden jetzt aus dem Code geparsed. Kann (z.B. aufgrund von manuellen Anpassungen) der Code nicht geparsed werden, kann er nicht mehr durch den Wizard bearbeitet werden. Die Code-Messages können einen MLKey aus dem Wörterbuch verwenden. Die bisherige Variante mit TextCollection-Einträgen soll nach und nach durch die MLKeys ersetzt werden und so die ctMessage-TextCollections auslaufen. Bei MsgBox.Show() sind die Enum-Werte für Button und Icon leserlich ausgeschrieben. Bisher wurden dort nur die int-Werte verwendet. Die Konvertierung des bestehenden Codes in das neue Format erfolgt auf folgende Weise: Durch die MLKey-Konvertierungs-Routine – diese setzt alle Code-Messages automatisch auf einen MLKey und/oder das neue Format um. Durch manuellen Aufruf des Exception- oder MsgBox-Wizards. Beim Speichern wird der Code durch die neue Variante ersetzt. Bei beiden Konvertierungen wird nur der Code betrachtet - der alte XML-Teil wird ignoriert. Neue Messages werden immer im neuen Format generiert. Dabei ist es egal, ob ein Textcollection-Eintrag oder ein MLKey verwendet wird. Neue Text-Funktionen In Framework Studio 4.2 wurden im Zuge der Umstellung auf die MLKeys auch die Text-Zugriffe auf Text-Collections und DevMLStrings überarbeitet. Note Es muss eine Migration durchgeführt werden. Actions SetEnabled und SetVisible nullable Die Control-Actions SetEnabled und SetVisible haben neue Überladungen bekommen, welche das Zurücksetzen auf den im Property-Grid des Form-Designers eingestellten Wert ermöglichen. Dazu wurden folgende Überladungen ergänzt, bei denen der null -Wert zum Zurücksetzten verwendet werden kann: SetEnabled(bool? value) SetEnabled(FSbool value) SetVisible(FSVisibility? value) Caution Achtung, falls Reflection verwendet wurde! Sollte eine der ursprünglichen Methoden aus irgend einem Grund per Reflection angesprochen worden sein, so kann es nun zu dem Problem kommen, dass nicht mehr eine eindeutige, sondern mehrere Überladungen der Methode gefunden werden. Die Überladungen SetEnabled(bool value) und SetVisible(FSVisibility value) wurden entfernt, da Aufrufe vom Compiler direkt auf die entsprechenden Nullable-Überladungen umgelenkt werden. Forms und Workflows Obsolete setzen Soll ein Form oder ein Workflow nicht mehr verwendet werden, so können die für diese Elemente generierten Klassen mit dem Obsolete Attribut versehen werden. Dazu muss der Name des Elements mit _Obsolete enden. Beispiel: wlfArticleDetail_Obsolete Der Compiler erzeugt dann bei Verwendung der Elemente Warnings in der Form 'wflArticleDetail_Obsolete' is obsolete: 'Workflow 'wflArticleDetail_Obsolete' will be deleted in future version.' . Weitere Neuerungen Die MLColumn-Sprache kann zur Laufzeit beeinflusst werden. An den DBColumns können die Größen-Angaben überschrieben werden, auch wenn ein Metadatentyp zugeordnet ist. Compare with previous in Method- und Element-History Browsern Such-Funktionalität für die ML-Columns Im Register AccessUnits wird bei einer ungültigen Parent Beziehung ein Button 'Fix the parent Access Unit' angezeigt. Dieser löscht die ungültige Parent Beziehung und legt, falls kein anderer gültiger Parent vorhanden ist, die Access Unit unter Root."
  },
  "articles/neuheiten-4-3.html": {
    "href": "articles/neuheiten-4-3.html",
    "title": "Neuheiten Framework Studio 4.3",
    "keywords": "Neuheiten Framework Studio 4.3 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen . Statisches Caching an Components (Static Cache) Framework Studio wurde um einen statischen Caching-Mechanismus erweitert. Wird dieser für eine geeignete Component aktiviert, so können Daten statt von der Datenbank aus diesem Cache geladen werden. Dadurch sind erhebliche Performance-Vorteile möglich. Details sind im Kapitel Statisches Caching beschrieben. Umstellung auf PropertyChanged Die Framework Studio Components implementieren jetzt das Standard-Interface INotifyPropertyChanged. Details sind im Kapitel PropertyChanged beschrieben. Ggf. sind Anpassungen im eigenen Code notwendig. Bitte beachten sie dazu die Hinweise für die Umstellung . In diesem Zuge sind einige weitere Änderungen vorgenommen worden: Die Methoden GetProperty , SetProperty , GetPropertyMdt und die Eigenschaft ComponentProperties wurde an (I)DevFramework Base Object verschoben. Damit können jetzt auch direkt an der Collection definierte Properties verarbeitet werden. Mit der neuen Methode IsComponentProperty kann man prüfen, ob es sich um ein vom Entwickler angelegtes Property handelt. Das Databinding in den Forms wurde komplett neu entwickelt. Das bringt unter anderem die folgenden Vorteile: Deutlich weniger Code und deutlich kleinere Assemblies (ca. -30%) Bei der Änderung von Werten wird für die Aktualisierung der Control-Inhalte am Ende des Requests jeder Wert nur einmal neu gelesen. Das gilt auch, wenn ein Property im Laufe des Requests mehrfach geändert wurde. Im Einzelfall kann das eine signifikante Steigerung der Performance bedeuten. Verhaltens-Änderung bei der SelectedRowsCollection Die an einem Grid gebundene Objekt-Collection und SelectedRowsCollection haben in der Vergangenheit eng zusammengearbeitet. Werden Records aus der Collection gelöscht oder eine neue Collection zugewiesen, dann werden aus der SelectedRowsCollection unmittelbar die entsprechenden Einträge entfernt. Das war möglich weil jede Änderung sofort vom Data-Binding übernommen wurde. Der neue asynchrone Ansatz im Data-Binding verhindert dies erst einmal. Damit bestehende Logik, die heute diesen Mechanismus voraussetzt, weiterhin funktioniert, wurde er im neuen Data-Binding nachgebaut - allerdings mit einer kleinen Einschränkung: Warning Weist man im Form eine neue Objekt-Hierarchie zu, die ihrerseits die Objekt-Collection für das Grid beinhaltet, dann wird die SelectedRowsCollection nicht automatisch geleert. Das muss in diesem Fall manuell durchgeführt werden. Deprecated Eigenschaft LabelOfControl Die Unterstützung für die Control-Eigenschaft LabelOfControl , die teilweise noch im Hintergrund gezogen hat, wurde entfernt. Siehe LabelOfControl Cleanup . Intellisense mit Roslyn Das Intellisense im Code-Editor wurde komplett überarbeitet. Es setzt jetzt mit \"Roslyn\" auf dieselbe Technologie auf wie das Intellisene von Visual Studio. Folgende Features werden jetzt unterstützt (Auszug): Lambda-Expressions (Linq) Generische Typen var schlüsselwort Überladene Methoden werden korrekt aufgelöst GoTo Definition für Form-Controls uvm ... Im Code-Editor werden Compile-Error und Warnings während dem Tippen direkt im Code markiert. Die Details des Errors werden in einem Tooltip angezeigt. Export von Tabellen Beschreibungen Im HTML-Export der Dokumentation gibt es eine neue Option Export DB-Tables . Diese integriert die Beschreibungen aller Datenbank-Tabellen. Beim Export über die FSConsole kann das über den Parameter \\ExportDBTables gesteuert werden. Im PBE kann dieser Export automatisiert werden. Menü Änderung beim Anlegen von Properties und Methods Beim Anlegen neuer Methoden in Forms oder Components wird nun in den Menüs abgefragt, ob diese als Public Method oder Protected Method angelegt werden sollen. Ferner gilt diese Regelung auch für Properties in Forms. Bei den Properties in den Components kann zwischen einer, wie bisher standermäßgen Public Property und einer Membervariable unterschieden werden. Eine Membervariable wird automatisch als Protected angelegt. Weitere Neuerungen Beim Export des Wörterbuches kann man die direkten Verwendungen der einzelnen MLKeys als Kommentar exportieren. Dazu gibt es im Export-Dialog eine neue Checkbox Include usings . Copy&Paste ist kompatibel bis einschließlich Framework Studio 3.11. Mit älteren Versionen von Framework Studio können per Copy&Paste keine Element-Informationen mehr ausgetauscht werden. In der Registerkarte Set Method kann bei Component Properties vom Typ Individual die generierte Prüfung auf den Getter der Checkbox Check before set unterbunden werden. Eine Prüfung findet standardmäßig statt, weshalb die Checkbox per default gesetzt ist. Die Registerkarte Description bei den Components wurde in General umbenannt. Ab der neuen Version befindet sich hier eine zusätzliche Checkbox Autogenerate Membervariable . Diese Checkbox wird ausschließlich bei Individual und Individual (readonly) Properties angezeigt und generiert sowohl eine Membervariable als auch ein Depends On Property, sobald sie gesetzt wird. In die Registerkarte General wurden ferner die Textfelder Display MinLength , Display MaxLength , Display MinLines und Display MaxLines und die Comboboxen Mapping und Drag Source verschoben. Des Weiteren können Sie wie gewohnt im Textfeld Description eine Beschreibung hinzufügen. Mit der Taste F1 kann im PropertyGrid für ein selektiertes Property, für welches eine Definition vorliegt, die Dokumentation geöffnet werden."
  },
  "articles/neuheiten-4-4.html": {
    "href": "articles/neuheiten-4-4.html",
    "title": "Neuheiten Framework Studio 4.4",
    "keywords": "Neuheiten Framework Studio 4.4 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen . Neue Requirements Kein Internet Explorer 11 mehr Der Internet Explorer 11 wird nicht mehr unterstützt. Folgende Features können nur noch mit aktuellen Browsern wie z.B. Edge, Chrome oder Firefox genutzt werden: Client Start Page Mit Framework Studio generierte Online-Hilfe Mobile Client Windows Client-Betriebssysteme Am Client- und Entwicklungs-Rechner wird nur noch Windows 10 unterstützt. Ältere Windows-Versionen werden nicht mehr unterstützt. Client Launcher Mit der Version 4.4 gibt es einen neuen Client-Launcher . Dieser bietet eine experimentelle Unterstützung für Java 11 (64 Bit) . Darüber hinaus gibt es ein paar kleinere Neuerungen . Ein Update auf diese Version ist aber nicht zwingend nötig. Bei Bedarf kann weiterhin der Client-Launcher mit der Version 4.2.16 verwendet werden. Umbau der Code Generierung und des Compiles Die Code-Generierung und der FS Compile wurden grundlegend überarbeitet. Hieraus ergeben sich folgende Neuheiten: Für jeden Namespace und Typen gibt es nur noch eine DLL, welche generiert und kompiliert wird. Die Link-Schichten sind obsolet und werden zukünftig nicht mehr generiert. Auch die Context-Versionen sind nicht mehr notwendig. Die Anzahl der Assemblies hat sich stark reduziert, womit das debuggen komfortabler und der Compile schneller ist. Der Code aller Schichten muss und kann vor Ort komplett erstellt werden. Die Debug DLLs, welche mit dem FrameworkCompiler kompiliert wurden, werden nicht mehr in das Repository geschrieben. Note Zum Debuggen kann und muss zwingend der betroffene Code lokal debuggable kompiliert werden. Das bietet den entscheidenden Vorteil, dass Visual Studio beim Debuggen zuverlässig die richtigen cs-Dateien findet. Debug-Informationen, die vom FrameworkCompiler erzeugt wurden, zeigten immer auf einen absoluten Dateipfad, der auf dem eigenen Rechner nicht mehr stimmt. Es gibt bei den Options die Möglichkeit einen automatischen Debug Compile zu aktivieren. Des Weiteren wurde der Login -Dialog, sowie der GetDLLs Dialog um die gleiche Option \"AutoDebug DLLs\" erweitert. Wird beispielsweise beim Login die AutoDebug-Option auf \"All\" gesetzt, werden alle Compile Object Types beim Login automatisch debuggable kompiliert. Nähere Informationen finden Sie in den entsprechenden Dialog-Dokumentationen. Die Optionen Debug und DebugAll sind überarbeitet worden. Debug bedeutet, dass die Services, Components, CustomControls und Forms-Elemente des aktuellen Packages und der Base-Packages debuggable kompiliert werden. Im Gegensatz hierzu kompiliert DebugAll alle Element-Typen debuggable. Beachten Sie, dass vor allem Interfaces und DBTables aufwendig und somit mehr Zeit benötigen, um debuggable kompiliert zu werden. Important Im Zuge der Änderungen an der Code-Generierung und der Zusammenlegung der Code-Dateien in eine DLL, können zirkulären Referenzen auftreten. Des Weiteren kann es sein, dass nun fehlende Referenzen ergänzt werden müssen. Etwaige Fehler müssen in der IDE behoben werden. Nachfolgende Maintenance Routine kann gegebenenfalls beim Lösen der Fehlern unterstützen. DevExpress XtraReports Mit der Version 4.4 bietet Framework Studio experimentelle Unterstützung für DevExpress XtraReports 21.1 an. Hierbei handelt es sich um eine alternative Reporting-Lösung, die zunächst parallel mit Crystal Reports eingesetzt werden kann, diese langfristig allerdings ersetzen soll. Einige Vorteile der neuen Lösung sind z.B.: Erhöhte Performance, sowohl im Druck als auch beim Design Keine Installation einer separaten Runtime notwendig Kein Erwerb von Nutzer-Lizenzen notwendig Datenquellen müssen nicht über xsd-Dateien abgewickelt werden, sondern werden direkt auf Basis der Objekte selbst gebildet Langfristig Support für von Windows losgelöste Entwicklung (.NET Core) Technisch zugänglichere Plattform (Custom Controls, Custom Designer u.Ä.) Dadurch die Möglichkeit, Reports direkt im Browser anzupassen Warning Dieses Release beinhaltet noch keine vollwertige Funktionalität. Sie können sich bereits mit der neuen Lösung auseinandersetzen und Nutzungserfahrungen sammeln, ein produktiver Einsatz ist allerdings ausdrücklich noch nicht vorgesehen. Eine Beibehaltung der aktuellen Dateiformate und API in Versionen vor dem vollständigen Release wird angestrebt, aber nicht garantiert. Im Report Document Type wurden Anpassungen vorgenommen, die gleichzeitiges Führen von Crystal- und DevExpress-Dateien für den selben logischen Report erlauben. Jeder Report kann jetzt gleichzeitig einen Crystal Report und einen DevExpress Report besitzen. Die beiden Dateien sind unabhängig voneinander editier-, lösch- und ersetzbar. Falls ein Report Document Type gedruckt werden soll, der gleichzeitig einen Crystal- und einen DevExpress-Report beinhaltet, wird auf Basis des Flags Global.ReportingSoftware entschieden, welcher der beiden genutzt werden soll. Das Flag lässt sich im Use-Code überschreiben. Zur Unterstützung bei der Umstellung auf DevExpress wird eine Konvertierungsfunktionalität angeboten, die die grundlegende Struktur des Crystal Reports übernimmt und bei weniger komplexen Reports große Teile dessen von selbst konvertiert. Falzmarken und in den Report eingebettete Subreports wurden mit eigenen Custom Controls gelöst. Um bei der Konvertierung mit dem originalen Crystal Report vergleichen zu können, wurde ein Button im Designer geschaffen, welcher diesen schreibgeschützt öffnet. Maintenance Routine für Referenzen und Konstruktoren Im Maintenance-Mode stehen speziell für den Update auf die Version 4.4 neue Cleanup-Routinen zur Verfügung. Constructor Cleanup : Ungültige Konstruktor Deklarationen in Components werden in eine gültige Form überführt. Dies ist notwendig, da der Compile in der FS Version 4.4 ungültige Deklarationen als Error ausgibt. References Cleanup : Entfernt nicht existente externe User-Referenzen und stellt externe $GAC -Referenzen auf $DotNetDirectory um. Namespace-Referenzen überarbeitet Die Namespace-Referenzen arbeiten mit Compile Object Types. Diese entsprechen den Compile-Schritten. So sind z.B. die Object Types Service , Service Proxy , Service Host und FSTransformation zum Compile Object Type Service zusammengefasst. Der Dialog für die Namespace-Referenzen wurde überarbeitet: Es werden jetzt alle Referenzen für alle Typen in einer Liste angezeigt. Die Liste bietet eine Übersicht der wichtigsten Detail-Informationen. Die Usings werden als Freitext-Feld bearbeitet. Bei der Auswahl von $GAC -Referenzen werden diese, wenn möglich auf $DotNetDirectory korrigiert. Individueller Code - Code files Für die Definition von individuellem Code steht ein neues Element Code File zur Verfügung. Der Code einer Code file muss eine Klasse beinhalten, in welcher Methoden, Konstruktoren, Properties etc. definiert werden können. Es können mehrere Klassen, jedoch keine Namespaces, in eine Code file definiert werden. Aufgrund gängiger Konventionen sollte ein Code File jedoch nur eine Klasse beinhalten und der Name des Code Files identisch mit dem Namen der Klasse sein. Ferner ist der identische Namen für die Intellisense notwendig. Für ein Code file muss ein Compile Step festgelegt werden. Dieser bestimmt mit welchem Object Typ der Code kompiliert wird und somit in welchem Namespace sich das Code file befindet. Soll der individuelle Code auch in einem anderen Namespace zur Verfügung stehen, muss hierfür eine Referenz angelegt werden. Diese muss auf den Namespace des Code files und auf dessen Compile step verweisen. Ein Beispiel hierzu findet sich hier . Note Der Compile step sollte zu einem späteren Zeitpunkt nicht geändert werden, da ansonsten bestehende Referenzen auf das Code file ungültig werden und der Compile Fehler generieren wird. Die Compile Fehler können verhindert werden, indem der ObjectType der Referenzen ebenfalls angepasst wird. REST Endpoint für Service Hosts Standardmäßig bietet ein Service Host den ausgewählten Service bzw. dessen Service Contract nach außen hin über WCF und damit das SOAP-Protokoll an. Moderne Applikationen und allen voran Webapplikationen in Borwsern oder auf mobilen Endgeräten unterstützen mittlerweile jedoch oft kein SOAP mehr und bevorzugen deshalb die Kommunikation über JSON. Framework Studio bietet die Möglichkeit, den Service Host so zu konfigurieren, dass vollständig automatisch ein zusätzlicher Endpoint generiert wird, mit dem die im Service Contract propagierten Methoden auch über JSON und damit über einen normalen HTTP-Request angesprochen werden können. Eine detaillierte Beschreibung dieser neuen Funktionalität befindet sich HIER . Placeholder für Editfields und Comboboxen Für Editfields und Comboboxen steht ein neues Property CaptionAsPlaceholder zur Verfügung. Wenn dieses Property auf true gesetzt wird, zeigt das Editfield oder die Combobox die Caption als Placeholder an, solange das Control leer ist bzw. keinen Datensatz anzeigt. Auf diese Weise können zusammenhängende Daten ggf. übersichtlicher dargestellt werden: Hinweise Placeholder funktionieren sowohl im Java Client als auch im HTML Client. Die Farbe des Placeholders ist fest auf RGB(180, 180, 180) bzw. #b4b4b4 gesetzt. Befindet sich das Control in einem FieldPanel, so wird kein extra Label generiert, wenn CaptionAsPlaceholder auf true gesetzt ist. Bilder Unterstützung für HTML Editfields Editfields mit dem Editor Type HTML können nun Inline-Bilder anzeigen. Diese Bilder können aus der Zwischenablage im Java-Client oder mithilfe eines <img/> Tags eingefügt werden. Reports, die mit DevExpress erstellt werden, unterstützen diese Bilder. Crystal Reports unterstützt diese Bilder leider nicht. Genaueres unter Editfield . FS Client Launcher Im Client-Launcher gibt es folgende Neuerungen: Die Online-Hilfe kann aus dem Konfigurations-Dialog mit F1 aufgerufen werden. Anzeige des Splash Screen der Application Für Version 4.4 Anwendungen gibt es eine Experimentelle Unterstützung für Java 11 (64 Bit) Weitere Neuerungen Für Comboboxen und Listboxen kann die DisabledBackColor definiert werden. In Methoden-Parametern und Rückgabetypen können die C# 7 Tuple-Types verwendet werden. Bei den Access Units wurde die Ansicht der verbundenen AccessUnits verbessert. Es werden nun neben den Parents auch die AccessUnit-Children angezeigt. Zudem können die AccessUnit-Parents bearbeitet werden. Die RowID und RowVersion sind nun zwei unabhängige Mechanismen. Dies bedeutet, dass die FSROWID als eindeutiger und alleiniger Primary Key für Update- und Delete-Bedingung gilt. Die RowVersion wird weiterhin für die Concurrency-Violation Überprüfung verwendet. Dabei ist es nebensächlich, ob der Primary Key eine ROWID oder ein individueller PK ist. Analog zur GlobalOnBeforeSaveAction() gibt es auch eine GlobalOnAfterSaveAction() , welche jedoch nach der SaveAction aufgerufen wird. Im StaticCache steht eine neue Methode ContainsKey(pk) zur Verfügung. Für Checkboxen wurde der Tabellenfilter auf Checked/Unchecked (bzw. Aktiviert/Deaktiviert) geändert. Gibt es Datensätze mit Null-Werten, werden diese bei der Checkbox-Filterung als Unchecked gewertet. Im Package Manager ist es möglich Warnings , welcher der Compiler ignorieren soll, anzugeben. Des Weiteren kann auch das Level der Warnings angegeben werden. Die Einstellung wird an die Customizing-Packages vererbt. Sie kann ausschließlich durch Nissen & Velten am eNVenta Package (bzw. einem anderen Default-Package) geändert werden. Im Publish, Run und Publish2go Wizard kann nun auch das Icon für die Anwendung gesetzt werden. Es ist nun möglich, im Wörterbuch nach Dependencies für MLKeys zu suchen. Es ist nun möglich, auf der Client Start Page die Client-Option Java Web Start während des Publish Vorganges ein oder aus zu blenden. Standardmäßig ist der Java Web Start nun deaktiviert. Es ist nun möglich an dem Application-Element die Form-Navigation im HTML Client zu deaktivieren. Bei den Relation-Properties (Components) steht in der Registerkarte Load Command nun ein CodeEditor mit entsprechender Intellisense zur Verfügung. Es ist nun möglich, den Code im C#-Code Editor , mit dem Button Format Code zu formatieren. Es ist nun möglich, Grid-Columns per Action zu verschieben. Dafür gibt es zwei neue Methoden( MoveBefore / MoveAfter ) an der GridColumnControlAction und zwei neue Methoden( InsertBefore / InsertAfter ) an der GridControlAction . Der Text in einem Dokumentations-Editor wird jetzt auf Rechtschreibfehler überprüft. Gefundene Rechtschreibfehler werden rot unterstrichen. Es werden die Sprachen Deutsch (de), Englisch (en), Französisch (fr) und Italienisch (it) unterstützt. Es ist nun möglich, Dokumentationen abhängig von den Lizenzeinstellungen zu exportieren. Dafür wurden neue Checkboxen im Export Wizard hinzugefügt und die Parameter der FSConsole erweitert. Das Einfügen von Links im Dokumentations-Editor wurde überarbeitet. Es kann nun mithilfe von Autocomplete nach existierenden Dokumentationen gesucht werden. Es ist nun möglich, Url-Links aus der Zwischenablage mit STRG+V, Rechte-Maustaste->Edit->Paste oder dem Link einbinden Dialog im Dokumentations-Editor einzufügen. Es ist nun möglich, Bilder aus der Zwischenablage mit STRG+V, Rechte-Maustaste->Edit->Paste oder dem Bild einbinden Dialog im Dokumentations-Editor einzufügen. Es ist nun möglich, Tooltips im Dokumentationsfenster zu bearbeiten. Es ist nun möglich, Headlines im Dokumentationsfenster zu nutzen. Am cGlobal wurde der neuer EntryPoint OnLicenseGranted geschaffen, mit dem man Lizenz-Freigabe programmatisch einschränken kann, obwohl die Lizenz-Datei dies erlaubt. Parallel dazu wurde die neue Methode LicenseGrantedInFile am AUHelper geschaffen. Noch nicht abgespeicherte Tabs werden nun mit einem Stern * gekennzeichnet."
  },
  "articles/release-4-2.html": {
    "href": "articles/release-4-2.html",
    "title": "Release-Information Framework Studio 4.2",
    "keywords": "Release-Information Framework Studio 4.2 4.2.26 (25.02.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.26_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2022029190 - Java-Client : Alle Jar-Dateien müssen neu signiert werden, weil das Java-Zertifikat widerrufen wurde. 2022029126 - IDE : Nach dem bearbeiten eines Global Events kann es passieren, dass im Workflow-Link auf dieses Global Event keine Init-Methode mehr angeboten wird. 2022029194 - IDE : Wird auf einem ControlType ein Undo Checkout ausgeführt, dann werden Form-Controls mit diesem ControlStyle und der zu verwerfenden Control-Version auf gelöscht gesetzt. Note Dieser Fehler kann eine Erklärung für Fälle sein, in denen aus heiterem Himmel Controls verschwunden sind - ohne dass jemand das Form ausgecheckt hat. Er war seit 05.2020 aktiv. 2022029147 - Doku : Informationen zum Aufräumen von tblRep_SessionLogging . 4.2.25 (28.01.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.25_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2022018908 - JavaClient : Wird per Action ein TabbedWindow (oder sein Parent) ausgeblendet, dann feuert das OnSelectedTabPageChange Event. Findet das beim Öffnen eines Forms statt, dann kann das zur Folge haben, dass das Form sich nicht im Vordergrund öffnet. 2022018909 - Java-Client : Beim Öffnen eines Forms wird in der Java-Console ggf. eine Meldung \" FrameworkSystems.FSJavaClient.DevControl.LayoutComponentDefault cannot be cast to FrameworkSystems.FSJavaClient.DevControl.DevControlTabPage \" ausgegeben. 2022018927 - Java-Client : Beim Ausführen der Action LoadGridLayout kann es bei großen Grids vorkommen, dass nicht alle Daten verarbeitet werden. 2021128765 - IDE : Beim Import einer TMX-Datei ins Wörterbuch werden ISO-Sprach-Codes in Großbuchstaben nicht erkannt. 2021128815 - HTML Client : Das Picture Control wird nicht upgedated, wenn die DataSource auf \"null\" gesetzt wird. 2021128823 - HTML Client : Die Frequenz der Beep-Action ist hart auf 1000Hz festgelegt und ignoriert damit den übergebenen Wert. 4.2.24 (23.12.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.24_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021118513 - IDE : Beim Ändern eines Query-JoinTypes in der Customization kommt es zu einer Exception. 2021118541 - IDE : Wird ein zu langer Datenbank-Servername oder Repository-Name verwendet, dann bricht der Start der IDE mit einer Exception ab. 2021128590 - IDE : Die Browser-Variante des HTML Clients funktioniert weder im Development Broker noch in einer gepublishten Umgebung. 2021128584 - Code-Generierung : Wird im Metadatentyp als Format-Pattern ein Regulärer Ausdruck verwendet, dann wird dieser im generierten Code nicht sauber escaped. In der Folge kann es zu Compile-Fehlern kommen. 2021128747 - HTML Client : Die ComboBox (ListValuesInput) reagiert nicht auf Eingaben von Buchstaben zur Auswahl des Eintrags. 2021128773 - HTML Client : Editfields mit einer DataSource vom Typ \"FSDateTime\" werfen beim Senden des Wertes zum Broker in gewissen Fällen eine Exception. 4.2.23 (26.11.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.23_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021108192 - IDE : Wird im ListView als DataSource eine TextCollection verwendet, dann ist nach dem Neustart der IDE in der Template-Variable die Zuordnung auf das Text-Property verloren. In der Folge kommt es auch zu Compile-Fehlern. 2021108258 - IDE : Verkleinert man das Framework Studio Haupt-Fenster, dann kann es passieren, dass im Namespace-Baum die untere Hälfte nicht mehr greifbar ist. Ist dann der Monitor zu klein - z.B. über Remote Desktop - dann kann man das Haupt-Fenster nicht weit genug vergrößern und der Namespace-Baum lässt sich nicht mehr bedienen. 2021118300 - HTML Client : OnAfterRequest() wird am Broker nur für das derzeit aktive Form des Clients aufgerufen. 4.2.22 (29.10.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.22_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021108162 - Java Client : Die Actions LoadGridLayout() und SaveGridLayout() arbeiten intern mit dem Titel der Spalte. Dadurch werden beim LoadGridLayout() Spalten ggf. nicht korrekt erkannt, wenn der Titel sich ändert oder mehrere Spalten denselben Titel haben. Note Die Actions arbeiten jetzt mit dem internen Namen der Spalte. LoadGridLayout() erkennt aber weiterhin die Informationen, die mit dem Titel gespeichert wurden. 2021108103 - IDE : Werden bei der Suche nach CheckOut Treffer gefunden, deren Namespace nicht mehr existiert, dann gibt es eine Exception und das Ergebnis wird nicht angezeigt. Das kann vorkommen, wenn der Namespace von einem anderen Benutzer gelöscht wird, während man selbst darin neue Elemente angelegt hat. Note Diese Treffer werden jetzt direkt unterhalb vom Package angezeigt. 2021108136 - IDE : Wenn im Form-Designer die Font eines Elementes über dem Property-Grid angepasst werden soll, kann es in seltenen Fällen vorkommen, dass Fonts ohne Namen in der Liste zur Auswahl stehen. Wenn eine Font ohne Namen ausgewählt wird, führt dies zu einem Absturz der IDE. 2021108146 - IDE : Wenn nach dem Anlegen einer neuen .WTS-Ressource in den eNVenta Update Script Editor gegangen wird und dort direkt auf \"New Table\" geklickt wird, führt dies zu einem Absturz von FS. 2021108205 - IDE : Wenn beim Erstellen einer neuen Column in einer Datenbanktabelle ein Metadatentype ausgewählt wird, wird der Name des neuen Columns richtigerweise umbenannt. Allerdings verliert der Name dabei den Package prefix (z. B. CCC_). 4.2.21 (24.09.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.21_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021097624 - IDE : Ruft man in einer customized Form die Control Events auf einem Custom Control auf, werden dort die Event-Methoden-Zuweisungen aus der Basis nicht angezeigt. 2021097638 - IDE : Bei einem Undo Checkout auf einem ReportDocumentType wird die vorherige Version des Reports nicht auf die Festplatte geschrieben. Bei einem darauffolgenden Edit wird die bereits bearbeitete Version angezeigt, nicht die zurückgesetzte. 4.2.20 (27.08.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.20_Setup_x64 FS4.2.20_AuthService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuer Authentication-Service Es gibt einen neuen Authentication-Service mit der Version 4.2.20. Dieser ersetzt die bisherige Version 4.0.16. Die neue Version behebt einen Fehler in der Windows-Authentication (siehe unten). Note Der neue Authentication-Service ist kompatibel mit älteren Versionen von Applikationen (FS 4.0 und älter). Korrigierte Fehler 2021087506 - Authentication Service : Die Windows-Authentifizierung funktioniert nicht, wenn der Authentication Service als Windows Service installiert ist und mit einem Domain-User betrieben wird. 2021087467 - HTML Client : Beim Öffnen des virtuellen Keyboards in Android 8 oder älter, wird die WebView in seltenen Fällen vertikal um die Höhe der Statusbar nach oben verschoben. Die Folge ist ein grauer Streifen zwischen der WebView und dem Keyboard. 2021087519 - HTML Client : Labels werden als fokussierbar angesehen und stören die Fokusreihenfolge. 2021087523 - HTML Client : Controls ohne Größe (MaxWidth = 0 oder MaxHeight = 0) werden fälschlicherweise in der Fokusreihenfolge berücksichtigt und stören diese dadurch. 4.2.19 (30.07.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.19_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020104512 - IDE : bei der Anlage eines neuen Crystal Report mit einer neuen Report-Datei gibt es eine Exception: System.System.ArgumentNullException: Der Wert darf nicht NULL sein 2021077185 - IDE : Nach dem Bearbeiten von Namespace-Referenzen kann es vorkommen, dass trotz Speichern der Namespace noch immer als geändert angezeigt wird. FS muss neu gestartet werden . 2021077150 - Framework : Mit Framework Studio 4.2.17 und 4.3.5 wurden an den FS-Typen das Interface IFormattable implementiert (Bug 2021066957). Diese Erweiterung hat negative Auswirkungen auf bestehenden Code - z.B. wenn SQL-Statements mit String.Format() oder String-Interpolation erzeugt werden. Bisher wurden null-Werte über Methode ToString() mit dem String \"null\" abgebildet, die Format-Methoden liefern aber einen leeren String zurück. Note Die IFormattable-Implementierung wurde bis auf Weiteres wieder komplett entfernt. 2021077114 - HTML Client : Wird ein Control mit \"Tab\" verlassen, so kann es ein, dass der Fokus-Indikator (Outline oder gelbe Hintergundfarbe) immer noch sichtbar ist. 2021077151 - HTML Client : Ein TabbedWindow kann per \"Tab\" nicht fokussiert werden. Befindet sich der Fokus im letzten Control der aktiven TabPage, so springt der Fokus nicht mehr heraus zum nächsten Control. 2021077221 - HTML Client : Die Kamera funktioniert nicht auf Android 11 oder höher 2021077223 - HTML Client : Bei der Ausführung der TakePhoto-Action am Client wird nicht nur das Bild zurück an den Broker geschickt, sondern auch lokal eine Kopie in der Gallery gespeichert. 2021077228 - HTML Client : Der Fullscreen-Modus funktioniert auf Android 11 nicht. Note Auf Grund eines zwar bestätigten aber bisher nicht korrigierten Bugs in Android 11 kann der HTML Client auf dieser Version deshalb nur im normalen Modus betrieben werden. 2021077229 - HTML Client : Beim Pausieren der App auf Android wird ggf. die aktive Session nicht korrekt gespeichert. Dadurch kann nach einem Neustart der App ggf. die Session nicht fortgeführt werden. 4.2.18 (25.06.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.18_Setup_x64 FS4.2.18_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neue Crystal Reports Runtime Es wird die Crystal Reports Runtime mit Version 13.0.26 und höher unterstützt. Voraussetzung ist der neue Print-Service 4.2.18. Das Requirements-Paket beinhaltet vorerst weiterhin die Version 13.0.18 Note Bitte beachten sie unbedingt die Hinweise in den aktualisierten Systemvoraussetzungen ! Korrigierte Fehler 2021066859 - Print-Service : Treten beim Verarbeiten von Druckaufträgen wiederholt Fehler auf, dann führt der Print-Service einen Restart durch. Wird der Print-Service aber als Console ausgeführt, dann funktioniert dieser Restart nicht. In der Folge läuft der Print-Service weiter und produziert weiter Fehler. 2021066919 - Print-Service : Wenn im Print-Service sehr viele Drucker definiert sind, dann kann das den Start des Dienstes so stark verzögern, dass der Start in einen Timeout läuft. Im PrintServiceConfigEditor wird ein Timeout von 30 Sekunden verwendet. Note Die Analyse der Drucker wird jetzt nach dem Start des Dienstes ausgeführt. Anstehende Druckjobs werden erst im Anschluss verarbeitet. Es kann also sein, dass die ersten Druckjobs erst mehrere Sekunden nach erfolgreichem Start des Dienstes verarbeitet werden. 2021066928 - Print-Service : Läuft der Print-Service in einen Fehler - z.B. bei der Verarbeitung eines Crystal Report Documents - dann erfolgt ein automatischer Restart des Services. Dabei wird die letzte Transaktion auf \"fehlerhaft\" gesetzt. In der Folge wird der Druck-Job nicht verarbeitet, auch wenn nach dem Neustart eine Verarbeitung möglich wäre. Note Tritt so ein Fehler auf, dann wiederholt der Print-Service jetzt nach dem Restart einmalig den Druck-Job. 2021066966 - Print-Service : Wird der Print-Service als Console ausgeführt, dann blockiert eine Markierung von Text die Console und damit den kompletten Print-Service. Note Bei einer Blockade läuft der Print-Service jetzt im Hintergrund weiter. Während der Blockade werden alle Ausgaben gepuffert und nach der Freigabe ausgegeben. Die Blockade der Console-Ausgabe während der Markierung ist eine Windows-Funktion und kann durch den Print-Service nicht unterbunden werden. 2020093875 - IDE : Eine DLL-Referenz in einem Form-Namespace, welche in Sub Namespaces verwendet werden kann, führt zu einem Compile-Fehler im Child bzw. Sub-Namespace. 2021056504 - IDE : Werden an einer GridColumn die Events bearbeitet, werden die Änderungen nicht autom. gespeichert und auch der Speicherbutton wird nicht aktiviert. 2021066783 - IDE : Mit einem Oracle-Repository kommt es beim Aufruf der Method History zu einem Fehler: ORA-00932: Inkonsistente Datentypen: CLOB erwartet, CHAR erhalten. 2021066884 - IDE : Im Paste-Dialog in der Registerkarte \"Summary\" wird bei einem Replace \"No conflicts found!\" angezeigt. Hierdurch ist auf den ersten Blick nicht ersichtlich, dass eine Methode mit gleicher Signatur überschrieben wird. 2021066945 - IDE : Beim Checkin eines Records werden auch von dem Record verwendete, neu angelegte Records erkannt und diese automatisch mit eingecheckt. Handelt es sich bei dem verwendeten Record aber um eine Customization, dann ist dessen Checkin nicht zwingend nötig, weil er ja schon im Basis-Package eingecheckt wurde. 2021066893 - HTML Client : Das sofortige Blockieren der UI bei einem Event wurde entschärft. Das Sperren erfolgt erst nach 500ms. 4.2.17 (30.04.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.17_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021036188 - Oracle : Werden in einem Grid Spalten mit Langtext gefiltert oder sortiert, dann kommt zu einer Sql-Exception, wenn die Texte auf der Datenbank eine Länge von 2000 bzw. 4000 Zeichen überschreiten. Die SQL-Methode LOB_COMPARABLE( ) beinhaltet keine Längenbegrenzung. ORA-22835: Buffer too small for CLOB to CHAR or BLOB to RAW conversion. 2021036077 - IDE : Ist in einem Workflow-Link ein Target FormContainer zugewiesen, dann kann es sein, dass dieser in einem abgeleiteten Workflow nicht mehr zieht. 2021036122 - IDE : Beim Öffnen des Method History Browser für kopierte oder neu erstellte Methoden, bei denen die Deklaration vor dem Speichern nicht bearbeitet wurde, kann es zu einer Fehlermeldung kommen. 2021046301 - IDE : Im Runtime License Manager kann es im AccessUnitTree durch Drücken der Leertaste zu einer Unhandled Exception und in der Folge zum Absturz der IDE kommen. 2021046405 - IDE : Beim Anlegen oder Löschen von Template DataSources im ListView- oder Template Control Designer kommt keine Rückfrage zum Auschecken des Forms. 2021046385 - HTML Client : Bei sehr schnellen Eingaben per Maus oder Touch können versehentlich mehrere Requests aneinandergereiht werden. 2021046388 - HTML Client : Im ListView und Template Control werden NULL-Werte als \"null\" (String) angezeigt, anstatt nichts anzuzeigen. 2021046253 - SqlServer : Wird am Ende einer sehr großen Transaktion ein Rollback ausgeführt, dann kann das zu einem Timeout und einem Abbruch der Sql-Connection führen. In der Folge kann es wegen der geschlossenen Sql-Connection im laufenden Broker-Request zu weiteren Sql-Fehlern kommen. 4.2.16 (26.03.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.16_Setup_x64 FSCL_4.2.16_Setup_x86 FSCL_4.2.16_Setup_x64 FSCL_4.2.16_Setup_Msi_x86 FSCL_4.2.16_Setup_Msi_x64 FS_4.2.16_Requirements_x86 (neuer FSClient Launcher) FS_4.2.16_Requirements_x64 (neuer FSClient Launcher) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen im FS Client-Launcher werden die Protokolle automatisch in Dateien gespeichert. Im FS Client-Launcher kann über eine Umgebungs-Variable eine abweichende Java Runtime definiert werden. Korrigierte Fehler 2021025789 - Java-Client : In den Fenstern des Haupt-Arbeitsbereiches ist es nicht mehr möglich, mit den Pfeil-Tasten durch die Menüs zu navigieren. Das erschwert die Bedienung an Blindenarbeitsplätzen. 2021035831 - Publish : Beim Auto-Publish mit FSConsole wird bei Datenbankverbindungen mit Windows Authentication fälschlicherweise trotzdem ein Username und ein Passwort erwartet. 2021025761 - IDE : Wird beim Export des Wörterbuches die Auswahl der Sprachen eingeschränkt, dann werden trotzdem alle Sprachen exportiert. 2021035928 - IDE : Bei einem \"ReplaceAll\" im Code-Editor wird der Suchtext fälschlicherweise immer als RegEx interpretiert, unabhängig von der Checkbox \"Use regular expression\". 2021036115 - Framework : Arbeitet eine Component mit einer importierten Business-Datenbank, dann kann es beim Aufruf der Methode GenerateLoadCondition() zu einer SQL-Exception kommen, wenn die Datenbank-Tabelle \"dbRun_Config\" nicht existiert. 4.2.15 (26.02.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.15_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Änderung der Logik beim Schließen des letzten Forms im HTML Client Auf Grund von Bug 2021015392 wurde die Logik, die beim Schließen des letzten Forms im HTML Client greift, überarbeitet. Es gibt nun 2 Szenarien, die es zu beachten gilt. Eine detaillierte Beschreibung gibt es hier HTML Client Actions Der HTML Client unterstutzt nun die Actions SetTitle und SetCaption . Mehr Informationen zu den unterstützten Action finden Sie hier Korrigierte Fehler 2021025560 - Java-Client : In einem TreeView wird durch den Benutzer ein TreeNode selektiert. Das löst ein OnAfterSelect-Event aus. Dann wird durch eine Aktion am Broker (z.B. durch setzen des TreeView-Datasources) ein anderer TreeNode selektiert. Klickt der Benutzer jetzt erneut auf den zuerst selektierten Eintrag, dann wird kein OnAfterSelect-Event ausgelöst. 2021025568 - Java-Client : Bei der Arbeit mit der Accessibility-Schnitstelle kann es beim Schließen von Forms zu Exceptions kommen: java.lang.ClassCastException: FrameworkSystems.FSJavaClient.DevControl.DevControlFieldRow cannot be cast to javax.accessibility.Accessible 2021015392 - HTML Client : Wird das letzte Form vom Broker aus per Action geschlossen, so muss am Client die Session ohne Rückfrage geschlossen werden, wenn keine weiteren Forms offen sind. 4.2.14 (29.01.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.14_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Vorwärts- und Rückwärtsnavigation mit Maustasten Die bisherige Navigation zwischen Einträgen ist nun auch mit den beiden zusätzlichen Navigationstasten an der Seite der Maus möglich. Korrigierte Fehler 2020125151 - Oracle : An einigen Stellen wird für das Ermitteln von Datenstrukturen der Datenbank auf die ALL_-Views zugegriffen. Besser ist es, die USER_-Views zu verwenden, weil dadurch Fehler vermieden werden können. 2016042153 - IDE : Am DBIndex gibt es eine Eigenschaft \"Active\". Diese wird über eine wenig intuitive Combobox gesteuert, welche keine Beschriftung hat und allermeist nur \"Inherit\" anzeigt. 2020114533 - IDE : Ein leerer customized Namespace kann nicht gelöscht werden. 2020125090 - IDE : Wird eine AccessUnit und deren AccessUnit Parent angelegt und nur ersteres wird eingecheckt, erfolgt keine Dependency Prüfung auf den AccessUnit Parent. 2021015220 - IDE : Werden in einem Customizing-Package Themes definiert, dann werden diese nicht mehr erkannt, sobald für dieses Customizing-Package eine Context-Version gebildet wird. 4.2.13 (18.12.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.13_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020125024 - JavaClient : Nach dem Aufruf der Grid-Action ResetSortAndFilter() am Broker wird im Client die Markierung im Spalten-Kopf nicht entfernt. Erst wenn man mit der Maus über den Spalten-Kopf fährt, wird dieser aktualisiert. 2020104105 - IDE : Wenn man an einem WorkflowLink die Eigenschaft \"Create Target\" ändert, wird unter Umständen die Eigenschaft \"Auto Fokus\" auf den gleichen Wert gesetzt. Die Benutzeroberfläche ermöglicht dann kein Ändern der Eingenschaft mehr. Gespeichert wird für \"Auto Fokus\" allerdings ggf. der ursprüngliche Wert. 2020114784 - IDE : Im GlobalEvent wird beim Parameter der Datentyp über einen TreeView ausgewählt. Dort kann nicht auf Typen des Basis-Packages zugegriffen werden. Note Der Datentyp wird jetzt über eine Auto-Completion-Textbox bearbeitet - wie auch z.B. bei den Component-Properties oder den Report-Datasources. 2020114826 - IDE : Existiert eine AccessUnit, die bei einer anderen AccessUnit als Parent hinterlegt ist, nicht mehr, kommt es zu Exceptions beim Compilieren und beim Öffnen der AccessUnit Ansicht. Note In der Registerkarte 'Access Units' wird ein Button 'Fix the parent Access Unit' angezeigt, sobald am AccessUnit ein ungültiger Parent hinterlegt ist. Wird dieser Button gedrückt, hat dies zur Folge, dass die ungültige Beziehung gelöscht wird. Sollte kein anderer gültiger Parent verfügbar sein, wird 'Root' als Parent definiert. 2020124958 - Framework : Im Grid-Binding kann es zu einem Stackoverflow / Absturz kommen, wenn das Grid den Inhalt eines Individual Properties anzeigt, welches im Getter einen neuen Value erzeugt. 2020125083 - Package Merge : Components verlieren beim Merge in das Basis-Package in der Query Einstellungen GroupBy und ReadOnly. 2020125050 - Package-Merge : Bei TextCollections kann es passieren, dass im Customizing geänderte Texte nicht korrekt in das Basis-Pacakge gemerged werden. 4.2.12 (27.11.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.12_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . HTML Client Neuerungen SetFocus Action auf Formebene Bisher wurde lediglich die letzte am Broker ausgeführte SetFocus-Action am Client ausgeführt und das unabhängig von den Forms. SetFocus-Actions werden nun per Form abgearbeitet. Deep Links Der Android Mobile Client unterstützt nun das Öffnen von Deep Links. Damit kann z.B. aus einem Browser heraus per Link der Mobile Client geöffnet und automatisch ein Login an einem Broker ausgeführt werden. Zudem kann der Broker-Liste ein Eintrag hinzugefügt werden. Beispiel im HTML: <a href=\"fsbroker://framework-systems.de?name=Demo&url=http%3A%2F%2FAwesomeServer%3A8080%2FAwesomeApplication&login=true&save=true\">Open Deep Link</a> Der Link beginnt immer mit der Custom-Url fsbroker://framework-systems.de . Diese wird vom Mobile Client im Android-System registriert und sorgt für das Öffnen der App. Zusätzlich kann die Url aus bis zu vier der folgenden Parameter bestehen: Parameter Typ Benötigt Funktion name string (url-encoded) Ja Der Name des Brokers url string (url-encoded) Ja Die Broker-Url login boolean (true/false) Nein Steuert, ob sich die App nach dem Öffnen sofort am gegebenen Broker angemelden soll. Bei false wird lediglich die Startseite angezeigt. Der Standardwert ist true . save boolean (true/false) Nein Steuert, ob der angegebene Broker in der Login-Liste des Mobile Client gespeichert werden soll. Existiert ein Eintrag mit demselben namen, so wird dessen Url überschrieben. Der Standardwert ist false . Die Parameter name und url müssen immer url-enkodiert sein. So muss wie im Beispiel statt http://AwesomeServer:8080/AwesomeApplication die url-enkodierte Variante http%3A%2F%2FAwesomeServer%3A8080%2FAwesomeApplication angegeben werden. Einen entsprechenden Url-Encoder finden Sie z.B. unter https://www.urlencoder.org Note Ein Klick auf einen Deep Link wird vom Mobile Client nur dann interpretiert, wenn folgende Bedingungen erfüllt sind: Die App ist nicht bereits an einem Broker angemeldet Die App findet beim Start keine alte Session, die fortgeführt werden kann Korrigierte Fehler 2020114581 - Publish : Im Publish-Setting können keine Unicode-Zeichen gespeichert werden. Je nach Code-Page der Datenbank gehen ggf. auch deutsche Umlaute verloren. Auch beim Einlesen eines Release-Settings im Publish und Publish2Go gehen Unicode-Zeichen verloren. 2020114749 - Package-Manager : Existieren in der Repsitory-Datenbank Tabellen oder Constraints mit Namen, die Whitespaces oder Sonderzeichen enthalten (z.B. BIN$-Tabellen auf Oracle), dann kann es beim Import oder beim Löschen einer Package-Version zu SQL-Fehlermeldungen kommen. In der Folge kann es passieren, dass auf dem Repository die Constraints nicht mehr aktiviert werden. 2020104499 - IDE : Bei der Code-Generierung der Interfaces kann es passieren, dass für die Component-Properties falsche Display-Length Informationen generiert werden. In der Folge werden Änderungen am Metadatentyp nicht korrekt gezogen. 2020114542 - IDE : Für das Anzeigen des generierten Codes zu Debugging-Zwecken wird Visual Studio 2019 nicht erkannt. Note Da es mehrere parallele Installationen von Visual Studio geben kann, ist eine eindeutige Ermittlung des Installationspfades nicht möglich. Der Pfad muss in den Optionen manuell angegeben werden. Framework Studio öffnet bei Bedarf den Optionen-Dialog. 2020114672 - IDE : Bei einem Oracle-Repository kann als Database kein TNS-String angegeben werden. Das führt zur Exceptions bei der Anmeldung am Repository. Note Für die Verwendung einer Container-Datenbank kann bei Database \"SERVICE_NAME=AbcXyz\" angegeben werden. Beim Server-Namen kann der Port jetzt mit \":\" angegeben werden z.B. \"Server:1521\". 2020114783 - IDE : Wird eine Component-Methode von public auf protected gesetzt, dann werden die Interfaces nicht in den Auto-Compile aufgenommen. Die Folge ist ein Compile-Error bei den Components. 2020114578 - HTML Client : Wird beim Start der App eine alte Session wieder hergestellt, so kommt es ggf. vor, dass der dem Form per Action zugewiesene CloseButton nicht funktioniert. 4.2.11 (30.10.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.11_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . HTML Client Neuerungen Neues Framework als Basis Der HTML Client wurde bisher mit Apache Cordova und Adobe PhoneGap Build in die mobile Welt gebracht. Adobe hat im September angekündigt, PhoneGap nicht mehr weiter zu entwickeln. Auf Grund von erweiterter Hardware-Unterstützung und der einfacheren Integration in den Entwicklungsprozess haben wir jedoch schon vor dieser Ankündigung den HTML Client auf das Ionic Capacitor Framework umgezogen. Auch die Browser-Version des HTML Clients profitiert maßgeblich vom neuen Framework. Zusätzlich zu den Bugfixes unter Korrigierte Fehler sind ab sofort folgende Verbesserungen Verfügbar: Die TakePhoto Action funktioniert nun auch im Browser Die GetGeolocation Action funktioniert nun auch im Browser Die PrintReport Action wird nun unterstützt Eine noch aktive Session wird sofort beim Starten der App geladen Wird das letzte Form geschlossen, gibt es eine Rückfrage, ob die Session geschlossen werden soll Die UI wird bei länger laufenden Requests nun vollständig gesperrt, um parallele Eingaben zu verhindern Neue Systemvoraussetzungen Unterstützt werden wie bisher Handys und Tablets mit Android 6.0 oder höher. Caution Auf Geräten mit Android 7.X oder niedriger muss Google Chrome parallel zwingend installiert sein, da die integrierte WebView nicht mehr unterstützt wird Ist auf dem Endgerät Google Chrome nicht installiert, so wird zur Anzeige der HTML-Applikation die integrierte Android WebView verwendet. Diese basiert wie Google Chrome ebenfalls auf der Chromium Engine, ist aber auf vielen - vor allem älteren - Endgeräten nur in einer sehr betagten Version verfügbar. Dies kann ggf. zu Fehlern führen. Es gelten folgende Regeln: Ist Google Chrome installiert, wird dessen Chromium Engine für die Ausführung des Framework Studio Mobile Client verwendet Ist Google Chrome nicht installiert, wird die Android WebView verwendet Note Auch auf neueren Geräten ab Android 8.0 empfehlen wir, die aktuellste Version von Google Chrome zu installieren, um die breiteste Unterstützung von Features und die fehlerfreie Darstellung der App zu garantieren. Globales CSS für ListViewItems und Template Controls Es besteht ab sofort die Möglichkeit, ListViewItems und Template Controls mit globalen CSS Styles zu versehen, welche applikationsweit angewendet werden. So kann sehr einfach ein grundlegendes Theme für die HTML Controls bereitgestellt werden, ohne dasselbe CSS an jedem Control erneut anwenden zu müssen. Mehr Informationen dazu gibt es unter folgenden Links: ListView TemplateControl Korrigierte Fehler 2020104399 - Broker : Bei der Konvertierung von XML nach JSON kann kann es zu einer Exception kommen, welche als Folge ggf. den HTML Client abstürzen lässt. 2020104461 - Package-Manager : Beim Löschen einer Package-Version wird eine Exception angezeigt: Record to update was not found in repository. Type: LabelRecord, Lbl_ID: 12... 2020093967 - IDE : Werden Properties an Template DataSources geändert, so wird keine Rückfrage zum Auschecken des Forms gestellt. Betrifft den ListView Template Editor sowie den Template Control Editor. 2020104124 - IDE : Im Template Editor von Template Control und ListView wird das DataSource Editor Panel nicht geschlossen, wenn die letzte DataSource aus der Liste entfernt wird. 2020104125 - IDE : Wenn am ListView ein Padding oder Margin definiert ist, so stellt die Preview im Template Editor das ListViewItem falsch dar. 2020104354 - IDE : Namespace-Referenzen auf den v4.0 Global Assembly Cache werden nicht unterstätzt. Der Auswahl-Dialog bietet diese Assemblies nicht an. 2020094098 - Framework : Wird mit einer Component, die eine Tabelle einer importierten Datenbank verwendet, ein Datensatz gelöscht, dann kommt es zu Exceptions, wenn die Datenbank keine Tabelle dbRun_mlStrings besitzt. Die Tabelle dbRun_mlStrings wird durch die Update-Logik automatisch angelegt, allerdings dann nicht, wenn die komplette Datenbank als \"imported\" gekennzeichnet ist. 2020031857 - HTML Client : Wird direkt im Form_Load-Event der Fokus mit SetFocus() in ein Control gesetzt, so wird dieses dennoch nicht fokussiert. 2020083526 - HTML Client : Bei langen Requests wird nun die komplette UI gesperrt (nach 300ms), sodass während der Bearbeitung keine Request-Kaskaden vom User ausgelöst werden können, die für Verwirrung sorgen. 2020083528 - HTML Client : Wird SetFocus() auf einem Control ausgeführt, welches im gleichen Request erst auf \"Visible\" geschaltet wird, so wird der Fokus nicht in das Control gesetzt. 2020083532 - HTML Client : Wird eine FieldRow zum ersten Mal auf \"Visible\" gesetzt, kann es sein, dass das Control-Label in der ersten Spalte nicht angezeigt wird. 2020083684 - HTML Client : Wird das letzte Form einer App geschlossen, so bleibt die Session offen, ohne die Möglichkeit, zurück ins Hauptmenü des HTML Client zu wechseln. Beim Schließen des letzten Forms der App wird nun gefragt, ob die Session beendet und zurück ins Hauptmenü gewechselt werden soll. 2020104210 - HTML Client : Wenn ein ListView ein Bottom Padding hat und durch die Anzahl der ListViewItems scrollbar wird, so wird das Bottom Padding nicht angezeigt, wenn man ganz nach unten scrollt. 2020104396 - HTML Client : Wenn in einem ListView oder Template Control der %FILESURL% Platzhalter verwendet wird, aber keine Template-Variablen definiert sind, so wird der Platzhalter zur Laufzeit nicht durch den Broker-Pfad ersetzt. 2020104444 - HTML Client : Auf Android-Geräten werden alle Bilder (z.B. an ImageButtons oder in ListViews) auf unbestimmte Zeit gecached. Selbst wenn eine Resource mit einem neuen Bild versehen und compiliert wird, wird am Client immernoch das alte Bild angezeigt. 2020094030 - Package-Merge : WorkflowEvents an Forms und ihre Links gehen unter Umständen verloren. 2020094032 - Package-Merge : Die Checkbox \"Output\" wird an VirtualColumns beim Merge nicht immer korrekt gesetzt. 4.2.10 (25.09.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.10_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Fehler im Package-Merge Warning Seit 29.05.2020 gibt es mehrere Probleme mit dem Package-Merge. Einige wurden korrigiert, jedoch sind noch offene Punkte bekannt. Daher empfehlen wir, bis zum nächsten Patchday auf den Package-Merge zu verzichten. Korrigierte Fehler 2020093914 - JavaClient : Der Client startet im Hintergrund eine cmd.exe. Das führt ggf. zu Problemen, wenn per Gruppenrichtline der Zugriff auf die Kommandozeile verhindert wird. 2020093778 - IDE : Kopiert man ein Property, an dem explizit ein MLKey zugeordnet ist, von einer Component in eine Andere, so wird der MLKey nicht mit übertragen. Statt dessen werden die Texte aus dem MLKey eingetragen. 2020093830 - IDE : Wird ein Compile-Vorgang gestartet, direkt nachdem der Mauszeiger in den Code-Editor platziert wurde, dann kann es in seltenen Fällen zu Exceptions und ggf. auch zu einem Absturz der IDE kommen. 2020093841 - IDE : Wunsch: Beim Kopieren per Copy&Paste von Elementen in ein anderes Package mit Texten, denen ein MLKey zugeordnet ist, soll der vollständige MLKey bei Bedarf im Zielpackage eingefügt werden. 2020093992 - IDE : In TextCollections ist die Angabe von Texten nicht mehr möglich. 2020083585 - HTML Client : Die Enter-Taste wird auf Android <= 6.0 nicht erkannt. So kann z.B. nicht mit Enter aus einem Editfield heraus gesprungen werden. 2020083660 - HTML Client : Ist einer CheckBox als DataSource ein FS-Datentyp (z.B. FSshort, FSint oder FSlong) zugeordnet und dieser auf \"NULL\" gesetzt, so ist die CheckBox dennoch angehakt. 2020011097 - Package-Merge : Im Schritt \"Checkout\" kommt es zu Fehlermeldungen, wenn im Zielpackage Elemente customized waren und anschließend wieder gelöscht wurden. 2020093954 - Package-Merge : Die Parent-Beziehungen von AccessUnits werden nicht übertragen. 2020093955 - Package-Merge : Es werden nicht alle geänderten Einstellungen in das Zielpackage übertragen. 2020093963 - Package-Merge : DataContracts werden beim Merge-Vorgang ausgelassen. 4.2.9 (28.08.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.9_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020083454 - JavaClient : Wird eine Anwendung als \"Frameless\" gestartet (z.B. der Pick-Monitor in eNVenta ERP), dann kann es passieren, dass eine Fehlermeldung angezeigt wird: Java-Exception: The frame is displayable. 2020083525 - Oracle : Beim automatischen Datenbank-Update kann es vorkommen, dass das Einlesen der Struktur-Informationen sehr lange dauert. 2019016813 - IDE : Wird eine Text-Collection per Paste in eine bestehende Text-Collection gemerged, werden die ausgewählten Texte in der Summary-Registerkarte nicht angezeigt. 2020011256 - IDE : Im Documentation-Editor wird beim Rückgängig machen der letzten Aktion (STRG+Z) der gesamte Text gelöscht, wenn lediglich eine neue Section hinzugefügt wurde oder seit dem CheckOut nichts verändert wurde. 2020062830 - IDE : Ändert man an einem Property im Getter oder Setter die Checkbox \"Write Individual\", dann wird der Methoden-Code nicht aktualisiert. 2020073327 - IDE : Beim Copy&Paste einer TextCollection werden die MLKeys nicht übertragen. 2020073331 - IDE : Nach Einfügen einer Text-Collection wird den Save-Button nicht aktiviert. 2020073346 - IDE : Im ClassView werden die Member nicht korrekt nach Name sortiert. 2020073361 - IDE : Wird im Basis-Form eine Form-Methode gelösch, die in einem Control-Event zugeordnet ist, dann wird in der Event-Zuordnung im agbeleiteten Form diese Methode weiterhin angezeigt. 2020073369 - IDE : Führt man im Workflow-Editor einen Doppel-Klick auf ein Global-Event aus um dieses zu öffnen, dann wird eine Exception angezeigt. Ein weiterer Doppel-Klick öffnet das Global-Event. 2020073372 - IDE : Wird ein neues Global-Event angelegt, dann wird eine SQL-Exception ausgelöst. Ein Speichern ist nicht mehr möglich. 2020083515 - IDE : Wird ein als Imported gekennzeichneter View customized, dann ist im Customizing die Checkbox \"Imported\" nicht aktiv. In der Folge wird beim Compile der DBTables ein Error ausgegeben: #error: 'FSErr[1064] No view definition has been specified. 2020083531 - IDE : Wird ein DataContract, dessen Contract Type auf \"IList\" oder \"Array\" steht, customized, dann wird in der Customization der Typ \"Single Item\" angezeigt. Note Wenn so ein Fall entstanden ist, dann muss der DataContract im Customizing-Package gelöscht und neu customized werden. 2020083513 - HTML Client : Ist an einem modalen Form \"HideModalHeader = true\" gesetzt, so wird mit dem Back-Button auf Android-Geräten nicht das Form geschlossen, sondern versucht, die Session zu beenden. 4.2.8 (31.07.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.8_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . HTML Client Neuerungen MLKeys und Preview im TemplateControl und ListView Im HTML-Editor des TemplateControls und ListViews können jetzt MLKeys verwendet werden. Außerdem gibt es dort nun eine Preview-Funktion. Weitere Informationen: TemplateControl und ListView . Unterstützung für das TabbedWindow Control Das TabbedWindow Control wird nun in vollem Umfang vom HTML Client unterstützt: Volle Unterstützung der TabTemplates Horizontale und vertikale ausrichtung Verwendung des DataSource -Properties, um TabPages aus dem Code heraus zu selektieren Overflow-Verhalten bei zu vielen Tabs: Sind die Tabs zu breit oder zu hoch für das Display, kann ganz einfach mit dem Mausrad oder per Touch auf mobilen Geräten durch die Liste gescrollt werden OnSelectedTabPageChange und OnSelectedTabPageChanged Events Modale Dialoge ohne Header Über ein neues Property HideModalHeader am Form kann der Header (mit Titel und Close-Button) ausgeblendet werden, wenn es als modaler Dialog aufgerufen wird. So steht etwas mehr Platz zur Verfügung. Da mit dem Header auch der Close-Button verschwindet, muss der Aufruf von this.Close() am Form anderweitig erfolgen, z.B. durch einen eigens implementieren Button oder ein Event. Fullscreen Der HTML Client wird auf mobilen Geräten ab sofort im Fullscreen-Modus ausgeführt. So steht noch etwas mehr platz für Controls zur Verfügung, da die Statusleiste und Softbuttons des Geräts die App nun überlappen. Form BadgeImages Zusätzlich zu den ImageButtons werden BadgeImages nun auch am Form über das Property BadgeImage DataSource unterstützt. Korrigierte Fehler 2020073096 - JavaClient : Wird die Anwendung über den FSClient-Launcher gestartet, dann erfolgt bei mehreren Anwendungen keine Gruppierung in der Windows Taskleiste. Note Jetzt erfolgt die Gruppierung in der Taskleiste nach der Adresse des Brokers. 2020073176 - Java-Client : Beim Entfernen und wieder Einfügen von dynamischen Grid-Spalten wird die Einfügereihenfolge nicht beachtet. 2020073067 - Oracle : Die Update-Logik in der Anwendung erzeugt Exceptions, wenn in der Business-DB Trigger ohne Tabellen-Bezug existieren. 2020073177 - Oracle : Bei paralleler Verarbeitung kann es passieren, dass der Connect zur Oracle-Datenbank eine Exception 'Timeout bei Verbindungsanforderung' erzeugt. Das betrifft z.B. das parallele Einlesen der Daten beim Start der IDE und das parallele Erzeugen von GlobalObjects in Services und im E-Gate. Note Beim Start der IDE wird jetzt die Anzahl der zusätzlichen Repository-Connections auf 8 erhöht. Mit dem Bug 2020062828 wurde für Oracle die Anzahl auf 4 begrenzt. 2020073201 - Package-Manager : Beim Branch einer Package-Version gehen alle MLKeys verloren. 2020072990 - IDE : In Methoden an Services und ServiceProxies generiert der Exception Editor Wizard durch die Verwendung von \"this.Global\" nicht kompilierbaren Code. 2020073068 - IDE : Der Documentation Chapter Tree wird falsch sortiert. Wenn man die Reihenfolge ändert, wird beim nächsten Öffnen des Chapter Tree wieder die falsche Reihenfolge angezeigt. 2020073205 - IDE : Beim Kopieren von Controls kann es zu einer NullReferenceException kommen. 2020073292 - IDE : Wenn man nach dem Laden eines Settings im Run- oder PublishWizard Framework Studio neu startet, gehen die Setting-Einstellungen verloren. 2020073317 - IDE : Wird ein neues Global-Object angelegt, dann wird dieses nach dem Wechsel auf einen anderen Namespace nicht mehr im Namespace-Baum angezeigt. 2020073335 - IDE : Bei der Bearbeitung des Source-Events im Workflow-Link kann es zu einem Absturz der IDE kommen. 2020073350 - IDE : Bei der Arbeit mit Text-Collections kann es passieren, dass in den Code der Text-Collection fälschlicherweise 2 Properties \"ID\" und \"Text\" generiert werden. In der Folge kann das zu Compile-Fehlern führen, wenn dadurch der Component-Code evtl. nicht zum Interface-Code passt. 2020073078 - Framework : Beim Neustart der Endanwendung unter Beibehalt des angemeldeten Benutzers wird der AuthenticationService nicht kontaktiert, um die Benutzerrollen neu auszuwerten. 2020072975 - HTML Client : Das OnValidated-Event wird gefeuert, obwohl sich im Textfeld nichts geändert hat. 2020073049 - HTML Client : Buttons und ImageButtons berechnen ihre Höhe unabhängig vom ShowCaption-Property. 2020073066 - HTML Client : In einem FieldPanel mit \"SynchronizedColumns = true\" wird für ausgeblendete Control Labels ggf. Platz reserviert, wodurch das Layout durcheinander gebracht wird. 2020073075 - HTML Client : FieldRows mit dem LabelMode \"None_Fill\" verursachen zur Laufzeit eine Exception, wenn das zugehörige FieldPanel \"SynchronizedColumns = true\" gesetzt hat. 2020073097 - HTML Client : Ausgeblendete Controls werden in manchen Situationen in der Fokusreihenfolge beachtet. Dies hat zur Folge, dass der Fokus ggf. in einem Control vor einem ausgeblendeten Control festhängt. 4.2.7 (26.06.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.7_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020031817 - Java-Client : Die Shortcuts Ctrl-H, Ctrl-T, Ctrl-Shift-T und Ctrl-Shift-O funktionieren nicht, wenn sich der Fokus in einem (Html)-Eingabefeld befindet. 2020062855 - Publish2Go : Wird eine Application per Publish2Go gepublished, kann es passieren, dass bei einer Application die Einstellung für den HTML-Client falsch ausgewertet wird. Auf der Broker-Startseite wird dann die Option \"HTML\" nicht angeboten. Oder bei mehren Applications wird die Option \"HTML\" fälschlicherweise bei einer normalen Application angeboten. Note Publish2Go-Pakete müssen mit der neuen Version komplett neu erzeugt werden, damit die Korrektur wirksam wird. 4.2.6 (16.06.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.6_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020052640 - IDE : Leitet man von einer Basis-Formklasse aus einem Basis-Package ab (Derive), zu der es eine Customization im aktuellen Package gibt, so kommt es zu einer Fehlermeldung und der Ableitung fehlen anschließend Controls. 2020062773 - IDE : Beim Copy&Paste wird der Control-Style nicht übertragen. Wird im Form-Designer ein neues Control mit einem vererbten Control-Style angelegt, dann wird der \"Control-Type\" auf eine alte Art verschlüsselt. 2020062779 - IDE : Wurde ein Control-Type gelöscht, dann führt das beim Öffnen eines Forms in der IDE und beim Compile zu einer Exception. Das passiert auch, wenn die betroffenen Controls bereits auf \"gelöscht\" stehen. 2020062828 - IDE : Das parallele Einlesen der Objekt-Daten beim Start der IDE mit mehreren Datenbank-Verbindungen bereitet unter Oracle Verbindungs-Probleme. Note Neues Verhalten nach der Korrektur. Unter Oracle wird die maximale Anzahl der zusätzlichen Repository-Verbindungen auf 4 begrenzt. Unter SQL-Server werden jetzt maximal 8 zusätzliche Verbindungen geöffnet. Nach 15 Sekunden werden die zusätzlichen Verbindungen wieder geschlossen. 2020062840 - IDE : Unter Oracle kommt es beim Checkout einer Textcollection zu einer Datenbank-Exception: ORA-00932: Inkonsistente Datentypen: CHAR erwartet, NUMBER erhalten. 4.2.5 (29.05.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.5_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Framework Studio Performance verbessert Die Performance der Framework Studio IDE wurde erheblich verbessert. Besonders zu spüren ist das beim Öffnen großer Elemente in Customizing Packages. Auch die Laufzeit des Compile-Wizard hat sich signifikant verringert. Erreicht wurde diese Verbesserung dadurch, dass die IDE beim Start einmal alle relevanten Informationen aus der Repository-Datenbank einliest. Direkt nach dem Start der IDE ist ein höherer Verbrauch an Arbeitsspeicher zu beobachten. Bei längerer Arbeit relativiert sich dieser Effekt, da die IDE bisher auch schon sehr viele Informationen in den Arbeitsspeicher gelesen hat. Um eine bessere Performance zu erzielen, werden die Daten parallel über mehrere Datenbank-Verbindungen eingelesen. Das bedeutet, Framework Studio öffnet in kurzer Zeit bis zu 8 zusätzliche Verbindungen zur Repository-Datenbank. Die zusätzlichen Verbindungen werden nach spätestens 15 Sekunden wieder geschlossen. MDT- und DBColumn-Änderungen im Service Release Im Service-Release-Modus können jetzt am Metadatentyp und an der DB-Column die folgenden Eingenschaften geändert werden: Caption, Tooltip, Description DisplayMinLength, DisplayMaxLength DisplayMinLines, DisplayMaxLines Korrigierte Fehler 2020042334 - Java-Client : Die Windows-Skalierung hat keinen Einfluss auf die Skalierung des Browser Controls. 2020042358 - Java-Client : In einer Grid-Combobox kann der Leer-Eintrag nicht ausgewählt werden, wenn an dem zugrundeliegenden Metadatentypen Values oder Value-Ranges definiert sind. 2019027232 - IDE : Es kommt vor, dass nach der Suche der Ergebnis-TreeView ganz nach rechts gescrollt wird. 2020031851 - IDE : Im \"Generated Code\"-Fenster und in der Method-History führt ein Klick mit der rechten Maustaste zu einer Exception. 2020042348 - IDE : Eine Exception wird geworfen, wenn der Datenbankname beim Anmelden an einem Repository ein Leerzeichen am Ende beinhaltet. 2020052462 - IDE : Der Form-Designer zeigt keine Control-Images an, wenn man ein Theme ungleich \"Default\" auswählt. Lediglich im Theme veränderte Bilder werden angezeigt. 2020052447 - Package Manager : Wird für eine Package-Version, die sich im Service-Release-Modus befindet, der Compile-Wizard ausgeführt, dann werden die Metadatentypen und DBTables nicht compiliert. Dadurch werden z.B. Änderungen an der Caption nicht gezogen. 4.2.4 (24.04.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.4_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020021741 - Java-Client : Werden in ein Html-Texteingabefeld mindestens 35 Zeilenumbrüche (p-Tags) eingefügt und erst danach Text, so kommt es beim nächsten Brokerrequest zu einer StackOverflowException. Die Anwendung ist dann unter Umständen nicht mehr bedienbar. 2020031863 - IDE : Beim Kopieren eines Browser-Controls kann es zu einer NullReferenceException kommen. 2020032095 - IDE : In einem abgeleiteten Workflow wird an Events einer Form-Instanz die Base-Eigenschaft angezeigt. Sie ist sogar änderbar. 2020042138 - IDE : Beim Kopieren und Einfügen eines ListView oder Template Controls in einem Package mit Package Prefix, wird den Template DataSources das Prefix im Namen mehrfach vorangestellt und weicht somit vom Namen im HTML Template ab. 2020032100 - Code-Generierung : Bei der Prüfung auf doppelte Controls werden bei Forms im neuen Layout weiterhin Controls aus dem Deprecated Layout berücksichtigt und führen unter Umständen zu einer nicht behebbaren Warning. 4.2.3 (27.03.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.3_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Labeln und Branchen im Package Manager Im Package Manager gibt es generell zwei Möglichkeiten, eine neue Package-Version zu eröffnen: Label ( ): Erzeugt eine neue Version auf gleicher Ebene und versiegelt dabei die Ursprungsversion. Ausgecheckte Elemente werden dabei in die neue Version übertragen. Branch ( ): Erzeugt eine neue Unterversion (eine Ebene tiefer) und verändert den Zustand der Ursprungsversion dabei nicht. Ausgecheckte Elemente verbleiben in der Ursprungsversion. Folgendes hat sich geändert: Beide Funktionen stehen nun immer zur Verfügung, wenn man Besitzer ( Owner ) des Packages ist. Auch beim Branchen wird nun geprüft, ob alle in der Ursprungsversion eingecheckten Elemente vom FrameworkCompiler kompiliert wurden. Ausgecheckte Elemente werden beim Branchen generell nicht in die neue Version übernommen. HTML Client Der ImageButton unterstützt nun das BadgeImage. Korrigierte Fehler 2020021640 - IDE : Öffnet man einen bestehenden Exception Editor / Message Box Wizard und öffnet die MLKey-Auswahl, dann ist der erste MLKey ist ausgewählt. Es sollte der aktuelle MLKey selektiert sein. 2020021722 - IDE : Der \"Multilanguage Text Migration\" Wizard weist in Custom Packages mit nur deutschen Texten bestehende passende MLKeys mit Fremdsprachentexten aus Basispackages nicht zu. 2020031861 - IDE : Wird im Message-Editor ein MLKey ausgewählt, der keinen englischen Text besitzt, dann wird im generierten Code kein Text angezeigt. Es sollte in diesem Fall ein Fallback auf den deutschen Text erfolgen. 2020031842 - HTML Client : ListView und Template Controls \"verschucken\" den Focus, wenn sie mittels Tastatur fokussiert werden. 2020031866 - HTML Client : In seltenen Fällen wird im OnLeave-Event in den FrameworkOnLeaveEventArgs der Activator nicht oder falsch befüllt. 2020031889 - HTML Client : Die Selektoren für ListViewItems sind nicht sichtbar, wenn die SelectorPosition am ListView auf \"MiddleLeft\" oder \"MiddleRight\" gesetzt ist. 4.2.2 (28.02.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020021533 - Broker : Wird ein im Treeview dargestelltes Element aus seiner Collection am Parent entfernt und anschließend eine Eigenschaft geändert, die zuvor zu einer geänderten Darstellung im Treeview geführt hätte (z.B. sDisplayName), so kann es zu einer Fehlermeldung kommen. System.ArgumentOutOfRangeException: index must reference an CollectionEntry. 2020011293 - IDE : Wird im Customizing-Package in einem Workflow ein Fired-Event verknüpft, welches aus dem Basis-Package kommt, dann wird bei der Verwendung dieses Events in einem anderen Workflow das dahinter liegenede Form nicht erkannt. Das verursacht Warnings beim Compile und bei Methoden-Aufrufe im Workflow-Link können keine Werte aus dem Quell-Form als Parameter übergeben werden. 2020021461 - IDE : Ein Verweis auf eine ältere Newtonsoft.Json.dll führt zu einer Exception beim Testen der Runtime Supervisor Url. 2020021519 - IDE : Öffnet man aus einem Customizing-Package heraus die Component aus dem Basis-Package, dann kann es vorkommen, dass in der Combobox DB-Connection ein falscher Wert angezeigt wird. Diese falsche Anzeige hat aber keine Auswirkung auf die tatsächlich verwendete Connection. 2020021539 - IDE : Beim Customizen von Methoden über das Contextmenü im Codeeditor wird eine falsche Deklaration angelegt. 2020021606 - HTML-Client : Ein SetFocus() and einem Control im Form.load() Event wird am Client nicht korrekt verarbeitet. Der Fokus wird nicht in das Control gesetzt. 2020021513 - Package-Merge : Unter Oracle kann es beim Package-Merge zu folgender Exception kommen: FrameworkSystems.FrameworkExceptions.FrameworkDbException (0x80004005): ORA-01461: Ein LONG-Wert kann nur zur Einfügung in eine LONG-Spalte gebunden werden ---> Oracle.ManagedDataAccess.Client.OracleException (0x80004005) 4.2.1 (31.01.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Connection-Pooling überarbeitet Aufgrund verschiedener Probleme wurde das Connection-Pooling der FrameworkDataConnection komplett überarbeitet. Dabei gab es auch Verhaltens-Änderungen. Bisher hat der Pool immer alle existierenden Connections gezählt - sowohl den Vorrat an verfügbaren als auch die momentan verwendeten Connections. Jetzt steuern die FSPooling -Parameter nur noch den Vorrat. Das hat (im Vergleich zu früher) den Vorteil, dass das Pooling auch dann noch wirksam ist, wenn dauerhaft eine größere Anzahl an Connections in Verwendung ist. Der Connection-Pool stellt im Broker eine Menge von wiederverwendbaren Datenbank-Verbindungen zur Verfügung. Dabei kann über die FSPooling -Parameter das Verhalten des Pools gesteuert werden. Die Parameter haben die folgende Bedeutung: FSPoolingMin : Wird eine Connection nicht mehr benötigt, wird sie (z.B. am Ende eines Broker-Requests) wieder zurück in den Vorrat / Pool gepackt. Der Pool darf dauerhaft diese Anzahl an Connections beinhalten. FSPoolingMax : Das ist die maximale Anzahl der Connections, die sich im Pool befinden dürfen. Ist der Pool voll, dann wird die Connection nicht in den Pool zurückgepackt sondern sie wird direkt geschlossen. FSPoolingTimeout : (in Sekunden) Die Connections zwischen Min und Max verbleiben maximal diese Zeit im Pool. Werden sie nicht vorher wieder verwendet, werden sie nach dem Timeout aus dem Pool entfernt und geschlossen. Neuerungen Such-Funktionalität für die ML-Columns Korrigierte Fehler 2020011151 - Oracle : Wird in einer DB-Column eine Spalte mit dem Typ Boolean angelegt, dann bringt der Datenbank-Update-Assistent einen Fehler, wenn die entsprechende Spalte auf der Datenbank bereits korrekt angelegt ist. 2020011286 - Package-Manager : An der Package-Version werden im Register Language nicht alle Sprachen aus den Basis-Packages angezeigt, wenn man an der Using-Hierarchie Änderungen vornimmt. 2020011298 - Package-Manager : Bei Package-Hierarchien mit Context-Versionen werden die Sprachen aus dem Basis-Package nicht korrekt übernommen. 2020011377 - Package-Manager : Beim Import einer Package-Version kann es zu folgendem Fehler kommen: \"There is an open DataReader associated with this Connection which must be closed first.\" 2019120999 - IDE : Wird an einer Tabellen-Spalte, die in einer customizten DBTable hinzugefügt wurde, aus Versehen die CheckBox \"Not Null\" gesetzt, dann lässt sich diese nicht mehr entfernen. 2019121032 - IDE : Wenn Framework Studio abstürzt, dann läuft der Development-Broker im Hintergrund weiter. Dieser blockiert Dateien im Compile-Verzeichnis und muss manuell beendet werden. 2020011086 - IDE : Wird bei einer Sql-Server Repository-Connection ein Server-Name mit einem Port angegeben (z.B. 127.0.0.1,1433), dann wird beim Beenden der IDE eine Exception angezeigt. 2020011136 - IDE : Wird in der ListView-Ansicht des Workflows nach einem Namen gefiltert und anschließend in der angezeigten Liste mit Doppelklick ein Workflow selektiert, dann wird eine InvalidCastException angezeigt. 2020011258 - IDE : FS stürzt mit einer GDI+ Exception ab, wenn animierte Gifs für die Dokumentation ausgewählt werden. 2020011334 - IDE : Nach dem Import eines Service-Releases wird ein darin neu angelegter MLKey im Multilanguage Text Editor zwar angezeigt, jedoch kommt es beim Kompilieren zu einer Exception, weil der MLKey nicht generiert wird. 2019121005 - Framework : Am Typ FSSystemGuid fehlt die statische Methode FromString(string). 2020011254 - FS-Broker : Wird bei einem Metadatentypen ein Format-Pattern mit einem \"&\" Zeichen angegeben, dann verursacht das XML-Exceptions wenn man ein Form öffnet, das ein Control mit diesem Metadatentypen enthält. 4.2 (20.12.2019) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.0_Setup_x64 FS_4.2.0_Requirements_x64 ( Requirements-Paket ) FS_4.2.0_RuntimeAdministration Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Die Neuerungen finden Sie unter Neuheiten 4.2 Beta-Version Hinweise Die Installation-Routine der Release-Version führt für eine bereits installierte Beta-Version ein Update auf die Release-Version aus. Important Bitte beachten Sie alle Anweisungen und Hinweise in diesem Abschnitt, wenn sie bereits eine Beta-Version von Framework Studio 4.2 verwendet haben. Die Package-Exporte und Service-Release-Exporte der aktuellen Framework Studio 4.2 Version sind inkompatibel mit den vorangegangenen Framework Studio 4.2 Beta Versionen. Dies gilt in beide Richtungen. Führen Sie in jedem Fall einen Update auf die Release-Version durch, bevor sie neue Packages im Repository importieren. Verwenden sie keine Beta-Packages mehr. Im Laufe der Beta-Versionen gab es Änderungen am Repository . Bitte führen Sie auf allen mit der Beta-Version neu erstellten und upgedateten Repositories den Update erneut aus: Im Programm-Verzeichnis die FrameworkStudioUpgradeDatabase.exe starten und am Repository anmelden. Falls noch offene Scripte angeboten werden, diese bitte ausführen. Zeilenversionierung im SQL-Server Beim Anlegen neuer Runtime Repositories im SQL-Server hat Framework Studio versäumt, die Zeilenversionierung zu aktivieren. Dadurch kann es insbesondere bei längeren Transaktionen zu unnötigen Blockierungen von Select-Statements kommen. Dieser Fehler ist nun durch die Korrektur von Bug 2019110775 behoben. Warning Bestehende SQL-Server Runtime Repositories müssen manuell korrigiert werden! Details dazu finden Sie hier: Zeilenversionierung im SQL-Server . Korrigierte Fehler In der Version 4.2 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.0.18 enthalten. Zusätzlich wurden die folgenden Bugs behoben. 2019027233 - Code-Generierung : Im generierten Code von ReportDocumentTypes wird der Package-Name verwendet statt dem Assembly-Prefix. 2019089003 - Doku-System : Ausgeblendete Controls (hidden/Collapsed) werden im Doku-Screenshot nicht gerendert. 2019100072 - Framework : Die MLColumn-Einträge werden nicht mit dem Record gelöscht, wenn nicht zuvor auf die fremdsprachigen Texte zugegriffen wurde. 2019099502 - Repository : Alle Sublabeled Tabellen sollen aus Performance-Gründen mit einem Index auf die PackageID-Spalte versehen werden."
  },
  "articles/release-4-3.html": {
    "href": "articles/release-4-3.html",
    "title": "Release-Information Framework Studio 4.3",
    "keywords": "Release-Information Framework Studio 4.3 4.3.13 (25.02.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.13_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2022029190 - Java-Client : Alle Jar-Dateien müssen neu signiert werden, weil das Java-Zertifikat widerrufen wurde. 2022029126 - IDE : Nach dem bearbeiten eines Global Events kann es passieren, dass im Workflow-Link auf dieses Global Event keine Init-Methode mehr angeboten wird. 2022029194 - IDE : Wird auf einem ControlType ein Undo Checkout ausgeführt, dann werden Form-Controls mit diesem ControlStyle und der zu verwerfenden Control-Version auf gelöscht gesetzt. Note Dieser Fehler kann eine Erklärung für Fälle sein, in denen aus heiterem Himmel Controls verschwunden sind - ohne dass jemand das Form ausgecheckt hat. Er war seit 05.2020 aktiv. 2022029147 - Doku : Informationen zum Aufräumen von tblRep_SessionLogging . 4.3.12 (28.01.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.12_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2022018908 - JavaClient : Wird per Action ein TabbedWindow (oder sein Parent) ausgeblendet, dann feuert das OnSelectedTabPageChange Event. Findet das beim Öffnen eines Forms statt, dann kann das zur Folge haben, dass das Form sich nicht im Vordergrund öffnet. 2022018909 - Java-Client : Beim Öffnen eines Forms wird in der Java-Console ggf. eine Meldung \" FrameworkSystems.FSJavaClient.DevControl.LayoutComponentDefault cannot be cast to FrameworkSystems.FSJavaClient.DevControl.DevControlTabPage \" ausgegeben. 2022018927 - Java-Client : Beim Ausführen der Action LoadGridLayout kann es bei großen Grids vorkommen, dass nicht alle Daten verarbeitet werden. 2021128765 - IDE : Beim Import einer TMX-Datei ins Wörterbuch werden ISO-Sprach-Codes in Großbuchstaben nicht erkannt. 2021128775 - IDE : Wird im Code-Editor vor einer geschweiften Klammer in einem SingleLine-Kommentar ein \".\" gesetzt, aktiviert sich die Intellisense. 2022018882 - Doku-System : Die Tabellenbeschreibungen beim HTML-Export werden unsortiert ausgegeben. 2021128815 - HTML Client : Das Picture Control wird nicht upgedated, wenn die DataSource auf \"null\" gesetzt wird. 2021128823 - HTML Client : Die Frequenz der Beep-Action ist hart auf 1000Hz festgelegt und ignoriert damit den übergebenen Wert. 4.3.11 (23.12.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.11_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021118541 - IDE : Wird ein zu langer Datenbank-Servername oder Repository-Name verwendet, dann bricht der Start der IDE mit einer Exception ab. 2021128588 - IDE : Beim Kopieren eines Component Properties wird die Eigenschaft \"Autogenerate Membervariable\" nicht kopiert. 2021128590 - IDE : Die Browser-Variante des HTML Clients funktioniert weder im Development Broker noch in einer gepublishten Umgebung. 2021128584 - Code-Generierung : Wird im Metadatentyp als Format-Pattern ein Regulärer Ausdruck verwendet, dann wird dieser im generierten Code nicht sauber escaped. In der Folge kann es zu Compile-Fehlern kommen. 2021128747 - HTML Client : Die ComboBox (ListValuesInput) reagiert nicht auf Eingaben von Buchstaben zur Auswahl des Eintrags. 2021128773 - HTML Client : Editfields mit einer DataSource vom Typ \"FSDateTime\" werfen beim Senden des Wertes zum Broker in gewissen Fällen eine Exception. 4.3.10 (26.11.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.10_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021108192 - IDE : Wird im ListView als DataSource eine TextCollection verwendet, dann ist nach dem Neustart der IDE in der Template-Variable die Zuordnung auf das Text-Property verloren. In der Folge kommt es auch zu Compile-Fehlern. 2021108258 - IDE : Verkleinert man das Framework Studio Haupt-Fenster, dann kann es passieren, dass im Namespace-Baum die untere Hälfte nicht mehr greifbar ist. Ist dann der Monitor zu klein - z.B. über Remote Desktop - dann kann man das Haupt-Fenster nicht weit genug vergrößern und der Namespace-Baum lässt sich nicht mehr bedienen. 2021118333 - IDE : Im Form-Designer werden beim Wechsel zwischen verschiedenen Form-AccessUnits die 'Parents' nicht korrekt angezeigt bzw. aktualisiert. 2021118513 - IDE : Beim Ändern eines Query-JoinTypes in der Customization kommt es zu einer Exception. 2021118297 - Framework : Werden einem ReportDocument AdditionalReports hinzugefügt, dann liefert die Methode GetReportEnums() Ergebinsse mit mehrdeutigen Report-Namen zurück. Bis zur Version 4.2 war die Ergebnismenge eindeutig. 2021118425 - FS-Framework : Enthält ein TreeView sehr viele Ebenen, dann dauert der Dispose beim Schließen des Forms sehr lange. Die Laufzeit wächst dabei exponentiell mit der Anzahl der Ebenen. 2021118300 - HTML Client : OnAfterRequest() wird am Broker nur für das derzeit aktive Form des Clients aufgerufen. 4.3.9 (29.10.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.9_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021087483 - Java Client : Werden in einem Request die MultiSelect-Eigenschaft eines Grids und zusätzlich Rows selektiert, greift die Selektierung nicht. Auch bereits selektiere Zeilen gehen verloren. 2021108162 - Java Client : Die Actions LoadGridLayout() und SaveGridLayout() arbeiten intern mit dem Titel der Spalte. Dadurch werden beim LoadGridLayout() Spalten ggf. nicht korrekt erkannt, wenn der Titel sich ändert oder mehrere Spalten denselben Titel haben. Note Die Actions arbeiten jetzt mit dem internen Namen der Spalte. LoadGridLayout() erkennt aber weiterhin die Informationen, die mit dem Titel gespeichert wurden. 2021108103 - IDE : Werden bei der Suche nach CheckOut Treffer gefunden, deren Namespace nicht mehr existiert, dann gibt es eine Exception und das Ergebnis wird nicht angezeigt. Das kann vorkommen, wenn der Namespace von einem anderen Benutzer gelöscht wird, während man selbst darin neue Elemente angelegt hat. Note Diese Treffer werden jetzt direkt unterhalb vom Package angezeigt. 2021108136 - IDE : Wenn im Form-Designer die Font eines Elementes über dem Property-Grid angepasst werden soll, kann es in seltenen Fällen vorkommen, dass Fonts ohne Namen in der Liste zur Auswahl stehen. Wenn eine Font ohne Namen ausgewählt wird, führt dies zu einem Absturz der IDE. 2021108146 - IDE : Wenn nach dem Anlegen einer neuen .WTS-Ressource in den eNVenta Update Script Editor gegangen wird und dort direkt auf \"New Table\" geklickt wird, führt dies zu einem Absturz von FS. 2021108205 - IDE : Wenn beim Erstellen einer neuen Column in einer Datenbanktabelle ein Metadatentype ausgewählt wird, wird der Name des neuen Columns richtigerweise umbenannt. Allerdings verliert der Name dabei den Package prefix (z. B. CCC_). 2021097867 - Framework : Wird in einem abgeleiteten oder customizten Form einem Grid als DataSource eine neue Collection zugewiesen, dann kann auf diesem Grid keine Sortierung ausgeführt werden. 4.3.8 (24.09.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.8_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021097624 - IDE : Ruft man in einer customized Form die Control Events auf einem Custom Control auf, werden dort die Event-Methoden-Zuweisungen aus der Basis nicht angezeigt. 2021097638 - IDE : Bei einem Undo Checkout auf einem ReportDocumentType wird die vorherige Version des Reports nicht auf die Festplatte geschrieben. Bei einem darauffolgenden Edit wird die bereits bearbeitete Version angezeigt, nicht die zurückgesetzte. 2021097738 - IDE : Wenn direkt nach dem Start der IDE der Fokus im leeren Property Grid steht und die Taste F1 gedrückt wird, dann beendet sich die IDE mit einer UnhandledException. 4.3.7 (27.08.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.7_Setup_x64 FS4.2.20_AuthService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuer Authentication-Service Es gibt einen neuen Authentication-Service mit der Version 4.2.20. Dieser ersetzt die bisherige Version 4.0.16. Die neue Version behebt einen Fehler in der Windows-Authentication (siehe unten). Note Der neue Authentication-Service ist kompatibel mit älteren Versionen von Applikationen (FS 4.0 und älter). Korrigierte Fehler 2021087434 - Broker : Grids und ListViews besitzen in FieldPanels kein generiertes Label, wenn die Caption aus dem DataSource-Property gezogen wird. 2021087506 - Authentication Service : Die Windows-Authentifizierung funktioniert nicht, wenn der Authentication Service als Windows Service installiert ist und mit einem Domain-User betrieben wird. 2021087467 - HTML Client : Beim Öffnen des virtuellen Keyboards in Android 8 oder älter, wird die WebView in seltenen Fällen vertikal um die Höhe der Statusbar nach oben verschoben. Die Folge ist ein grauer Streifen zwischen der WebView und dem Keyboard. 2021087519 - HTML Client : Labels werden als fokussierbar angesehen und stören die Fokusreihenfolge. 2021087523 - HTML Client : Controls ohne Größe (MaxWidth = 0 oder MaxHeight = 0) werden fälschlicherweise in der Fokusreihenfolge berücksichtigt und stören diese dadurch. 4.3.6 (29.07.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.6_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2021077133 - Reporting : Wird am ReportDocument über die Methode SetDatasource() ein Wert gesetzt, dann wird das bei einem vorherigen Druck erzeugte DataSet nicht zurückgesetzt. Das hat zur Folge, dass bei Folge-Drucken in eNVenta die Daten für den Report nicht neu aufbereitet werden. Das betrifft z.B. das Ändern der Checkbox Briefkopf im Druck-Dialog. 2021077068 - Broker : Läuft eine Application mit Authentication, dann wird die Lizenz-Prüfung teilweise nicht durchgeführt. Dadurch sehen Benutzer in der Oberfläche nicht lizensierte Elemente. Der Fehler tritt in der Methode für die Berechtigungs-Prüfung Granted() auf. Die Prüfung auf funktionaler Ebene durch LicenseGranted() ist davon nicht betroffen. 2021077185 - IDE : Nach dem Bearbeiten von Namespace-Referenzen kann es vorkommen, dass trotz Speichern der Namespace noch immer als geändert angezeigt wird. FS muss neu gestartet werden . 2021077150 - Framework : Mit Framework Studio 4.2.17 und 4.3.5 wurden an den FS-Typen das Interface IFormattable implementiert (Bug 2021066957). Diese Erweiterung hat negative Auswirkungen auf bestehenden Code - z.B. wenn SQL-Statements mit String.Format() oder String-Interpolation erzeugt werden. Bisher wurden null-Werte über Methode ToString() mit dem String \"null\" abgebildet, die Format-Methoden liefern aber einen leeren String zurück. Note Die IFormattable-Implementierung wurde bis auf Weiteres wieder komplett entfernt. 2021077114 - HTML Client : Wird ein Control mit \"Tab\" verlassen, so kann es ein, dass der Fokus-Indikator (Outline oder gelbe Hintergundfarbe) immer noch sichtbar ist. 2021077151 - HTML Client : Ein TabbedWindow kann per \"Tab\" nicht fokussiert werden. Befindet sich der Fokus im letzten Control der aktiven TabPage, so springt der Fokus nicht mehr heraus zum nächsten Control. 2021077221 - HTML Client : Die Kamera funktioniert nicht auf Android 11 oder höher 2021077223 - HTML Client : Bei der Ausführung der TakePhoto-Action am Client wird nicht nur das Bild zurück an den Broker geschickt, sondern auch lokal eine Kopie in der Gallery gespeichert. 2021077228 - HTML Client : Der Fullscreen-Modus funktioniert auf Android 11 nicht. Note Auf Grund eines zwar bestätigten aber bisher nicht korrigierten Bugs in Android 11 kann der HTML Client auf dieser Version deshalb nur im normalen Modus betrieben werden. 2021077229 - HTML Client : Beim Pausieren der App auf Android wird ggf. die aktive Session nicht korrekt gespeichert. Dadurch kann nach einem Neustart der App ggf. die Session nicht fortgeführt werden. 4.3.5 (25.06.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.5_Setup_x64 FS_4.2.18_PrintService Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neue Crystal Reports Runtime Es wird die Crystal Reports Runtime mit Version 13.0.26 und höher unterstützt. Voraussetzung ist der neue Print-Service 4.2.18. Das Requirements-Paket beinhaltet vorerst weiterhin die Version 13.0.18 Note Bitte beachten sie unbedingt die Hinweise in den aktualisierten Systemvoraussetzungen ! Korrigierte Fehler 2021066859 - Print-Service : Treten beim Verarbeiten von Druckaufträgen wiederholt Fehler auf, dann führt der Print-Service einen Restart durch. Wird der Print-Service aber als Console ausgeführt, dann funktioniert dieser Restart nicht. In der Folge läuft der Print-Service weiter und produziert weiter Fehler. 2021066919 - Print-Service : Wenn im Print-Service sehr viele Drucker definiert sind, dann kann das den Start des Dienstes so stark verzögern, dass der Start in einen Timeout läuft. Im PrintServiceConfigEditor wird ein Timeout von 30 Sekunden verwendet. Note Die Analyse der Drucker wird jetzt nach dem Start des Dienstes ausgeführt. Anstehende Druckjobs werden erst im Anschluss verarbeitet. Es kann also sein, dass die ersten Druckjobs erst mehrere Sekunden nach erfolgreichem Start des Dienstes verarbeitet werden. 2021066928 - Print-Service : Läuft der Print-Service in einen Fehler - z.B. bei der Verarbeitung eines Crystal Report Documents - dann erfolgt ein automatischer Restart des Services. Dabei wird die letzte Transaktion auf \"fehlerhaft\" gesetzt. In der Folge wird der Druck-Job nicht verarbeitet, auch wenn nach dem Neustart eine Verarbeitung möglich wäre. Note Tritt so ein Fehler auf, dann wiederholt der Print-Service jetzt nach dem Restart einmalig den Druck-Job. 2021066966 - Print-Service : Wird der Print-Service als Console ausgeführt, dann blockiert eine Markierung von Text die Console und damit den kompletten Print-Service. Note Bei einer Blockade läuft der Print-Service jetzt im Hintergrund weiter. Während der Blockade werden alle Ausgaben gepuffert und nach der Freigabe ausgegeben. Die Blockade der Console-Ausgabe während der Markierung ist eine Windows-Funktion und kann durch den Print-Service nicht unterbunden werden. 2020093875 - IDE : Eine DLL-Referenz in einem Form-Namespace, welche in Sub Namespaces verwendet werden kann, führt zu einem Compile-Fehler im Child bzw. Sub-Namespace. 2021056504 - IDE : Werden an einer GridColumn die Events bearbeitet, werden die Änderungen nicht autom. gespeichert und auch der Speicherbutton wird nicht aktiviert. 2021066783 - IDE : Mit einem Oracle-Repository kommt es beim Aufruf der Method History zu einem Fehler: ORA-00932: Inkonsistente Datentypen: CLOB erwartet, CHAR erhalten. 2021066884 - IDE : Im Paste-Dialog in der Registerkarte \"Summary\" wird bei einem Replace \"No conflicts found!\" angezeigt. Hierdurch ist auf den ersten Blick nicht ersichtlich, dass eine Methode mit gleicher Signatur überschrieben wird. 2021066945 - IDE : Beim Checkin eines Records werden auch von dem Record verwendete, neu angelegte Records erkannt und diese automatisch mit eingecheckt. Handelt es sich bei dem verwendeten Record aber um eine Customization, dann ist dessen Checkin nicht zwingend nötig, weil er ja schon im Basis-Package eingecheckt wurde. 2021066893 - HTML Client : Das sofortige Blockieren der UI bei einem Event wurde entschärft. Das Sperren erfolgt erst nach 500ms. 4.3.4 (30.04.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.4_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Bei den Access Units wurde die Ansicht der verbundenen AccessUnits verbessert. Es werden nun neben den Parents auch die AccessUnit-Children angezeigt. Zudem können die AccessUnit-Parents bearbeitet werden. Korrigierte Fehler 2021036188 - Oracle : Werden in einem Grid Spalten mit Langtext gefiltert oder sortiert, dann kommt zu einer Sql-Exception, wenn die Texte auf der Datenbank eine Länge von 2000 bzw. 4000 Zeichen überschreiten. Die SQL-Methode LOB_COMPARABLE( ) beinhaltet keine Längenbegrenzung. ORA-22835: Buffer too small for CLOB to CHAR or BLOB to RAW conversion. 2021036077 - IDE : Ist in einem Workflow-Link ein Target FormContainer zugewiesen, dann kann es sein, dass dieser in einem abgeleiteten Workflow nicht mehr zieht. 2021036122 - IDE : Beim Öffnen des Method History Browser für kopierte oder neu erstellte Methoden, bei denen die Deklaration vor dem Speichern nicht bearbeitet wurde, kann es zu einer Fehlermeldung kommen. 2021046301 - IDE : Im Runtime License Manager kann es im AccessUnitTree durch Drücken der Leertaste zu einer Unhandled Exception und in der Folge zum Absturz der IDE kommen. 2021046405 - IDE : Beim Anlegen oder Löschen von Template DataSources im ListView- oder Template Control Designer kommt keine Rückfrage zum Auschecken des Forms. 2021046240 - Framework : Gibt es in einem Grid mehrere Spalten, die dasselbe Property anzeigen, dann führt das beim Sortieren und Filtern im Client zu einer Exception. 2021046385 - HTML Client : Bei sehr schnellen Eingaben per Maus oder Touch können versehentlich mehrere Requests aneinandergereiht werden. 2021046388 - HTML Client : Im ListView und Template Control werden NULL-Werte als \"null\" (String) angezeigt, anstatt nichts anzuzeigen. 2021046253 - SqlServer : Wird am Ende einer sehr großen Transaktion ein Rollback ausgeführt, dann kann das zu einem Timeout und einem Abbruch der Sql-Connection führen. In der Folge kann es wegen der geschlossenen Sql-Connection im laufenden Broker-Request zu weiteren Sql-Fehlern kommen. 4.3.3 (26.03.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.3_Setup_x64 FS_4.3.3_Requirements_x64 (neuer FSClient Launcher) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen im FS Client-Launcher werden die Protokolle automatisch in Dateien gespeichert. Im FS Client-Launcher kann über eine Umgebungs-Variable eine abweichende Java Runtime definiert werden. Korrigierte Fehler 2021025789 - Java-Client : In den Fenstern des Haupt-Arbeitsbereiches ist es nicht mehr möglich, mit den Pfeil-Tasten durch die Menüs zu navigieren. Das erschwert die Bedienung an Blindenarbeitsplätzen. 2021035831 - Publish : Beim Auto-Publish mit FSConsole wird bei Datenbankverbindungen mit Windows Authentication fälschlicherweise trotzdem ein Username und ein Passwort erwartet. 2021025761 - IDE : Wird beim Export des Wörterbuches die Auswahl der Sprachen eingeschränkt, dann werden trotzdem alle Sprachen exportiert. 2021035810 - IDE : Der Befehl \"New Workflow for Form\" legt einen neuen Workflow an, auch wenn dieser bereits existiert. Note Der Befehl wurde in \"Open or create Workflow for Form\" umbenannt und öffnet einen bereits existierenden Workflow. Sollten mehrere Workflows für eine Form existieren, wird die Dependency-Suche ausgeführt. 2021025793 - Framework : Das ListView-Control löscht bei einem Aufruf von Load() oder Clear() an der gebundenen Collection nicht die bisher angezeigten ListViewItems. 2021036115 - Framework : Arbeitet eine Component mit einer importierten Business-Datenbank, dann kann es beim Aufruf der Methode GenerateLoadCondition() zu einer SQL-Exception kommen, wenn die Datenbank-Tabelle \"dbRun_Config\" nicht existiert. 2021035904 - FS-Framework : In einer Component kann es in sehr seltenen Fällen bei einem Aufruf von PropertyChanged zu einer NullException kommen. Der Fehler tritt nur im Multi-Threading auf (z.B. im eNVenta Job-Server). 2021035808 - FS-Services : Nach dem Publish eines Services startet dieser nicht. Es wird eine Fehlermeldung System.ArgumentNullException ausgegeben. 2021035983 - Package Merge : Beim Analysieren der betroffenen Records kann im Bereich Workflow eine NullReferenceException auftreten. 4.3.2 (26.02.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Änderung der Logik beim Schließen des letzten Forms im HTML Client Auf Grund von Bug 2021015392 wurde die Logik, die beim Schließen des letzten Forms im HTML Client greift, überarbeitet. Es gibt nun 2 Szenarien, die es zu beachten gilt. Eine detaillierte Beschreibung gibt es hier HTML Client Actions Der HTML Client unterstutzt nun die Actions SetTitle und SetCaption . Mehr Informationen zu den unterstützten Action finden Sie hier Korrigierte Fehler 2021025560 - Java-Client : In einem TreeView wird durch den Benutzer ein TreeNode selektiert. Das löst ein OnAfterSelect-Event aus. Dann wird durch eine Aktion am Broker (z.B. durch setzen des TreeView-Datasources) ein anderer TreeNode selektiert. Klickt der Benutzer jetzt erneut auf den zuerst selektierten Eintrag, dann wird kein OnAfterSelect-Event ausgelöst. 2021025568 - Java-Client : Bei der Arbeit mit der Accessibility-Schnitstelle kann es beim Schließen von Forms zu Exceptions kommen: java.lang.ClassCastException: FrameworkSystems.FSJavaClient.DevControl.DevControlFieldRow cannot be cast to javax.accessibility.Accessible 2021015413 - Framework : Wird einem Property, welches an ein Grid-Control gebunden ist eine neue Instanz zugewiesen, dann werden die am Grid eingestellten Filter und Sortierungen zurückgesetzt. 2021025449 - Framework : die Eigenschaft \"ComponentProperties\" hat eine schlechte Performance. 2021025498 - Framework : Bei Template- und ListView-Controls werden die Namen der Template-Variablen nicht korrekt im Response verschlüsselt. In der Folge kommt es zu Fehlermeldungen im Mobile-Client: Could not find TemplateDataSource 2021025514 - FS-IDE : Wird in einem Namespace, der im Basis-Package keine Component beinhaltet (z.B. eNVenta NV.ERP.MM), im Customizing-Package eine neue Component angelegt, dann kommt es beim Compile zu einer FileNotFoundException. 2021015392 - HTML Client : Wird das letzte Form vom Broker aus per Action geschlossen, so muss am Client die Session ohne Rückfrage geschlossen werden, wenn keine weiteren Forms offen sind. 4.3.1 (29.01.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Die Vorwärts- und Rückwärtsnavigation zwischen Einträgen ist nun auch mit den beiden zusätzlichen Navigationstasten an der Seite der Maus möglich. Korrigierte Fehler 2020125151 - Oracle : An einigen Stellen wird für das Ermitteln von Datenstrukturen der Datenbank auf die ALL_-Views zugegriffen. Besser ist es, die USER_-Views zu verwenden, weil dadurch Fehler vermieden werden können. 2016042153 - IDE : Am DBIndex gibt es eine Eigenschaft \"Active\". Diese wird über eine wenig intuitive Combobox gesteuert, welche keine Beschriftung hat und allermeist nur \"Inherit\" anzeigt. 2020114533 - IDE : Ein leerer customized Namespace kann nicht gelöscht werden. 2020124914 - IDE : Ruft man in der Set-Method eines Component-Properties den Exception-Wizard auf, dann kann es im Anschluss zu NullReferenceExceptions kommen. In diesem Fall ist ein Restart von Framework Studio nötig um die Situation zu bereinigen. 2020125090 - IDE : Wird eine AccessUnit und deren AccessUnit Parent angelegt und nur ersteres wird eingecheckt, erfolgt keine Dependency Prüfung auf den AccessUnit Parent. 2021015220 - IDE : Werden in einem Customizing-Package Themes definiert, dann werden diese nicht mehr erkannt, sobald für dieses Customizing-Package eine Context-Version gebildet wird. 2020125181 - Code-Generierung : Wird an einem abgeleiteten Grid der DataSource überschrieben, dann führt das zu einem Compile-Fehler. 2020125172 - Framework : Das Listen-DataBiding einer Combobox überträgt zu oft Daten an den Client, wenn der Verwendete Display- oder Value-Member ein Individual Property ist. In der Folge kann es im JavaClient bei der Eingabe von Werten in die Combobox zu Fehlverhalten kommen. 2020125182 - Framework : Wird an einem abgeleiteten Grid der DataSource überschrieben, dann zeigt das Grid in der Anwendung nur leere Zeilen an. 2020125183 - Framework : Wird an einer Component ohne Datenbank-Bezug die Methode RollbackChanges() aufgerufen, dann wird kein PropertyChanged-Event gefeuert. In der Folge wird im in einem Form das Databinding nicht aktualisiert. 4.3 (18.12.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.3.0_Setup_x64 FS_4.3.0_Requirements_x64 ( Requirements-Paket ) Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Die Neuerungen finden Sie unter Neuheiten 4.3 Bekannte Probleme Warning In der aktuellen Version sind die folgenden Probleme vorhanden. Diese werden mit dem nächsten Service-Release behoben. 2020124914 - IDE : Ruft man in der Set-Method eines Component-Properties den Exception-Wizard auf, dann kann es im Anschluss zu NullReferenceExceptions kommen. In diesem Fall ist ein Restart von Framework Studio nötig um die Situation zu bereinigen. Workaround : Zuerst mit der Maus in die Get-Method des Properties klicken. Dadurch wird eine Initialisierung ausgeführt, die die Exception verhindert. Korrigierte Fehler In der Version 4.3 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.2.13 enthalten. Zusätzlich wurden die folgenden Bugs behoben: 2020052729 - Java-Client : Im Dialog für die Eingabe der Spalten-Filter sollte der Fokus direkt in das Eingabe-Feld gesetzt werden. Nach Eingabe eines Wertes soll der Filter direkt angewendet werden. 2017089506 - IDE : Wenn man in einem Code-Editor die Suche eingeschränkt auf den selektierten Bereich ausführt, wird immer Case-sensitiv gesucht, auch wenn die Checkbox nicht gesetzt ist. Find and Replace ist ebenfalls betroffen. 2020042323 - IDE : Beim Erstellen einer individual Datenbank-Connection wird ein neuer (leerer) Eintrag erstellt. Es sollte der vorhandene Eintrag kopiert und als Individual (editable) angelegt werden. 2020073102 - IDE : Wird in einer DBTable die letzte Column gelöscht, dann wird eine NullReferenceException angezeigt. 2020104512 - IDE : bei der Anlage eines neuen Crystal Report mit einer neuen Report-Datei gibt es eine Exception: System.System.ArgumentNullException: Der Wert darf nicht NULL sein 2020104214 - Code-Generierung : Public ComponentProperties vom Typ Membervariable werden z.T. in das Interface der Component generiert. Databinding im Form ist damit dann trotzdem nicht möglich. Note In vergangenen Versionen wurden diese Properties bereits als Obsolete gekennzeichnet. Mit der aktuellen Version wurden sie komplett entfernt. Damit gilt jetzt die ganz klare Regel: Component-Properties mit dem Typ Membervariable stehen nicht in den Interfaces zur Verfügung. 2020124918 - Code-Generierung : Wird ein Global Object auf ein cGlobal-Property umgelenkt, welches mit einem Obsolete-Attribut versehen ist, dann gilt das Global Object selber nicht als Obsolete. Dadurch treten 1.) Obsolete-Warnings beim Compile der Global Objects auf, und 2.) erzeugen Verwendungen dieses Global Objects keine Warning."
  },
  "articles/release-4-4.html": {
    "href": "articles/release-4-4.html",
    "title": "Release-Information Framework Studio 4.4",
    "keywords": "Release-Information Framework Studio 4.4 4.4.3 (25.02.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.3_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Bekannte Probleme 2022029176 - Package-Manager : Wird im Package-Manager mit der Version 4.4 eine Package-Version mit einer älteren Version (z.B. FS 4.2) gelöscht, dann werden Context-Versionen nicht berücksichtigt. Dadurch wird die Package-Hierarchie zerstört. Weil sich das nicht mehr lösen lässt, muss das Repository-Backup zurück gespielt werden. Note Das Löschen von älteren Package-Versionen wurde vorübergehend deaktiviert, um Beschädigungen an Repositories zu verhindern. Es wird voraussichtlich mit dem nächsten Patchday eine Korrektur geben. Neuerungen Die Anmeldung mit dem FrameworkAdministrator an der IDE zur User-Verwaltung wurde entfernt. Die User-Verwaltung kann nun ausschließlich über den Package Manager im Menü Tools -> Manage Users aufgerufen werden. In der IDE werden noch nicht abgespeicherte Tabs mit einem Stern * gekennzeichnet. Korrigierte Fehler 2022029190 - Java-Client : Alle Jar-Dateien müssen neu signiert werden, weil das Java-Zertifikat widerrufen wurde. 2022029110 - Reporting : Ein ReportEnum-Konstruktor setzt keinen Dateinamen, wodurch z.B. der Druck von per Client Side Customizing erstellten Reports fehlschlägt. 2022019075 - IDE : Beim Anmelden mit dem FrameworkAdministrator an der IDE kommt es zu einer Exception. Note Die Anmeldung mit dem FrameworkAdministrator an der IDE zur User-Verwaltung wurde entfernt. Die User-Verwaltung kann nun ausschließlich über den Package Manager im Menü Tools -> Manage Users aufgerufen werden. 2022029093 - IDE : Customize aus dem Context-Menü einer Basis-Methode funktioniert nicht. 2022029094 - IDE : In der laufenden Session werden Änderungen an Components im Intellisense-Store nicht aktualisiert. Dadurch sind z.B. neu angelegte Properties erst nach einem Neustart zu sehen. 2022029126 - IDE : Nach dem bearbeiten eines Global Events kann es passieren, dass im Workflow-Link auf dieses Global Event keine Init-Methode mehr angeboten wird. 2022029194 - IDE : Wird auf einem ControlType ein Undo Checkout ausgeführt, dann werden Form-Controls mit diesem ControlStyle und der zu verwerfenden Control-Version auf gelöscht gesetzt. Note Dieser Fehler kann eine Erklärung für Fälle sein, in denen aus heiterem Himmel Controls verschwunden sind - ohne dass jemand das Form ausgecheckt hat. Er war seit 05.2020 aktiv. 2022029147 - Doku : Informationen zum Aufräumen von tblRep_SessionLogging . 2022029101 - Framework : AccessUnitHierarchy.CreateHierarchy wirft eine NullReferenceException. 4.4.2 (28.01.2022) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Am cGlobal wurde ein neuer EntryPoint geschaffen, mit dem man Lizenz-Freigabe programmatisch einschränken kann, obwohl die Lizenz-Datei dies erlaubt. Es ist nun möglich, Headlines im Dokumentationsfenster zu nutzen. Korrigierte Fehler 2022018908 - JavaClient : Wird per Action ein TabbedWindow (oder sein Parent) ausgeblendet, dann feuert das OnSelectedTabPageChange Event. Findet das beim Öffnen eines Forms statt, dann kann das zur Folge haben, dass das Form sich nicht im Vordergrund öffnet. 2022018909 - Java-Client : Beim Öffnen eines Forms wird in der Java-Console ggf. eine Meldung \" FrameworkSystems.FSJavaClient.DevControl.LayoutComponentDefault cannot be cast to FrameworkSystems.FSJavaClient.DevControl.DevControlTabPage \" ausgegeben. 2022018927 - Java-Client : Beim Ausführen der Action LoadGridLayout kann es bei großen Grids vorkommen, dass nicht alle Daten verarbeitet werden. 2018043231 - IDE : Beim Paste eines Metadatentyps zeigt die Prüfung keine Konflikte an, wenn der Basis-Metadatentyp nicht existiert. Beim Einfügen wird dann eine Exception ausgelöst. 2021128765 - IDE : Beim Import einer TMX-Datei ins Wörterbuch werden ISO-Sprach-Codes in Großbuchstaben nicht erkannt. 2021128775 - IDE : Wird im Code-Editor vor einer geschweiften Klammer in einem SingleLine-Kommentar ein \".\" gesetzt, aktiviert sich die Intellisense. 2022018943 - IDE : Nach dem Kopieren und Einfügen eines CustomControls kann das Zielform nicht mehr compiliert werden. 2022018947 - IDE : Wenn im Dokumentations-Editor sehr große Dokumentationen bearbeitet werden, kann es zum zeitweisen Einfrieren des Editors kommen. 2022018949 - IDE : GAC-Referenzen werden nicht zu der zu kompilierenden Klasse hinzugefügt, wodurch der Compile mit Errors abbricht. 2022018881 - Doku-System : Die Checkbox \"Include DB-Tables\" beim HTML-Export hat keinen Effekt. Die Tabellenbeschreibungen werden nicht exportiert. 2022018882 - Doku-System : Die Tabellenbeschreibungen beim HTML-Export werden unsortiert ausgegeben. 2022018856 - Framework : AUHelper.GetAccessUnitInfos() verursacht NullReferenceException. 2021128815 - HTML Client : Das Picture Control wird nicht upgedated, wenn die DataSource auf \"null\" gesetzt wird. 2021128823 - HTML Client : Die Frequenz der Beep-Action ist hart auf 1000Hz festgelegt und ignoriert damit den übergebenen Wert. 2022018973 - PackageManager : Muss ein importiertes Package aufgrund eines Service Release kompiliert werden, dann kann es vorkommen, dass die MLKeys dieses Packages nicht berücksichtigt werden. 4.4.1 (23.12.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Kein Internet Explorer 11 mehr Der Internet Explorer 11 wird nicht mehr unterstützt. Folgende Features können nur noch mit aktuellen Browsern wie z.B. Edge, Chrome oder Firefox genutzt werden: Client Start Page Mit Framework Studio generierte Online-Hilfe Mobile Client Neuerungen Erweiterungen im Dokumentations-Editor Rechtschreibprüfung Das Einfügen von Links wurde überarbeitet Einfügen von Url-Links aus der Zwischenablage Einfügen von Bildern aus der Zwischenablage Der Tooltip kann direkt im Editor bearbeitet werden. HTML Client Actions Folgende Actions werden nun vom HTML Client unterstützt: Beep BeepDouble BeepMultiple Korrigierte Fehler 2021128654 - Broker : Wird im Customizing-Package eine Developer-Lizenz verwendet, dann werden die Lizenzen der Basis-Packages nicht ausgewertet. Folglich werden alle Features freigeschaltet. 2021118528 - IDE : Im Login-Dialog kann man mit TAB nicht in die Combobox Auto Debug DLLs springen. 2021118541 - IDE : Wird ein zu langer Datenbank-Servername oder Repository-Name verwendet, dann bricht der Start der IDE mit einer Exception ab. 2021128575 - IDE : Wenn versucht wird, in einer Dokumentation ein Hyperlink einzufügen, muss dieser mit http:// beginnen und verbietet somit https:// Hyperlinks. 2021128588 - IDE : Beim Kopieren eines Component Properties wird die Eigenschaft \"Autogenerate Membervariable\" nicht kopiert. 2021128680 - IDE : Wurden nach dem FrameworkCompiler Elemente eingecheckt, dann werden diese anderen Benutzern bei Get Latest CheckIns ggf. nicht angezeigt. 2021128584 - Code-Generierung : Wird im Metadatentyp als Format-Pattern ein Regulärer Ausdruck verwendet, dann wird dieser im generierten Code nicht sauber escaped. In der Folge kann es zu Compile-Fehlern kommen. 2021128747 - HTML Client : Die ComboBox (ListValuesInput) reagiert nicht auf Eingaben von Buchstaben zur Auswahl des Eintrags. 2021128773 - HTML Client : Editfields mit einer DataSource vom Typ \"FSDateTime\" werfen beim Senden des Wertes zum Broker in gewissen Fällen eine Exception. 4.4.0 (10.12.2021) Die Auslieferung umfasst die folgenden Pakete: FS_4.4.0_Setup_x64 FS_4.4.0_PrintService FS_4.4.0_Requirements_x64 ( Requirements-Paket ) FSCL_4.4.0_Setup_x86 FSCL_4.4.0_Setup_x64 FSCL_4.4.0_Setup_Msi_x86 FSCL_4.4.0_Setup_Msi_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Die Neuerungen finden Sie unter Neuheiten 4.4 Korrigierte Fehler In der Version 4.4 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.3.10 enthalten. Zusätzlich wurden die folgenden Bugs behoben. 2021118369 - Framework : Wird an einer Grid-Combobox im Customizing an abweichender Display-Member definiert, dann ziehen ggf. weiterhin Eigenschaften des in der Basis angegebenen Display-Members. So wird z.B. weiterhin ein \"Uppercase\" gezogen, wenn im neuen Display-Member kein Format definiert ist."
  },
  "articles/requirements.html": {
    "href": "articles/requirements.html",
    "title": "Systemvoraussetzungen",
    "keywords": "Systemvoraussetzungen Entwicklungs-Rechner Ein Rechner auf dem mit der Framework Studio IDE entwickelt wird bzw. ein Rechner oder Server auf dem der Framework-Compiler ausgeführt wird. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows 10 - mind. Version 18.03 Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Windows Server 2012 R2 .NET Framework .NET Framework 4.8 - oder höher https://dotnet.microsoft.com/download/dotnet-framework/net48 Weitere Software Java-Runtime Crystal Reports Runtime Crystal Reports Designer Visual Studio: empfohlen zum Debuggen von Anwendungen Visual Studio 2017 oder höher Andere Versionen können auf eigene Verantwortung in den IDE-Options konfiguriert werden. Anwendungs-Server Rechner, auf dem Broker oder mit Framework Studio veröffentlichte Services laufen. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Windows Server 2012 R2 Client-Betriebssysteme: Ein Broker oder Service kann prinzipiell auf einem Client-Betriebssystem (Windows 10) installiert werden. In einer Produktiv-Umgebung wird aber dringend der Einsatz eines o.g. Server-Betriebssystems empfohlen. Auf Client-Betriebssystemen können nur sehr wenige Benutzer parallel arbeiten. .NET Framework .NET Framework 4.8 - oder höher Weitere Software Crystal Reports Runtime IIS Print-Server Der Print-Service benötigt eine Verbindung zur Runtime-Repository-Datenbank und er muss die gewünschten Drucker ansprechen können. Er wird nicht von der Anwendung direkt kontaktiert, deshalb kann auch ein Client-Betriebssystem verwendet werden. Print-Service Die hier aufgeführten Systemvorrausetzungen gelten für den Print-Service Version 4.2. Framework Studio ist kompatibel mit älteren Versionen des Print-Service. Kommen diese zum Einsatz, gelten die Systemvorrausetzungen für die jeweilige Version. Framework Studio Print-Service 4.2.18 Framework Studio Print-Service 4.0.29 Framework Studio Print-Service 3.11.67 Betriebssystem siehe Entwicklungs-Rechner Es wird der Einsatz eines 64-Bit Betriebssystems empfohlen. Wenn z.B. ein spezieller Drucker-Treiber nur unter 32-Bit funktioniert, kann der Print-Service auch unter 32-Bit eingesetzt werden. Weitere Software Crystal Reports Runtime .NET Framework 4.8 - oder höher Einer der folgenden PDF Reader, wenn der PDF-Print-Adapter verwendet werden soll. Adobe Reader https://get.adobe.com/de/reader/ Foxit Reader https://www.foxitsoftware.com/de/pdf-reader/ Sumatra PDF https://www.sumatrapdfreader.org/ Microsoft Office 2003 oder höher, wenn der MSOffice-Print-Adapter verwendet wird oder bei der Benutzung einer Faxsoftware (z.B. Tobit-Fax). Open Office, wenn der OpenOffice-Print-Adapter verwendet wird. Authentication-Server Authentication-Service Framework Studio Authentication-Service 4.2 Betriebssystem siehe Anwendungs-Server Weitere Software .NET Framework 4.5 oder höher Oracle-Client Client-Rechner Rechner, auf dem die Anwendung mit dem Java-Client ausgeführt wird. Betriebssystem An das Betriebssystem werden grundsätzlich keine besonderen Anforderungen gestellt. Entscheidend ist, dass die Java-Runtime verfügbar ist. Je nach Framework-Studio-Anwendung kann es ggf. weitere Einschränkungen geben. Windows 10 Windows Server 2012 Windows Server 2008 Ubuntu Linux Mac OS X 10.9 Weitere Software Java-Runtime Crystal Reports Designer - sofern Reports bearbeitet werden sollen Je nach Framework-Studio-Anwendung ggf. weitere Software Java-Runtime Die Java Laufzeit-Umgebung wird benötigt am Client-Rechner und auf dem Entwicklungs-Rechner zur Ausführung der Anwendung. Windows-Rechner Framework Studio Client Launcher 4.2.16 / 4.4.0 Der aktuelle Client Launcher ist im Requirements-Paket enthalten. Andere Betriebssysteme Java 8 mit Java Web-Start Auf anderen Betriebssystemen wie Linux oder MacOS wird die Java Runtime benötigt. Crystal Reports Runtime Diese Runtime wird benötigt auf dem Anwendungs-Server, dem Print-Service und dem Entwicklungs-Rechner. SAP Crystal Reports Runtime engine for .NET Framework 13.0.9 - 13.0.30 Tip Wir empfehlen aktuell den Einsatz der Version 13.0.29 . Diese Version ist im Requirements-Paket enthalten. Bei 64Bit-Betriebssystemen muss die 64Bit-Version der Runtime verwendet werden. Caution Beim Einsatz der Version 13.0.26 oder höher ist folgendes zu beachten: Es auf dem Rechner dürfen keine Framework-Studio Programme (Anwendungs-Server, Print-Server) mit älteren Version verwendet werden als 3.11.67 , 4.0.29 und 4.2.11 . Andernfalls bitte die Runtime entsprechend den Requirements der jeweiligen Version verwenden. Nach einem einfachen Update auf eine neue Runtime 13.0.26 oder höher kann es zu Fehlern beim Druck kommen. Aus diesem Grund dringend das folgende Vorgehen empfohlen: Alte Crystal Reports Runtime (13.0.24 oder kleiner) deinstallieren, Rechner neu starten und Neue Crystal Reports Runtime (13.0.26 oder höher) installieren. Wenn es nach einem (versehentlichen) Update zu Fehlern kommt, dann: Crystal Reports Runtime deinstallieren, Rechner neu starten und Crystal Reports Runtime erneut installieren. Crystal Reports Designer Der Crystal Reports Designer wird für die Bearbeitung der Crystal Reports auf dem Entwicklungs-Rechner benötigt und sofern erforderlich auch auf dem Client-Rechner. Crystal Reports 2008 Datenbank-Server Microsoft SQL Server 2014 - oder höher (Standard / Enterprise / BI) Microsoft SQL Server 2012 SP1 (Standard / Enterprise / BI) <!-- https://docs.microsoft.com/sql/sql-server/end-of-support/sql-server-end-of-life-overview Bei Anpassung der SQL-Version bitte auch folgende Anleitung Anpassen: * http://nvrack03:15001/Hersteller/Framework%20Studio/TeamWiki/Wiki-Seiten/Repository-%C3%84nderung%20(Anleitung).aspx --> Die Express- und Developer-Editionen des SQL Server können zu Entwicklungs- und Test-Zwecken eingesetzt werden. Dabei sind aber entsprechende funktionale und lizenzrechtliche Einschränkungen seitens Microsoft zu beachten. Der Einsatz erfolgt auf eigene Verantwortung. Oracle 12.2 - oder höher (Standard / Enterprise) Es ist kein Oracle Client erforderlich. Framework Studio bringt mit dem Oracle Managed Provider eine eigene Client-DLL mit."
  },
  "articles/requirements-package.html": {
    "href": "articles/requirements-package.html",
    "title": "Requirements-Paket",
    "keywords": "Requirements-Paket Die Requirements für Framework Studio stehen in einem separaten Download zur Verfügung. FS4.4.0_Requirements_64Bit.zip Die Requirements werden benötigt, wenn Sie das erste mal eine Installation von Framework Studio durchführen. Damit die Installation der Requirements direkt von der Setup.exe angestoßen werden kann, kopieren Sie den Ordner Requirements (samt Inhalt) aus dem entsprechenden Paket direkt in den Ordner mit der Setup.exe. Die Struktur der Ordner muss dann folgendermaßen aussehen: FS_4.4.x_Setup_x64\\ FS_4.4.x_Setup_x64.exe Neuheiten.pdf Requirements_Readme.txt Requirements\\ CRRuntime_64bit_13_0_29.msi ... Enthaltene Bestandteile .net Framework 4.8 ndp48-web.exe Es wird empfohlen, diesen Web-Installer auszuführen. Damit erhalten sie automatisch die aktuellste Version und das passende Sprachpaket. ndp48-x86-x64-allos-enu.exe Der Offline-Installer spart den Download der Runtime. Er beinhaltet das .net Framework in englischer Sprache und die Version ist ggf. nicht mehr die aktuellste. Bei Bedarf gibt weitere Pakete direkt von Microsoft unter https://dotnet.microsoft.com/download/dotnet-framework/net48 Das .net Framework 4.8 muss installiert werden, bevor die Setup.exe ausgeführt wird. Es muss auf den folgenden Rechnern installiert werden: Anwendungs-Server Authentication-Server Print-Server Entwicklungs-Rechner ASP .NET Core Runtime 3.1 dotnet-hosting-3.1.19-win.exe Die ASP .NET Core Runtime wird für den Web-Designer von DevExpress Reporting benötigt. Die aktuellste Version der Runtime gibt es unter https://dotnet.microsoft.com/download/dotnet/3.1 . Dort im Abschnitt ASP .NET Core Runtime für Windows das Hosting Bundle herunterladen. Note In eNVenta ERP gibt es aktuell noch keine Freigabe für die Verwendung des Web-Designers. Aus diesem Grund prüft der Installer von Framework Studio noch nicht auf diese Runtime. Die Runtime muss (sofern der Web-Designer dennoch zum Einsatz kommt) auf den folgenden Rechnern installiert werden: Anwendungs-Server Entwicklungs-Rechner Crystal Reports Runtime 64Bit: CRRuntime_64bit_13_0_29.msi Caution Bitte beachten sie unbedingt die Hinweise in den Requirements . Die SAP Crystal Reports Runtime dient zur Aufbereitung der Druck-Belege. Sie muss auf den folgenden Rechnern installiert werden: Anwendungs-Server Print-Server Entwicklungs-Rechner FS Client Launcher 64-Bit: FSCL_4.4.0_Setup_x64.exe Die 32-Bit-Version FSCL_4.4.0_Setup_x86.exe steht als separater Download zur Verfügung Der Framework Studio Client-Launcher beinhaltet eine Java-Runtime zum Ausführen des Java-Clients. Er muss auf folgenden Rechnern installiert werden: Alle Rechner, auf denen die eNVenta-Anwendung ausgeführt wird Entwickler-Rechner zum Ausführen der Anwendung ggf. Anwendungs-Server, sofern auf ihnen die Anwendung ausgeführt werden soll"
  },
  "articles/update-4-2/mlkey-migration.html": {
    "href": "articles/update-4-2/mlkey-migration.html",
    "title": "MLKey Migration",
    "keywords": "MLKey Migration Ziel ist es, dass alle Texte aus den Records entfernt und in das Wörterbuch übertragen werden. Die Records erhalten dafür Verweise auf Einträge im Wörterbuch, die MLKeys . Generell teilt sich die Migration in zwei große Phasen auf: MLKeys erzeugen und zuordnen : Diese Phase kann parallel zur Weiterentwicklung durchgeführt werden. Es werden zum Einen neue Einträge im Wörterbuch angelegt und zum Anderen vorgemerkt, wo diese später verwendet werden sollen. MLKeys übertragen : In dieser Phase werden primär die vorbereiteten Zuordnungen an die Elemente übertragen: angegebene Texte werden entfernt und statt dessen die gewünschten MLKeys eingetragen. Dazu müssen alle betroffenen Elemente ausgecheckt werden. Zusätzlich werden weitere Umstellungen (z.B. bestehende Messages und Exceptions) durchgeführt. Abwärts-Kompatibilität Texte, die bisher an den Records definiert sind, funktionieren auch weiterhin, weil jeder MLString neben dem MLKey explizit gesetzte Texte versteht. So kann man nach dem Update auf die Version 4.2 die Migration in aller Ruhe angehen. Note In Kunden-Packages ist die Umstellung der eigenen Texte auf MLKeys empfohlen. Sie ist aber nicht zwingend notwendig. Das hat aber langfristig einige Nachteile zur Folge - insbesondere in Hinblick auf die Mehrsprachigkeit der Anwendung: Der Language Export / Import funktioniert nur für das Wörterbuch. Individuelle Texte an Records werden nicht (mehr) berücksichtigt. Das Pflegen von Fremdsprachen an den Records ist sehr aufwändig. Die MLKeys aus dem Wörterbuch bringen hingegen die Übersetzungen automatisch in alle Bereiche der Anwendung. Important Funktionale Packages, die als Produkt an mehrere Kunden vertrieben werden, sollten in jedem Fall migriert werden. MLKeys erzeugen und zuordnen Diese erste Phase der MLKey Migration dient zum Einen der Erzeugung der benötigten Einträge im Wörterbuch (MLKeys) und zum Anderen der Zuordnung, wo diese später verwendet werden sollen. Zentrales Werkzeug für diese Phase ist der Dialog Multilanguage Text Migration , welcher über das Menü Tools / Multilanguage Text Migration geöffnet werden kann. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Alle durch den Benutzer definierten Zuordnungen werden in der Ressource Migration.xml im Verzeichnis FSGeneral/Resources/lang gespeichert, welche automatisch bei der ersten Benutzung angelegt wird. Ist diese Datei bei der Bearbeitung mit dem Multilanguage Text Migration Dialog nicht ausgecheckt, so wird beim Speichern mit dem Button Save automatisch die neueste Version ausgecheckt, die Änderungen ergänzt und anschließend sofort wieder eingecheckt. Dieses Verhalten ist dann hilfreich, wenn mehrere Benutzer gleichzeitig mit dem Multilanguage Text Migration Dialog arbeiten. Andernfalls empfiehlt es sich, die Datei vor Beginn der Arbeit auszuchecken und erst nach Beendigung der Arbeit wieder einzuchecken. So werden unnötige Checkin- und Checkout-Vorgänge vermieden. Beim Speichern werden außerdem ggf. ungespeicherte Änderungen am Wörterbuch gespeichert. Generelles Vorgehen Die zu leistende Arbeit besteht in erster Linie darin, logisch identische Begriffe zusammenzuführen und logisch unterschiedliche Begriffe, die ggf. in einzelnen Sprachen Überlappungen mit anderen Begriffen haben, zu trennen. Beispiel: Die Begriffe Suche mit SQL , Suchen mit SQL , SQL Suche , SQL-Suche , Suchen SQL , Sql Suche und weitere Varianten sollten zu einem einzigen Eintrag zusammengefasst werden. (1) Load Data Important Zunächst sollten Tooltips außen vor gelassen werden. Dazu darf die Checkbox Include Tooltips NICHT gesetzt sein, wenn mit dem Button Load Data alle im Package angegebenen Texte eingelesen werden. Erst wenn allen Texten ein MLKey zugeordnet wurde, werden die im Folgenden beschriebenen Schritte nach dem erneuten Laden der Daten inklusive Tooltips ein zweites Mal durchgeführt. Note Wenn durch ein Basis-Package bereits Einträge im Wörterbuch existieren, so wird Framework Studio nach dem Laden automatisch einem mehrsprachigen Text aus dem Custom-Package den MLKey zuweisen, der mindestens in den angegebenen Sprachen die Texte in exakt der Schreibweise enthält. Die mit dem Button Load Data eingelesenen Texte werden in einer Tabelle angezeigt. Die einzelnen Spalten haben folgende Bedeutung: Record : Name des Elements, an dem der Text angegeben ist, z.B. frmArticle . Element : Name des Unterelements, an dem der Text angegeben ist, z.B. edtsName . Type : Typ des Unterelements, z.B. FormControl . Property : Eigenschaft, an der der Text angegeben ist, z.B. Caption . MLKey : Der MLKey, welcher zugeordnet werden soll, z.B. LBL_Name . {Sprachen...} , z.B. German , English usw.: Der Text, welcher in der jeweiligen Sprache angegeben ist, z.B. Name . Die Spalten können durch anklicken der Spaltenüberschrift sortiert werden. Meist wird man nach deutschem Text sortiert arbeiten. Ein Doppelklick in die Spalten Record oder Element öffnet das Designerfenster für das Element und springt soweit möglich zum Unterelement. In allen anderen Spalten wird beim Doppelklick der Text der Zelle als Filterkriterium in das Feld Search: gesetzt. Für die Filterfunktion mit dem Feld Search: gelten folgende Regeln: Groß-Kleinschreibung wird ignoriert Es wird in allen Spalten gesucht Es werden nur die Zeilen angezeigt, die ALLE der durch ein Leerzeichen getrennten Buchstabenfolgen enthalten In Anführungsstriche \" gekapselte Buchstabenfolgen müssen genau so in der Zeile enthalten sein, damit diese angezeigt wird Beispiel: Die Suche nach LBL_Quantity \" geliefert\" zeigt nur die Zeilen an, welche geliefert mit einem führenden Leerzeichen und LBL_Quantity in irgendeiner Spalte enthalten. (2) Auto Create MLKeys Nach dem Einlesen der Daten (zunächst ohne Tooltips, siehe Load Data ) sollten einmalig mit dem Button Auto Create MLKeys alle automatisch erzeugbaren MLKeys in das Wörterbuch eingefügt werden. Automatisch erzeugt werden MLKeys dann, wenn es zu gleichen Texten in einer Sprachen keine abweichenden Texte in anderen Sprachen gibt. Note Framework Studio weist danach automatisch den Zeilen einen MLKey zu, die nur Texte enthalten, welche zu einem MLKey aus dem Wörterbuch keinen Wiederspruch aufweisen. (3) Manuelle Zuweisungen Ist die Checkbox Show only missing keys gesetzt, so wird die Anzeige aller Texte in der Tabelle auf die Einträge reduziert, welchen bisher noch kein MLKey zugewiesen wurde - die noch zu bearbeitenden Einträge. Im unteren Bereich des Multilanguage Migration Dialogs werden im Bereich Details zum aktuell in der Tabelle selektierten Eintrag alle Eigenschaften angezeigt. Ist bereits ein MLKey zugewiesen, werden die Texte des MLKeys in der Tabellenspalte In MLKey angezeigt. In der oberen Tabelle können auch mehrere Zeilen gleichzeitig ausgewählt werden. So kann mehreren Zeilen gleichzeitig ein MLKey zugewiesen werden. Für die Zuweisung stehen mehrere Optionen zur Verfügung: Mit dem Button im Bereich Details kann ein bereits existierender MLKey ausgewählt werden, siehe Multilanguage Text Editor , insbesondere Suchen von MLKeys . Wurde bereits ein MLKey zugewiesen, so wird ein weiterer Button Set ... angeboten, mit dem der zuletzt zugewiesene MLKey den aktuell selektierten Zeilen zugewiesen werden kann. Mit dem Button im Bereich Details kann ein neuer MLKey (basierend auf den selektierten Zeilen) erzeugt werden. Wenn beim Erzeugen eines neuen MLKeys mehrere Zeilen ausgewählt wurden und diese in einzelnen Sprachen abweichende Texte enthalten, so wird pro Sprache bei Bedarf der folgende Dialog geöffnet: In diesem werden alle Varianten, sortiert nach Häufigkeit absteigend, aufgeführt. Durch Selektion und Bestätigung mit dem Button OK oder durch Doppelklick wird die Auswahl als Vorbelegung für den neuen MLKey verwendet (siehe Erfassen neuer MLKeys ). Important Bei der Zuweisung und Erzeugung von MLKeys sind die eNVenta Regeln für MLKeys zu beachten. Mit dem Button Rename MLKey ist es im Rahmen der Migration möglich, einen bestehenden MLKey umzubenennen. Alle manuellen Zuordnungen dieses MLKeys werden automatisch angepasst. (4) Bereinigungen Im Wörterbuch werden sich durch die vorangegangenen Schritte (z.B. durch die von Framework Studio automatisch generierten MLKeys) einige Unsauberkeiten eingeschlichen haben. Daher sind die folgenden Maßnahmen empfehlenswert: Maßnahmen im Wörterbuch: Sortierung nach MLKey: Folgen aufeinander logisch identische Begriffe? Suche Nach _1 , _2 , _3 usw: Sind diese Varianten nötig oder sollten anders benannt werden? Sortierung nach deutschem Text: Folgen aufeinander logisch identische Begriffe? In Custom-Packages sind dabei nur die MLKeys aus dem eigenen Package (zu erkennen an der Fettschreibung) und ihre Vorgänger und Nachfolger interessant. Außerdem können im Multilanguage Text Migration Dialog mit dem Button Find unused MLKeys alle MLKeys aus dem eigenen Package aufgelistet werden, welche im Wörterbuch existieren, jedoch nirgendwo zugeordnet sind. Diese gilt es, kritisch zu prüfen. (5) Abschluss Phase 1 Wurden die vorigen Schritte (zunächst ohne Tooltips, danach mit Tooltips) abgeschlossen, so kann nun mit Phase 2 ( MLKeys übertragen ) fortgefahren werden. MLKeys in Custom-Packages Im Customizing kann man grundsätzlich 2 verschiedene Arten von überschriebenen Texten unterscheiden: Texte, die eine ganz neue Bedeutung haben. Wenn z.B. ein relativ allgemeiner Metadatentyp in einem Component-Property verwendet wird, wird dort am Default-Label ein neuer Text formuliert. In diesen Fällen sollte auf jeden Fall ein entsprechender (ggf. neuer) MLKey zugeordnet werden. Ändern eines bestehenden Textes. Es wird z.B. ein Metadatentyp customized und das Default-Label geändert - aus dem Begriff \"Angebot\" wird z.B. \"Offerte\". Die Bedeutung bleibt aber dieselbe. In solchen Fällen gilt es zu prüfen, ob es evtl. ratsam ist, diese Änderung direkt im Wörterbuch vorzunehmen. So zieht diese für die gesamte Anwendung. Bei der Migration weist man dann diesen Einträgen den existierenden MLKey zu - auch wenn er identisch mit dem bereits zugeordneten MLKey aus dem Basis-Package sein sollte. In einem späteren Schritt der Migration wird eine redundante Zuordnung dann automatisch eliminiert. MLKeys übertragen Ist das Wörterbuch komplett vorbereitet (siehe MLKeys erzeugen und zuordnen ), ist es an der Zeit, die MLKeys in die Records zu übertragen. In diesem Schritt werden alle Aktionen ausgeführt, die einen Checkout der Records zur Folge haben. So wird die ggf. erhebliche Menge an Checkouts auf das nötigste reduziert. (1) Als FCUser anmelden Weil nach der Konvertierung sehr viel kompiliert werden muss, ist es empfehlenswert als FCUser zu arbeiten. So kann direkt nach dem Kompilieren der Complete Framework Compiler aufgerufen werden und es ist kein zusätzlicher FrameworkCompiler nötig. Mit dem Benutzer FrameworkCompiler anmelden - mit Refresh Workspace. Get DLLs ist nicht notwendig. Framework Studio direkt wieder beenden. Jetzt als FCUser anmelden - mit Refresh Workspace. Das übernimmt den Workspace vom Benutzer FrameworkCompiler. (2) Apply MLKeys Im Fenster Multilanguage Text Migration mit dem Button Load Data (inkl. den Tooltips) alle Daten einlesen. Es sollte jetzt keine offenen Zuordnungen mehr geben - wenn man die Checkbox Show only missing keys setzt, dürfen keine Einträge angezeigt werden. Mit dem Button Apply MLKeys wird die Routine gestartet. Es werden alle zugeordneten MLKeys an die entsprechenden Properties der Records übertragen. Dabei werden ALLE in den jeweiligen Sprachen gesetzten Texte aus den Records entfernt. Somit ziehen ab diesem Zeitpunkt die Texte nur noch aus dem Wörterbuch. (3) Convert Messages Mit dem Button Convert Messages im Fenster Multilangage Text Migration wird die Routine gestartet. Für diese Routine müssen keine Daten eingelesen werden - das gilt auch, wenn sie zu einem späteren Zeitpunkt erneut gestartet wird. Es werden alle Methoden-Codes analysiert und nach Exceptions- und MessageBox-Aufrufen gesucht. Diese werden in das neue Message-Format umgewandelt und die Verweise auf die Text-Collections werden durch den entsprechenden MLKey ersetzt. Warning Die Routine Apply MLKeys muss zuvor ausgeführt worden sein, damit die Message-TextCollections sauber zugeordnete MLKeys besitzen. Alter Exception-Code vor der Konvertierung: #region Required for Exception Editor support. Do not modify manually. //Component type is required. //Severity: 0 ; Buttons: OK; Icon:Error throw new FrameworkApplicationException (String.Format(FSGeneral.ctMessagesFactory.Get(this.Global,3550).Value[Global.SelectedLanguage],new object []{}),0 ); //<ExceptionEditor TextColl=\"Messages\" ID =\"832e0e50c2b748068ba38a2c4422aaab\" Severity=\"0\" EHID=\"\" ></ExceptionEditor> #endregion End of generated section Neuer Exception-Code nach der Konvertierung: // FSCodeMessage: Component type is required. throw new FrameworkApplicationException(this.Global.GetMLKeyText(MLKeys.MSG_445559f2ca44452e8d49ca9515b3a83e), 0); Es ist relativ wahrscheinlich, dass Warnings oder sogar Errors ausgegeben werden. Diese können erst einmal ignoriert werden. Es handelt sich dabei um inhaltliche Probleme und nicht um Compile-Errors. Die Convert Code Messages Routine kann zu einem späteren Zeitpunkt erneut ausgeführt und diese Probleme dann behoben werden. Important Damit sind die Message-Text-Collections jetzt obsolete. Sie dürfen aber nicht gelöscht oder geleert werden, weil sie ggf. noch von Customizing-Packages referenziert werden. (4) MLStrings Cleanup Nachdem alle MLKeys übertragen wurden, können jetzt noch einige Bereinigungen durchgeführt werden. Über das Menü Tools / Checks / MLStrings Cleanup kann das Cleanup-Fenster geöffnet werden. Dort stehen mehrere Routinen zur Auswahl. Diese sollten einer nach der anderen ausgeführt werden. Dabei ist es ratsam zuerst den Button Analyze zu benutzen. Erst nach der Sichtung der Infos und Warnings wird die Routine mit dem Button Cleanup ausgeführt. Clean MLKeys Wird in einem Record (z.B. DBColumn, Form-Control) der MLKey mit demselben Wert überschrieben, wie er in der Basis (z.B. Metadatentyp, Basis-Package) definiert ist, dann wird diese Überschreibung entfernt. Transfer translations Wurden trotz vererbtem MLKey Übersetzungen nur an Records gepflegt, dann wurden diese mit der Migration ggf. nicht in das Wörterbuch übertragen. Das wird mit dieser Routine nachgeholt. Wird an einem Record, der einen MLKey besitzt, eine Übersetzung gefunden und das Wörterbuch kennt diese noch nicht, wird diese in das Wörterbuch übertragen und der Text vom Record entfernt. Dabei gewinnt pro MLKey der erste Record. Wird ein weiterer Record mit gleichem MLKey aber einer anderen Übersetzung gefunden, dann wird dieser als Warning ausgegeben. Beim Cleanup verbleibt dieser Text am Record. Bei einem weiteren Lauf würde dieser Record mit der Routine Clean individual texts gefunden werden. Clean individual texts Die MLKey-Migration berücksichtigt nur Texte, die mindestens in Deutsch und Englisch gepflegt sind. Sind an einem Record nur andere Sprachen definiert, dann wird dieser Text nicht migriert. Oftmals erben diese Records schon einen Text aus der Basis und es sind nur einige Übersetzungen gepflegt. Diese sollen hier bereinigt werden. Es werden Texte, die identisch mit dem Wörterbuch sind, entfernt. Vom Wörterbuch abweichende Texte werden als Warning ausgegeben und NICHT entfernt. Diese müssen in einem weiteren Schritt bearbeitet werden. Warnings bearbeiten Jetzt müssen die aufgetretenen Warnings begutachtet und ggf. manuell bearbeitet werden. Clean individual texts mit Remove different Wurden im vorherigen Schritt die Warnings begutachtet, können mit dieser Aktion alle abweichenden Texte entfernt werden. (5) Compile und CheckIn Jetzt müssen alle Änderungen compiliert werden. Menü Compile / Compile Changes . Nachdem der Compiler erfolgreich beendet wurde, werden alle Elemente eingecheckt. Dabei sollte ein CheckIn-Kommentar z.B. MLKey Migration angegeben werden. Zum Abschluss noch über den Compile-Manager den Button Complete Framework Compiler aufrufen."
  },
  "articles/update-4-2/neue-text-funktionen.html": {
    "href": "articles/update-4-2/neue-text-funktionen.html",
    "title": "Neue Text-Funktionen",
    "keywords": "Neue Text-Funktionen In Framework Studio 4.2 wurden im Zuge der Umstellung auf die MLKeys auch die Text-Zugriffe auf Text-Collections und DevMLStrings überarbeitet. Note Auch wenn keine MLKey-Migration ausgeführt wird, muss die Convert Messages Routine trotzdem ausgeführt werden, damit die Verarbeitung der Fremdsprachen-Texte korrekt funktioniert. Siehe Abschnitt Migration auf Version 4.2 Bei der Verwendung von this.Global.SelectedLanguage erfolgt kein Fallback auf andere Sprachen. Aus diesem Grund sollte dies nicht mehr verwendet werden. Für das ermitteln des Textes wurden deshalb einfachere Varianten geschaffen, die ohne explizite Angabe der Sprache arbeiten. Andere Stellen erhalten jetzt stattdessen das komplette this.Global um daraus die Sprach-Hierarchie inkl. Fallbacks zu ermitteln. Die Text-Ermittlungen benötigen auch immer einen Zugriff auf das GlobalObject, damit die zentralen Einsprungpunkte immer angelaufen werden. Text-Collection Soll für einen bestimmten Text-Collection-Eintrag der Text ermittelt werden, dann erfolgt dies idealerweise über die Factory -Klasse. Dort wird eine Methode GetText(global, id) angeboten. Diese Methode Liefert den Text in der aktuellen Sprache / Sprach-Hierarchie, welche über das GlobalObject festgelegt ist. string sText = ctTextCollFactory.GetText(this.Global,7); Wird der Text in einer bestimmten Sprache benötigt, dann muss über die Methode Get(global, id) der Text-Collection-Eintrag ermittelt und an diesem mit der Methode GetText(iso) der gewünschte Text ermittelt werden. string sText = ctTextCollFactory.Get(this.Global,7).GetText(sIsoCode); Text-Collection-Eintrag Manchmal wird auch mit bestimmten Einträgen der Text-Collection gearbeitet. Dieser bietet die folgenden Möglichkeiten, den Text zu ermitteln. Das Property Text liefert den Text in der aktuellen Sprache / Sprach-Hierarchie, welche über das GlobalObject festgelegt ist. string sText = oTextCollEntry.Text; Die Methode GetText(iso) liefert den Text in einer gewünschten Sprache. Dabei erfolgt kein Fallback auf eine andere Sprache. Ist in der angegebenen Sprache kein Text formuliert, wird String.Empty zurückgegeben. string sText = oTextCollEntry.GetText(sIsoCode); Über das Property Value wird ein Objekt mit dem Typ DevMLString zurückgegeben. Dieses hat aber selber keinen Bezug zum GlobalObject, weshalb ihm zur Ermittlung der Texte ein GlobalObject übergeben werden muss. Es sollten wenn möglich die o.g. Wege zur Ermittlung der Texte benutzt werden. Das Property Value ist nur in Ausnahme-Fällen zu verwenden. DevMLString Zur Ermittlung eines Textes muss ein GlobalObject übergeben werden. Es gibt dazu die folgenden Möglichkeiten: // Text in aktueller Sprache / Sprach-Hierarchie string sText1 = oDevMLString.GetString(this.Global); string sText2 = oDevMLString[this.Global]; // Text in bestimmter Sprache string sText3 = oDevMLString.GetString(this.Global, sIsoCode); Obsolete Schnittstellen Am DevMLString wurden einige Properties/Methoden auf Obsolete gesetzt, weil sie kein GlobalObject verwenden. Beim Compile werden betroffene Stellen als Warning ausgegeben. // Diese Aufrufe sind Obsolete!!! string sText1 = oDevMLString.GetString(sIsoCode); string sText2 = oDevMLString[sIsoCode]; string sText2 = oDevMLString.German; Die Methode GetDefinedLanguagesAsIso() macht keinen Sinn mehr, weil die Texte nicht mehr dieser Stelle definiert sind. Nach der Umstellung auf den MLKey wird als Iso-Code nur noch der Wert \"_key\" zurückgegeben. Migration auf Version 4.2 Um eine saubere Funktion der Fremdsprachen-Texte zu gewährleisten, müssen diese Aufrufe mit dem Update auf die Version 4.2 umgestellt werden. Ein sehr großer Teil der Aufrufe wird mit der Convert-Messages Routine in der MLKey-Migration automatisch umgesetzt. Es bleiben aber einige wenige Stellen übrig, die manuell nachgearbeitet werden müssen. Sie werden beim Compile durch die Obsolete-Warning erkannt. Im folgenden werden ein paar Code-Beispiele aufgeführt, die verdeutlichen, wie die Umstellung zu erfolgen hat. Alter Code neuer Code ctAbcFactory.Get(this.Global,7).Value[this.Global.SelectedLanguage] ctAbcFactory.GetText(this.Global,7) ctAbcFactory.Get(this.Global,7).Value[sIsoCode] ctAbcFactory.Get(this.Global,7).GetText(sIsoCode) oTextCollEntry.Value[Global.SelectedLanguage] oTextCollEntry.Text oTextCollEntry.Value.GetString(sIsoCode) oTextCollEntry.Value[sIsoCode] oTextCollEntry.GetText(sIsoCode) oTextCollEntry.Value.German oTextCollEntry.GetText(\"de\") oDevMLString.GetString(sIsoCode) oDevMLString[sIsoCode] oDevMLString.GetString(this.Global, sIsoCode) oDevMLString.German oDevMLString.GetString(this.Global, \"de\")"
  },
  "articles/update-4-3/property-changed.html": {
    "href": "articles/update-4-3/property-changed.html",
    "title": "Umstellung auf PropertyChanged",
    "keywords": "Umstellung auf PropertyChanged Die Components arbeiten nutzen jetzt das Event PropertyChanged um Änderungen an Properties zu kommunizieren. Sie implementieren dazu das Standard-Interface INotifyPropertyChanged . Die bisher verwendeten Events, welche für jedes einzelne Component-Property sparat generiert wurden, entfallen. Wenn eigener Code existiert, der mit diesen Events arbeitet, muss dieser angepasst werden. Im folgenden werden einige Situationen beschrieben. Die Beispiele verwenden eine Component cdArticle mit den Properties sArticleID und sArticleName . Event-Handler umstellen Bisher gab es die folgenden Events public event EventArgs sArticleIDChanged; public event EventArgs sArticleNameChanged; Diese wurden auf die folgende Weise verwendet: // anhängen des Event-Handlers oArticle.sArticleIDChanged += OnArticleIDHasChanged; // Event-Handler-Methode protected void OnArticleIDHasChanged(object sender, EventArgs args) { // Code für geänderte Artikel-ID } // Event mit Lambda-Expression oArticle.sArticleNameChanged += (sender, args) => { // Code für geänderte Artikel-Bezeichnung }; Jetzt gibt es nur noch ein Event, welches in der Basis-Klasse DevFrameworkBaseObject implementiert ist. public event PropertyChangedEventArgs PropertyChanged; Dieses wird auf folgende Weise verwendet: // anhängen des Event-Handlers oArticle.PropertyChanged += OnArticleIDHasChanged; // Event-Handler-Methode protected void OnArticleIDHasChanged(object sender, PropertyChangedEventArgs args) { if (args.IsProperty(nameof(IcdArticle.sArticleID))) { // Code für geänderte Artikel-ID } } // Event mit Lambda-Expression oArticle.sArticleNameChanged += (sender, args) => { if (args.IsProperty(nameof(oArticle.sArticleName))) { // Code für geänderte Artikel-Bezeichnung } }; Aufrufe von Fire-Methoden Alter Code: this.FiresArticleIDChanged(); this.FiresArticleNameChanged(); Neuer Code: this.FirePropertyChanged(nameof(this.sArticleID)); this.FirePropertyChanged(nameof(this.sArticleName)); Muss man viele dieser Aufrufe ersetzen, kann man dafür im Code-Editor die Funktion Find/Replace verwenden. Suche mir Regular Expression: this.Fire(?<prop>(?!Property)\\w+)Changed\\s*\\(\\s*\\) Ersetzen durch: this.FirePropertyChanged(nameof(this.${prop})) StateChanged, IsModifiedChanged Die Component-Properties State und IsModified , werden jetzt ebenfalls über PropertyChanged behandelt. Die virtuellen Methoden OnStateChanged und OnIsModifiedChanged sind entfallen. Stattdessen kann diese Logik in die neue Methode OnPropertyChanged verschoben werden. Alter Code: protected override void OnStateChanged() { // Status hat sich geändert } protected override void OnIsModifiedChanged() { // IsModified hat sich geändert } Neuer Code: protected override void OnPropertyChanged(string propertyName) { // Base-Aufruf ist wichtig !!! base.OnPropertyChanged(propertyName); if (propertyName == nameof(this.State)) { // Status hat sich geändert } if (propertyName == nameof(this.IsModified)) { // IsModified hat sich geändert } } Neuer Code für Event-Handler: // anhängen des Event-Handlers oArticle.PropertyChanged += OnArticleStateChanged; // Event-Handler-Methode protected void OnArticleStateChanged(object sender, PropertyChangedEventArgs args) { // Die Prüfung auf PropertyName == null macht hier keinen Sinn if (args?.PropertyName == nameof(this.State)) { // Status hat sich geändert } } Reflection Caution Wenn die alten Changed-Events per Reflection angesprochen wurden, dann muss das gezielt umgebaut werden. Diese Fälle werden nicht durch den Compiler gefunden. Mit einer Volltext-Suche nach folgendem Regulären Ausdruck könnten potentielle Stellen leicht gefunden werden: \\bEventInfo\\b Beispiel für einen problematischen Code: System.Reflection.EventInfo oChangedEventInfo = this.oTarget.GetType().GetEvent(sPropertyNameP + \"Changed\"); if (oChangedEventInfo != null) { oChangedEventInfo.AddEventHandler(this.oTarget, oXmlPropertyInfo.oChangedEventHandler); }"
  },
  "doc/access-units/access-unit-hierarchie.html": {
    "href": "doc/access-units/access-unit-hierarchie.html",
    "title": "Access Unit Hierarchie",
    "keywords": "Access Unit Hierarchie Über den Menüpunkt Tools / Access Unit Treeview ... kann das Fenster zum Bearbeiten der Access Unit Hierarchie aufgerufen werden. Über diese Hierarchie wird letztendlich festgelegt, wie das Programm durch Access Units in einzelne Programmteile unterteilt wird. Unter die Access Unit auSales sollten beispielsweise alle Access Units eingehängt werden, die mit dem Verkauf zu tun haben. Access Unit Tree: Im obigen Beispiel gehören die beiden Form Access Units aufrmAccountInfo und auftmAccountSelect (und somit die entsprechenden Forms) zur Access Unit auAccount_Information . Diese wiederum gehört zur Access Unit auAccount. Wenn eine neue Access Unit angelegt wird, wird diese automatisch unter dem Wurzelknoten Root eingehängt. Eine Access Unit hat ihre Parent Access Units als Eigenschaft. Jede AccessUnit kann an mehreren Stellen im Hierarchiebaum eingehängt sein. Es dürfen dabei aber keine Kreise entstehen. Die Parent Beziehungen werden per Drag & Drop im Hierarchiebaum geändert. Analog zu Windows wird dann, wenn man dabei die Strg-Taste drückt, kopiert , ohne Strg-Taste verschoben ."
  },
  "doc/access-units/access-units.html": {
    "href": "doc/access-units/access-units.html",
    "title": "Access Units",
    "keywords": "Access Units Eine Access Unit repräsentiert einen Programmbereich. Für jede Access Unit kann für 5 verschiedene Zugriffsarten ( Access , AccessDerived , Insert , Update und Delete ) abgefragt werden, ob der entsprechende Zugriff (nach Auswertung der Lizenzen und der Rechte des Benutzers) erlaubt wird. Für ein Form haben die Zugriffsarten folgende Bedeutung: Access: Das Form darf geöffnet werden AccessDerived: Ableitungen dieses Forms dürfen geöffnet werden Insert: Einfügen von Datensätzen ist mit diesem Form erlaubt Update: Vorhandene Datensätze dürfen aktualisiert werden Delete: Datensätze dürfen gelöscht werden Der Entwickler kann folgende Eigenschaften über das Designerfenster einer Access Unit definieren: Name Name der Access Unit. Aus diesem ergibt sich automatisch der im generierten Code verwendete Name Name in code. Label Mehrsprachige Bezeichnung der AccessUnit. Diese wird im externen Werkzeug zur Rollenverwaltung (Bestandteil der Runtime Administration) angezeigt. Description Hier kann (mehrsprachig) beschrieben werden, welchen Programmbereich diese Access Unit repräsentiert. Die Beschreibung wird u. a. im externen Werkzeug zur Rollenverwaltung als Tooltip zur AccessUnit angezeigt. Im Designerfenster wird über die Checkbox is form AccessUnit angezeigt, ob diese Access Unit die spezielle Form Access Unit (s.u.) ist, die beim Öffnen des Forms in der Anwendung ausgewertet wird. Diese Eigenschaft kann durch den Benutzer nicht geändert werden. Unter dem Punkt Parents werden alle Access Units aufgeführt, von denen diese Access Unit eine Unterkomponente ist, also alle Elternknoten im Access Unit Treeview. Diese Eigenschaft kann über den Access Unit Treeview ( Access Unit Hierarchie ) oder hier direkt geändert werden. Über die Textbox kann ein neuer Parent ausgewählt und über den Plus-Button hinzugefügt werden. Über den Löschen-Button kann eine zuvor selektierte Parent-AccessUnit gelöscht werden. Der letzte Parent kann jedoch nicht entfernt werden. Sowohl die Children als auch die Parent-AccessUnits können über einen Doppelklick geöffnet werden. Access Units können im Namespace angelegt werden (z.B. auSales, um den kompletten Verkauf zu repräsentieren). Für diese Access Units steht der gewohnte Checkin/Checkout-Mechanismus zur Verfügung. Außerdem können Access Units in einem Form angelegt werden (Menü File / New / Access Unit oder Button New ... / Access Unit ). Diese Access Units sind Unterkomponenten des Forms und werden daher automatisch mit dem Form aus- und eingecheckt. Jedes Form besitzt automatisch eine besondere Access Unit, die das Form selber repräsentiert. Der Name dieser Form Access Unit ist der Name des Forms mit dem Präfix au (also z.B. für frmSalesOrder aufrmSalesOrder ). Wenn ein Form in der Anwendung geöffnet wird, so wird vorher automatisch überprüft, ob das Recht „Access“ für die FormAccessUnit des Forms erteilt wurde und ob für alle FormAccessUnits der Basisforms das Recht „AccessDerived“ erteilt wurde. Für jedes Form wird automatisch eine FormAccessUnit angelegt. Diese Access Unit kann nicht gelöscht werden. Ist ein oder mehrere Parents ungültig, wird der Button Fix the parent Access Unit angezeigt. Wird dieser Button gedrückt, hat dies zur Folge, dass die ungültige Beziehung gelöscht wird. Sollte kein anderer gültiger Parent verfügbar sein, wird 'Root' als Parent definiert. Form Designer Registerkarte Access Units: Aus dem Code heraus kann ein Zugriffsrecht einer AccessUnit von einem Form aus folgendermaßen abgefragt werden: bool InsertGranted = Global.AUHelper.Granted(this.aufrmSalesOrder, AUPermissionType.Insert); bool FormAccessGranted = Global.AUHelper.Granted(this.FormAccessUnit); bool AuSalesGranted = Global.AUHelper.Granted(AUList.auSales, AUPermissionType.Delete); Wenn kein AUPermissionType angegeben wird, wird automatisch Access abgeprüft. Auf die FormAccessUnit kann aus dem Form sowohl über ihren Namen als auch über FormAccessUnit zugegriffen werden. Über die Klasse AUList sind alle global verfügbaren AccessUnits ansprechbar."
  },
  "doc/access-units/allgemeine.html": {
    "href": "doc/access-units/allgemeine.html",
    "title": "Rechteverwaltung / Access Units",
    "keywords": "Rechteverwaltung / Access Units Allgemeiner Überblick Für die mit Framework Studio erstellte Anwendung wird eine umfangreiche Rechteverwaltung bereitgestellt. Diese Rechteverwaltung hat im Wesentlichen zwei Aufgaben: Programmbereiche, für die ein Kunde keine Lizenz erworben hat, sollen für den Kunden gesperrt werden. Benutzerabhängiges Verhalten der Anwendung: Abhängig von den Aufgaben, die ein Benutzer im Unternehmen hat, sollen gezielt Programmteile gesperrt werden können. Beispiel: Ein Hausmeister muss Bestellungen aufgeben können, darf aber keine Informationen über Zahlungsrückstände von Kunden bekommen. Zentraler Punkt bei der Entwicklung sind sogenannte Access Units . Diese repräsentieren Programmbereiche. Bei der Entwicklung mit Framework Studio werden Access Units definiert und hierarchisch angeordnet. Ein Packagehersteller kann zu einem Repository eine Lizenz erstellen, die definiert, welche Access Units frei geschaltet werden sollen und welche gesperrt werden sollen. Diese Lizenz kann als signierte Xml-Datei weitergegeben werden. Dazu wird der Runtime License Manager ( Laufzeitlizenzen ) verwendet. Mit diesem können auch Lizenzen zu allen installierten Packages in eine einzige Xml-Datei gespeichert werden. Eine solche Xml-Datei muss zur Laufzeit der Anwendung im Brokerverzeichnis mit dem Namen FSLicense.xml bereit liegen. Wenn das benutzerabhängige Verhalten erwünscht ist, muss für die entsprechende Application die Authentifizierung aktiviert werden (Authentication). Des Weiteren muss zur Laufzeit ein Authentifizierungsdienst zur Verfügung stehen. Der Broker wird diesen Dienst kontaktieren, um einen Benutzer mit Passwort zu authentifizieren. Der Authentifizierungsdienst teilt dem Broker dabei mit, welche Rollen ein Benutzer innehat."
  },
  "doc/access-units/laufzeitlizenzen.html": {
    "href": "doc/access-units/laufzeitlizenzen.html",
    "title": "Laufzeitlizenzen",
    "keywords": "Laufzeitlizenzen Mit dem Runtime License Manager werden Laufzeitlizenzen für die mit Framework Studio erstellte Anwendung erzeugt und verwaltet. Dieses Werkzeug wird über den Menüpunkt Tools / Runtime License Manager in Framework Studio oder im Package Manager gestartet. Außerdem wird das Tool über den Button Change configuration unter dem Navigationspunkt Runtime License sowohl im Run Wizard als auch im Publish Wizard gestartet. Allgemeines / Hintergrund Laufzeitlizenzen werden im Repository gespeichert. Dort können für jedes Label (also für jede Version eines Packages) beliebig viele Lizenzen abgelegt werden. Wenn eine Applikation gestartet werden soll, muss zuvor im Brokerverzeichnis die Datei FSLicense.xml erstellt werden. Diese Datei enthält für jedes Label der Applikation eine Lizenz. Mit dem Runtime License Manager wird gesteuert, welche der vorhandenen Lizenzen für die erstellten Applikationen und Service Hosts verwendet werden sollen. Wenn Sie den Runtime License Manager aus dem Run Wizard oder aus dem Publish Wizard heraus starten, werden die Einstellungen im aktuellen Setting gespeichert. Sollte für ein Package, von dem man der Besitzer ist, noch keine Lizenz existieren, wird für das Package automatisch eine Developer Lizenz erzeugt. Wenn Sie den Runtime License Manager über den Menüpunkt Tools / Runtime License Manager starten, werden die Einstellungen, welche Lizenzen verwendet werden sollen, nicht gespeichert. Runtime License Manager: Auf der linken Seite wird ein Baum dargestellt, der sogenannte Lizenzbaum. In diesem Baum werden auf der ersten Ebene hierarchisch sortiert alle Packages der Anwendung angezeigt. In den Unterknoten der Packages werden alle im Repository (zur aktuellen Package Version) abgelegten Lizenzen angezeigt. Wenn im Lizenzbaum durch einfachen Klick mit der Maus eine Lizenz ausgewählt wird, werden alle Details zu dieser Lizenz im rechten Fensterbereich dargestellt. Dort stehen die Registerkarten Access unit tree ( Registerkarte Access unit tree ), License parameters ( Registerkarte License Parameters ) und Language ( Registerkarte Language ) zur Auswahl. Buttons Im Runtime License Manager stehen folgende Buttons zur Verfügung: New Anlegen einer neuen Lizenz für das aktive Package Save Alle Änderungen an der ausgewählten Lizenz werden in die Datenbank gespeichert. Dieser Button ist nur aktiv, wenn die ausgewählte Lizenz seit dem letzten Laden oder Speichern geändert wurde. Copy Es wird eine Kopie einer Lizenz aus dem aktiven Package angelegt. Dieser Button ist nur aktiv, wenn eine Lizenz aus dem aktiven Package ausgewählt ist. Delete Die ausgewählte Lizenz wird aus der Datenbank gelöscht Refresh all Alle Lizenzen des aktiven Packages werden aktualisiert. Dieser Schritt ist dann nötig, wenn sich die Access Unit Hierarchie (Access Unit Hierarchie) für eines der verwendeten Packages geändert hat, beispielsweise wenn eine neue Version eines Basispackages importiert wurde oder im aktiven Package neue Access Units eingecheckt wurden. Außerdem empfiehlt sich diese Aktion nach dem Upgrade von Lizenzen und nach dem Import von Lizenzen für das aktive Package. Import Eine einzelne, zuvor in eine XML-Datei exportierte Lizenz wird importiert. Export Die ausgewählte Lizenz wird in eine XML-Datei exportiert. Export all Alle Lizenzen des aktiven Packages werden in je eine XML-Datei in einem gemeinsamen Ordner exportiert. Upgrade Lizenzen, die im Repository für eine ältere Package Version (Label) des ausgewählten Packages gespeichert sind, können in die aktuelle Package Version kopiert werden. Siehe Lizenz aus einem anderen Label übertragen. Search Startet den Dialog zum Suchen nach AccessUnits. Siehe Suche nach Access Units. Save Configuration Die Lizenzauswahl wird in das aktuelle Setting gespeichert und der Runtime License Manager geschlossen. Siehe Konfiguration speichern. Dieser Button steht nur dann zur Verfügung, wenn der Runtime License Manager über den Run Wizard oder den Publish Wizard geöffnet wurde. Save FSLicense.xml Die Xml-Datei FSLicense.xml wird im Brokerverzeichnis erzeugt, die für jedes Package der Anwendung eine Lizenz erhält, und der Runtime License Manager wird geschlossen. Siehe Konfiguration speichern . Dieser Button steht nur dann zur Verfügung, wenn der Runtime License Manager über den Menüpunkt Tools / Runtime License Manager gestartet wurde. Language Mit diesem Drop Down Button wird die Sprache ausgewählt, in der die Access Units im Access Unit Tree ( Registerkarte Access unit tree ) dargestellt werden. Zur Auswahl stehen alle Sprachen, die im Default Package definiert wurden und , um den technischen Namen der AccessUnit darzustellen. Lizenz aus einem anderen Label übertragen Wenn im Lizenzbaum ein Package ausgewählt ist, kann mit dem Button Upgrade der Dialog zum Kopieren von Lizenzen aus einer anderen Version des Packages (Label) geöffnet werden. Runtime License Manager - Upgrade: In der Combobox Source Label wird das Label ausgewählt, von dem Lizenzen kopiert werden sollen. Mit dem Button Upgrade werden die ausgewählten Lizenzen kopiert. Wird ein bereits gelöschtes Label ausgewählt, können Lizenzen mit dem Button Delete endgültig aus dem Repository entfernt werden. Beim Upgrade wird der Gültigkeitsbereich der Lizenzen (Version from und Version to) auf die aktuelle Packageversion erweitert, wenn diese eine gültige .NET Version ist (2 bis 4 natürliche Zahlen getrennt durch je einen Punkt) und die aktuelle Packageversion nicht durch den Versionsbereich abgedeckt ist. Andernfalls wird der Gültigkeitsbereich unverändert übernommen. Warning Beim Upgrade von Lizenzen aus einem Basispackage werden diese nicht verändert, wenn man nicht Besitzer des Packages ist. Neue Funktionalität ist also ggf. nicht freigeschaltet. Dazu muss eine neue Lizenz vom Hersteller des Basispackages eingespielt werden. Suche nach Access Units Wenn im Lizenzbaum eine Lizenz ausgewählt ist, die keine Developer-Lizenz ist, kann mit dem Button Search der Dialog zum Suchen nach Access Units gestartet werden. Access Unit Search: Im Textfeld Search for geben Sie den Suchtext an. Im Bereich Search in geben Sie an, wo nach diesem Text gesucht werden soll: Name Technischer Name der Access Unit, z.B. aufrmArticle Label Bezeichnung, die im Access Unit Tree angezeigt wird Description Beschreibung, die für die Access Unit hinterlegt wurde ID ID, die die Access Unit eindeutig identifiziert Mit der Checkbox Search Up legen Sie fest, ob von der aktuellen Position im Access Unit Tree aus aufwärts gesucht werden soll. Im Bereich Permissions kann nach bestimmten Zugriffsrechten gesucht werden. Durch setzen der Checkboxen Access, Access Derived, Update, Insert oder Delete werden Vergleiche für die jeweilige Zugriffsart aktiviert. Für jede Zugriffsart kann der Wert mit einem der folgenden verglichen werden: access-unit-permissions-options In der folgenden Übersicht wird für jede Option angegeben, auf welche Werte die Option einschränkt: None None und Explicit None Allowed Hierarchic Allowed und Explicit Allowed Denied Hierarchic Denied und Explicit Denied Explicit None Explicit None Explicit Allowed Explicit Allowed Explicit Denied Explicit Denied Gray Alle Rechte, jedoch nur die, die durch eine verwendete Lizenz verboten sind. Das entspricht allen Checkboxen, die mit grauem Hintergrund dargestellt werden. Ändern Sie das Recht durch Anklicken oder über das Kontextmenü der Rechte-Checkbox. Mit dem Button Find Next wird die Suche gestartet, mit dem Button Done beenden Sie die Suche und schließen das Suchfenster. Die Suchergebnisse werden im Access Unit Tree blau und unterstrichen dargestellt. Mit dem Button Show List werden alle Access Units, die den Suchkriterien entsprechen in einer Liste angezeigt. In diesem Dialog kann mit dem Button Copy to clipboard (Tastenkombination Strg-C ) die gesamte Liste mit Suchkriterien in die Zwischenablage kopiert werden. Mit dem Button Copy selected to clipboard werden alle ausgewählten Einträge in die Zwischenablage kopiert. Durch Doppelklick auf einen Eintrag wird dieser im Access Unit Tree ausgewählt. Konfiguration speichern Mit dem Button Save Configuration / Save FSLicense.xml werden die aktuell ausgewählten Lizenzen in das aktuelle Setting übernommen bzw. in die Datei FSLicense.xml geschrieben und anschließend der Runtime License Manager geschlossen. Diese Funktion kann nur dann aufgerufen werden, wenn im Lizenzbaum eine Lizenz des aktiven Packages ausgewählt ist. Außerdem muss für jedes Basispackage eine Lizenz im Lizenzbaum ausgewählt sein (gelbe Markierung). Wenn Sie für ein Basispackage eine andere Lizenz als die zurzeit gelb hinterlegte verwenden wollen, öffnen Sie das Kontextmenü der gewünschten Lizenz und wählen dort den Eintrag Use as Basic License aus. Registerkarte Access unit tree Auf dieser Registerkarte werden alle Access Units im so genannten Access Unit Tree dargestellt. Der Access unit tree stellt die Hierarchie dar, in der die Access Units angeordnet sind. Warning Damit die Hierarchie auf dem aktuellen Stand ist, müssen an allen Packages, nach der letzten Änderung der Hierarchie des jeweiligen Packages, AccessUnits als FrameworkCompiler „recursive from root“ kompiliert worden sein! Dabei ist zu beachten, dass die Hierarchie eines Packages sich nicht nur über den Access Unit Treeview ( Access Unit Hierarchie ) ändern lässt, sondern auch bei jedem Einchecken eines neuen Forms automatisch geändert wird. Importierte Packages müssen zur Aktualisierung der Hierarchie grundsätzlich nicht neu kompiliert werden, da dies bereits vor dem Export geschehen sein sollte. In der Spalte Name werden alle Access Units hierarchisch dargestellt. Access Units mit einem Schlüsselsymbol , Form Access Units mit einem Schlüssel auf einem Form . In den übrigen Spalten symbolisieren spezielle Checkboxen das erteilte Recht für die einzelnen Zugriffsarten ( ACC = Access, ACD = AccessDerived, UPD = Update, INS = Insert, Del = Delete, Bedeutung der Zugriffsarten: Access Units ). Die speziellen Checkboxen können verschiedene Symbole darstellen: Leere Checkbox: Keine Angabe durch den Benutzer. Der Anwendung wird diese Zugriffsart für die AccessUnit verwehrt. Blauer Haken: Die Zugriffsart der AccessUnit wird explizit erlaubt. Roter waagerechter Strich: Die Zugriffsart der AccessUnit wird explizit verweigert. Gelbes Prozentzeichen: Zu dieser Zugriffsart der AccessUnit wird explizit keine Angabe durch den Benutzer gemacht. Der Anwendung wird diese Zugriffsart verwehrt. Grauer Haken: Die Zugriffsart der AccessUnit wird erlaubt, weil diese AccessUnit ein Unterelement einer AccessUnit ist, für welche die Zugriffsart erlaubt wird (hierarchisch erlaubt). Grauer waagerechter Strich: Die Zugriffsart der AccessUnit wird verweigert, weil diese AccessUnit ein Unterelement einer AccessUnit ist, für welche die Zugriffsart verweigert wird und diese AccessUnit nicht unter einer anderen AccessUnit hängt, für welche die Zugriffsart erlaubt wird (hierarchisch verboten). Wenn eine Checkbox mit grauem Hintergrund dargestellt wird, so bedeutet dies, dass das repräsentierte Zugriffsrecht bereits durch eine der verwendeten Basislizenzen verweigert wird. Sie können in der Lizenz für das aktuelle Package diese Zugriffsart trotzdem erlauben. Die Endanwendung wird diese Zugriffsart jedoch nur erlaubt bekommen, wenn andere Basislizenzen verwendet werden, die diese Zugriffsart ebenfalls ermöglichen. Mit dem Menüeintrag Parents im Kontextmenü einer Access Unit erhält man eine Liste aller Access Units, die die ausgewählte Access Unit als Unterelement enthalten. Wählt man aus der Liste eine Access Unit aus, wird direkt dorthin gesprungen. Im Access Unit Tree kann mit der Multiplikationstaste * der komplette Teilbaum der ausgewählten AccessUnit aufgeklappt werden, mit der Subtraktionstaste - wird der Teilbaum wieder kollabiert. Registerkarte License Parameters Diese Registerkarte beinhaltet alle allgemeinen Eigenschaften der ausgewählten Lizenz: License ID Automatisch generierte ID der Lizenz. Dieser Wert kann nicht geändert werden. Name Name der Lizenz. Dieser Name wird im Lizenzbaum angezeigt. Customer Person oder Firma, für welche die Lizenz ausgestellt wurde. Type Typ der Lizenz. Zur Auswahl stehen Customer , Demo , Developer und Partner . Lediglich der Typ Developer hat eine besondere Bedeutung: Bei einer Developer-Lizenz werden alle Access Unit Rechte erteilt (soweit sie nicht durch andere Lizenzen für Basispackages gesperrt wurden). Daher steht die Registerkarte Access unit tree bei einer Developer-Lizenz nicht zur Verfügung. Die zweite Besonderheit einer Developer-Lizenz ist, dass die Authentifizierung deaktiviert wird, auch wenn die Applikation so konfiguriert wurde, dass Authentifizierung verwendet werden soll. Category Die Kategorie, der die Lizenz zugeordnet wurde. Kategorien können beliebig benannt werden, dürfen aber nur aus den Buchstaben A-Z, dem Trennstrich, dem Unterstrich und Ziffern bestehen. Groß-Klein-Schreibung ist dabei unerheblich. Wird keine Kategorie angegeben, so ist die Lizenz automatisch mit der Standardkategorie „Standard“ verknüpft. ( Kategorien für Laufzeitlizenzen ) User Limit Hier kann die Zahl der gleichzeitig aktiven Benutzer begrenzt werden. Valid from Datum, ab dem die Lizenz gültig ist Valid to Datum, an dem die Gültigkeit der Lizenz endet Version from Packageversion, ab der die Lizenz gültig ist. Die Version muss aus zwei bis vier natürlichen Zahlen getrennt durch je einen Punkt bestehen oder leer sein, um keine Einschränkung festzulegen. Version to Packageversion, bis zu der die Lizenz gültig ist. Die Version muss aus zwei bis vier natürlichen Zahlen getrennt durch je einen Punkt bestehen oder leer sein. Nicht angegebene Unterversionen werden mit eingeschlossen. Beispiel: Version 3.9.1 wird freigegeben, wenn die Versionsobergrenze (Version to) auf 3.9 festgelegt wurde. Package Name des Packages, für die die Lizenz erstellt wurde Label Version des Packages, für das die Lizenz erstellt wurde Kategorien für Laufzeitlizenzen Motivation Es gibt Anwendungsfälle, in denen nur ein Bruchteil einer kompletten Anwendung zum Einsatz kommen soll. Typische Beispiele sind Kassen oder Scanner. Sie nutzen nur einen sehr kleinen Umfang der Gesamtanwendung. Häufig kommen diese speziellen Arbeitsplätze in großer Zahl vor. Daher wünschen Endkunden für diese funktional stark eingeschränkten Anwendungen \"günstigere\" Lizenzen. Prinzip Einer Laufzeitlizenz kann eine Kategorie zugeordnet werden. Zur Laufzeit wird pro Kategorie geprüft, ob die in der Lizenz angegebene Benutzerzahleinschränkung erfüllt ist. So können zwei unterschiedliche Lizenzen mit unterschiedlichem Funktionsumfang und abweichender Benutzerzahlbeschränkung, die abweichenden Kategorien zugeordnet sind, parallel eingesetzt werden. Beispiel: Lizenz „Scanner“ schaltet nur einen kleinen Funktionsumfang frei, ist der Kategorie „SCANNER“ zugeordnet und für 25 User ausgelegt. Lizenz „Standard“ schaltet die gesamte Anwendung frei, ist der Kategorie „STANDARD“ zugeordnet und für 10 User ausgelegt. Wenn Sie nun eine Applikation mit der Lizenz „Scanner“ veröffentlichen und eine weitere Applikation mit der Lizenz „Standard“, so können 25 Benutzer die eingeschränkte Applikation „Scanner“ starten und parallel dazu 10 Benutzer die andere Applikation in vollem Funktionsumfang. Insgesamt kann die Anwendung von 35 Benutzern parallel gestartet werden. Details Im Runtime License Manager kann auf der Registerkarte License Parameters der aktuell ausgewählten Lizenz im Textfeld Category eine Kategorie zugeordnet werden ( Registerkarte License Parameters ). Kategorien können beliebig benannt werden, dürfen aber nur aus den Buchstaben A-Z, dem Trennstrich, dem Unterstrich und Ziffern bestehen. Groß-Klein-Schreibung ist dabei unerheblich. Wird keine Kategorie angegeben, so ist die Lizenz automatisch mit der Standardkategorie Standard verknüpft. Eine Lizenz kann mit Lizenzen für Basispackages zusammen eingesetzt werden, die einer anderen Kategorie zugeordnet sind. Registerkarte Language Auf dieser Registerkarte wird konfiguriert, welche Sprachen freigegeben werden sollen. Die einzelnen Sprachen werden zeilenweise in einer Tabelle dargestellt. Die Tabellenspalten haben folgende Bedeutung: Name Bezeichnung der Sprache ISO Sprachkürzel nach ISO 639-1 Granted In der Checkbox können zwei Symbole dargestellt werden: Ein blauer Haken bedeutet, dass die Sprache freigegeben werden soll. Ein roter waagerechter Strich bedeutet, dass die Sprache gesperrt wird. Bei einer neu erstellten Lizenz sind zunächst alle Checkboxen mit blauen Haken versehen. Wenn eine Checkbox grau hinterlegt ist, wird dadurch angezeigt, dass diese Sprache durch eine der aktuell ausgewählten Basislizenzen gesperrt wird. Is Default In dieser Spalte wird die Default Sprache mit einem blauen Haken markiert. Die Default Sprache wird im PackageManager am Basispackage definiert. Wenn die Anwendung eine nicht lizenzierte Sprache anfordert, wird automatisch auf die Default Sprache umgeschaltet. Die Default Sprache ist automatisch immer freigegeben."
  },
  "doc/admin/admin.html": {
    "href": "doc/admin/admin.html",
    "title": "Administration",
    "keywords": "Administration Framework Studio Administration-Tool Ein Bestandteil von Framework Studio ist das Administration-Tool. Dabei handelt es sich um ein eigenständiges Programm. (FrameworkStudioAdministration.exe) Aufgaben des Tools: Verwalten von Lizenzen für die Nutzung von Framework Studio Erzeugen eines leeren Repositories Verwalten von Lizenzen Wenn Sie mit Framework Studio arbeiten, müssen Sie eine Datenbank haben, in der die Lizenz-Informationen abgelegt werden. Beim Start des Administration-Tools erscheint wie beim Framework Studio eine Repository-Auswahl. Dort geben Sie - falls noch nicht vorhanden - die Datenbank mit den Lizenz-Daten an. (siehe Framework Studio start .) Mit dem Button ( Import License ) können Sie eine Lizenz-Datei importieren. Es erscheint ein Datei-Auswahl-Dialog in dem Sie eine *.fsl-Datei auswählen können. Nach der Auswahl wird die darin enthaltene Lizenz erstellt. Mit dem Button ( Export License ) wird die im Baum markierte Lizenz in eine fsl-Datei exportiert. Mit dem Button (Delete) wird die im Baum markierte Lizenz gelöscht. Das Löschen wird erst wirksam, wenn Sie den Button ( Save All ) drücken. Warning Wenn Sie mehrere Lizenzen importieren, die für das aktuelle Datum und die aktuelle Version gültig sind, wird die Anzahl der Benutzer im User Limit nicht addiert. Es wird zufällig eine gezogen. Erstellen eines Repositories Ein neues Repository kann mit dem Programm Framework-Studio Administration erstellt werden. Alternativ dazu kann die gleiche Funktionalität im Dialog zur Repository-Auswahl beim Start von Framework Studio mit dem Menüpunkt Repositories / Create new Repository ... gestartet werden. Dort haben Sie auch die Möglichkeit, ein Demo Repository und die dazugehörige Demo Datenbank anzulegen ( Repositories / FSDemo , siehe Weitere Funktionalität im Hauptmenü ). Es gibt grundsätzlich zwei Möglichkeiten, wie ein neues Repository erzeugt wird: Ein neues leeres Repository erzeugen, um eine eigene Anwendung zu entwickeln. Ein vorhandenes Default-Package importieren, um die darin enthaltene Anwendung in einen Broker zu generieren oder darauf aufbauend ein Customizing-Package zu erzeugen. Warning Es gibt immer genau ein unterstes Package. Dieses nennt sich Default-Package. Mehrere Default-Packages können nicht miteinander kombiniert werden. Es ist also nicht möglich, nachträglich ein Package zu importieren, bei dem es sich um ein solches Default-Package handelt. Über das Menu File / New / Repository im Administration Tool öffnet sich ein Fenster, mit dem Sie ein neues Repository erzeugen können. Connection Type (SqlServer, Oracle) Hier können Sie angeben, welche Art von Datenbank Sie für das neue Repository verwenden wollen. Server Name (Nur bei SQL-Server) Gibt an, auf welchen Server das Repository abgelegt ist bzw. abgelegt werden soll. Bei Oracle werden die Datenbanken nur mit Namen angesprochen. Diese Namen müssen im Oracle-Client hinterlegt werden. Database Name Gibt den Namen der Datenbank an, in der das Repository eingespielt werden soll. Bei SQL-Server wird eine neue Datenbank erzeugt, falls diese noch nicht existiert. Wenn die Datenbank bereits existiert, muss es sich dabei um eine leere Datenbank handeln. Es darf auch keine Framework Studio Lizenz-Datenbank sein. Bei Oracle muss die angegebene Datenbank existieren. Die Tabellen für das Repository werden in das Profil des angegebenen Benutzers generiert. Es dürfen in dem Profil noch keine Repository-Datenstrukturen existieren. Es darf auch keine Framework Studio Lizenz-Datenbank in diesem Profil installiert sein. Authentication Gibt an, mit welchem Login auf die Datenbank zugegriffen werden soll. Repository with empty default Package Es wird ein leeres Default-Package generiert. Der Name des Packages wird mit „Package“ vorbelegt. Er kann später im Package Manager geändert werden. Dies sollte vor dem Start der Entwicklung gemacht werden. I want to choose my default Package Es wird ein vorhandenes Package importiert. Das Package kann mit dem Button ausgewählt werden. Dabei muss es sich um ein Default-Package handeln. Der Import kann je nach Größe des Packages relativ lange dauern. Button OK Erzeugt das Repository. Button Cancel Schließt den Dialog ohne eine Aktion auszuführen. Benutzer-Verwaltung Wenn Sie Framework Studio starten und sich mit dem Benutzer-Namen FrameworkAdministrator anmelden, erscheint nicht das Hauptfenster von Framework Studio , sondern ein Fenster für die Benutzer-Verwaltung. Benutzer anlegen Mit dem Button ( New ) können Sie einen neuen Benutzer anlegen. Der neue Benutzer erscheint in der Liste mit den Benutzern und kann dann bearbeitet werden. Benutzer bearbeiten Sie können die Daten eines Benutzers bearbeiten, indem Sie diesen in der Liste auswählen. Die Daten werden dann in den rechten Teil des Fensters eingespielt und können bearbeitet werden. Name Name des Benutzers. Mit diesem Namen meldet sich der Entwickler beim Start von Framework Studio am Repository an. Der Benutzername kann auch noch geändert werden, wenn der Benutzer bereits Elemente bearbeitet hat. Password / Confirm Password In diesen Feldern kann das Passwort des Benutzers festgelegt oder geändert werden. Um die Änderungen zu speichern, drücken Sie den Button Save. FrameworkCompiler Mode Ist die Checkbox gesetzt, arbeitet der angegebene Benutzer wie der FrameworkCompiler mit dem Unterschied, dass dieser Benutzer auch auschecken darf. Das bedeutet, dass dieser Benutzer beim Kompilieren den Saved Code und die Assemblies für den FrameworkCompiler in das Repository zurückschreiben darf. Der FrameworkCompiler Mode wurde für folgende Anwendungsfälle konzipiert: Durchführen eines Kompiliervorgangs als FrameworkCompiler mit der direkten Möglichkeit, Korrekturen durchführen zu können – auch in Kombination mit dem Compile Manager ( Compile Manager ). Das ist z.B. bei einem Package-Update sehr vorteilhaft. Arbeiten im Ein-Benutzer-Betrieb. So können z.B. auch Korrekturen durchgeführt werden, ohne am Ende mit dem FrameworkCompiler erneut kompilieren zu müssen. Bei der Arbeit mit einem Benutzer im FrameworkCompiler Mode (FCUser) müssen einige Richtlinien beachtet werden: Es sollte nur einen FCUser geben. Mit diesem können Sie sich aber durchaus zur selben Zeit an verschiedenen Package-Versionen anmelden. Wenn mit einem FCUser an einer Package-Version gearbeitet wird, dann sollte dies der einzige Benutzer sein, der an dieser Package-Version arbeitet. Weil der FCUser generierten Code zurückschreibt, der sich ggf. auch auf von ihm ausgecheckte Elemente bezieht, kann das für andere Benutzer zu Fehlern führen. In der Zeit, in der mit einem FCUser gearbeitet wird, darf kein FrameworkCompiler laufen. Andernfalls kann es dazu führen, dass sich FCUser und FrameworkCompiler die generierten Codes und Assemblies gegenseitig zerstören. Am Ende der Arbeit sollten wieder alle Elemente eingecheckt und der FrameworkCompiler-Vorgang abgeschlossen werden. FrameworkStudio gibt beim Beenden eine entsprechende Warnmeldung aus. Beenden Sie FrameworkStudio als angemeldeter FCUser ohne \"Complete FrameworkCompiler\", wird folgende Warnung angezeigt. Diese Meldung soll darauf hinweisen, dass der FCUser entgegen unserer Anwendungsfälle verwendet wird. (Diese Warnung gibt keine Auskunft über etwaige Fehler beim Complete FrameworkCompiler.) Benutzer löschen Um einen Benutzer zu löschen, wird dieser markiert und anschließend der Button (Delete) gedrückt. Das Löschen müssen Sie jetzt noch mit dem Button (Save All) bestätigen. Warning Ein Benutzer kann nur dann gelöscht werden, wenn er noch keine Elemente bearbeitet hat. Sollten Sie versuchen einen Benutzer zu löschen, der bereits gearbeitet hat, erscheint eine Fehlermeldung."
  },
  "doc/allgemein/options.html": {
    "href": "doc/allgemein/options.html",
    "title": "Options",
    "keywords": "Options Die Options können in der IDE über den Menüeintrag Tools / Options geöffnet werden. IDE (Registerkarte) Login Auto Debug DLLs Diese Option kann hinterlegt werden und wird im Login -Dialog und im GetDLLs -Dialog verwendet. Auf den \"normalen\" Compile hat diese Option keine Auswirkung. Im Login- und GetDLL-Dialog wird die Einstellung aus den Options übernommen. Die Einstellung kann jedoch in beiden Dialogen temporär geändert werden. Bedeutet, dass Änderungen am Auto Debug im Login- oder GetDLL-Dialog keine Auswirkungen auf die Option im Options-Dialog haben. Es stehen folgende drei Optionen zur Verfügung: Service, Component: Alle Namespaces der Services und Components werden debuggable kompiliert. All : Hier werden alle Namespaces jeden Types debuggable kompiliert. None : Bei dieser Einstellungen wird nichts debuggable kompiliert. Appearance Error Display Wird die Checkbox Legacy Error Window gesetzt, kann erzwungen werden, dass die Errors in derselben Art und Weise ausgegeben werden, wie es bis Framework Studio 2.6 der Fall war. Background Image Wird die Checkbox Disable gesetzt, wird in der Framework Studio Umgebung kein Hintergrundbild mehr angezeigt. Dies kann zu einer Performancesteigerung bei Remote Sessions beitragen (z.B. VNC). Documentation Indicators Zeigt an den Controls im Form-Designer an, ob eine Dokumentation gepflegt ist, bzw vererbt wurde. Siehe Dokumentationsstatus von Steuerelementen Form Control DoubleClick Gibt an, was im Form-Designer passieren soll, wenn auf ein Control Strg + Doppelklick ausgeführt wird. RadioButton Show Control Events : Zeigt den Events-Dialog für das Control an. Diese Option ist sinnvoll für normale Entwickler. Der Documentation-Editor kann über das Context-Menü des Controls geöffnet werden. RadionButton Show Documentation : Zeigt den Documentation-Editor für das Control an. Diese Option ist sinnvoll für Benutzer, die viel an Dokumentationen arbeiten. Die Control-Events können über das Context-Menü des Controls geöffnet werden. Show form designer grid Gibt an, ob im Form-Designer das Raster-Grid angezeigt werden soll. Bei der Arbeit über Remote Desktop kann dieses Grid die Performance sehr stark verschlechtern. Languages in designer Hier können die Sprachen eingestellt werden, die in den MLStrings und im Wörterbuch angeboten werden sollen. Die Reihenfolge wird - sofern dies möglich ist - von den Designer-Fenstern berücksichtigt. Es werden kommasepariert die Iso-Codes der Sprachen angegeben - z.B. de,en,fr . Wird keine Angabe gemacht, werden in allen Designer-Fenstern immer alle verfügbaren Sprachen angeboten. Code Editor Font Family Hier können Schriftart und -größe für den Code-Editor angepasst werden. Go to Definition with Ctrl+DoubleClick Schaltet im Code-Editor die Funktion Go to Definition (F12) mit Strg + Doppelklick ein. Es kann sinnvoll sein, diese Funktion zu deaktivieren, wenn man diese Funktion öfters aus Versehen auslöst. Dann bleibt immer noch die F12-Taste oder das Context-Menü zum Aufruf dieser Funktion. Context Tooltip Gibt an, ob im Code-Editor Informationen zu Elementen angezeigt werden sollen, wenn mit der Maus auf Code-Teile gezeigt wird. Compile / Debug (Registerkarte) Broker Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Host Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Compile Rootdirectory Gibt an, unter welchem Ordner Framework Studio die Compile-Verzeichnisse erzeugen soll. Diese Einstellung muss manuell in der Datei FrameworkStudio.exe.config angepasst werden. Beispiel: <configuration> <appSettings> <add key=\"CompileBaseDirectory\" value=\"C:\\FS\\Compile42\" /> [...] Visual Studio Path Hier kann angegeben werden, wo Visual Studio installiert ist. Die aktuell von Framework Studio unterstützten Versionen von Visual Studio werden automatisch erkannt. Wenn eine andere Version oder Edition (z.B. Visual Studio Express) verwendet werden soll, kann das entsprechende Programm angegeben werden. Mit dem Button Reset wird der Wert auf die Original-Einstellung zurückgesetzt. Diese Einstellung wird für das Menu View / Compiled Code in Visual Studio in den Designer-Fenstern verwendet. Außerdem wird der Ordner aus dieser Einstellung verwendet, um für die Arbeit mit Services das Programm WcfTestClient.exe zu finden. Visual Studio Arguments Hier können die Kommandozeilen-Argumente für das Öffnen der Quellcode-Dateien angegeben werden. Beim Einsatz von Visual Studio können die Standard-Einstellungen %file% /Edit beibehalten werden. Der Platzhalter %file% steht für die zu öffnenden Dateien. Dieser werden in dem Format \"Datei1.cs\" \"Datei2.cs\"… übergeben. Wenn dieser Platzhalter nicht angegeben ist, dann werden die Dateien an der Parameter gestellt. Utilities (Registerkarte) Mit dem Button [...] kann jeweils ein Dateiauswahldialog geöffnet werden. SvcUtil Gibt den Pfad zur SvcUtil.exe des Windows SDK an. Diese wird für die Generierung des Services verwendet. InstallUtil Gibt den Pfad zur InstallUtil.exe des .NET-Frameworks an. Crystal Report Designer Gibt den Pfad zum Crystal Report Designer an. Diff Tool Hier kann die ausführbare Datei für das Diff Tool angegeben werden. Diff Tool Data Dir Hier kann das Datenverzeichnis für das Diff Tool angegeben werden."
  },
  "doc/application/application.html": {
    "href": "doc/application/application.html",
    "title": "Application",
    "keywords": "Application"
  },
  "doc/code-editor/code-messages.html": {
    "href": "doc/code-editor/code-messages.html",
    "title": "Code-Messages",
    "keywords": "Code-Messages Wenn Sie eine Methode eines Forms bearbeiten, stehen Ihnen Editoren zum komfortablen Erstellen und Bearbeiten von mehrsprachigen Ausnahmen (Exceptions) und Meldungen (Message-Boxen) zur Verfügung. Diese können Sie über die Buttons Exception Editor Wizard und Message Box Editor Wizard aufrufen. Wenn Sie eine Textcollection ändern, indem Sie beispielsweise einen neuen Eintrag erzeugen oder einen bestehenden Eintrag ändern, dann muss die Textcollection dazu in der aktuellen Version für Sie ausgecheckt werden. Benutzen Sie dazu den Button Edit Message . Andere Benutzer können nun die Textcollection nicht bearbeiten. Beim Verlassen des Message Box Editors bzw. Exception Editors wird die Textcollection automatisch wieder eingecheckt, so dass auch andere Benutzer wieder auf die Textcollection zugreifen können. Beide Editoren weisen nur sehr geringfügige Unterschiede auf. Radiobutton ML Key Hier können sie einen MLKey angeben. Mit dem Auswahl-Button neben dem Textfeld öffnet sich der Dialog Select ML Key . Dies ist die Standard-Option. Neue Meldungen sollten immer über das Wörterbuch gezogen werden. Radiobutton New Message Wenn Sie diesen Radiobutton auswählen, wird ein neuer Text in die ausgewählte Textcollection eingetragen. Important Wenn Sie einen neuen Text hinzufügen, müssen Sie auch die Textcollection kompilieren, da es sonst beim Ausführen des Programms Fehlermeldungen gibt. Radiobutton Change Message Wenn Sie diesen Radiobutton auswählen, können Sie mit dem Button Choose existing Message einen bestehenden Eintrag aus der angegebenen Textcollection auswählen oder mit dem Button Search nach einem bestehenden Eintrag suchen. Button Change Collection Mit diesem Button kann die Textcollection geändert werden, aus der ein Text ausgewählt werden soll, bzw. in welcher der neue Text eingetragen werden soll. Als Default-Wert ist die Textcollection ctMessages ausgewählt. Button Choose existing Message Mit diesem Button kann aus der gewählten Textcollection ein existierender Eintrag ausgewählt werden. Feld Collection Zeigt an, welche Textcollection ausgewählt ist. Button Search Mit diesem Button öffnen Sie einen Suchdialog. In diesem Dialog wird die Suche auf die Textcollection, die im Exception Editor / Message Box Editor angegeben ist, eingeschränkt. Die Suchfunktionalität ist identisch mit den Möglichkeiten, die auf der Registerkarte Search im Framework-Designer zur Verfügung gestellt werden. Text-Grid Ist ein MLKey ausgewählt, wird hier nur der Text angezeigt. Der ML Key kann über das Textfeld bzw. den Auswahl-Button geändert werden. Die Bearbeitung der Texte-Inhalte erfolgt über das Wörterbuch . In diesem Grid kann der Text der Message in den verschiedenen Sprachen eingegeben werden. Wurde mit Choose existing Message ein Eintrag ausgewählt, wird dieser geändert und in die Textcollection zurückgeschrieben. Alle vorhandenen Message-Boxen, die diesen Eintrag verwenden, sind ebenfalls davon betroffen. Dem Text können Parameter zugewiesen werden. Die Parameter werden in der Form {0}, {1} usw. angegeben. Jeder Parameter kann mehrmals verwendet werden. Der Beleg {0} für Kunde {1} hat sich geändert. Wollen Sie den Beleg {0} speichern? Die Parameter werden in der Textbox String.Format... gefüllt. Combobox Icon (nur Message-Box) Gibt an, welches Icon verwendet werden soll Error Exclamation Information Question None Combobox Buttons (nur Message-Box) Gibt an, welche Buttons angezeigt werden sollen. Wird OK ausgewählt, ist es nicht notwendig, einen Event-Handler zu hinterlegen. Werden andere Buttons ausgewählt, muss ein Event-Handler hinterlegt werden. AbortRetryIgnore OK OKCancel RetryCancel YesNo YesNoCancel Combobox Default (nur Message-Box) Gibt den Button an, der beim Anzeigen der Message-Box ausgewählt sein soll. So kann z.B. bei den Buttons YesNo durch Angabe von Button2 das versehentliche Betätigen des Yes -Button verhindert werden. Button1 Button2 Button3 Die Nummer des Buttons entspricht der Angabe bei Buttons. z.B. YesNoCancel bedeutet Button1 = OK , Button2 = No , Button3 = Cancel Button Event Handler (nur Message Box Editor) Mit diesem Button kann angegeben werden, ob mit dem Klick in der Message-Box (z.B. auf OK oder Cancel ) ein Event angestoßen werden soll oder nicht. Ist der Button gedrückt, erscheint rechts daneben eine Combobox, mit der evtl. bestehende Methoden ausgewählt werden können. Mit dem Button New wird ein neuer Event-Handler angelegt. Es wird eine Methode OnMsgBoxClick1 angelegt. Der Parameter MsgBoxEventArgs hat ein Property DialogResult, damit abgefragt werden kann, welcher Button gedrückt wurde. public void OnMsgBoxClick1(object sender, MsgBoxEventArgs e) { if (e.DialogResult == DialogResult.OK) { //Code for Ok. } } Combobox Severity (nur Exception Editor) Hier können Sie den Schweregrad der Ausnahme (0-3) festlegen. Add Inner Exception (nur Exception Editor) Wenn die Checkbox gesetzt ist, können Sie das Property InnerException füllen. Geben Sie dazu die zu übergebende Variable im Textfeld an. Geben Sie dazu im Textfeld den Namen der lokalen Exception-Variable an. Textbox String.Format... In dieser Textbox können die Parameter der Message angegeben werden. Es ist möglich im Message Text Parameter anzugeben. Dies geschieht mit {0}, {1} usw. Diese Parameter können im Text auch mehrmals verwendet werden. Für jeden dieser Parameter kann hier, mit Komma getrennt, ein Wert angegeben werden. Der erste Parameter steht für {0} , der zweite für {1} usw. this.oOrder.lngOrderID, this.oOrder.lngCustomerID Button OK Schließt den Dialog und fügt den generierten Message-Code in den Code-Editor ein. Button Cancel Schließt den Dialog und verwirft die Änderungen. Wenn der Message-Box-Editor mit OK verlassen wird, wird an die Stelle im Code, an der sich der Cursor befindet der Code generiert. // FSCodeMessage: Really delete article {0}? MsgBox.Show(this.Global.FormatMLKeyText(MLKeys.MSG_9188180c5ac64a5384141b553eef8105, this.oSelectedArticle.sName), \"\", MsgBoxButtons.YesNo, MsgBoxIcons.Question, new MsgBoxEventHandler(OnDeleteQuestionMsgBoxClick)); Durch eine farbige Markierung ist dieser Code im Code-Editor gut zu erkennen. Um die Code-Message nachträglich zu ändern, setzen Sie den Fokus irgendwo in den generierten Code-Block und drücken erneut den entsprechenden Wizard-Button. Es öffnet sich wieder der Editor wie oben und die Daten der Code-Message werden angezeigt und können geändert werden. Bei Bedarf können auch einzelne Bestandteile wie z.B. der MLKey oder ein Enum-Wert direkt im Code geändert werden. Caution Die Struktur des Code darf jedoch nicht geändert werden, weil dieser sonst für eine spätere Bearbeitung mit dem Editor nicht geparsed werden kann. Der Code darf nicht mehrzeilig sein."
  },
  "doc/code-editor/index.html": {
    "href": "doc/code-editor/index.html",
    "title": "Code-Editor",
    "keywords": "Code-Editor Framework Studio bietet einen umfangreichen C#-Code Editor mit IntelliSense Funktion und Code Highlighting. Intellisense Der Code Editor beinhaltet die Funktionalität von IntelliSense, die kontextabhängig Code-Vervollständigung zur Verfügung stellt. Aufgerufen werden kann IntelliSense mit der Tastenkombination Strg + Leertaste an einer beliebigen Stelle im Code. Go to Definition Mit der Kombination Strg + Doppelklick oder über das Kontextmenü kann aus dem Code Editor heraus zu den angeklickten Zielen gesprungen werden. Dies funktioniert bei Properties und Methoden. Ausgenommen davon sind Methoden fremder Components. Go to Base Über den Eintrag Go to Base im Kontextmenü des Code Editors kann zu der Basis der aktuellen Methode navigiert werden. Compare with Base Über den Kontextmenüeintrag Compare with Base im Code Editor ist es möglich, Überschreibungen von Methoden mit deren Implementierung im Basis-Package zu vergleichen. Zum Vergleich wird ein externes Programm verwendet, welches mit dem Menüpunkt Tools / Options im Hauptfenster konfiguriert werden muss. (Vgl. Konfiguration von Method History Browser)"
  },
  "doc/code-file/codefile.html": {
    "href": "doc/code-file/codefile.html",
    "title": "Code file",
    "keywords": "Code file Framework Studio bietet die Möglichkeit freien C#-Code zu programmieren. Erstellen einer Code file Es wird der Namespace ausgewählt, in dem das neue Element angelegt werden soll. Anschließend wird in der Registerkarte Namespaces über New / Code File ein neues Code file angelegt. Anschließend muss ein Compile Step ausgewählt werden, damit der Code kompiliert wird. Das Code file muss eine Klasse, kann jedoch auch mehrere Klassen beinhalten. Aufgrund gängiger Konventionen sollte ein Code File jedoch nur eine Klasse beinhalten und der Name des Code files identisch mit dem Namen der Klasse sein. Namespaces können nicht definiert werden. Compile step Der Compile step bestimmt, mit welchem Typen das Code file kompiliert wird. Dieser muss angegeben werden, ansonsten wird der Code nicht kompiliert. Soll der Code auch in einem anderen Namespace zur Verfügung stehen, muss auf den Namespace und den ObjectType/Compile step eine Referenz angelegt werden. Ein detailliertes Beispiel finden Sie unter Beispiel . Caution Das Ändern des Compile steps wird nicht empfohlen. Sollten Sie das Code file bereits in anderen Namespaces verwendet haben, werden infolge der Änderung die Referenzen ungültig und der Compile wird nicht erfolgreich durchlaufen. Referenz Beispiel Wird ein Code file im Namespace \"Company\" angelegt und der Compile step wird auf \"Component\" gesetzt, dann wird der Code der Code file in die Dll des Namespace \"Company\" der Component generiert und kompiliert. Für den Zugriff auf den Code außerhalb des Namespaces, muss eine Referenz auf den Namespace und den Object Type bzw. Compile Step hinterlegt werden. In folgender Abbildung wird eine Referenz vom Namespace \"Article\" auf den Namespace \"Company\" angelegt. So kann nun innerhalb der Components im Namespace \"Article\" die cfCompany-Klasse verwendet werden."
  },
  "doc/comp/components.html": {
    "href": "doc/comp/components.html",
    "title": "Components",
    "keywords": "Components Components stellen funktionale Klassen dar. Framework Studio unterscheidet zwischen vier verschiedenen Typen: Textcollections Components ohne Query Components mit Query (DataComponents) Collections In diesem Abschnitt wird auf Components mit Query und Collections eingegangen. Informationen zu Textcollections und Components ohne Query finden Sie in den folgenden Abschnitten. Eine spezielle Sorte von Components stellen in Framework Studio die Data-Components dar. Data-Components werden über den Database-Editor erstellt (siehe Abschnitt Database Editor) und stellen die Verbindung zu den Daten in der Datenbank her. Jeder aus der Datenbank geladene Datensatz entspricht deshalb einem Objekt vom Typ der jeweiligen Component. Zu einer Data-Component können Sie auch zusätzlich Properties definieren, die Sie über Get/Set-Methoden füllen oder setzen. Außerdem können auf einer Component Methoden hinterlegt werden, die mit den Daten operieren und sie validieren. Eine Component besteht aus folgenden Bestandteilen: Query: Sie stellt die Verbindung zu einer Datenquelle (in der Regel) einer Datenbanktabelle dar. Dazu werden eine oder mehrere Tabellen eingebunden und angegeben, welche Spalten in der Query enthalten sein sollen. Die Component stellt genau einen Datensatz aus dieser Query dar. Allerdings kann eine Query auch ein Join sein. Properties: Sie bieten die Spalten der Query nach außen an. Dabei wird jede Spalte in der Query zu einem Property. Properties können aber auch völlig frei ohne Verbindung zur Query definiert werden. Die verschiedenen Arten der Properties werden im Abschnitt Properties behandelt. Methoden: Sie können verschiedene Zwecke erfüllen. Zum einen können Methoden frei wie in einer normalen Klasse definiert werden. Diese können dann irgendwelche Operationen ausführen. Zum anderen gibt es Entrypoints (virtuelle Methoden), die in der Component überschrieben werden können, um z.B. die Daten vor dem Abspeichern in der Datenbank zu validieren. Collections sind (wie in .NET) eine Sammlung von Objekten einer Component. Sie stellen bereits von sich aus Properties und Methoden bereit, um diese Sammlung zu verwalten. Eine Collection verwaltet immer die Objekte von genau einer Component. Sie können zu einer Collection nur Properties und Methoden hinzufügen. Anlegen von Components Eine Component können Sie erzeugen, indem Sie auf der Namespaces-Registerkarte den Namespace auswählen, in dem die Component angelegt werden soll. Abschließend drücken Sie den Button ( New ) und wählen den Eintrag Component aus. Die neue Component wird gleich im Hauptfenster des Framework Designers geöffnet. Components bearbeiten Sie öffnen eine vorhandene Component, indem Sie auf der Namespaces-Registerkarte einen Doppelklick auf die gewünschte Komponente machen. Auf der Registerkarte Class sehen Sie in einer Übersicht alle Properties und Methoden der Component. Sie haben die Möglichkeit über einen Doppelklick auf die Properties und Methoden im Fenster direkt zu dem jeweiligen Element zu springen. Alternativ können Sie auch über das Tabcontrol des Component-Fensters zu den jeweiligen Elementen navigieren. In gewohnter Weise können Sie jetzt Elemente über die Buttons des Hauptmenüs oder das Kontextmenü im Baum hinzufügen, ändern, umbenennen oder löschen. Name Bezeichnung der Komponente. Dieser Name muss pro Namespace eindeutig sein. Es empfiehlt sich, die Namen der Komponenten auch über Namespaces hinweg eindeutig zu vergeben. Check In By Gibt an, wer die Komponente wann das letzte Mal eingecheckt hat und welche Versionsnummer die aktuelle ist. Ist die Komponente ausgecheckt, werden die Daten des ausgecheckten Zustands angezeigt. Inspected Diese Checkbox hat bisher keine Funktion und dient nur zur Information. Registerkarte General Type Bei einer Collection ist hier angegeben, welche Component diese Collection enthält. Datasource: Gibt den Datasource an. Diese Angabe ist notwendig, wenn in der Component eine Query definiert werden soll oder wenn in der Component (oder Collection) eine Transaktion abgehandelt werden soll. For Component (Collections): Zeigt an, welche Component diese Collection enthält. Description Hier kann eine Beschreibung der Komponente hinterlegt werden. Control Types Hier kann ein Control-Type für die Komponente festgelegt werden, was z.B. bei Collections Sinn macht. Wird bei der Collection z.B. ein Grid hinterlegt, wird später im Form-Designer automatisch ein Grid erzeugt, wenn die Collection auf das Form gezogen wird. Load Size (Collections) Hier wird festgelegt, für wie viele Datensätze beim ersten Load Komponenten instanziiert werden sollen. Für alle weiteren Datensätze wird nur der Primärschlüssel verwaltet. Der automatische Nachlademechanismus sorgt dafür, dass die Komponenten nachgelesen und instanziiert werden, sobald der erste Zugriff darauf erfolgt. Ein Wert kleiner gleich Null sorgt dafür, dass sofort alle Komponenten instanziiert werden. Der Wert kann auch dynamisch über das Property LoadSize verändert werden."
  },
  "doc/comp/static-cache.html": {
    "href": "doc/comp/static-cache.html",
    "title": "Statisches Caching",
    "keywords": "Statisches Caching Framework Studio stellt einen statischen Caching-Mechanismus bereit. Wird dieser für eine geeignete Component aktiviert, so können Daten statt von der Datenbank aus diesem Cache geladen werden. Dadurch sind erhebliche Performance-Vorteile möglich, da die Anzahl der Datenbankzugriffe reduziert wird. Anwendungsgebiete In Geschäftsanwendungen gibt es viele kleine Datenbanktabellen mit wenigen Spalten und verhältnismäßig wenigen Datensätzen. Häufig enthalten diese Tabellen Daten, welche im täglichen Betrieb kaum Veränderungen unterliegen. Beispiele sind Tabellen zu Währungen , Sprachen , Versandarten , Lagerorten , Steuerschlüsseln , um nur einige zu nennen. Für diese überschaubar kleinen Datenmengen mit sich eher selten ändernden Daten ist das statische Caching geeignet. Konzept Der Entwickler kann definieren, dass für eine Component ein statischer Cache bereit gestellt werden soll. Der statische Cache läd bei Bedarf die benötigten \"Rohdaten\" (soweit möglich sessionübergreifend, also benutzerunabhängig) pro .NET-Prozess (\"w3wp.exe\") in den Arbeitsspeicher. Wird eine Anfrage an den Cache gestellt und die Daten im Cache sind älter als 5 Minuten , so werden die Daten neu von der Datenbank in den Cache gelesen. Bei der Anfrage an den Cache werden die Rohdaten benutzerabhängig gefiltert und anschließend Objekte daraus erzeugt. Werden Components gespeichert, so liefert der Cache für den speichernden Benutzer die geänderten Daten, für alle anderen Benutzer weiterhin die ungeänderten Daten. Wird nach dem Speichern ein Commit ausgeführt, wird der Cache automatisch invalidiert, sodass der nächste lesende Zugriff auf den Cache (egal durch welchen Benutzer in diesem .NET-Prozess) dafür sorgt, dass die Daten neu von der Datenbank eingelesen werden. Note Der Cache ist streng typisiert. Where-Bedingungen müssen als Function formuliert werden. Die Angabe eines Where-Strings ist nicht möglich. Der Cache berücksichtigt die über die Virtual Columns an der Component definierte Sortierung. Besonders Effizient können Daten über den (an der DBTable definierten) logischen Primärschlüssel (PK) abgefragt werden. Important Zu beachten ist, dass der lesende Zugriff auf den statischen Cache (analog zum \"normalen\" Laden von der Datenbank), für ein Global nicht thread-save ist. Nutzung Aktivieren des Caches Ist eine Component für das statische Caching geeignet, weil sie z.B. wenige hundert Datensätze verwaltet die Datensätze kaum 20 Eigenschaften enthalten, die alle nicht große Datenmengen (wie z.B. Byte-Arrays für Bilder) enthalten die Anzahl der Änderungen pro Tag an zumindest einem Datensatz an den Fingern abzuzählen sind es (bis auf einzelne, spezielle Ausnahmen) völlig ausreichend ist, dass die Daten bis zu 5 Minuten alt sein können dann kann der Entwickler durch setzen der Checkbox Provide Static Cache auf der Registerkarte General im Designerfenster der Component dafür sorgen, dass für diese Component ein statischer Cache generiert wird. Die Checkbox ist generell in jedem bearbeitbaren Package aktivierbar, soweit sich die Package-Version nicht im Service-Release Modus befindet. Wurde die Checkbox in einem Basis-Package gesetzt, kann diese Einstellung in Custom-Packages nicht mehr rückgängig gemacht werden. Nicht gesetzt werden kann die Checkbox, wenn die Component keinen Datenbankbezug hat. Zugriff auf den Cache Wurde für eine Component der statische Cache aktiviert , generiert Framework Studio für die Component eine statische Klasse aus dem Namen der Component gefolgt vom Suffix \"Cache\" in die Interface-Dll. Beispiel: Für die Component cdCurrency wird eine Klasse cdCurrencyCache generiert. Diese Klasse enthält eine statische Methode Get(IGlobalObjects global) , welche eine generische Singleton-Instanz zum Zugriff auf den statischen Cache mit dem übergebenen Global zurück gibt. Diese Instanz implementiert das Interface IStaticCache<TObj, TPK> , wobei TObj der Interface-Typ der Component ist (z.B. IcdCurrency ) und PK der Typ des/der Primärschlüssel-Properties ist (z.B. FSshort für shtCurrencyID). Das Ermitteln eines Objektes anhand des Primärschlüssels ist dann beispielsweise über den Indexer möglich: IcdCurrency oCurrency = cdCurrencyCache.Get(this.Global)[shtCurrencyIDP]; Sollte der Primärschlüssel aus mehreren Properties bestehen, so ist ein ValueTuple mit allen Properties des Primärschlüssels in alphabetischer Reihenfolge anzugeben. Beispiel (Primärschlüssel sType und sCode ): var oDemo = cdDemoCache.Get(this.Global)[(sMyCode, sMyType)]; Der Cache implementiert IEnumerable<TObj> . Der folgende Code IcdCurrencyColl oCurrencyColl = cdCurrencyCollFactory.Create(this.Global); oCurrencyColl.Load(\"COALESCE([shtBlocked], 0) = 0\", \"shtCurrencyCode\"); foreach (IcdCurrency oCurrency in oCurrencyColl) { // ... do something } lässt sich daher wie folgt auf die Verwendung des Caches umstellen. foreach (var oCurrency in cdCurrencyCache.Get(this.Global) .Where(c => c.shtBlocked.Value == 0) .OrderBy(c => c.shtCurrencyCode)) { // ... do something } Der Cache bietet darüberhinaus viele weitere Methoden, um Collections oder Objekte zu befüllen. Note Die detaillierte Beschreibung aller Funktionen ist bei der Beschreibung des Interfaces IStaticCache<TObj, TPK> einzusehen. Sollte es einmal nötig sein, auf Ebene von IDevFrameworkDataObject auf einen Cache zuzugreifen, so bietet die statische Klasse StaticCache ebenfalls eine statische Methode Get(IGlobalObjects global) an, mit der (soweit existent) ein untypisierter Cache ( IStaticCache ) ermittelt werden kann. Relation-Properties An Components können Properties vom Typ Relation angelegt werden. Typischerweise werden als DependsOn Properties die Primärschlüsseleigenschaften angegeben. Relation-Properties verwenden automatisch den Cache, wenn für den Property-Typ der statische Cache aktiviert ist und die DependsOn-Bedingung dem am DBTable definierten logischen Primärschlüssel entspricht. Globale Einsprungpunkte Grundidee des statischen Caches ist, alle Daten sessionübergreifend, also benutzerunabhängig, pro .NET-Prozess (\"w3wp.exe\") in den Arbeitsspeicher zu laden. Dadurch kann der Cache nicht den globalen Einsprungpunkt public virtual void GlobalOnBeforeLoad(DevFrameworkObject obj, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) durchlaufen, da hier pro Session anhand eines beliebigen Where-Strings unterschiedlich gefiltert werden kann. Eine einfache Filterung ist für den Cache jedoch in dem Moment möglich, in dem Objekte (zu einem konkreten Global) aus dem Cache angefragt werden. Dazu wurde der globale Einsprungpunkt protected internal virtual bool GlobalWhereStaticCache(IStaticCacheObject oStaticCacheObject) geschaffen, welcher eine Filterung der Ergebnismenge durch den Cache ermöglicht. Der zuletzt genannte Einsprungpunkt ist jedoch nicht in der Lage, beliebiges SQL im Nachhinein auszuwerten. Sollte jedoch eine Filterung nötig sein, die direkt beim Laden komplexes SQL ermöglicht, kann der statische Cache die Daten nicht sessionübergreifend einlesen. Ebenso ist es in diesem Einsprungpunkt nicht möglich, Einschränkungen auf Werte vorzunehmen, welche zwar als Tabellenspalte existieren, jedoch nicht als Property an der Component angelegt sind. Deshalb wurde ein weiterer globaler Einsprungpunkt protected internal virtual StaticCacheMode GlobalGetStaticCacheMode(IDevFrameworkDataObject oDevFrameworkDataObject) geschaffen, welcher pro Component einmalig durchlaufen wird um festzulegen, in welchem Modus der Cache arbeiten soll. Die beiden Modi Broker (default) und Session sowie ihre Konsequenzen sind im Detail am StaticCacheMode beschrieben. Im Modus Session läd der statische Cache die \"Rohdaten\" nicht global sondern pro Session. Dadurch erhöht sich der Arbeitspeicherverbrauch. Gleichzeitig kann so der erstgenannte Einsprungpunkt public virtual void GlobalOnBeforeLoad(DevFrameworkObject obj, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) wie gewohnt durchlaufen werden. Besonderheiten Distinct und GroupBy Important Ist eine Component als Distinct oder GroupBy definiert, darf der statische Cache zu dieser Component nicht im Modus Broker betrieben werden. Wenn eine Component nicht als Distinct oder GroupBy definiert ist, in einem speziellen Fall jedoch Distinct oder GroupBy gewünscht ist, kann an den Methoden des statischen Caches, die die Angabe eines orderBy ermöglichen, als orderBy die entsprechende Funktion angegeben werden. Beispiel Distinct: public virtual int LoadDistinctByName() { return cdArticleCache.Get(this.Global).FillCollection(This, l => l.DistinctBy(o => o.sName)); } Beispiel GroupBy: public virtual int LoadGroupByName() { // Gruppiert werden soll nach sName Func<IcdArticle, FSstring> fnKeySelector = oArticle => oArticle.sName; // Ergebnisobjekt vom Typ IcdArticle zu jedem Schlüsselwert und den dazugehörigen Artikeln erzeugen Func<FSstring, IEnumerable<IcdArticle>, IcdArticle> fnResultSelector = (sName, oArticles) => { IcdArticle oResult = cdArticleFactory.Create(this.Global); var oFirstArticle = oArticles.First(); oResult.sID = oFirstArticle.sID; oResult.sName = oFirstArticle.sName; oResult.sColor = oFirstArticle.sColor; // Hinweis: Auch wenn mehrere Aggregatfunktionen (Sum, Count, Max, ...) aufgerufen werden, sollte nur einmal über alle Elemente iteriert werden oResult.decPrice = oArticles.Select(oArticle => oArticle.decPrice.Value).Sum(); // Status des Ergebnisobjekts soll unchanged sein oResult.State = FrameworkComponentState.Unchanged; return oResult; }; // GroupBy-Funktionalität als spezielles orderBy übergeben return cdArticleCache.Get(this.Global).FillCollection(This, l => l.GroupBy(fnKeySelector, fnResultSelector)); }"
  },
  "doc/comp/tab_method.html": {
    "href": "doc/comp/tab_method.html",
    "title": "Registerkarte Methods",
    "keywords": "Registerkarte Methods Bei den Methoden handelt es sich um Methoden im Sinne von .NET. Innerhalb der Methoden können Sie frei nach den Regeln von C# Code schreiben und mit den Properties der Component arbeiten. Die Methoden werden im Class-Registerkarte aufgelistet und sind an dem -Icon zu erkennen. Neue Methoden anlegen / löschen Mit dem Button ( New ) und dem Eintrag Public Method , Protected Method oder Method(override) aus dem sich öffnenden Kontextmenü können Sie eine neue Methode erzeugen. Mit Public Method und Protected Method wird eine leere Methode angelegt. Mit Method(override) haben Sie die Möglichkeit, eine in einer Basis-Klasse definierte virtuelle Methode zu überschreiben. Es erscheint ein Auswahl-Dialog, der die verfügbaren Methoden anbietet. Wenn Sie einen Eintrag auswählen und mit OK bestätigen, wird eine neue Methode angelegt, deren Deklaration entsprechend vorbelegt ist. In der Class-Registerkarte hat das Kontext-Menü der Methoden einen Eintrag Delete . Mit diesem Eintrag können Sie die Methode löschen. Methoden bearbeiten Um eine Methode zu öffnen, gibt es zwei Möglichkeiten: Auf der Registerkarte Class einen Doppelklick auf die gewünschte Methode. Auf der Registerkarte Method die gewünschte Methode in der Tabelle auswählen. Auf der Registerkarte Method wird in dem großen Edit-Feld der Quellcode der Methode angezeigt, den Sie dort auch bearbeiten können. Methoden in jeder Component / Collection Im folgenden Abschnitt werden die Methoden beschrieben, die jede Component / Collection bereits als Voraussetzung mitbringt, da sie in der Component-Basisklasse DevFrameworkObjekt bzw. DevFrameworkObjektColl implementiert sind. AcceptChanges( ) Verfügbar für Component / Collection. public void AcceptChanges( ) Übernimmt alle Änderungen, indem es die OrgValues auf die PropertyValues und den Status auf Unchanged setzt. Es wird keine Datenbanktransaktion ausgeführt. Bei Collections führt diese Methode dazu, dass Objekte, deren Status Deleted ist, aus der Collection unwiderruflich entfernt werden. AdoptValues() Verfügbar für Component / Collection Übernimmt alle Properties der übergebenen Component / Collection in die eigenen Properties. Von Unterobjekten wird eine Tiefen-Kopie (Clone) erzeugt. void AdoptValues(IDevFrameworkBaseObject fromComponent) void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptMode mode) void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptDictionary dict) void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptDictionary dict, AdoptMode mode) Im Parameter fromComponent wird die Component übergeben, deren Properties übernommen werden sollen. Über die Parameter dict und mode kann optional das Verhalten der Methode gesteuert werden. Siehe auch Kapitel Clone() und AdoptValues() Clear() Verfügbar für Collection. public void Clear() Reinitialisiert die Collection als leere Collection. Clone() Verfügbar für Component / Collection Erzeugt eine Tiefen-Kopie der Component oder Collection und gibt diese zurück. public IDevFrameworkBaseObject Clone() public IDevFrameworkBaseObject Clone(AdoptMode mode) public IDevFrameworkBaseObject Clone(AdoptDictionary dict) public IDevFrameworkBaseObject Clone(AdoptDictionary dict, AdoptMode mode) Über die Parameter dict und mode kann optional das Verhalten der Methode gesteuert werden. Siehe auch Kapitel Clone() und AdoptValues() . Delete( ) Verfügbar für Component / Collection. Diese Methode setzt den Komponentenstatus auf Deleted. Die Komponente wird dabei aus der Collection entfernt. Damit auf dem Datasource ein physikalischer Delete ausgeführt wird, muss noch ein Save aufgerufen werden. Diese Methode ist funktional identisch mit der Methode Remove() . public void Component.Delete() Setzt den Komponentenstatus auf Deleted. public void Collection.Delete() Setzt den Komponentenstatus aller Components der Collection auf Deleted. public void Collection.Delete(DevFrameworkObject obj) Setzt den Komponentenstatus der übergebenen Component auf Deleted. public void Collection.Delete(SelectedRowsCollection selectedRows) Setzt den Komponentenstatus aller Komponenten, deren IDs in der SelectedRowsCollection enthalten sind, auf Deleted. Load( ) Verfügbar für Component / Collection. public int Load() Lädt alle Datensätze aus der verknüpften Query. public int Load(string loadCondition) Lädt Datensätze entsprechend der Bedingung aus der Datenbank und liefert die Anzahl der gefundenen Datensätze zurück. public int Load(string loadCondition, string OrderByClause) public int Load(string loadCondition, string HavingClause, string OrderByClause) Für das Anpassen der Load-Kriterien werden verschiedene Methoden zum Überschreiben angeboten: OnBeforeLoad( ) auf der Ebene der Component bzw. Collection. GlobalOnBeforeLoad( ) auf globaler Ebene. LoadCount( ) Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) Verfügbar für Component / Collection. public void Save( ) Save speichert die Änderungen in die Daten-Datenbank. Component.Save( ) Der Befehl läuft in folgenden Schritten ab: CreateTransaction( ) OnBeforeSaveCustom( ) (Entrypoint) OnBeforeSave() (Entrypoint) GlobalOnBeforeSaveAction( ) (Entrypoint) DeleteMarkedObjects() Aktion auf der Datenbank. AcceptChanges( ) OnAfterSave() (Entrypoint) OnAfterSaveCustom( ) (Entrypoint) Commit( ) Läuft etwas in einem der Entrypoints schief und es wird eine Exception geworfen, wird die gesamte Transaktion abgebrochen und Rollback( ) ausgeführt. Es folgt eine Aufstellung, wie sich der Befehl bei den einzelnen Status verhält. FrameworkComponentState.Unchanged Es wird keine Aktion auf der Datenbank ausgeführt. Die Entrypoints werden nur angestoßen, wenn EntryPoints.CallAllways übergeben wurde. FrameworkComponentState.New Es wird ein Insert in die Daten-Datenbank gemacht. Es werden alle Daten in die OrgValue-Properties übertragen. FrameworkComponentState.Changed Es wird ein Update auf die Daten-Datenbank gemacht. Es werden alle Daten in die OrgValue-Properties übertragen. FrameworkComponentState.Deleted Es wird ein Delete auf die Daten-Datenbank gemacht. Ist die Component ein Eintrag in der Collection, wird sie aus dieser entfernt. Collection.Save( ) Der Befehl läuft in folgenden Schritten ab: CreateTransaction( ) OnBeforeSaveCustom( ) (Entrypoint) OnBeforeSave( ) (Entrypoint) Save( ) auf jedes Objekt in der Collection OnAfterSave( ) (Entrypoint) OnAfterSaveCustom( ) (Entrypoint) Commit( ) Läuft etwas in einem der Entrypoints schief und es wird eine Exception geworfen, wird die gesamte Transaktion abgebrochen und Rollback( ) ausgeführt. Warning Ist der Status einer Component Unchanged, werden die Entry-Points der Save-Methode (OnBeforeSave, OnAfterSave, …) nicht aufgerufen, da der Save-Vorgang abgebrochen wird, und keine Transaktion stattfindet. public void Save(SaveEntryPoints) Diese Überladung der Methode ist dazu da, wenn die Entrypoints abgearbeitet werden sollen, obwohl der Save der Component auf Unchanged steht. // Die Entrypoints werden immer ausgeführt oCompoinet.Save( SaveEntryPoints.CallAllways ) // Die Entrypoints werden nur ausgeführt, wenn der Status nicht Unchanged ist. oCompoinet.Save( SaveEntryPoints. CallOnlyIfChanged ) RollbackChanges( ) Verfügbar für Component / Collection. public void RollbackChanges( ) Setzt alle PropertiesValues auf die OrgValues. CreateTransaction( ) Verfügbar für Component / Collection. public FrameworkDataTransaction CreateTransaction( ) Startet eine Transaktion. Weisen Sie der Komponente einen Datasource zu, damit eine Transaktion gestartet werden kann, da die Transaktion selbst an einen Datasource gebunden ist. Gibt das Transaktionsobjekt zurück, sofern es erzeugt werden konnte. An diesem Transaktionsobjekt kann der Commit bzw. Rollback erfolgen. An geeigneter Stelle muss es mittels Dispose-Aufruf bzw. dem Ende eines using-Blocks abgeräumt werden. Wenn die Transaktion aufgrund eines Fehlers nicht gestartet werden kann, wird eine Exception geworfen. HasDbChanged( ) Verfügbar an DataComponent. public bool HasDbChanged() Damit kann einer RowVersionInvalidException zuvorgekommen werden. Mit der Methode ReloadData() können die Daten des Datensatzes neu eingelesen werden. Gibt zurück, ob sich der Datensatz auf der Datenbank geändert hat. Diese Methode arbeitet sowohl mit der RowID-RowVersion-Logik als auch mit einer PK-RowVersion-Logik. Wenn an einer Component die Save-Methode aufgerufen wird, prüft diese, ob der Datensatz in der Datenbank geändert wurde, um ein konkurrierendes Update zu verhindern. Wenn das zutrifft, dann wird eine RowVersionInvalidException geworfen und die Save-Aktion abgebrochen. Mit dieser Methode kann das im Vorfeld geprüft und ggf. ReloadData() ausgeführt werden. ReloadData( ) Verfügbar an DataComponent. public int ReloadData() Diese Methode aktualisiert die Daten aus der Datenbank. Sie führt einen Load auf die Component aus und verwendet dabei die aktuellen Primary-Key-Informationen für die Suchbedingung. Wenn die Component nicht mit der RowID-RowVersion-Logik arbeitet, dann wird der logische Primary-Key verwendet. Das ist z.B. sinnvoll, wenn mit der Methode HasDbChanged eine Änderung auf der Datenbank festgestellt wurde. Zurückgegeben wird das Ergebnis der Load-Methode: 1 – erfolgreich eingelesen; 0 – es wurde nichts gelesen, weil der Datensatz z.B. nicht mehr existiert. OnBeforeLoad( ) Verfügbar für Component / Collection mit einer Query. Diese Methode kann überschrieben werden. Sie bietet auf Component-Ebene einen zentralen Einstiegspunkt, um vor einem Datenbank-Load die Load-Condition, die Having-Clause oder die Order-By-Clause zu erweitern oder anzupassen. Data-Component: protected virtual bool OnBeforeLoad(ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause, bool fromCollection) Sie wird aufgerufen, bevor an der Component / Collection ein Load() oder an der Component ein GetFetchNext() ausgeführt wird. Der Aufruf erfolgt vor GlobalOnBeforeLoad( ) . Beim Aufruf aus der Collection wird im Parameter fromCollection true übergeben. So kann bei Bedarf entsprechend reagiert werden. Es ist jedoch empfehlenswert, die Load-Condition nur einmal zentral in der Component zu erweitern. Der Aufruf folgt nach dem Aufruf der OnBeforeLoad-Method in der Collection. Data-Collection: protected virtual bool OnBeforeLoad(ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) Sie wird aufgerufen, bevor an der Collection ein Load( ) ausgeführt wird. Der Aufruf erfolgt vor GlobalOnBeforeLoad( ) . Nach dieser Methode ruft die Collection auch an der Component die Methode OnBeforeLoad() auf. Dazu wird temporär ein neues leeres Objekt erzeugt. OnBeforeSave( ) Verfügbar für Component / Collection. protected virtual bool OnBeforeSave() Diese Methode kann in der Component / Collection überschrieben werden. Siehe auch LoadCount() Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnBeforeSaveCustom( ) Verfügbar für Component / Collection. protected virtual bool OnBeforeSaveCustom() Diese Methode kann in der Component / Collection überschrieben werden. Siehe auch LoadCount() Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnBeforeSaveAction( ) Verfügbar für Component. protected virtual void OnBeforeSaveAction() Diese Methode kann in der Component überschrieben werden. Standardmäßig ruft diese Methode this.Global.ocGlobal.GlobalOnBeforeSaveAction() auf. Siehe auch LoadCount() Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnAfterSave( ) Verfügbar für Component / Collection. protected virtual void OnAfterSave() Diese Methode kann in der Component / Collection überschrieben werden. Wird nach dem Speichern aufgerufen. Siehe auch LoadCount() Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnAfterSaveCustom( ) Verfügbar für Component / Collection. protected virtual void OnAfterSaveCustom() Diese Methode kann in der Component / Collection überschrieben werden. LoadCount( ) Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save( ) OnAfterInit( ) Verfügbar für Component / Collection protected virtual void OnAfterInit( ) Diese Methode kann in der Component / Collection überschrieben werden. Sie wird aufgerufen, direkt nachdem die Component / Collection instanziiert wurde. Hier können Werte vorbelegt werden, die man ansonsten in einem Konstruktor setzen würde. Warning Innerhalb dieser Methode darf kein Load, Save oder sonst eine Datenbank-Aktion ausgeführt werden. Hintergrund: Es kann sein, dass die Methode aufgerufen wird, wenn eine Component im Rahmen eines Collection-Loads instanziiert wird. In diesem Fall ist bereits ein Datareader auf der Datenbank geöffnet. Eine Datenbank-Aktion würde zu einer Exception führen. OnAfterLoad( ) Verfügbar für Component protected virtual void OnAfterLoad( ) Diese Methode kann in der Component überschrieben werden. Sie wird aufgerufen, nachdem der Inhalt der Component aus der Datenbank gelesen wurde. GetTableName( ) Verfügbar für Component public virtual string GetTableName(string propName) Gibt den Tabellennamen eines bestimmten Properties zurück. Falls es das Property nicht gibt bzw. das Property nicht mit einer Datenbankspalte verknüpft ist, wird String.Empty zurückgegeben. GetDefaultLabel( ) Verfügbar für Component. public string GetDefaultLabel(string propName) Gibt das Default-Label eines bestimmten Properties zurück. Falls es das Property nicht gibt, wird String.Empty zurückgegeben. Das Label wird in der aktuellen Sprache zurückgegeben. GetPropertyMdt( ) Verfügbar an Component / Collection public MLContainer GetPropertyMdt(string propertyName) Ermittelt den Metadatentyp des Properties propertyName. Sie ermöglicht dynamisch den Zugriff auf die mdt_-Properties der Factory-Klasse. Siehe auch Abschnitt Metadaten von Properties. Die öffentlichen Properties können mit dem Property  ComponentProperties ermittelt werden. GetProperty( ) Verfügbar für Component. public virtual object GetProperty(string propertyName) Ermittelt den Wert des öffentlichen Properties propertyName. Die öffentlichen Properties können mit dem Property  ComponentProperties ermittelt werden. SaveCallEntryPointsAllways( ) public void SaveCallEntryPointsAllways( ) Aufruf der LoadCount( ) Verfügbar an Component / Collection public int LoadCount(string loadCondition) Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert. Save() Methode, wobei die Entry-Points auch durchlaufen werden, wenn der Status der Komponente Unchanged ist. MarkForDeletion( ) Verfügbar an Component public void MarkForDeletion( ) Mit dieser Methode wird dem Property StateBeforeUpdate Verfügbar für Component. public FrameworkComponentState StateBeforeUpdate {get, set} Dieses Property übernimmt den Wert des Properies State direkt bevor im Save der Datenbank-Befehl ausgeführt wird. Dieser Wert bleibt bis zum nächsten Save() erhalten. Somit steht in den Methoden OnAfterSave() und OnAfterSaveCustom() bzw. nach einem Save-Vorgang der Status der Component weiterhin zur Verfügung. Das Property State hingegen nimmt nach der Datenbank-Aktion den Wert Unchanged an. In den Methoden OnBeforeSave() und OnBeforeSaveCustom() hat dieses Property keinen klar definierten Wert. IsMarkedForDeletion der Wert true zugewiesen. An der dazugehörigen Collection können anschließend mit der Methode die markierten Objekte aus der Collection gelöscht werden. DeleteMarkedObjects( ) Verfügbar in Collection public void DeleteMarkedObjects( ) Mit dieser Methode wird an allen Objekten der Collection, in denen das Property StateBeforeUpdate Verfügbar für Component. public FrameworkComponentState StateBeforeUpdate {get, set} Dieses Property übernimmt den Wert des Properies State direkt bevor im Save der Datenbank-Befehl ausgeführt wird. Dieser Wert bleibt bis zum nächsten Save() erhalten. Somit steht in den Methoden OnAfterSave() und OnAfterSaveCustom() bzw. nach einem Save-Vorgang der Status der Component weiterhin zur Verfügung. Das Property State hingegen nimmt nach der Datenbank-Aktion den Wert Unchanged an. In den Methoden OnBeforeSave() und OnBeforeSaveCustom() hat dieses Property keinen klar definierten Wert. IsMarkedForDeletion den Wert true hat, die Methode Delete() ausgeführt. Remove( ) Verfügbar in Collection Diese Methode entfernt Objekte aus der Collection. Der Status des entfernten Objektes wird dabei auf Deleted gesetzt. D.h., ein Save() hätte ggf. einen physischen Delete auf der Datenbank zur Folge. Diese Methode ist funktional identisch mit der Methode Delete( ). public void Remove( Object ) Entfernt das übergebene Objekt aus der Collection. public void Remove( SelectedRowsCollection ) Entfernt alle in der übergebenen SelectedRowsCollection angegebenen Objekte aus der Collection. Drop( ) Verfügbar in Collection Diese Methode trennt Objekte aus der Collection heraus. Dabei bleibt der Status der Objekte erhalten. public void Drop( guid ) Entfernt das mit der übergebenen Guid definierte Objekt aus der Collection. public void Drop( DevFrameworkObject ) Entfernt das übergebene Objekt aus der Collection. public void Drop( SelectedRowsCollection ) Entfernt alle Komponenten aus der Collection, deren IDs in der übergebenen SelectedRowsCollection enthalten sind. Dispose( ) Verfügbar in Collection Die Collection wird geleert und alle verwendeten Ressourcen freigegeben. Nach dieser Operation kann die Collection nicht mehr verwendet werden. Add( ) Verfügbar in Collection Diese Methode fügt ein Objekt in die Collection ein. Es wird die Index-Position des Objektes zurückgegeben. public int Add( object ) Am eingefügten Objekt wird die Collection-Eigenschaft auf die neue Collection geändert. public int Add( object, bool setCollection ) Wenn der Parameter setCollection mit false angegeben wird, dann wird die Collection-Eigenschaft des Objektes nicht verändert. AddRange() Verfügbar in Collection Diese Methode fügt mehrere Objekte in die Collection ein. Sie können dieser Methode ganze Collections übergeben. So ist es beispielsweise möglich, zwei Collections zusammenzuführen. Die Methode hat als Parameter den Typ IEnumerable<DevFrameworkObject> . So können auch generische Listen übergeben werden, die z.B. mit einer Linq-Query ermittelt wurden. public void AddRange(IEnumerable<DevFrameworkObject> value) An allen hinzugefügten Elementen wird die die Collection-Eigenschaft auf die neue Collection geändert. public void AddRange(IEnumerable<DevFrameworkObject> value, Boolean setCollection) Wenn der Parameter setCollection mit false angegeben wird, dann wird die Collection-Eigenschaft der hinzugefügten Objekte nicht verändert. Insert( ) Verfügbar an Collection Fügt ein Objekt an eine bestimmte Position in die Collection ein. public int Insert( int index, object ) Mit Index 0 wird das Objekt am Anfang der Collection eingefügt. Mit Index größer oder gleich Collection.Count wird das Objekt am Ende der Collection eingefügt. Am eingefügten Objekt wird die Collection-Eigenschaft auf die neue Collection geändert. public int Insert( int index, object, bool setCollection ) Wenn der Parameter setCollection mit false angegeben wird, dann wird die Collection-Eigenschaft des Objektes nicht verändert. MoveItem() Verfügbar an Collection int Collection.MoveItem(DevFrameworkObject itemToMove, int indexDelta) Verschiebt den übergebenen Eintrag und gibt den neuen Index des verschobenen Eintrags zurück. Der Parameter indexDelta gibt an, wie weit der Eintrag verschoben werden soll. Bei negativen Werten wird nach oben und bei positiven Werten nach unten verschoben. Wird ein Wert angegeben, der die Grenzen der Collection sprengt, dann wird der Eintrag maximal an die Grenze der Collection (Anfang oder Ende) verschoben. Wird ein Eintrag übergeben, der nicht Bestandteil der Collection ist, dann wird eine Exception geworfen. Beispiel: // verschiebt den ausgewählten Artikel einen Eintrag nach oben this.oArticleColl.MoveItem(this.oArticleSelected, -1); // verschiebt den ausgewählten Artikel 2 Einträge nach unten this.oArticleColl.MoveItem(this.oArticleSelected, 2); MoveItemTo() Verfügbar an Collection void Collection.MoveItemTo(DevFrameworkObject itemToMove, int targetIndex) Verschiebt den übergebenen Eintrag an eine bestimmte Stelle. Der Parameter targetIndex gibt den Index an, an den der Eintrag verschoben werden soll. Wird ein Eintrag übergeben, der nicht Bestandteil der Collection ist, dann wird eine Exception geworfen. Beispiel: // verschiebt den ausgewählten Artikel an den Anfang der Collection this.oArticleColl.MoveItemTo(this.oArticleSelected, 0); CreateNewRecord( ) Verfügbar an Collection DevFrameworkObject Collection.CreateNewRecord() Erzeugt passend zur Collection einen neuen Record. Der Rückgabetyp ist DevFrameworkObject bzw. IDevFrameworkObject. Es muss ggf. ein entsprechender cast eingebaut werden. Beispiel: IcdCustomer oCustomerNew = this.oCustomerColl.CreateNewRecord() as IcdCustomer; NewRecord( ) Verfügbar an Collection DevFrameworkObject Collection.NewRecord() Erzeugt passend zur Collection einen neuen Record und fügt ihn am Ende der Collection ein. Der Rückgabetyp ist DevFrameworkObject bzw. IDevFramerworkObject. Es muss ggf. ein entsprechender cast eingebaut werden. Beispiel: IcdCustomer oCustomerNew = this.oCustomerColl.NewRecord() as IcdCustomer; UpdateRelationKey( ) Verfügbar innerhalb von Component und Collection protected bool UpdateRelationKey(string propertyName, string key) Diese Funktion speichert an der Instanz der Component bzw. der Collection pro übergebenem Property-Namen einen Schlüssel. Dabei wird geprüft, ob sich der Schlüssel gegenüber dem letzten Aufruf dieser Funktion geändert hat. Bei einer Änderung wird true zurückgegeben. Wenn sich der Schlüssel nicht geändert hat, wird false zurückgegeben. Diese Funktion kann z.B. dazu verwendet werden, um in Individual Properties bei der Änderung eines Schlüssel-Wertes einen Reload zu veranlassen. Die Funktion ist protected und kann somit nur innerhalb der Component bzw. der Collection verwendet werden. Beispiel: // Get-Methode des Individual Properties \"oCustomerIndiv\" if (this.oCustomerMember == null) { this.oCustomerMember = cdCustomerFactory.Create(this.Global); } String sWhere = \"[lngCustomerID] = \" + DB.SqlString(this.lngCustomerID); if (this.UpdateRelationKey(\"oCustomerIndiv\", sWhere) { // Die Suchbedingung – also der Key – hat sich geändert. ==> Reload this. oCustomerMember.Load(sWhere); } return this.oCustomerMember; SetCommandTimeout( ) Verfügbar an Data-Collection public void SetCommandTimeout(int seconds) Damit kann vor einem Load der Timeout des SQL-Commands gesetzt werden. In Framework Studio haben alle Commands per Default einen Timeout von 300 Sekunden. Wenn ein Statement längere Zeit benötigt, dann führt das zu einer Exception. Das kann in seltenen Fällen bei komplexen Statements auf großen Datenbeständen der Fall sein. Mit dem Wert 0 wird der Timeout komplett deaktiviert. Das bedeutet, dass das Statement im schlimmsten Fall endlos laufen kann. Beispiel: // Timeout deaktivieren this.oCollection.SetCommandTimeout(0); // Daten lesen. this.oCollection.Load(\"<very complex condition>\"); Properties in jeder Component / Collection ComponentProperties Verfügbar für Component. public virtual System.Collections.Specialized.StringCollection ComponentProperties {get} Gibt eine Liste mit den Namen aller Properties zurück. Es werden nur Properties ausgegeben, die public sind. Diese Namen kann man mit verschiedenen Methoden verwenden. Z.B: GetProperty( ) GetDefaultLabel( ) State Verfügbar für Component. public FrameworkComponentState State {get, set} Status der Komponente. Dieser kann z.B. im OnBeforeSave() ausgewertet werden. Mit dem Ausführen der Datenbank-Aktion erhält das Property den Wert Unchanged bzw. UnchangedButDeleted . Im OnAfterSave() bzw. nach dem Save() kann der ursprüngliche Wert über das Property StateBeforeUpdate erfragt werden. Das Enum FrameworkComponentState hat folgende Werte: New: Die Komponente wurde instanziiert und es wurden keine Daten mit Load() eingelesen. Werden Properties in dieser Komponente geändert, bleibt der Status weiterhin New . Ein Save() führt einen Insert-Befehl auf der Datenbank aus. Unchanged: Die Komponente wurde mit Load() eingelesen und die Daten wurden danach nicht verändert. Ein Save() führt keine Aktion auf der Datenbank aus. Changed: Die Komponente wurde mit Load() eingelesen und der Wert mindestens eines Properties wurde geändert. Ein Save() führt einen Update-Befehl auf der Datenbank aus. Soll ein Insert-Befehl erzwungen werden, muss der Status manuell auf New gesetzt werden. Deleted: Die Komponente wurde mit Load() eingelesen und es wurde die Methode Delete() aufgerufen. Ein Save() führt einen Delete-Befehl auf der Datenbank aus. NewButDeleted: Die Komponente wurde mit einem new() erstellt und es wurde die Methode Delete() aufgerufen. Ein Save() führt keine Aktion auf der Datenbank aus. UnchangedButDeleted: Nachdem die Methode Delete() aufgerufen und mit Save() der Delete-Befehl auf der Datenbank ausgeführt wurde, erhält die Komponente diesen Status. Ein weiterer Save() führt keine Aktion auf der Datenbank aus. Wird der Wert eines Properties geändert, behält die Component diesen Status – er wird nicht auf Changed gesetzt. StateBeforeUpdate Verfügbar für Component. public FrameworkComponentState StateBeforeUpdate {get, set} Dieses Property übernimmt den Wert des Properies  State direkt bevor im Save der Datenbank-Befehl ausgeführt wird. Dieser Wert bleibt bis zum nächsten Save() erhalten. Somit steht in den Methoden OnAfterSave() und OnAfterSaveCustom() bzw. nach einem Save-Vorgang der Status der Component weiterhin zur Verfügung. Das Property State hingegen nimmt nach der Datenbank-Aktion den Wert Unchanged an. In den Methoden OnBeforeSave() und OnBeforeSaveCustom() hat dieses Property keinen klar definierten Wert. IsMarkedForDeletion Verfügbar für Component. public bool IsMarkedForDeletion {get, set} Über dieses Property ist es möglich, ein mehrstufiges Löschen zu realisieren. Das ist notwendig, wenn z.B. die Datensätze in einem Grid zum Löschen markiert werden sollen, bevor sie gelöscht werden. Wenn Sie die Methode Delete( ) verwenden, werden die entsprechende Zeilen im Grid nicht mehr angezeigt. Dieses Property ist vor allem dann interessant, wenn die Component in einer Collection verarbeitet wird. Wenn an mindestens einem Element in einer Collection diese Eigenschaft true ist, dann liefert Collection. IsModified den Wert true. Ist IsMarkedForDeletion true, dann wird im Grid in der entsprechenden Zeile das im Grid-Property RowDeletedIcon hinterlegte Icon angezeigt. (siehe Grid Properties) Mit der Methode DeleteMarkedObjects an der entsprechenden Collection wird an jedem Objekt, an dem das Property den Wert true hat, ein Delete aufgerufen. IsModified Verfügbar für Component und Collection. Component: public bool IsModified {get} IsModified ist true , wenn State nicht den Wert Unchanged hat. Insbesondere gilt somit für neue Components (State=New) IsModified = true . Collection: public bool IsModified {get} IsModified ist true , wenn bei mindestens einem Element der Liste die Eigenschaft IsModified den Wert true hat oder mindestens ein Element gelöscht oder zum Löschen markiert ( IsMarkedForDeletion ) wurde. LoadSize Verfügbar für Collection mit Datenbank-Bezug Über dieses Property kann zur Laufzeit festgelegt werden, für wie viele Datensätze beim ersten Laden die Komponenten direkt instanziiert werden sollen. Für alle weiteren Datensätze wird zunächst nur der Primärschlüssel verwaltet. Durch den automatischen Nachlademechanismus werden die Komponenten dann beim ersten Zugriff automatisch nachgeladen und instanziiert. Wenn dieses Property auf einen Wert kleiner oder gleich Null gesetzt wird, werden direkt alle Komponenten instanziiert. Ein Nachladen ist dann nicht mehr nötig. Dies ist vor Allem dann sinnvoll, wenn anschließend ohnehin auf alle Components der Collection zugegriffen wird, beispielsweise durch eine foreach Schleife. LoadMaxCount Verfügbar für Collection mit Datenbank-Bezug. Dieses Property gibt an, wie viele Datensätze maximal eingelesen werden sollen. Es muss gesetzt werden, bevor der Load ausgeführt wird. Der Standardwert ist 0. Das bedeutet keine Begrenzung. // Beispiel: nur die ersten 30 Sätze lesen: this.oContactHistoryColl = new cdContactHistoryColl(this.Global); this.oContactHistoryColl.LoadMaxCount = 30; this.oContactHistoryColl.Load( this.sWhereClause ); Das bringt bei sehr großen Datenmengen einen Geschwindigkeits-Vorteil. Dieses Property hat keinen Einfluss auf das an die Datenbank geschickte Statement. Die Datenbank liefert bei dem ausgeführten Select alle Datensätze. Die Collection bricht bei Erreichen der Grenze die Verarbeitung ab. Dadurch müssen die überflüssigen Primary-Key-Informationen nicht eingelesen werden. Bei sehr vielen Treffern entlastet das auch den Hauptspeicher erheblich. Noch besser ist es, wenn es möglich ist, die Suchbedingung so zu formulieren, dass die Datenbank-Abfrage nicht zu viele Treffer liefert. Dadurch ist der Performance-Gewinn deutlich größer durch setzen dieses Properties. Besonders groß ist der Effekt, wenn die Datenbank-Abfrage eine Sortierung beinhaltet. Denn trotz dem Setzen dieses Properties muss die Datenbank alle Treffer sortieren. Metadaten von Properties Zur Laufzeit kann der Entwickler auf die Metadatentyp-Informationen der Properties zugreifen. Dafür stehen folgende Möglichkeiten zur Verfügung: Über die Factory-Klasse Mit der Methode GetPropertyMdt Die Factory-Klasse, welche mit den Interfaces kompiliert werden, bietet für jedes Component-Property eine Eigenschaft mdt_... an, welche eine Instanz mit den Metadatentyp-Informationen zurückgibt. Beispiel: An der Component cdArticle gibt es ein Property sArticleID. int intMaxSize = cdArticleFactory.mdt_sArticleID.Size; Mit der Methode GetPropertyMdt() kann mithilfe des Property-Namen die Metadatentyp-Information ermittelt werden. Das ermöglicht auch die Arbeit auf der Ebene DevFrameworkObject. Beispiel MLContainer mdt = oArticle.GetPropertyMdt(\"sArticleID\"); if (mdt is MDTStringBase) { int intSize = ((MDTStringBase)mdt).Size; } Folgende Basis-Klassen liegen den Metadatetypen zugrunde: Klasse-Hierarchie Verwendung (Properties) MLContainer Allgemeine Basis. Sie wird für Properties verwendet, die keinen Metadatentyp besitzen: DefaultLabel / MLColumnCaption / MLToolTip/ DragSource MetadatatypeBase Basis für alle Metadatentypen: FormatPattern / FormatMask MDTStringBase Basis für Strings (FSstring): Size/ Values MDTBoolBase Basis für Booleans (FSbool): Values MDTByteArrayBase Basis für Byte-Arrays (FSByteArray): Values MDTDateTimeBase Basis für DateTime (FSDateTime): Values MetadatatypeNumberBase Allgemeine Basis für Numerische Metadatentypen: Precision/ Scale MDTByteBase Basis für Byte (FSbyte): Values MDTDecimalBase Basis für Decimal (FSdecimal): Values MDTDoubleBase Basis für Double (FSdouble): Values MDTFloatBase Basis für Float (FSfloat): Values MDTIntBase Basis für Int (FSint): Values MDTLongBase Basis für Long (FSlong): Values MDTShortBase Basis für Short (FSshort): Values Beschreibungen der o.g. Properties DevMLString DefaultLabel: Das mehrsprachige Default-Label DevMLString MLColumnCaption: Die mehrsprachige Spalten-Beschriftung. Wenn diese nicht gepflegt ist, wird DefaultLabel zurückgegeben. DevMLString MLToolTip: Der mehrsprachige Tooltip. int Precision: Anzahl von Nachkommastellen; wird nur bei numerischen Typen angeboten. int Scale: Maximale Anzahl von Stellen inkl. Nachkommastellen. Wird nur bei numerischen Typen angeboten. int Size: Maximale Länge eines Strings. FrameworkFormatMask FormatMask: Gibt einen Wert mit dem Typ FrameworkFormatMask zurück. Dieses Enum kann folgende Werte beinhalten: FrameworkFormatMask.None FrameworkFormatMask.LowerCase FrameworkFormatMask.UpperCase FrameworkFormatMask.DateOnlyShort FrameworkFormatMask.DateOnlyMedium FrameworkFormatMask.DateOnlyLong FrameworkFormatMask.DateTimeShort FrameworkFormatMask.DateTimeMedium FrameworkFormatMask.DateTimeLong FrameworkFormatMask.TimeOnlyShort FrameworkFormatMask.TimeOnlyMedium FrameworkFormatMask.TimeOnlyLong FrameworkFormatMask.Decimal FrameworkFormatMask.Integer FrameworkFormatMask.PositiveInteger FrameworkFormatMask.NegativeInteger FrameworkFormatMask.UserDefined string FormatPattern: Ein individuelles Format-Pattern. Dieses kann z.B. bei numerischen Typen für die Formatierung von Zahlen in Strings verwendet werden. Bei FSstrings handelt es sich um einen regulären Ausdruck. [,] Values: Dieser Array beinhaltet die im Metadatentyp vorgenommenen Value-Einschränkungen. Die erste Dimension des Arrays bildet die einzelnen Einschränkungen ab. In der 2. Dimension sind der Von- und der Bis-Wert enthalten. Wenn nur der Von-Wert definiert wurde, dann steht dieser auch im Bis-Wert. Beispiel: A , B , E - G bildet folgendes Array new string[,] { {@\"A\", @\"A\"}, {@\"C\", @\"C\"}, {@\"E\", @\"G\"} }; Kopieren / Mergen kompletter Components Es ist möglich, komplette Components zu kopieren oder auch zusammenzuführen. Das funktioniert auch, wenn es sich bei Quelle und Ziel um unterschiedliche Repositories handelt. Zu beachten ist, dass der Dialog sehr viele Freiheiten bietet. Dies ermöglicht natürlich auch fehlerhafte Stände zu erstellen. Dieser Mechanismus ist für versierte Benutzer konzipiert. Grundsätzlich sollte der Benutzer wissen, was er tut und VOR der Aktion sicherstellen, dass alle von der Component benötigten Elemente am Ziel vorhanden sind. Aktionen Eine Component kann über das Kontext Menü an der Component kopiert werden. Eine Component kann über das Kontext Menü am Namespace eingefügt werden. Eine Component kann über das Kontext Menü an der Component gemerged (zusammengeführt) werden. Einfügen Wird eine Component ohne Basis kopiert, kann diese überall eingefügt werden. Eine Customization wiederrum kann nur erstellt werden, wenn im Package noch keine Customization vorhanden ist und die passende Basis existiert. Dialog Registerkarte Summary Die Summary zeigt, ob beim Paste oder Merge Konflikte gefunden wurden. MergeDialog - Summary Framework Studio versucht bei der Aktion die benötigten Elemente im Ziel-Package auf zwei verschiedenen Wegen zu finden: Über die interne ID: Das funktioniert meist dann, wenn Quell- und Ziel-Package identisch sind oder wenn Elemente aus einem gemeinsamen Basis-Package verwendet werden. Über den Namen: Wenn über die ID nichts gefunden wird, wird nach einem gleichnamigen Element (z.B. Metadatentyp, Component, Property) gesucht. Das ist vor allem dann sehr nützlich, wenn nach und nach mehrere Components in ein anderes Package kopiert werden. Wenn diese Wege nicht zum Ziel führen, wird dies als Konflikt betrachtet und der Benutzer muss nach einer Lösung suchen. Teilweise kann das auf den folgenden Registerkarten erfolgen. Manchmal ist es aber auch nötig, die Aktion abzubrechen, erst die Voraussetzungen zu schaffen (z.B. eine DBTable anlegen) und die Aktion anschließend noch einmal auszuführen. Die anderen Registerkarte sollten also der Reihe nach – wie ein Wizard – durchgearbeitet und die entsprechenden Einstellungen vorgenommen werden, um die Aktion am Ende korrekt ausführen zu können. Die Registerkarte sind bei beiden Aktionen Paste und Merge identisch. Registerkarte Needed Types Bei den Needed Types werden alle Typen aufgelistet, die nicht zum Standard gehören. Diese können beliebig ausgetauscht werden. Das kann z.B. dann sinnvoll sein, wenn eine benötigte Component vorher auch schon kopiert wurde und jetzt ggf. unter einem anderen Namen in einem anderen Namespace zu finden ist. Registerkarte General Unter General können die Interfaces, die Description und die ControlTypes überschrieben werden. Registerkarte Join Tables Bei einer JoinTable stehen zwei Aktionen zur Verfügung, wenn dies nicht durch die Checkbox ignoriert wird. Ein Insert fügt eine neue JoinTable an während der Replace die Werte an der JoinTable ersetzt. Registerkarte Virtual Columns Auch bei den VirtualColumns gibt es die Aktionen Replace, Insert oder Ignore. Diese verhalten sich wie bei der JoinTable. Registerkarte Properties Ein Property bietet beim Einfügen noch die weitere Möglichkeit, den Namen anzupassen. Der Replace ersetzt alle Werte für das ausgewählte Property. Registerkarte Methods Bei den Methoden ist wie bei den Properties eine Umbenennung möglich. Merge Mit einem Merge kann erreicht werden, dass Änderungen an einer Component in einer Kopie davon nachgezogen werden. Was nicht möglich ist, sind gelöschte Elemente durch den Merge zu entfernen. Es werden nur neu hinzugekommene oder geänderte beachtet. Für jedes Element wird in der Component das zugehörige Element gesucht und dann ein Replace vorgeschlagen. Ein Replace ändert nur dann die Daten, wenn diese sich in der kopierten Component auch geändert haben. Es kann also eine Component mit sich selbst gemerged werden und diese ist danach nicht modified, da es keine Änderungen gab."
  },
  "doc/comp/tab_properties.html": {
    "href": "doc/comp/tab_properties.html",
    "title": "Registerkarte Properties",
    "keywords": "Registerkarte Properties Neue Properties anlegen Die Properties werden in der Class-Registerkarte angezeigt. Hier können neue Properties angelegt werden. Das können Sie über den Button ( New ) mit dem Eintrag Property bzw. Membervariable oder über das Kontext-Menü der Component ( New / Property bzw. New / Membervariable ) machen. Eine dritte Möglichkeit besteht darin, eine Component direkt per Drag & Drop aus dem Namespace Treeview auf die Property Tabelle zu ziehen. Drag&Drop von Components Das Property wird angelegt und zugleich im Component-Fenster angezeigt. Properties löschen Properties werden ebenfalls über die Registerkarte Class gelöscht. Wählen Sie das zu löschende Property aus und anschließend aus dem Kontext-Menü den Eintrag Delete . Properties kopieren Sie können ein Property in eine andere Komponente, in ein anderes Form kopieren oder innerhalb der Komponente duplizieren. Dazu wählen Sie das gewünschte Property in der Property-Liste aus. Anschließend verwenden Sie entweder die Standardtastenkürzel Strg+C, Strg+V und Strg+X oder das Kontextmenü, um den gewünschten Kopiervorgang durchzuführen. Properties bearbeiten Sie können ein Property öffnen, indem Sie einen Doppelklick auf den Eintrag in der Class-Registerkarte machen. Alternativ können Sie auch im Component-Fenster auf der Registerkarte Property in der Tabelle das gewünschte Property auswählen. Die Properties werden in der Tabelle sortiert, wenn Sie auf die Spaltenüberschrift des gewünschten Sortierkriteriums anklicken. Name Bezeichnung des Properties. Über diesen Namen wird das Property im Code angesprochen. Access Level Legen Sie hier das Access-Level des Properties fest. Die Angabe ist analog zum .NET-Standard. Datatype Siehe Datentyp bearbeiten UseInterface Es besteht die Möglichkeit, ein Property, welches als Datatype eine Component eingestellt hat, als Interface einzubinden, um zirkulare Referenzen zu umgehen. Wenn man an einer Component ein Property anlegt und dabei als Typ eine Component aus einem anderen Namespace verwendet, dann wird bei diesem Property automatisch die Eigenschaft UseInterface gesetzt. Property Type Folgende Typen stehen zur Auswahl: • Membervariable • Generated • Generated (readonly) • Individual • Individual (readonly) • und Relation. Diese Typen werden weiter unten genauer beschrieben. Mapping Diese Spalte gibt das Mapping (die Verbindung) des Properties zur Query an. In der Combobox stehen hier alle Spalten (Alias) der Query zur Auswahl. Registerkarte Description Hier kann eine Beschreibung zum Property angegeben werden. Registerkarten Get Method / Set Method Siehe Individual / Individual (readonly) Properties Registerkarten Depends On / LoadCommand Siehe Relation Properties Registerkarte Default Label Hier suchen Sie die Bezeichnung des Felds im Form aus. Sie können wählen, ob Sie die Bezeichnung aus der Database-Table bzw. dem Metadatentypen oder eine eigene Bezeichnung nehmen möchten. Die Bezeichnungen sind hierarchisch aufgebaut und können in den aufeinander aufbauenden Ebenen überschrieben werden. Metadatatype-Labels können durch die Database-Labels überschrieben werden, Database-Labels durch die Component-Labels, Component-Labels durch die Form-Labels. Ist in einer tieferen Ebene ein Label vergeben worden, wird dieses angezeigt. Registerkarte Control Types Sie haben die Möglichkeit, ein Standard-Control zu definieren bzw. ein zusätzliches Control hinzuzufügen. Soll es ein Editfield, eine Combobox etc. sein? Datentyp bearbeiten Die Eingabe des Datentyps erfolgt über ein Textfeld mit Auto-Vervollständigung. Beim Anlegen neuer Properties wird der zuletzt ausgewählte Datentyp vorbelegt. Diese Angabe kann nicht geändert werden, wenn dieses Property ein Mapping hat. Dann wird der Metadatentyp aus der entsprechenden Database-Column gezogen. :::image type=\"content\" source=\"media/registerkarte-properties-datentyp.png\" alt-text=\"datatype\"::: Tippen Sie einfach den Namen des gewünschten Datentyps ein. Elemente, die mit dem eingegebenen Text beginnen, werden in der Auto-Vervollständigungsliste angezeigt und können über die Pfeiltasten oder per Maus ausgewählt werden. Wenn Sie den Namen eines Namespaces angeben und anschließend einen Punkt eingeben, wird die Auswahl der Vorschläge auf diesen Namespace eingeschränkt. Beispiel: „Sales.cd“ liefert alle Elemente aus dem Sales Namespace, die mit cd beginnen. Durch Verwendung des Platzhalters „%“ können Sie angeben, dass die Ergebnisse nicht mit dem danach folgenden Text anfangen müssen, sondern der Text lediglich enthalten sein muss. Beispiel: „sales.%ordertype“ liefert alle Elemente aus dem Sales Namespace, deren Name ordertype enthält, also z.B. cdOrderType. Wird die TextBox verlassen, wird der Name des ausgewählten Elements durch den vollständig referenzierenden Namen ersetzt. Warning Beim ersten Verwenden der Textbox kann es einige Sekunden dauern, bis der interne Speicher mit allen Elementen gefüllt ist. Es werden maximal 100 Vorschläge angeboten. Externe Typen Properties von Components und Data Contracts sowie Membervariablen von Forms können externe Datentypen zugewiesen werden. Wird die CheckBox „External Type“ gesetzt, wird die Autovervollständigung des Datatype-Textfeldes deaktiviert und ein beliebiger Typ kann angegeben werden (im Beispiel List<List<int>> ). Dies bietet sich z.B. an, wenn in einem Namespace mit externen Assemblies gearbeitet wird, deren Klassen als Datentypen von Properties verwendet werden sollen. Im IntelliSense wird beim Aufruf eines solchen Properties „object“ angezeigt, da im Hintergrund mit „object“ gearbeitet wird. Das Property „lstTest“ aus dem Beispiel kann aber z.B. trotzdem so verwendet werden: int i = this.lstTest[0][1]; // Der Wert von i ist danach 2 Arten von Properties Membervariablen Bei diesem Typ wird kein Property, sondern eine Membervariable erzeugt. Membervariablen haben keine get- und keine set-Methode. Sie sollten nur mit dem Access-Level private versehen werden, um eine externe Manipulation zu unterbinden, da keinerlei Sicherungsmöglichkeiten nach außen definiert werden können. Eine Membervariable wird nicht im Form-Designer angeboten. Sie sollte nur zum Merken von Informationen innerhalb der Komponente verwendet werden. Generated / Generated (readonly) Properties Die get- und set-Methode für das Property wird automatisch generiert, kann aber auch überdefiniert werden. Dazu muss die Checkbox Write Individual auf der Registerkarte Get Method bzw. Set Method gesetzt werden. In Getter und Setter kann mit der Hintergrundvariable this.PropertyNameValue gearbeitet werden. In Customizations sollte mit base.PropertyName gearbeitet werden, damit Getter und Setter aus dem Basis-Package nicht ausgehebelt werden. In der Component wird auch der Original-Wert des Properties gespeichert. Wird dem Property ein Wert zugewiesen, der vom Original-Wert abweicht, wird der Status der Component auf Changed gesetzt. Der Original-Wert kann mit PropertynameOrgValue abgefragt werden. this.prop = „abc“; if (this.prop != this.propOrgValue ) { /*Wert hat sich geändert*/ } Ist Generated (readonly) ausgewählt, steht für das Property nur die get-Methode zur Verfügung. Auf das Property kann somit nur lesend zugegriffen werden. Bei einer Wertzuweisung an das Property liefert der Compiler eine Fehlermeldung. Hat das Property ein Mapping, verwalten die generierten get- und set-Methoden das Resultset der Query. Ohne Mapping wird eine versteckte private Variable verwaltet. Properties mit einem Mapping können nur auf Generated oder Generated (readonly) stehen. Ist in der Query die Spalte ’Readonly’ gecheckt, ist sogar nur Generated (readonly) möglich. Individual / Individual (readonly) Properties Bei diesen Typen können/müssen Sie die get- und die set-Methode manuell ausprogrammieren. Es werden in den Registerkarten Get Property und Set Property die entsprechenden Code-Felder aktiv. Der Aufruf des Setters führt nicht dazu, dass der Status der Component geändert wird. In der Registerkarte Set Method kann bei Properties vom Typ Individual die von Framework Studio generierte Prüfung auf den Getter mit der Checkbox Check before set unterbunden werden. Eine Prüfung findet standardmäßig statt, weshalb die Checkbox per default gesetzt ist. Bei Individual (readonly) wird nur das Code-Feld für die get-Methode aktiv. Warning Achten Sie darauf, dass eine Get-Methode immer einen Rückgabewert vom Typ des Properties besitzen muss. Folgende 3 Anwendungsfälle sind denkbar (Beispiel): 1.Fall: Sie haben z.B. einen Generated Property Status, und wollen in einem weiteren Property den Text zum Status ausgeben. Dann empfiehlt sich ein Individual (readonly) Property. Die get-Methode könnte folgendermaßen aussehen: if (this.Status == 1) return „offen“; else if (this.Status == 2) return “erledigt”; else return “”; 2. Fall: Sie haben ein Generated Property vom Typ string, wollen aber ein int Property haben, mit dem Sie im Code arbeiten. Mit einem Individual Property können Sie dieses entsprechend verpacken: Generated Property sType vom Typ string (z.B. mit einer Column aus der Query verbunden). Individual Property intType vom Typ int: get-Methode: return Convert.ToInt32( this.sType ); set-Methode: this.sType = Convert.ToString( value ); 3. Fall: Sie wollen ein Property anbieten, das nur bei Bedarf instanziiert und gefüllt wird. Dazu müssen Sie zum einen ein Individual (readonly) Property (z.B. oComp) anlegen und zum zweiten eine private Membervariable (z.B. oCompMember), die den nachgelesen Wert merkt, damit das Einlesen nur einmal erfolgt (Property und Membervariable müssen denselben Typ haben). get-Methode: if (this.oCompMember == null) { this.oCompMember = new cComp( this.Global ); oCompMember.Load ( ); } return oCompMember Relation Properties Die Relations dienen dazu, Ihre Komponenten miteinander zu verbinden. Wenn Sie z.B. einen Auftrag und einen Kunden haben, ist es in der Regel so, dass der Auftrag eine Kundennummer hat, die angibt, welcher Kunde den Auftrag erteilt hat. Relations stellen eine Möglichkeit dar, diese beiden Komponenten miteinander zu verbinden. Dazu wird im Auftrag ein Property Kunde angelegt. Dieses Property muss dem Typ Relation entsprechen. Anschließend müssen noch Angaben darüber gemacht werden, wie die beiden Komponenten miteinander verbunden sind. Warning Achten Sie darauf, dass als Datatype eine Component ausgewählt ist, da Sie andernfalls Relation nicht als Property Type auswählen können. Registerkarte General In der Registerkarte General können Sie die Checkbox Autogenerate Membervariable bei Individual/Individual (readonly) Properties setzen. Wird die Checkbox aktiviert, wird automatisch eine Membervariable generiert und das entsprechende Depends on Property gesetzt. Die Textfelder Display MinLength , Display MaxLength , Display MinLines und Display MaxLines und die Comboboxen Mapping und Drag Source befinden sich ebenfalls hier. Des Weiteren können Sie im Textfeld Description eine Beschreibung hinzufügen. Registerkarten Get Method und Set Method Analog zu Generated Properties Generated / Generated (readonly) Properties kann bei Bedarf zusätzlich individueller Code, der beim Setzen und Auslesen des Properties durchlaufen werden soll, programmiert werden. Registerkarte Depends On Auf dieser Registerkarte können Sie angeben, welches Property aus dem Auftrag mit welchem Property aus dem Kunden verbunden werden soll. Sie geben also eine Schlüsselbeziehung an, ähnlich wie Sie das auf einer relationalen Datenbank tun würden. Sie können auch mehrere Properties miteinander verknüpfen, wenn sich der Schlüssel aus mehreren Properties zusammensetzt. Button Add Fügt ein weiteres Property in die Relation ein. In der Tabelle wird eine neue Zeile angelegt und Sie definieren, welches Property mit welchem wie verknüpft werden soll. Button Remove Löscht die markierte Zeile aus der Relation. Spalte Depends on Property Hier wird das Property auf der Seite Component, in der Sie sich gerade befinden, angegeben. Im Beispiel wäre das ein Property des Auftrags, z.B. die „Kundennnr“. Spalte Compare Operator Gibt an, mit welchem Operator die Properties verknüpft werden sollen. Spalte oXXX.Property Gibt an, mit welchem Property der eingebundenen Component das eigene Property verknüpft werden soll. Im Beispiel wäre das evtl. „Kunde.Kundennr“. Spalte Generated Load Condition Zeigt die aus den anderen Spalten entstandene Suchbedingung an. Registerkarte Load Command Mit den Angaben auf der Registerkarte Depends On wird Code generiert, der für das Nachlesen der Daten (hier der Kundendaten) zuständig ist. Diesen Code können Sie überschreiben, wenn Sie eine eigene Logik wünschen. Sind alle Angaben gemacht, wird die Relation erst beim ersten Zugriff nachgelesen. Dabei werden die gemachten Angaben berücksichtigt. Ändern sich die Inhalte der verbundenen Properties, wird erneut ein Load ausgeführt. Warning Derzeit können nur 1:1 Relationen abgebildet werden. D.h. es ist nicht möglich eine Collection als Relation einzubinden."
  },
  "doc/comp/tab_query.html": {
    "href": "doc/comp/tab_query.html",
    "title": "Registerkarte Query",
    "keywords": "Registerkarte Query Auf der Registerkarte Query Generator kann eine Abfrage definiert werden. Damit das möglich ist, muss auf der Registerkarte General ein Datasource gesetzt sein. Die Query ist nicht bei Collections verfügbar. Die Collection bezieht die Query aus der ihr zugrundeliegenden Component. Toolbar im Query Generator Button Add Jointable Mit diesem Button kann eine neue Tabelle in die Query eingefügt werden. Es erscheint ein Auswahl-Dialog, der alle Tabellen des in der Component hinterlegten Datasources anbietet. Sie können dort eine Tabelle auswählen und diese mit dem Button OK in die Query einfügen. Wenn Sie mehr als eine Tabelle in die Query eingebunden haben, müssen Sie in JoinType und Condition entsprechende Angaben machen. Wenn Sie eine Tabelle mehrmals einbinden, müssen Sie auch einen Alias vergeben. (Diese Felder sind weiter unten genauer erklärt.) Button Remove Jointable Entfernt die momentan ausgewählte Tabelle aus der Query. Button Add Virtual Column Fügt eine neue Spalte in die Query ein. Es wird eine neue Zeile in der Tabelle mit den Spalten angelegt und Sie müssen dann in der Spalte Column die entsprechende Spalte angeben. Evtl. müssen Sie noch den Alias anpassen. Button Remove Virtual Column Löscht die momentan markierte Spalte aus der Query. Das Löschen schlägt fehl, wenn diese Spalte bereits einem Property zugeordnet ist. Button Autogenerate Virtual Columns Öffnet den Dialog Autogenerate Virtual Columns . Autogenerate Virtual Columns Wizard In diesem Dialog werden alle Spalten angeboten, die noch nicht in die Query eingebunden sind. Sind bereits alle Spalten mindestens einmal verwendet, wird der Dialog nicht aufgerufen. In der Spalte Choose können Sie festlegen, welche Spalten zur Abfrage hinzugefügt werden sollen. In der Spalte Alias können Sie den Alias angeben. Diesen können Sie später wieder überschreiben. Mit der Checkbox Generate a property for all new Columns wird automatisch für jede neue Spalte ein neues Property angelegt. Der Name des Properties richtet sich nach dem hier angegebenen Alias. Diesen Vorgang können Sie auch später mit dem Button Autogenerate Properties nachholen. Mit dem Button Next öffnet sich das Fenster Summary . Es zeigt eine Zusammenfassung mit den zu generierenden Spalten und Properties an. Anschließend werden die Spalten (und ggf. auch Properties) mit dem Button Finish generiert. Button Autogenerate Properties Generiert für alle Spalten, die noch nicht einem Property zugewiesen sind, ein neues Property. Basis für den Namen der neuen Properties ist die Spalte Alias in der Tabelle. Wird der Alias nachträglich geändert, wird der Name das Properties nicht angepasst. Button Query with group by clause Schaltet Group By an oder aus. Wird Group by eingeschaltet, wird in der Tabelle eine neue Spalte GroupBy sichtbar. In ihr kann angegeben werden, ob nach der Spalte gruppiert werden soll oder ob eine Aggregatfunktion (SUM, MIN, MAX..) angewendet werden soll. Wenn das der Fall ist, wird die Angabe in der Spalte Criteria in die Having-Clause des SQL-Statements eingebaut. Soll trotzdem für eine Spalte eine Where-Clause angegeben werden, müssen Sie die Spalte noch einmal einbinden, Output deaktivieren, in GroupBy nichts angeben und Criteria wie gewünscht füllen. Button (Distinct Wenn der Button Distinct gedrückt ist, wird das Schlüsselwort „distinct“ in die Abfrage generiert. Distinct-Abfragen führen automatisch zu einer readonly-Komponente. Button ReadOnly Component Wird dieser Button aktiviert, kann auf die Komponente kein Save ausgeführt werden. Button Execute query Dieser Button dient zum Testen der angegebenen Query. Im unteren Teil des Fensters wird die Registerkarte Preview aktiviert und das Ergebnis der Query eingespielt. Die Registerkarte Preview können Sie auch manuell aktivieren, um die Query zu testen. Felder auf der Registerkarte Query In der Listbox werden die an der Query beteiligten Tabellen angezeigt. Es können mit dem Button (Add jointable ...) neue Tabellen hinzugefügt und mit dem Button (Remove jointable ...) die momentan ausgewählte Tabelle entfernt werden. Je nachdem, welche Tabelle ausgewählt ist, können rechts daneben weitere Angaben zur Tabelle gemacht werden. Alias Gibt den Alias an, der in der Query verwendet werden soll. Ist kein Alias angegeben, wird der Name der Tabelle verwendet. Wird eine Tabelle zweimal eingebunden, muss ein Alias angegeben werden, da sonst nicht eindeutig klar ist, welche Tabelle gezogen werden soll. JoinType Dieses Feld ist ab der zweiten Tabelle zugänglich. Es gibt an, welche Art von Join verwendet werden soll ( Inner Join , Left Outer Join , Rigth Outer Join , No Join ). Je nachdem, was dort angegeben ist, wird auch das Statement zusammengebaut. Wenn als Typ No Join angegeben ist, wird ein Statement erzeugt, das in etwa so aussieht: SELECT ... FROM Table1, Table2 WHERE Tabel1.Spalte1 = Table2.Spalte3... Condition Gibt die Bedingung für den Join an. Haben Sie in den DBTables bei Relations Angaben gemacht, werden diese hier entsprechend gezogen. Tabelle In der Tabelle sind die Spalten der Abfrage angegeben. Tabelle / Spalte Pos In dieser Spalte wird die Reihenfolge der Felder in der Abfrage definiert. Tabelle / Spalte Output Gibt an, ob die Spalte ausgegeben werden soll oder nicht. Dieser wird als gecheckt vorbelegt. Sie können diese Checkbox deaktivieren, wenn Sie z.B. eine Spalte haben, bei der die Suchbedingung interessant ist. Dann kann für diese Abfrage-Spalte kein Property angelegt werden. Mit gesetzter Checkbox (bei „Spalte2“) erhalten Sie folgendes Ergebnis: SELECT Spalte1, Spalte2 FROM Tabelle WHERE Spalte2 = ‘ABC’ Mit deaktivierter Checkbox erhalten Sie in etwa folgendes Ergebnis: SELECT Spalte1 FROM Tabelle WHERE Spalte2 = ‘ABC’ Das ist z.B. dann interessant, wenn Group by aktiviert ist und Sie im Query-Designer für eine Spalte trotzdem eine Bedingung angeben möchten. Tabelle / Spalte Column Gibt an, welches Feld der Tabelle(n) gezogen werden soll. In einer Combobox werden alle Felder der beteiligten Tabellen angezeigt. Es kann eines dieser Felder ausgewählt werden. Soll das Feld eine Formel enthalten, kann diese hier auch frei eingegeben werden. Tabelle / Spalte Alias Gibt den Alias des Felds an. Dieser Name wird als Standard-Name für die generierten Properties gezogen. Als Standard wird der Name des ausgewählten Felds eingetragen. Tabelle / Spalte Sort Type Hier kann festgelegt werden, ob und wenn ja wie nach diesem Feld sortiert werden soll. Zur Auswahl stehen Ascending (aufsteigend) und Descending (absteigend). Tabelle / Spalte Sort Order Gibt die Reihenfolge an, in der die Felder sortiert werden sollen. Es werden Zahlen von 0 aufsteigend vergeben, wenn Sie die Spalte ‚Sort Type‘ setzen. Diese Reihenfolge kann nachträglich geändert werden, indem die Zahlen einfach überschrieben werden. Wird ein Feld nicht sortiert, wird in die Spalte der Wert –1 eingetragen. Wird später mit der Load-Methode eine OrderBy-Clause angegeben, sind die Angaben in Sort Type und Sort Order hinfällig. Tabelle / Spalte Group By Warning Diese Spalte ist nur sichtbar, wenn für die Query Group By eingeschaltet ist. Hier wird angegeben, wie sich die Spalte im Group By verhalten soll. Es kann Group By oder eine Aggregatfunktion (z.B. SUM, MAX, AVG) angegeben werden. Die Spalte kann auch leer gelassen werden. Das macht aber nur Sinn, wenn die Spalte Output nicht gecheckt ist. Tabelle / Spalte Key Field Warning Diese Spalte ist nur sichtbar, wenn für die Query Group By eingeschaltet ist. Um einen Datensatz eindeutig zu identifzieren, werden normalerweise die PK-Spalten verwendet. Dies ist bei einer GroupBy-Anfrage nicht automatisch möglich. Mit der Spalte Key Field können Sie angeben, welche Abfrage-Spalten einen Satz eindeutig identifizieren sollen. Wird hier keine Angabe gemacht, dann greift der Reload-Mechanismus in der Collection nicht. Es werden dann immer alle Datensätze komplett eingelesen. Warning Wenn falsche Angaben gemacht werden, dann kann dies beim Reload zu falschen Daten führen. Im Zweifel sollten besser keine Key-Spalten gekennzeichnet werden. Wenn neben den Key-Spalten nur wenige weitere Abfrage-Spalten vorhanden sind, dann macht es keinen Sinn, die Key-Spalten zu kennzeichnen. Der Reload-Mechanismus bringt in diesem Fall keinen Vorteil - es könnte sogar einen Nachteil für die Performance bedeuten. Tabelle / Spalte Criteria, Spalten Or In den Spalten Criteria, Or, Or, Or können Bedingungen angegeben werden, die in der Query immer gelten sollen. Es können maximal 4 Kriterien angegeben werden. Z.B. „IS NOT NULL“, „>0“... Wird später mit der Load-Methode eine Where-Clause angegeben, wird diese mit einem „And“ an die hier angegebene Bedingung angefügt. Bei Spalten mit ‘Group By‘ oder einer Aggregat-Funktion wird die Kondition automatisch zur Having-Clause. Warning Wird später mit der Load-Methode eine Having-Clause angegeben, sind diese Angaben hier hinfällig. Tabelle / Spalte Readonly Ist diese Spalte gesetzt, wird das Property als Readonly generiert. Registerkarten Framework Studio SQL / Oracle SQL /SQL-Server SQL Unten, auf den Registerkarten Framework Studio SQL / Oracle SQL / SQL-Server SQL , wird das SQL der eigentlichen Abfrage (bezogen auf die jeweilige Datenbank) angezeigt. Registerkarte Preview Hier wird das Ergebnis der Abfrage in einer Tabelle dargestellt. Damit kann auch getestet werden, ob die definierte Abfrage funktioniert."
  },
  "doc/custom-controls/custom-controls.html": {
    "href": "doc/custom-controls/custom-controls.html",
    "title": "Custom Controls",
    "keywords": "Custom Controls Allgemeines Hintergrund Framework Studio stellt eine breite Palette von Standard Controls zur Verfügung. Sie sind jedoch nicht darauf angewiesen, sich auf diese Controls zu beschränken. Mit Custom Controls bietet Framework Studio einen komfortablen Weg, eigene, komplexe oder stark spezialisierte Controls zu entwickeln und in Ihre Anwendung zu integrieren. Beispiele für diese so genannten Graphical Custom Controls sind: dreidimensionale Darstellung von Statistiken Farbauswahldialog HTML-Textfeld ... Ein weiteres Anwendungsgebiet für Custom Controls sind funktionelle Erweiterungen des Clients, die lokal am Client ausgeführt werden müssen. Beispiele für Functional Custom Controls sind: lokaler Dateiauswahldialog Telefonanbindung (TAPI) Darstellung von Daten in externen Programmen (z.B. Word oder Excel) ... Aufgrund der Client-Server Architektur, die Framework Studio unterstützt, muss für ein Custom Control sowohl der Client (ggf. auch mehrere) als auch Ihre Anwendung in Framework Studio um eine entsprechende Definition des Controls erweitert werden. In dieser Dokumentation wird die Erweiterung in Framework Studio beschrieben. Informationen zur Erweiterung der Clients finden Sie in den entsprechenden Dokumentationen. Erstellen und Löschen von Custom Controls Erstellen eines Custom Controls Custom Controls werden wie alle anderen Elementtypen erzeugt. Dazu muss einer der drei Typen Functional , Graphical und Child Custom Control ausgewählt werden. Elemente erstellen Löschen eines Custom Controls Elemente löschen Verwendung von Custom Controls in Forms Um ein Custom Control in ein Form zu integrieren, öffnen Sie das Form im Form-Designer (Forms) und wechseln Sie anschließend auf die Registerkarte Toolbox (Framework Designer). Von dort ziehen Sie das gewünschte Control auf die Registerkarte Default Variant des Form-Designers. Wenn Sie ein Functional Custom Control einfügen, wird dieses im Form-Designer auf der Registerkarte Functional Controls (Registerkarte Functional Controls) angezeigt. Properties Ein Custom Control kann bestimmte statische Eigenschaften besitzen, die der Entwickler im Form-Designer angeben können soll. Diese Properties werden bei der Initialisierung des Custom Controls übertragen. Anwendungsfallbeispiele sind statische Spaltenüberschriften einer Tabelle oder allgemein Initialisierungsparameter für komplexe Controls. Diese Eigenschaften sind Theme-spezifisch, sodass in den Default Control Styles z.B. Farbwerte und Schriftarten je nach Theme angepasst werden können. Die einzige Ausnahme bilden Properties mit dem Typ MLString. Diese sind Theme-übergreifend. Wenn Sie für ein Custom Control ein neues Property anlegen möchten, benutzen Sie entweder den Button New... / Property oder wählen den Menüpunkt File / New / Property . Custom Control Registerkarte Properties: Anschließend können Sie auf der Registerkarte Properties die Eigenschaften des Properties festlegen. In der Auswahlbox oben auf der Registerkarte können alle Properties des Custom Controls ausgewählt werden. Zum ausgewählten Property werden dann darunter die Eigenschaften angezeigt. Name Name des Properties. Type Typ des Properties. Hier werden alle Standard .NET Datentypen, einige speziellere .NET Datentypen wie Color und Font sowie der Framework Studio Datentyp MLString angeboten. Category Hier kann ein Name für die Kategorie angegeben werden, unter der das Property auf der Registerkarte Properties eines Forms bei markiertem Control angezeigt wird. TypeConverter Hier kann ein Typkonverter für die Eingabe im Propertygrid auf der Registerkarte Properties angegeben werden. Beispielsweise NonnegativeInt32Converter, um nur die Eingabe von positiven Ganzzahlen zu ermöglichen. UITypeEditor Ein Typeditor kann für eine komfortable Eingabe eines Wertes im Propertygrid angegeben werden. Zum Beispiel der UrlUITypeEditor, mit dem URLs eingegeben und auf Gültigkeit geprüft werden können. Alle Default Control Styles, auch die von Custom Controls, werden im Namespace FSGeneral / Controls aufgelistet. Wenn Sie dort Ihr selbst definiertes Custom Control öffnen, können Sie für die Properties des Custom Controls Standardwerte vorbelegen. Custom Control Default Control Style: Wenn Sie ein Functional Custom Control auf ein Form ziehen und es markieren, werden Ihnen die selbst definierten Properties auf der Registerkarte Properties angezeigt. Custom Control Instance Properties: Actions Actions ermöglichen dem Programmierer, am Client eine Methode des Custom Controls aufzurufen. Um eine neue Action anzulegen, benutzen Sie entweder den Button New... / Action oder wählen den Menüpunkt File / New / Action . Auf der Registerkarte Actions des Custom Control Designer-Fensters können Sie in der Auswahlbox zwischen allen Actions des Controls auswählen. Die ausgewählte Action wird darunter dargestellt. Custom Control Registerkarte Actions: Name Name der Action. Dieser Name dient am Client zur Identifizierung der Action. Declaration Deklaration der Methode, die über das Control aufgerufen werden kann. Die Methode darf keinen Rückgabewert haben und kann beliebig viele Parameter entgegen nehmen. Die Parameter müssen einfache .NET Datentypen sein. Custom Control Registerkarte Method: Nach der Definition einer Action kann diese Action aus einem Form heraus, wie im obigen Bild dargestellt, aufgerufen werden. Datasources Datasources dienen zum bidirektionalen Datenaustausch zwischen Client und Broker. Die gemeinsame Datenquelle funktioniert genau wie die Datasources an den Standardcontrols. Um einen neuen Datasource anzulegen, benutzen Sie entweder den Button New... / Datasource oder wählen den Menüpunkt File / New / Datasource . Custom Control Registerkarte DataSources: Auf der Registerkarte DataSources können Sie in der obersten Auswahlbox zwischen allen Datasources des Controls auswählen. Die Eigenschaften der ausgewählten Datenquelle werden darunter dargestellt. Name Name des Datasources. Type Typ des Datasources. Zur Auswahl stehen folgende Werte: Value: Die Datenquelle kann mit einem beliebigen FS-Standarddatentypen gefüllt werden (z.B. string, int, object, ...) Record: Objekt vom Typ DevFrameworkObject Collection: Collection vom Typ DevFrameworkObjectColl SelectedRowsCollection: SelectedRowsCollection Inherit: Funktionslos Bei den Typen Record, Collection und SelectedRowsCollection müssen Methoden implementiert werden, welche die gewünschten Daten aus einem Objekt in Xml und zurück in ein Objekt übertragen! Beim Typ Value ist dies nicht nötig. Custom Control Instance Datasource: GetXML Diese Methode wird zum Senden der Daten vom Broker an den Client benötigt. Die Daten müssen aus dem Objekt in einen geeigneten Xml-Knoten umgewandelt werden. Die Methodendeklaration lautet: IEnumerable<XObject> GetDataSourceXml(Dictionary[…] value) Wobei DataSource durch den Namen der Datenquelle ersetzt wird. Alle zurückgegebenen Elemente oder auch Attribute werden in den von Framework Studio generierten XML-Knoten mit dem Typ XElement eingefügt. Diese Methode kann das Ergebnis als Liste zurückgeben. Man kann das Ergebnis aber auch mit Hilfe von „yield return“ enumerieren. Wenn keine Informationen an den Client übergeben werden sollen, dann wird einfach „return null;“ aufgerufen. Beispiel einer GetXML-Methode: List<XObject> xaList = new List<XObject>(); cColor oColor = value as cColor; if (oColor != null) { xaList.Add(new XAttribute(\"A\", oColor.intA.ToString())); xaList.Add(new XAttribute(\"R\", oColor.intR.ToString())); xaList.Add(new XAttribute(\"G\", oColor.intG.ToString())); xaList.Add(new XAttribute(\"B\", oColor.intB.ToString())); } xaList.Add(new XElement(\"EinUnterKnoten\")); return xaList; Dasselbe Beispiel als Enumerator mit yield return : cColor oColor = value as cColor; if (oColor != null) { yield return new XAttribute(\"A\", oColor.intA.ToString()); yield return new XAttribute(\"R\", oColor.intR.ToString()); yield return new XAttribute(\"G\", oColor.intG.ToString()); yield return new XAttribute(\"B\", oColor.intB.ToString()); } yield return new XElement(\"EinUnterKnoten\"); Das erzeugte XML sieht folgendermaßen aus: <Data> <Color A=\"0\" R=\"0\" G=\"0\" B=\"0\"> <EinUnterKnoten /> </Color> </Data> SetXML Diese Methode wird zum Empfangen der Daten vom Client am Broker benötigt. Die Daten müssen aus dem XML-Knoten ausgelesen und in das Objekt kopiert werden. Die Methodendeklaration lautet: void SetDataSourceXML (XElement xeNode, Dictionary<string, string> properties, Dictionary<string, Dictionary<string, string>> children, DevFrameworkObject value) Mit dem Parameter xeNode wird der komplette DataSource-Knoten übergeben. Aus diesem können jetzt die Attribute und Elemente ausgelesen werden. Einfaches Beispiel: cColor oColor = value as cColor; if (oColor != null) { oColor.intA = int.Parse(xeNode.Attribute(\"A\").Value); oColor.intR = int.Parse(xeNode.Attribute(\"R\").Value); oColor.intG = int.Parse(xeNode.Attribute(\"G\").Value); oColor.intB = int.Parse(xeNode.Attribute(\"B\").Value); } foreach(XElement xeSubNode in xeNode.Elements()) { ... Unterknoten auswerten ... } Events Events kann der Client senden. Auf diese Events kann dann am Broker reagiert werden. Um einen Event anzulegen, benutzen Sie entweder den Button New... / Event oder wählen den Menüpunkt File / New / Event. In der Klassenansicht (Registerkarte Class im Hauptfenster) können Sie den Namen des Events ändern. Wenn Sie Ihr Custom Control in ein Form gezogen haben, können Sie im Form an das Event wie gewohnt einen Eventhandler anhängen. Custom Control Eventhandler: Child Custom Controls Wenn Sie auf der Registerkarte Namespaces des Framework-Designers im Objekt-Baum ein Custom Control markieren, können Sie über den Menüpunkt File / New / Custom Control / Child Custom Control ein Untercontrol anlegen. Warning An einem Untercontrol können Sie nur Properties definieren. Alle anderen Funktionen müssen über das Hauptcontrol abgewickelt werden."
  },
  "doc/database/connection.html": {
    "href": "doc/database/connection.html",
    "title": "Datenbank-Connection",
    "keywords": "Datenbank-Connection SQL-Server Connection Wird kein Username angegeben, dann wird Windows-Authentifizierung verwendet. Oracle-Connection 1.) Server / Database Bei der Angabe von Server und einer Database erzeugt Framework Studio einen TNS-String in dem folgenden Format: (DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST= <SERVER> )(PORT=1521)))(CONNECT_DATA=(SID= <Database> )(SERVER=DEDICATED))) Der Standard-Port 1521 kann über den Server-Namen beeinflusst werden, indem er mit einem \":\" getrennt angegeben wird. Die Database wird standardmäßig als SID angegeben. Durch Angabe von \"SERVICE_NAME=\" kann die Angabe als SERVICE_NAME definiert werden. Das kann bei Container-Datenbanken sinnvoll sein. Beispiel 1: Server=MyServer:1234 Database=MyDatabase dasselbe wie Database=\"SID=MyDatabase\" Ergibt den folgenden TNS-String: (DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=MyServer)(PORT=1234)))(CONNECT_DATA=(SID=MyDatabase)(SERVER=DEDICATED))) Beispiel 2: Server=[2607:f0d0:1002:51::4]:1234 (IPv6-Adresse mit Port) Database=\"SERVICE_NAME=MyDatabase\" Ergibt den folgenden TNS-String: (DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=[2607:f0d0:1002:51::4])(PORT=1234)))(CONNECT_DATA=(SERVICE_NAME=MyDatabase)(SERVER=DEDICATED))) 2.) TNS-String Wird kein Server angegeben, dann wird die Database direkt als TNS-String verwendet. Das kann benutzt werden, wenn der automatisch generierte TNS-String nicht ausreicht. Connection-String FSProviderType Gültige Werte: SqlServer OracleManaged Server Database UserID Wird bei SQL-Server kein UserName dann wird Windows-Authentifizierung verwendet. Password PasswordEncrypted Wird das Password in der Oberfläche eingegeben, dann erzeugt Framework Studio ein verschlüsseltes Passwort. Das verhindert lediglich, dass ein Benutzer das Passwort einfach lesen kann. FSUseAnsiString Standard-Wert: false Gibt an, ob die String-Parameter in den Commands als Ansi-String behandelt werden sollen. Caution Es können Unicode-Inhalte zur Datenbank transportiert werden. FSPoolingMin Standard-Wert: 5 Anzahl der Datenbank-Connections, die dauerhaft im Connection-Pool verbleiben sollen. FSPoolingMax Standard-Wert: 15 Anzahl der Datenbank-Connections, die maximal im Connection-Pool enthalten sein dürfen. Jede weitere Connection wird nach der Verwendung unmittelbar getrennt. FSPoolingTimeout Standard-Wert: 60 Timeout in Sekunden. Diese Zeit verbleiben die zusätzlichen Datenbank-Connections im Pool, bis auch sie getrennt werden. FSPoolingDebugOutput Gibt einen Dateinamen an, in dem der Connection-Pool ein Protokoll schreiben soll. Dieses kann für die Analyse des Connection-Pools verwendet werden. Connection-Pooling Der Connection-Pool stellt eine Menge von freien wiederverwendbaren Datenbank-Verbindungen zur Verfügung. Dabei kann über die FSPooling-Parameter das Verhalten des Pools gesteuert werden. Die Parameter haben die folgende Bedeutung: FSPoolingMin : Wird eine Connection nicht mehr benötigt, wird sie (z.B. am Ende eines Broker-Requests) wieder zurück in den Vorrat / Pool gepackt. Der Pool darf dauerhaft diese Anzahl an Connections beinhalten. FSPoolingMax : Das ist die maximale Anzahl der Connections, die sich im Pool befinden dürfen. Ist der Pool voll, dann wird die Connection nicht in den Pool zurückgepackt sondern sie wird direkt geschlossen. FSPoolingTimeout : (in Sekunden) Die Connections zwischen Min und Max verbleiben maximal diese Zeit im Pool. Werden sie nicht vorher wieder verwendet, werden sie nach dem Timeout aus dem Pool entfernt und geschlossen. Der Timeout wird geprüft, wenn versucht wird, eine Connection in den Pool zu packen."
  },
  "doc/database/datasource.html": {
    "href": "doc/database/datasource.html",
    "title": "Datasource",
    "keywords": "Datasource Ein Datasource (Datenquelle) definiert eine Datenbankverbindung, die von der Anwendung zum Lesen und Schreiben der Anwendungsdaten verwendet werden kann. Alle Datenquellen werden im Objekt-Baum ( Registerkarte Namespaces ) im Namespace FSGeneral / DBTables verwaltet. Das Erstellen und Löschen von Datenquellen funktioniert in diesem Namespace wie bei allen anderen Elementen ( Elemente erstellen , Elemente löschen ). Durch einen Doppelklick auf eine Datenquelle wird das Designer-Fenster geöffnet. Erläuterungen zu den Standardfunktionen, die im Designer-Fenster für Datenquellen angeboten werden, finden Sie unter Allgemeine Funktionalitäten . Alle weiteren Funktionen werden im Folgenden beschrieben: Name: Über das Textfeld können Sie der Datenquelle einen Namen zuweisen. Die Verbindungs-Einstellungen sin dim Kapitel Connection Einstellungen beschrieben. Test Connection: Über diesen Button können Sie testen, ob mit den angegebenen Verbindungsdaten eine Verbindung aufgebaut werden kann."
  },
  "doc/database/dbtable.html": {
    "href": "doc/database/dbtable.html",
    "title": "DBTable",
    "keywords": "DBTable Ein DBTable ermöglicht Komponenten den Zugriff auf eine Datenbanktabelle, die über einen Datasource angesprochen werden kann. Alle DBTables werden im Objekt-Baum ( Registerkarte Namespaces ) im Namespace FSGeneral / DBTables unterhalb des Datasources angezeigt, den der DBTable zur Verbindung mit der Datenbank verwendet. Das Erstellen und Löschen von DBTables funktioniert wie bei allen anderen Elementen ( Elemente erstellen , Elemente löschen ). Zuvor muss allerdings im Objekt-Baum der zu verwendende Datasource markiert werden! Durch einen Doppelklick auf ein DBTable wird das Designer-Fenster geöffnet. Erläuterungen zu den Standardfunktionen, die im Designer-Fenster für DBTables angeboten werden, finden Sie unter Allgemeine Funktionalitäten . Über den Menüpunkt Database / Import kann die auf der Datenbank existierende Datenstruktur ausgelesen werden und der DBTable automatisch konfiguriert werden ( Automatisiertes Importieren von Datenbankstrukturen ). Über den Menüpunkt Component / Create Component... kann aus dem DBTable eine Komponente generiert werden ( Erzeugen einer Komponente ). Die Checkbox View legt fest, ob es sich bei dieser Tabelle um einen View handelt. Wenn dies der Fall ist, muss auf der Registerkarte View eine entsprechende View-Definition angegeben werden. Diese Einstellung kann im Customizing nicht verändert werden. Die Checkbox Use History legt fest, ob historische Daten in einer separaten Tabelle ausgelagert sind ( Auslagerung historischer Daten ). Die Checkbox Imported gibt an, ob es sich bei dieser Tabelle um eine importierte Datenstruktur handelt. Importierte Strukturen werden beim automatischen Datenbank-Update nicht berücksichtigt. Wenn an der, der DBTable zugehörigen, Connection die Eigenschaft Imported gesetzt ist, dann ist auch die Checkbox an der DBTable automatisch gesetzt und kann nicht deaktiviert werden. Diese Einstellung kann im Customizing nicht verändert werden. Die einzelnen Registerkarten werden im Folgenden beschrieben. Registerkarte Columns Auf der Registerkarte Columns werden die einzelnen Spalten der Tabelle angezeigt. Die Eigenschaften der Spalten sind editierbar und müssen mit der Definition des Datenmodells auf der Datenbank vereinbar sein. Außerdem kann ein Metadatentyp zugeordnet werden. Link Preview DBTable Öffnet die Sql Statement Preview Tabelle In der Tabelle werden Informationen zu allen Spalten angezeigt. Die Tabelle ist readonly - die Details der ausgewählten Tabellen-Spalte können im Bereich unter der Tabelle angezeigt werden. Spalte Name : Der Name der Spalte Spalte Default Label : Zeigt den Text des Default-Labels an. Dieser kann auf der Registerkarte Texts bearbeitet werden. Spalte Metadatatype : Der Name des Metadatentyp Spalten Size , Precision , Scale : Die Größe des Feldes. Spalte Column Kind : Die Art der Spalte. RowID, RowVersion oder PK (Primary Key). Spalte MLColumn : Zeigt an, ob es sich um eine MLColumn handelt. Spalte Not Null : Zeigt an, ob die Spalte als Not Null gekennzeichnet ist. Feld Name Feldname in der Datenbank. Dabei muss es sich um einen gültigen \"Identifier\" handeln. Feld Metadatatype Art des Feld-Typs. Hier stehen alle Metadatentypen und Datenbank-Datentypen zur Verfügung. Der Link Open Öffnet den Metadatentyp der momentan ausgewählten Spalte. Checkbox Primary Key Gibt an, ob es sich bei der Spalte um einen Primär-Schlüssel handeln soll. Auf eine so gekennzeichnete Tabellen-Spalte kann kein Update erfolgen. Checkbox RowID, RowVersion Auf jeder Tabelle können die beiden Spalten FSROWID und FSROWVERSION definiert werden. Diese beiden Spalten werden dann jeweils mit der entsprechenden Checkbox gekennzeichnet. Diese Spalten sind für das Update der Daten notwendig, damit konkurrierende Transaktionen erkannt und verhindert werden können. (Siehe auch FSROWID / FSROWVERSION ) Checkbox MLColumn Ist die Checkbox aktiviert, kann in der Anwendung der Dateninhalt der Spalte mehrsprachig gepflegt werden (siehe MLColumn ). Checkbox Not Null Wenn gesetzt, dann darf diese Spalte keine Null-Werte beinhalten. Diese Information wird bei automatischen Datenbank-Update abgeglichen. Feld Size Größe des Felds bei alphanumerischen Datentyp. Wird eine Größe von 0 angegeben, handelt es sich um ein Langtext-Feld ohne Größen-Beschränkung. Feld Precision Anzahl der Stellen eines numerischen Feldes (inkl. Nachkommastellen). Feld Scale Anzahl der Nachkommastellen. Checkbox Override Wird diese Checkbox gesetzt, dann können die aus dem Metadatentyp geerbten Größen-Angaben Size , Precision und Scale , überschrieben werden. Warning Davon sollte nur in Ausnahmefällen gebrauch gemacht werden. Zuerst sollte versucht werden, einen passenden Metadatypen zu verwenden. Ist keiner vorhanden, dann muss ggf. ein passender Metadatentyp erzeugt werden - insbesondere dann, wenn das mehrere Tabellen-Spalten betrifft. Auch im Customizing-Package sollte man zuerst darüber nachdenken, den zugeordneten Metadatentyp anzupassen. Das beugt Probleme beim Übertragen von Werten in andere Spalten mit demselben Metadatentyp vor. Felder Display Length / Lines In den Feldern Display MinLength , Display MaxLength , Display MinLines und Display MaxLines können die Größen-Angaben für die Form-Controls gesteuert bzw. überschrieben werden. Siehe auch Größe von Controls . Registerkarte Texts Hier können Sie das zu verwendende Default-Label , die Column-Caption , der Tooltip und die Description für eine Datenbankspalte festlegen bzw. überschreiben. Wenn der Spalte ein Metadatentyp zugeordnet wurde, wird das Default-Label vom Metadatentyp verwendet, solange es nicht an dieser Stelle überschrieben wird. Registerkarte ControlTypes Auf der Registerkarte ControlTypes wird angezeigt, welche Controls der Spalte zugeordnet sind. Ist der Spalte ein Metadatentyp zugewiesen, werden die dem Metadatentyp bereits zugewiesenen Controls hier angezeigt. Die Liste kann ggf. ergänzt werden. Ist kein Metadatentyp zugewiesen, können Sie die ControlTypes hier hinterlegen. Mit den Buttons Add und Change öffnet sich das Fenster Assign Controls . Siehe auch Metadatentyp Registerkarte Control Types Registerkarte Documentation Auf der Registerkarte Documentation kann die Benutzer-Dokumentation für die Tabelle hinterlegt bzw. die Dokumentation aus dem verwendeten Metadatentypen überschrieben oder ergänzt werden. Siehe auch Dokumentations-System . Registerkarte Indices Die Indizes einer Tabelle lassen sich auf der Registerkarte Indices festlegen. Ein neuer Index lässt sich wie gewohnt durch das Kontextmenü, die Toolbar oder durch das Menü File / New anlegen. Diesem können nun Spalten zugeordnet werden, die entweder absteigend (DESC) oder aufsteigend (ASC) indiziert sein können. Des Weiteren kann ein Index als Unique (eindeutig) deklariert werden und er kann aktiviert oder deaktiviert werden, wodurch der automatische Abgleich mit der Datenbank beeinflusst wird. Indizes lassen sich nur dann verwalten, wenn es sich bei der Tabelle nicht um einen View handelt. Registerkarte View Wird eine DBTable mit der Checkbox View gekennzeichnet, dann muss auf der Registerkarte View ein SQL-Statement für die View-Definition angegeben werden. Die View-Definition wird beim automatischen Datenbank-Update abgegelichen und der View ggf. angepasst. Das Statement wird in Framework-Studio-Syntax formuliert ( SQL-Syntax ). Die Bezeichnungen der Ergebnis-Spalten werden aus dem Select-Statement ermittelt. Aus diesem Grund muss ggf. ein Spalten-Alias angegeben werden - z.B. bei berechneten Spalten und wenn die Bezeichnung von der Tabellen-Spalte abweichen soll. Es ist zwingend zu beachten, dass alle in der Registerkarte Columns definierten Spalten in der View-Definition enthalten sind. Die View-Definition kann im Customzing-Package überschrieben werden. Mit dem Link Preview Select öffnet sich die Sql Statement Preview . Damit kann das Statement gestestet werden. Registerkarte Description In dem Textfeld der Registerkarte können allgemeine Informationen zu dieser Tabelle hinterlegt werden. Sql Statement Preview Mit der Sql Statement Preview können SQL-Befehle getestet werden. Sie steht in verschiedenen Programmteilen zur Verfügung um z.B. eine DBTable, die View-Definition oder eine Component-Query zu testen. Registerkarte Select Statement Hier wird der SQL-Befehl angezeigt, der von der Aufruf-Stelle übergeben wurde. Dieser kann hier temporär bearbeitet werden, die vorgenommenen Änderungen werden jedoch nicht übernommen. Im Feld Additional where clause kann optional eine zusätzliche Suchbedingung angegeben werden. Wenn das Statement selber schon eine Bedingung besetzt, dann wird diese ergänzt. Bei Connection wird die aktuell ausgewählte Datenbank angezeigt. An diese wird das SQL-Statement geschickt. Mit dem Button View Result wird auf die Registerkarte View top 50 Results gewechselt. Registerkarte Converted Statement Zeigt den in die Syntax der Zieldatenbank konvertierten SQL-Befehl an. Standardmäßig wird der Typ der aktuell ausgewählten Datenbank vorbelegt. Mit den Buttons kann der Typ gewechselt werden. Falls bei der Konvertierung ein Fehler auftritt, wird dieser statt dem Statement angezeigt. Registerkarte View top 50 Results Beim Wechsel auf diese Registerkarte wird das Statement an die aktuell ausgewählte Datenbank gesendet und die ersten 50 Ergebnisse in einer Tabelle angezeigt. Automatisiertes Importieren von Datenbankstrukturen Framework Studio bietet Ihnen einen Automatismus, der es erlaubt, alle nötigen Angaben über die Struktur der Daten auf der Datenbank auszulesen und daraus die Spaltendefinitionen generieren zu lassen. Benutzen Sie dazu den Menüpunkt Database / Import , der Ihnen sowohl im Designer-Fenster eines Datasources als auch im Designer-Fenster eines DBTables zur Verfügung steht. Zunächst werden Ihnen alle Tabellen, die über die Datenquelle (des DBTables) erreichbar sind, zur Auswahl gestellt. Wenn Sie eine Tabelle ausgewählt haben, die in Framework Studio bisher noch nicht bekannt ist, wird diese automatisch als neuer Table in Framework Studio eingebunden. Danach sehen Sie im Fenster Update Table eine Tabelle, in der alle Columns (Spalten der Datenbanktabelle) aufgelistet werden. Update Table (Spalten): In der Tabellenspalte mit der Überschrift Column Name wird der Name der Datenbankspalte aufgeführt. In der Tabellenspalte Action wird ein Symbol dargestellt, an welchem Sie erkennen können, welche Art von Änderung bei einer Aktualisierung durchgeführt wird. Die Symbole haben folgende Bedeutung: New: Die Spalte ist in Framework Studio bisher unbekannt und wird neu eingefügt. Modified: Einige Eigenschaften der Spalte (z.B. Genauigkeit, Größe oder Metadatentyp) unterscheiden sich von den Vorgaben durch die Datenbank. Diese Eigenschaften werden geändert. OK: Die Konfiguration in Framework Studio stimmt mit der Datenstruktur in der Datenbank überein. Sie haben trotzdem die Möglichkeit, den Metadatentypen zu ändern. Delete: Diese Spalte ist in Framework Studio angelegt worden, existiert aber nicht in der Datenbank. Deshalb wird Sie aus der Konfiguration entfernt. In der Tabellenspalte Metadatatype wird der Metadatentyp, welcher der Spalte zugewiesen wird, festgelegt. In der Combobox stehen alle Metadatentypen zur Auswahl, deren Datentyp sich mit dem der Datenbankspalte vertragen. Außerdem haben Sie die Möglichkeit, über den Eintrag Create ’mdtBeispieldatentyp’ für diese Datenbankspalte einen neuen Metadatentypen generieren zu lassen. In der Tabellenspalte Action Description werden die einzelnen Änderungen aufgeführt, die bei einem Update der Spalte durchgeführt werden. Die alten Werte werden in runden Klammern hinter den neuen Werten aufgeführt. Mit der Checkbox in der Tabellenspalte Update legen Sie für jede einzelne Datenbankspalte fest, ob die vorgeschlagenen Änderungen tatsächlich durchgeführt werden sollen. Mit den Buttons und legen Sie fest, dass alle Datenbankspalten bzw. keine Datenbankspalte aktualisiert werden soll. Durch einen Klick auf gelangen Sie zur Zusammenfassung der vorzunehmenden Änderungen. Sie können den Aktualisierungsvorgang nun mit dem Button starten. Update Table (Zusammenfassung): Wenn Sie automatisch neue Metadatentypen generieren lassen, haben Sie die Möglichkeit, den Namespace auszuwählen, in dem der Metadatentyp angelegt werden soll. Select Namespace: Sie können für jeden neu zu erstellenden Metadatentypen einzeln einen Namespace auswählen oder durch Setzen der Checkbox Create all Metadatatypes in this Namespace alle Metadatentypen im gleichen Namespace erzeugen lassen. Mit dem Button New Namespace können Sie im ausgewählten Namespace einen neuen Namespace anlegen. Auslagerung historischer Daten Sehr große Datenvolumen in Tabellen mit aktuellen und historischen, viele Jahre alten Daten, können die Geschwindigkeit der Anwendung bremsen. Werden die historischen Daten in eine spezielle Tabelle ausgelagert, so kann Framework Studio abhängig von einem Laufzeitschalter beim Laden von Components entweder die aktuellen Daten oder alle Daten berücksichtigen. Der Geschwindigkeitsvorteil entsteht im Wesentlichen dadurch, dass im täglichen Betrieb nur mit den aktuellen Daten, also einer geringeren Datenmenge gearbeitet werden muss. Dem Datenbankadministrator wird außerdem die Möglichkeit gegeben, die historischen Daten auf einer langsameren Hardware zu speichern. Der Mechanismus ist für sehr große Datenmengen interessant. Typische Anwendungsfälle sind Journaltabellen, in denen viele Millionen Datensätze abgelegt sind. Details An DBTables kann über die Checkbox Use History festgelegt werden, ob historische Daten in eine separate Tabelle ausgelagert sind. Diese Eigenschaft kann auch in Customizing Packages nachträglich gesetzt werden. Ist der Schalter für eine Tabelle Xyz gesetzt, geht Framework Studio davon aus, dass eine Tabelle Xyz_H (für die historischen Daten) und ein View Xyz_A , welcher mit Union All die Daten aus Xyz und Xyz_H vereint, vorhanden ist. Tabelle und View können von der Endanwendung (z.B. beim Update) automatisch generiert werden. Note Für das Übertragen von Daten aus der Tabelle Xyz in die Historientabelle Xyz_H ist manuelle Programmierung nötig. Wird versucht, einen historischen Datensatz zu speichern, so wird eine Exception ausgelöst. Am Global Object (this.Global) gibt es einen Schalter Use History , mit dem global entschieden wird, ob beim Laden historische Daten berücksichtigt werden sollen. Ist der globale Schalter Use History gesetzt und an einer Tabelle ist der Schalter Use History ebenfalls gesetzt, so wird beim Laden statt auf die Originaltabelle auf den View zugegriffen. Um temporär den Historienmodus zu aktivieren, kann folgendes Using Konstrukt verwendet werden: // Historienmodus temporär erzwingen: using(this.Global.UseHistoryTemporarily()) { ... } Alle Components , die einen Datenbankbezug haben, bieten die Funktion GetTableName an. Diese Funktion gibt den Tabellennamen inklusive Alias zurück, zum Beispiel „Artikel_A as Artikel“ . Diese Funktion eignet sich für die Formulierung von Sub Selects. Für die manuelle Formulierung von Update-, Insert- oder Delete Statements kann an der Component Instanz auf QueryInfo.GetJoinInfo().FirstOrDefault().Table.TableName zugegriffen werden. Erzeugen einer Komponente Über den Menüpunkt Component / Create Component öffnet sich das gleichnamige Fenster. Hier wird eine Abfrage erzeugt, die genau die Daten aus der Datenbank holt, welche Sie über Ihren DBTable definiert haben. New Component Wizard / Create Component Aktivieren Sie die Checkbox Create a Collection for the Component , um gleichzeitig eine Collection zu der Komponente zu erzeugen. Die Collection wird in dem gleichen Namespace erzeugt und trägt das Suffix Coll (also cdXxxColl). Der Button Next auf der Maske Create Component öffnet das Fenster Choose Namespace . New Component Wizard / Choose Namespace Im Fenster Choose Namespace wählen Sie den Namespace aus, in dem die neue Komponente erzeugt werden soll. Über den Button Next öffnet sich das Fenster Summary . Es zeigt Ihnen eine Zusammenfassung Ihrer Einstellungen . Summary Mit Finish wird die Komponente erzeugt. Alle angezeigten Tabellen werden ebenfalls über Source Control gesteuert. Das bedeutet, dass Elemente, die editiert werden sollen, ausgecheckt und zum Übernehmen der Änderungen wieder eingecheckt werden müssen. In dieser Ansicht ist nicht direkt erkennbar, welche Elemente ausgecheckt sind und welche nicht. Sie sollten es sich deshalb zur Gewohnheit machen, Ihre Database-Elemente so schnell wie möglich wieder einzuchecken und so für andere Entwickler verfügbar zu machen. Tabellen können eingecheckt werden, indem Sie sie in der Tabelle auswählen und dann über das Hauptmenü Source Control / Check In wählen."
  },
  "doc/database/ml-column.html": {
    "href": "doc/database/ml-column.html",
    "title": "ML-Column",
    "keywords": "ML-Column Framework Studio bietet einen Mechanismus, um Dateninhalte in mehreren Sprachen zu speichern. Eine beliebige Tabellen-Spalte, in der eine Zeichenkette abgelegt ist, kann im Tabelleneditor als MLColumn markiert werden. Vorraussetzung ist jedoch, dass die Tabelle die Spalte FSRowID enthält, weil diese als eindeutige Referenz auf den Datensatz benötigt wird. Ist eine Tabellen-Spalte als MLColumn gekennzeichnet, dann werden die fremdsprachigen Texte in der Tabelle dbRun_MLStrings abgelegt. Die normale Tabellen-Spalte beinhaltet die Texte in Default-Sprache. Caution Fehlt einer Component das Property ROWID (mit Mapping auf die DB-Column FSRowID ), ist der Mechanismus für diese Component deaktiviert. Join-Components können keine ML-Columns aus mehreren Tabellen verabreiten, da die Component lediglich ein ROWID-Property betrachtet. Werden mehrere ROWID-Properties aus verschiedenen Tabellen eingebunden, dann ist es Zufall, welche ROWID für den MLColumn-Mechanismus herangezogen wird. Customizing-Package Die Eigenschaft MLColumn kann im Customizing-Package gesetzt werden. Somit kann man in Kunden-Umgebungen den Mechanismus gezielt für die gewünschten Tabellen-Spalten aktivieren. Anwendung in Default-Sprache Die Default-Sprache ist de - außer man definiert der Datenbank-Tabelle dbRun_Config mit dem ConfigKey ML_DEFAULT_LANGUAGE eine andere Default-Sprache. Wird die Anwendung in der Default-Sprache gestartet, dann arbeitet Framework Studio mit der ganz normalen Spalte der Tabelle - ohne jegliche Sonder-Logik. Die fremdsprachigen Texte können nicht beeinflusst werden. Ändert man einen Text, dann bleiben die ggf. existierenden Übersetzungen unverändert erhalten. Bei Bedarf müsste man die Anwendung anschließend in den Fremdsprachen starten und den gewünschten Text dort ebenfalls anpassen. Anwendung in Fremdsprache Startet man die Anwendung mit einer Fremdsprache, dann greifen besondere Mechanismen. Die entsprechenden Component-Properties behandeln dann ausschließlich den fremdsprachigen Text mit einem Fallback auf die Default-Sprache. Die ML-Column-Logik wird von den ganz normalen Component-Properties behandelt. Dadurch wirkt sie sich automatisch auf alle Bereiche der Anwendung aus - inkl. Form-Databinding und Reporting. Load : Beim Zugriff auf das entsprechende Component-Property wird der Text aus der Tabelle dbRun_MLStrings gelesen. Existiert dort kein Eintrag, wird der Text der Default-Sprache aus der normalen Tabellen-Spalte verwendet. Update : Wird der Text geändert, dann wird der Eintrag in der entsprechenden Fremdsprache überschrieben. Der Text in der Default-Sprache kann nicht verändert werden. Wird der fremdsprachige Text geleert, dann wird beim Save der Component der Eintrag aus der Übersetzungs-Tabelle gelöscht und das Component-Property fällt auf die Default-Sprache zurück. Insert : Beim Anlegen eines neuen Datensatzes wird der eingegebene Text sowohl in der normalen Tabelle als auch in der Fremdsprache gespeichert. Delete : Wird der Datensatz aus der Datenbank gelöscht, dann werden auch alle zu dieser FSROWID gespeicherten Texte aus der Übersetzungs-Tabelle gelöscht. Such-Funktion Note Dieses Feature muss in der Datenbank-Tabelle dbRun_Config mit dem ConfigKey ML_SEARCH_ENABLED aktiviert werden. Bei automatischen Suchfeldern werden die Fremdsprachen-Texte zusätzlich berücksichtigt. Wird die Anwendung in einer Fremdsprache ausgeführt, dann enthält die erzeugte SQL-Bedingung beinhaltet sowohl die normale Bedingung, welche den Treffer in der Default-Sprache sucht als auch einen Lookup auf die Texte in der entsprechenden Fremdsprache. -- Beipiel: Select [....] FROM Tabelle WHERE (Spalte LIKE 'abc%' OR EXISTS (SELECT 1 FROM dbRun_MLStrings WHERE ML_TableName = 'TABELLE' AND ML_ColumnName = 'SPALTE' AND ML_Iso = 'en' AND ML_FSROWID = FSROWID AND ML_SearchText LIKE 'abc%')) Note Der Lookup berücksichtigt die ersten 200 Zeichen des Textes. Die Fremdsprachen-Texte können auch Langtexte speichern. Diese lassen sich nicht indizieren. Aus Performance-Gründen erfolgt der Lookup über eine separate indiziere Spalte ML_SearchText . Diese wird (wenn das Feature aktiviert ist) von der Anwendung zusammen mit dem Langtext gespeichert. Sprache zur Laufzeit ändern Die Sprache ist mit dem Start der Anwendung an Global. SelectedLanguage festgelegt. Wird für einen bestimmten Code eine abweichende Sprache benötigt, dann kann dies über Global. UseMLColumnLanguage geschehen. Während der übergebenen Action kann so ein abweichender Iso-Code gesetzt werden. Über das Property Global. MLColumnLanguage kann die aktuell gültige Sprache ermittelt werden. this.Global.UseMLColumnLanguage(\"fr\", () => { // Erzeugen des Reports in französischer Sprache. }); Important Diese Funktion beeinflusst nicht die in der Oberfläche angezeigten Daten. Es gibt keine Möglichkeit dauerhaft auf die Sprache Einfluss zu nehmen. Tips für Entwickler Finden von MLColumns Wird eine DBColumn als MLColumn gekennzeichnet wird dafür der folgende Code generiert: public class Package_FSColumnName : FS.Demo.MDT.ArticleName { public Package_FSColumnName() { this.m_IsMLColumn = true; } } Dadurch können alle MLColumns mit dem Text this.m_IsMLColumn = true; über die Code-Suche gefunden werden. Dabei die Suche auf die DBTables einschränken."
  },
  "doc/documentation/chapter-tree.html": {
    "href": "doc/documentation/chapter-tree.html",
    "title": "Chapter Tree",
    "keywords": "Chapter Tree Allgemein Der Chapter Tree ist die zentrale Instanz, welche alle Form- und Documentation-Elemente in Kapitel organisiert. Zu erreichen ist der Chapter Tree über das Menü Tools -> Documentation -> Chapter Tree . Ein Form- oder Documentation-Element spiegelt in einer exportierten Dokumentation genau ein Kapitel mit eigener Kapitelnummer wider. Chapter Tree für die Organisation der Kapitel: Es gibt zwei Abschnitte im Chapter Tree. Der Documentation (Preparation) -Knoten beinhaltet alle Formulare und Documentation-Elemente, die in einer Anwendung neu hinzugekommen oder noch nicht in die Dokumentation eingebunden wurden. Sie werden alphabetisch aufsteigend aufgelistet. Der Documentation (Release) -Knoten spiegelt den Kapitelbaum der Dokumentation wieder, die mit dem Export Wizard gerendert werden kann. Als Text wird die im Dokumentations-Editor angegebene Caption des Formulars oder Documentation-Elements angezeigt. Ist diese nicht definiert wird in Klammern hinter dem Namen des Formulars oder Documentation-Elements der Zusatz “caption not set” angezeigt. Die Form- oder Documentation-Elemente können aus dem Chapter Tree mit einem Doppelklick auf den Knoten oder mit der Entertaste direkt geöffnet werden. Die Textbox am unteren Rand zeigt den vollen Namespace des aktuell ausgewählten Knoten an. Kapitelstruktur Wird die Dokumentation wie in der Abbildung mit dem Export Wizard in eine Word-Datei exportiert, folgt die Kapitelnummerierung der Ebene des Documentation (Release) -Knotens. Wie im Beispiel zu sehen hätten die folgenden Kapitel die angegebenen Kapitelnummern: Einführung in das Programm eNVenta = 1. eNVenta ERP = 2. Initialisierung = 5. eNVenta Init = 5.1 Da Word bis zu 9 Ebenen unterstützt, können auch im Chapter Tree die Formulare und Documentation-Elemente in bis zu 9 Ebenen (x.x.x.x.x.x.x.x.x) verschachtelt werden. Um ein Kapitel an eine andere Stelle einzufügen bzw. ein Kapitel aus dem Preparation- in den Release-Knoten zu verschieben, muss nur der entsprechende Knoten per Drag&Drop an die richtige Position gezogen werden. Sind nicht alle beteiligten Elemente im Framework Studio ausgecheckt, wird eine entsprechende Meldung angezeigt. Auschecken von beteiligten Elementen: Im Beispiel wurde der Knoten CSV Format Konversion aus dem Preparation-Knoten in den Release-Bereich unter das Kapitel eNVenta ERP -> Wv-Übersicht gezogen. Keines der Elemente war zu diesem Zeitpunkt ausgecheckt."
  },
  "doc/documentation/control-features.html": {
    "href": "doc/documentation/control-features.html",
    "title": "Control Features",
    "keywords": "Control Features Es gibt einige Einstellungen, die speziell an Controls verfügbar sind. Manche dieser Einstellungen sind an allen Controls verfügbar, andere wiederum nur an Controls eines bestimmten Typs. Wenn ein Control im Designer ausgewählt ist, sind alle verfügbaren Einstellungen unter der Kategorie Documentation zu finden. Alle Controls Documentation Öffnet den Dokumentations-Editor (siehe Editor ) HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. TabbedWindow ChaptersForTabs Gibt an, ob die Registerkarten des TabbedWindow als eigenständige Kapitel in die Dokumentation gerendert werden sollen. Dieser Schalter ist nur für TabbedWindows auf oberster Ebene vorgesehen. Er zieht also nicht für TabbedWindows, die z.B. in einem Panel verschachtelt sind. ImageButton ShowImageInDocumentation Gibt an, ob das am Control hinterlegte Bild in die Control-Überschrift in der Dokumentation gerendert werden soll oder nicht."
  },
  "doc/documentation/customizing.html": {
    "href": "doc/documentation/customizing.html",
    "title": "Customizing",
    "keywords": "Customizing Sections sind nur in Dokumentationen von Forms und Documentation-Elementen verfügbar und dienen dazu, längere Texte in Abschnitte zu unterteilen, die in Customizations dieser Elemente ausgetauscht oder ergänzt werden können. Beispiel: Eine Dokumentation eines Forms in Package P1 sieht wie folgt aus: Es ist zu sehen, dass der Text in zwei Sections unterteilt ist, die jeweils mit einer einmaligen ID ausgestattet sind. Wird dieses Form nun in einem Package P2 gecustomized und an der Funktion des Forms Änderungen vorgenommen, die danach nicht mehr mit der Dokumentation aus der Basis übereinstimmen, muss die Dokumentation der Customization ebenfalls angepasst werden. Meistens ist es jedoch der Fall, dass nur einzelne Teile oder nur wenige Sätze aus der bisherigen Dokumentation geändert werden müssen, um die Dokumentation zu korrigieren. Im konkreten Beispiel könnte im gecustomizten Form die Möglichkeit geschaffen worden sein, Auftragspositionen auch kopieren zu können. Diese Information sollte nun in die Dokumentation des neuen gecustomizten Forms eingefügt werden. Praktisch wäre natürlich eine Ergänzung nach dem ersten Satz „…editiert oder gelöscht werden.“ . Während in einem einzelnen Package die Sections funktionslos sind, stellen sie beim Customizing von Forms oder Documentation-Elementen einen Einsprungpunkt für zusätzliche Dokumentationen bereit. Um die zusätzliche Information in die Dokumentation einzufügen, muss im gecustomizten Form eine neue Section über den Button in der Werkzeugleiste erstellt werden: Customizing einer Section: Framework Studio erkennt, dass das Form gecustomized wurde und listet in der Combobox Base Section alle in der Basis verfügbaren Section-ID’s auf. Über das Panel Other des Editors kann zur Kontrolle der zu editierenden Section(-ID) die Basis-Dokumentation des Formulars angezeigt werden. Im Dialog für die Section-Auswahl gibt es drei Möglichkeiten, eine Section zu überschreiben: Override Die Section aus der Basis wird durch den neuen Text ersetzt. Before Der neue Text wird beim Rendern der Dokumentation des gecustomizten Formulars vor dem Text aus der Basis eingefügt. After Der neue Text wird beim Rendern der Dokumentation des gecustomizten Formulars nach dem Text aus der Basis eingefügt. Wird der Dialog geschlossen, wird eine neue Section erstellt, die ein customize -Attribut beinhaltet, in der die ausgewählte Customizing-Methode steht. Die zusätzliche Information (Auftragspositionen können kopiert werden) kann nun eingegeben werden. Wird eine Vorschau der Dokumentation gerendert, erscheint der neue Text an der gewünschten Stelle in der Basis-Dokumentation (in diesem Fall hinter dem ersten Satz aus der Basis)."
  },
  "doc/documentation/doc2help.html": {
    "href": "doc/documentation/doc2help.html",
    "title": "Doc2Help",
    "keywords": "Doc2Help Important Da Framework Studio mittlerweile auch selbst in der Lage ist, mittels des HTML-Exports ( HTML ) komplette Online-Hilfen zu generieren, sollte diese Möglichkeit verwendet werden, da Doc2Help Größenbeschränkungen hat, die bei sehr umfangreichen Dokumentationen ggf. zu Fehlern führen können. Doc2Help ist eine Anwendung der Firma ComponentOne , die in der Lage ist, aus Word-Dateien Onlinehilfen in HTML zu generieren. Um normale docx-Dateien jedoch mit Doc2Help verarbeiten zu können, müssen einige Vorkehrungen getroffen werden. Framework Studio bietet die Möglichkeit, mit der Option Doc2Help in den Wizard-Optionen eben diese Vorkehrungen automatisch zu treffen. Um z.B. in einer von Doc2Help generierten Onlinehilfe über einen Url-Parameter ein bestimmtes Kapitel aufzurufen, muss an jede Überschrift in Word eine besondere Formatvorlage eingebunden werden und ein Parameter mit dem Namen asciiname definiert werden. Parameter am Kapitel für Doc2Help: Wird eine Dokumentation über den Export Wizard erstellt und die Option Doc2Help aktiviert ist, sind keine weiteren Anpassungen an der Word-Datei nötig. Die Dokumentation kann in Doc2Help importiert und sofort in eine Onlinehilfe konvertiert werden."
  },
  "doc/documentation/docml.html": {
    "href": "doc/documentation/docml.html",
    "title": "DocML",
    "keywords": "DocML Bei einer Dokumentation in Textform bedarf es grundsätzlich der Möglichkeit, den Text zu formatieren und zu strukturieren. Für diesen Zweck bedient sich Framework Studio der eigens entwickelten Dokumentationssprache DocML . Ein Vorteil dieser Sprache ist, dass sie in beliebige andere Formate konvertiert werden kann. So ist die Vorschau einer Dokumentation in Framework Studio z.B. in Form von HTML realisiert. Es besteht aber auch die Möglichkeit, die gesamte Dokumentation als Worddatei zu exportieren. Um einen ersten Eindruck der Sprache zu bekommen folgt ein kurzer Auszug einer Dokumentation eines Formulars: Und hier die Ausgabe im Preview-Fenster in Framework Studio (HTML): Aufbau der Sprache Die Sprache DocML besteht weitestgehend aus dem Text, welcher die Dokumentation widerspiegelt sowie Tags, die mit Attributen versehen sein können, um den beinhaltenden Text zu formatieren oder zu strukturieren. Tags Ein Tag definiert sich durch eine öffnende eckige Klammer [ , einem Bezeichner (um welches Tag es sich handelt), gefolgt von einer schließenden eckigen Klammer ] : [ + Bezeichner + ] Beispiele: [b] , [tbl] , [f] , [ac] Dabei wird zwischen öffnenden und schließenden Tags unterschieden. Das schließende Tag beinhaltet nach der öffnenden Klammer einen Schrägstrich / : [/ + Bezeichner + ] Beispiele: [/b] , [/tbl] , [/f] , [/ac] Angewendet wird ein Tag immer auf den Text, der zwischen dem öffnenden und schließenden Tag steht: [b] Dies ist ein fett gedruckter Text [/b] Tags können ineinander geschachtelt werden um mehrere Formatierungen auf einen Textabschnitt vorzunehmen: [b][i] Dies ist ein fett gedruckter und kursiver Text [/i][/b] Es ist zu beachten, dass öffnende Tags genau in der umgekehrten Reihenfolge geschlossen werden müssen. Folgende Beispiele sind korrekt: [b][i] Ein Text [/i][/b] [i][b] Ein Text [/b][/i] [b][i][u] Ein Text [/u][/i][/b] Folgende Beispiele sind nicht korrekt: [b][i] Ein Text [/b][/i] [i][b] Ein Text [/i][/b] [b][i][u] Ein Text [/b][/u][/i] Eine komplette Auflistung aller verfügbaren Tags in DocML und deren Funktion findet sich im Kapitel Tag Reference . Leere Tags Eine besondere Untergruppe der Tags bilden die leeren Tags. Dies sind öffnende und schließende Tags in einem. Leere Tags können keinen Text oder andere Tags beinhalten. Leere Tags definieren sich durch eine öffnende eckige Klammer [ , den Bezeichner, einen Schrägstrich / und die schließende eckige Klammer ] : [ + Bezeichner + / + ] Beispiele: [screenshot/] , [img/] , [br/] Diese leeren Tags dienen z.B. dem Einfügen eines Bildes oder Zeilenumbruch in die Dokumentation. Tag-Attribute Die meisten Tags können in ihrem Verhalten durch Attribute gesteuert werden. Ein Attribut definiert sich durch einen Bezeichner gefolgt, von einem Gleichheitszeichen = sowie dem Attributwert in Hochkommas. Attribute können in öffnenden und leeren Tags vorkommen: In öffnendem Tag: [f bg=\"ff0000\" ] Text mit roter Hintergrundfarbe [/f] In leerem Tag: [screenshot caption=\"Auftragserfassung\" /] Im Kapitel Tag Reference ist ausführlich beschrieben, welcher Tag mit welchen Attributen gesteuert werden kann. Tag Reference Nachfolgend werden alle verfügbaren Tags und die zugehörigen Attribute der DocML -Sprache beschrieben. Die Tags unterscheiden sich in zwei Klassen, Inline-Tags und Block-Tags . Inline-Tags werden meist für Formatierungszwecke genutzt wie z.B. Fettschrift oder Textfarbe, während Block-Tags Strukturen wie Tabellen, Listen oder Abschnitte definieren. Warning Grundsätzlich gilt: Inline-Tags können keine Block-Tags beinhalten Inline-Tags Font Eigenschaften: Bezeichner: [f] Leeres Tag: nein Funktion: Wendet Schriftart, Schriftgröße, Schriftfarbe und Hintergrundfarbe auf den beinhaltenden Text an Attributes: Bez. Benötigt Mögliche Werte Funktion style nein Normal, Code Stellt die Schriftart zwischen Arial und einer Code-Schriftart um size nein XXXL, XXL, XL, L, Normal, S, XS, XXS oder XXXS Schriftgröße fc nein Systemfarben wie red , black , blue oder Farbangaben in HEX wie z.B. #FF00000 Textfarbe bc nein Systemfarben wie red , black , blue oder Farbangaben in HEX wie z.B. #FF00000 Hintergrundfarbe Beispiel: [f style=\"code\" size=\"xl\" fc=\"red\" bc=\"#00ff00\"]Möglichkeiten des Font-Tags[/f] Bold Eigenschaften: Bezeichner: [b] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als fett geschrieben Attributes: Keine Beispiel: [b]Dieser Text ist fett geschrieben[/b] Italic Eigenschaften: Bezeichner: [i] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als kursiv geschrieben Attributes: Keine Beispiel: [i]Dieser Text ist kursiv geschrieben[/i] Underline Eigenschaften: Bezeichner: [u] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als unterstrichen Attributes: Keine Beispiel: [u]Dieser Text ist unterstrichen[/u] Strikethrough Eigenschaften: Bezeichner: [s] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als durchstrichen Attributes: Keine Beispiel: [s]Dieser Text ist durchstrichen[/s] Subscript Eigenschaften: Bezeichner: [sub] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als tiefgestellt Attributes: Keine Beispiel: [sub]Dieser Text ist tiefgestellt[/sub] Superscript Eigenschaften: Bezeichner: [sup] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als hochgestellt Attributes: Keine Beispiel: [sup]Dieser Text ist hochgestellt[/sup] Align Left Eigenschaften: Bezeichner: [al] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als linksbündig Attributes: Keine Beispiel: [al]Dieser Text ist linksbündig[/al] Center Eigenschaften: Bezeichner: [ac] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als zentriert Attributes: Keine Beispiel: [ac]Dieser Text ist zentriert[/ac] Align Right Eigenschaften: Bezeichner: [ar] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als rechtsbündig Attributes: Keine Beispiel: [ar]Dieser Text ist rechtsbündig[/ar] Justify Eigenschaften: Bezeichner: [aj] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als Blocksatz Attributes: Keine Beispiel: [aj]Dieser Text ist im Blocksatz geschrieben[/aj] Image Eigenschaften: Bezeichner: [img] Leeres Tag: ja Funktion: Bindet eine Bildressource aus Framework Studio in die Dokumentation ein Besonderheiten: Wird nur das width- oder height-Attribut angegeben, wird das Seitenverhältnis des Bildes beibehalten. Werden keine Größenangaben gemacht, wird die Größe des Quellbildes verwendet. Eine Bildbezeichnung (caption-Attribut) kann nur definiert werden, wenn das inline-Attribut nicht definiert ist oder den Wert false hat. Attributes: Bez. Benötigt Mögliche Werte Funktion src ja ID einer Framework Studio Bildressource Verweist auf das Bild, welches in der Framework Studio Resource eingebunden ist width nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Breite des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“) height nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Höhe des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. height=“4.7in“) caption nein Text Bildbezeichnung inline nein true , false Wenn true wird das Bild wird ein Textzeichen im Textfluss behandelt, sonst wird eine neue Zeile eingefügt Beispiel: [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" height=\"1.5cm\" inline=\"true\"/] [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" caption=“Beispielbild“/] [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" width=“3cm“ height=\"1.5cm\" caption=“Test“/] Screenshot Eigenschaften: Bezeichner: [screenshot] Leeres Tag: ja Funktion: Bindet einen automatisch generierten Screenshot des Forms als Bild in die Dokumentation ein. Besonderheiten: Kann nur in Form-Dokumentationen verwendet werden. Werden keine Größenangaben gemacht, wird die Größe des Forms verwendet. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Breite des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“) caption nein Text Bezeichnung des Screenshots Beispiel: [screenshot/] [screenshot width=\"17cm\"/] [screenshot width=\"14.3in\" caption=\"Kostenrechnung\"/] Link Eigenschaften: Bezeichner: [lnk] Leeres Tag: ja Funktion: Erstellt einen Querverweis auf ein anderes Kapitel oder einen Hyperlink auf eine Url. Attributes: Bez. Benötigt Mögliche Werte Funktion src ja • ID eines Forms oder Documentation-Elements • Url mit führendem http:// Querverweis in der fertigen Dokumentation oder Hyperlink auf die angegebene Url text ja Text Der angezeigte Text des Links Beispiel: [lnk src=\"f037492b790d24c5b9f16cb4120465e25\" text=\"Artikeldetails\"/] [lnk src=\"http://www.google.de/\" text=\"Suchen mit Google\"/] Index Entry Eigenschaften: Bezeichner: [idx] Leeres Tag: ja Funktion: Erstellt einen Eintrag im Index der Dokumentation. Attributes: Bez. Benötigt Mögliche Werte Funktion entry ja text Definiert einen Haupteintrag im Index subentry nein Text Definiert einen Untereintrag unter dem Haupteintrag Beispiel: [idx entry=\"Haupteintrag\"/] [idx entry=\"Haupteintrag\" subentry=\"Untereintrag\"/] Base Eigenschaften: Bezeichner: [base] Leeres Tag: ja Funktion: Bindet die Basis-Dokumentation eines Controls, Component Properties, einer DBColumn oder eines Metadatentyps ein. Besonderheiten: Wird nur an Control, Component Property, DBColumn und Metadatentyp unterstützt. Mehr Information in den Kapiteln Vererbung und Customizing . Attributes: Keine Beispiel: [idx entry=\"Haupteintrag\"/] [idx entry=\"Haupteintrag\" subentry=\"Untereintrag\"/] Line Eigenschaften: Bezeichner: [line] Leeres Tag: ja Funktion: Erstellt eine Line als Absatztrenner über die komplette Seitenbreite. Attributes: Keine Beispiel: [line/] Break Eigenschaften: Bezeichner: [br] Leeres Tag: ja Funktion: Erstellt einen Zeilenumbruch. Attributes: Keine Beispiel: [br/] Block-Tags Section Eigenschaften: Bezeichner: [section] Leeres Tag: optional Funktion: Definiert einen Textabschnitt in einer Form-Dokumentation oder einem Documentation-Element, der durch die angegebene ID customizing-fähig ist. Siehe Customizing . Besonderheiten: Kann sich nur auf oberster Ebene und somit nicht in anderen Tags befinden. Wird nur in Form- und Documentation-Elementen unterstützt. Attributes: Bez. Benötigt Mögliche Werte Funktion id ja 32-stellige GUID Eindeutige ID des Textabschnitts customize Im Custom-Package before, after, override Überschreibungsart der gecustomizten Section Beispiel: [section id=“ f0bcfd1621444f6f9f24bc9305120809“/] [section id=“ f0bcfd1621444f6f9f24bc9305120809“ customize=“after“/] List Eigenschaften: Bezeichner: [lst] Leeres Tag: nein Funktion: Erstellt eine geordnete oder ungeordnete Liste von ListItems (li-Tags). Besonderheiten: Kann nur li-Tags beinhalten. Das Symbol kann nur definiert werden, wenn das type-Attribut als „unordered“ definiert ist. Attributes: Bez. Benötigt Mögliche Werte Funktion type ja ordered, unordered Definiert den Listentyp symbol nein disk, circle, square Definiert das Listensymbol bei ungeordneten Listen Beispiel: [lst type=\"unordered\" symbol=\"square\"] [li]ListItem 1[/li] [li]ListItem 2[/li] [li]ListItem 3[/li] [/lst] [lst type=\"ordered\"] [li]ListItem 1[/li] [li]ListItem 2[/li] [li]ListItem 3[/li] [/lst] ListItem Eigenschaften: Bezeichner: [li] Leeres Tag: nein Funktion: Erstellt einen Eintrag in einer Liste. Besonderheiten: Kann nur innerhalb von lst-Tags verwendet werden. Attributes: Keine Beispiel: [lst type=\"unordered\" symbol=\"square\"] [li]Ein ListItem[/li] [li]Noch ein ListItem[/li] [/lst] Table Eigenschaften: Bezeichner: [tbl] Leeres Tag: nein Funktion: Erstellt eine Tabelle. Besonderheiten: Die Breite der Tabelle kann absolut als auch prozentual angegeben werden. Wird keine Breite angegeben, definiert sich die Tabellenbreite über die Summe der Spaltenbreiten. Ist die Tabellenbreite in Prozent angegeben, müssen auch die Spaltenbreiten in Prozent angegeben werden. Ist keine Tabellenbreite angegeben, müssen die Spaltenbreiten in absoluten Werten angegeben werden. Eine Tabelle muss eine Spaltendefinition (coldef-Tag) inkl. Spalten (col-Tags) sowie mindestens eine Zeile (row-Tag) beinhalten. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein • Absolute Angaben wie z.B. „2.3cm“, „3.3in“, „14,34cm“ • Prozentuale Angaben wie z.B. „50%“, „75%“ Breite der Tabelle. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“). Die prozentuale Angabe bezieht sich auf die Seitenbreite bzw. die Fensterbreite im HTML fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. Beispiel: Ausgabe: Column Definition Eigenschaften: Bezeichner: [coldef] Leeres Tag: nein Funktion: Beinhaltet die Spaltendefinition einer Tabelle. Besonderheiten: Muss ein oder mehrere Spalten (col-Tags) beinhalten. Kann nur innerhalb eines tbl-Tags vorkommen. Kann innerhalb eines tbl-Tags nur einmal vorkommen. Kann nur col-Tags beinhalten. Muss innerhalb des tbl-Tags als erstes auftreten (vor jeglichen Zeilendefinitionen bzw. row-Tags). Attributes: Keine Beispiel: [coldef] [col width=\"50%\"/] [col width=\"50%\" fc=\"#ddee32\" bc=\"#dd3331\" align=\"right\"/] [/coldef] Column Eigenschaften: Bezeichner: [col] Leeres Tag: ja Funktion: Definiert eine Spalte innerhalb einer Tabelle. Besonderheiten: Kann nur innerhalb eines coldef-Tags vorkommen. Die Breite der Spalte kann absolut oder prozentual angegeben werden. Ist die Tabellenbreite (im tbl-Tag) prozentual angegeben, muss die Spaltenbreite ebenfalls prozentual angegeben werden. Ist keine Tabellenbreite (im tbl-Tag) angegeben, muss die Spaltenbreite absolut angegeben werden. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein • Absolute Angaben wie z.B. „2.3cm“, „3.3in“, „14,34cm“ • Prozentuale Angaben wie z.B. „50%“, „75%“ Breite der Tabelle. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“). Die prozentuale Angabe bezieht sich auf die Seitenbreite bzw. die Fensterbreite im HTML fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. align nein left, center, right Horizontale Ausrichtung der Spalte. Kann durch das colalign-Attribut an der Zelle überschrieben werden. Beispiel: [col width=\"4.5cm\"/] [col width=\"50%\" fc=\"#ddee32\" bc=\"#dd3331\" align=\"right\"/] Row Eigenschaften: Bezeichner: [row] Leeres Tag: nein Funktion: Definiert eine Zeile innerhalb einer Tabelle. Besonderheiten: Kann nur innerhalb eines tbl-Tags vorkommen. Muss innerhalb des tbl-Tags unterhalb des coldef-Tags stehen. Kann nur cell-Tags beinhalten. Attributes: Bez. Benötigt Mögliche Werte Funktion fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. align nein top, middle, bottom Vertikale Ausrichtung der Zeile. Kann durch das rowalign-Attribut an der Zelle überschrieben werden. Beispiel: [row fc=“#ddee43“] [cell]Zelle links oben[/cell] [cell rowalign=“top“]Zelle rechts oben[/cell] [/row] [row fc=\"GreenYellow\" bc=\"Linen\" align=\"bottom\"] [cell]Zelle links unten[/cell] [cell bc=\"black\" colalign=\"left\" rowalign=\"middle\"]Zelle rechts unten[/cell] [/row] Cell Eigenschaften: Bezeichner: [cell] Leeres Tag: nein Funktion: Definiert eine Zelle innerhalb einer Zeile. Besonderheiten: Kann nur innerhalb eines row-Tags vorkommen. Muss innerhalb eines row-Tags genauso oft vorkommen wie die Anzahl der Spalten im coldef-Tag der Tabelle. Attributes: Bez. Benötigt Mögliche Werte Funktion fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. rowalign nein top, middle, bottom Vertikale Ausrichtung der Zelle. colalign nein left, center, right Horizontale Ausrichtung der Zelle. Beispiel: [row fc=“#ddee43“] [cell fc=“#3434ee“]Zelle links oben[/cell] [cell colalign=“center“]Zelle rechts oben[/cell] [/row] [row fc=\"GreenYellow\" bc=\"Linen\" align=\"bottom\"] [cell]Zelle links unten[/cell] [cell bc=\"black\" colalign=\"left\" rowalign=\"middle\"]Zelle rechts unten[/cell] [/row] Headline Eigenschaften: Bezeichner: [h1] Leeres Tag: nein Funktion: Erstellt eine Überschrift. Besonderheiten: Es gibt drei verschiedene Headline-Tags h1, h2 und h3. Headline-Tags können nicht in anderen Headline-Tags eingefügt werden. In Headline-Tags können [i] , [u] und [s] Format-Tags benutzt werden. Attributes: Keine Beispiel: [h1]Überschrift h1[/h1] [h2]Überschrift h2[/h2] [h3]Überschrift h3[/h3] [h3]Überschrift [i]h3[/i][/h3] [h2]Überschrift [s]h2[/s][/h2]"
  },
  "doc/documentation/dokumentations-system.html": {
    "href": "doc/documentation/dokumentations-system.html",
    "title": "Dokumentations-System",
    "keywords": "Dokumentations-System Framework Studio bietet die Möglichkeit, die entwickelten Applikationen mittels eines in die IDE integrierten Dokumentationssystems zu dokumentieren. Im Gegensatz zu herkömmlichen Dokumentationen mittels Microsoft Word oder Latex bietet das System jedoch gravierende Vorteile, da es komplett an die Datenstruktur und –hierarchie von Framework Studio angepasst ist. Features Um den Einstieg in das Dokumentationssystem zu vereinfachen, werden im Folgenden die wichtigsten Features vorgestellt. Automatische Generierung der Dokumentationsstruktur „Wo steht was?“ ist ein großes Problem im Bereich Dokumentation. Ein Mitarbeiter beschreibt erst die Steuerelemente des Formulars und danach dessen Funktionalität, ein anderer macht es genau anders herum. Framework Studio trennt sich vom klassischen Weg der Dokumentationserstellung. Egal, ob die Dokumentation später als Word oder HTML exportiert wird, die Struktur bleibt dieselbe. Jedes Formular folgt dem gleichen Schema, alles hat seinen zugewiesenen Platz durch vordefinierte Formatvorlagen seitens Framework Studio. Vererbung vom Metadatentyp bis zum Steuerelement Hinter fast jedem Steuerelement in Framework Studio verbirgt sich als DataSource ein Component Property, eine DBColumn oder ein Metadatentyp . Hier verhält sich die Dokumentation ähnlich wie die Tooltips. Wird ein Metadatentyp dokumentiert, steht diese Dokumentation auch am Steuerelement zur Verfügung und wird in die endgültige Fassung herausgerendert. Dokumentationen können vererbt, gecustomized und überschrieben werden, sollte sich z.B. der Kontext in einem Formular ändern. Customizing und Package-Struktur Das Herz von Framework Studio bildet das Package-System. Das Dokumentationssystem folgt diesem und bietet voll Customizing-fähige Dokumentationen über Package-Grenzen hinweg. Vererben, überschreiben, anhängen, austauschen… die Dokumentation ist anpassbar bis zum letzten Satz. Mehrsprachigkeit Erfassen Sie die Dokumentation in allen möglichen Sprachen. Der Dokumentationseditor unterstützt das parallele Bearbeiten von mehreren Sprachen. Wenn Sie die englische Dokumentation schreiben, nehmen Sie sich einfach die deutsche Dokumentation als Vorlage für die Übersetzung zur Hand. Screenshot-Generierung Screenshot erstellen, in das Grafikprogramm laden, den Ausschnitt zurechtschneiden, Screenshot in das Dokument einfügen, Größe anpassen… und nach einer Woche ist der Screenshot veraltet, weil drei neue Steuerelemente hinzugekommen sind. Um dieses Problem aus dem Weg zu schaffen, bietet das Dokumentationssystem eine Screenshot-Generierung für Formulare. Bei jedem Herausschreiben der Dokumentation wird von Framework Studio anhand der Steuerelementdaten des Designers ein Screenshot des Formulars erstellt und automatisch in die Dokumentation eingefügt. So sind die Masken in der Dokumentation stets auf dem neuesten Stand und der Benutzer findet jedes Steuerelement wo er es erwartet. Theme Support In Framework Studio 3.5 hielten Themes Einzug in die IDE. Die Dokumentation lässt sich für verschiedene Themes rendern. Sind beispielsweise automatisch generierte Screenshots in die Dokumentation eingebunden, werden diese im jeweiligen Theme gerendert. Auch für eingebundene Bilder können je Theme unterschiedliche Bilder definiert werden. Aufbau des Dokumentationssystems Die beiden Elemente, die das Fundament des Dokumentationssystems bilden, sind das Form- und das Documentation-Element (siehe Documentation-Element ). Diese Elemente werden mittels einer Baumstruktur (siehe Chapter Tree ) in Kapitel unterteilt. Somit bildet jedes Form- oder Documentation-Element ein Kapitel mit eigener Kapitelnummer in der fertigen Dokumentation ab. Form Sie erkennen Form an einem -Icon. Elemente des Forms mit Dokumentation: Ein Form definiert sich grundsätzlich durch dessen Controls. Jedes Control kann eine DataSource zugewiesen haben, die über ein Component Property auf eine DBColumn verweist, die wiederum einen Wert eines Metadatatypes kapseln kann. Diesem Mechanismus folgt das Dokumentationssystem. Es besteht die Möglichkeit, auf jeder einzelnen Ebene in Framework Studio eine Dokumentation zu hinterlegen, die von der nächst höheren Instanz verwendet werden kann (siehe Vererbung ). So können am Metadatentyp z.B. Informationen zum Wertebereich oder zur Genauigkeit angegeben werden. In der Dokumentation des Controls, welches auf diesen Metadatentyp verweist, kann z.B. die Dokumentation des Metadatentyps eingebunden werden und steht dem Leser somit als zusätzliche Information zur Verfügung. Während in der Dokumentation eines Controls ausschließlich auf die Funktion dessen eingegangen werden sollte, dient die Dokumentation des Formulars der generellen Beschreibung, d.h. es können beliebige Texte verfasst werden, die die Funktionalität des Formulars im Gesamten beschreibt. So können Beispiele, Prozesse, Arbeitsanweisungen usw. beschrieben werden. Im Gegensatz zu den Control-Dokumentationen werden Form-Dokumentationen in sogenannte Sections unterteilt. Diese dienen als Text-Trenner für das Customizing (siehe Customizing ). Documentation-Element Sie erkennen Documentation-Element an einem -Icon. Die meisten Dokumentationen einer Anwendung beziehen sich auf ein oder mehrere Formulare. Oft muss aber auch ein Hintergrundprozess wie z.B. eine Preisfindung oder ein Importvorgang dokumentiert werden, für den es keine visuelle Repräsentation gibt. Für diesen Zweck bietet Frameworks Studio die Documentation-Elemente. Sie sind eigenständige Elemente wie Forms, Workflows oder Components und können wie diese ein- und ausgecheckt werden. Documentation-Elemente im Namespace TreeView: Die Documentation-Elemente bestehen nur aus einem einzigen Dokumentationseditor. Wie Forms bildet jedes Documentation-Element in der fertigen Dokumentation ein eigenes Kapitel mit eigener Kapitelnummer ab. Anwendungsfall für ein Documentation-Element: Wenn auf einem Formular ein Button existiert, welcher z.B. den Preis eines Artikels anhand eingegebener Konditionen berechnet, könnte der Kalkulationsprozess dokumentiert werden. Hier bietet sich ein Documentation-Element an. In diesem wird der Kalkulationsablauf im Detail beschrieben, ohne Bezug auf das Formular oder den Button, von dem der Prozess ausgelöst wird. In der Dokumentation des Button-Controls kann nun ein Verweis auf das Documentation-Element eingefügt werden, welcher in der fertigen Dokumentation als Hyperlink verfügbar ist. Der große Vorteil ist: Sollte in einem anderen Programmteil derselbe Kalkulationsprozess aufgerufen werden, müsste dort nur auf das bereits existierende Documentation-Element verwiesen werden, ganz nach dem Motto „write once, read anywhere“ ."
  },
  "doc/documentation/editor.html": {
    "href": "doc/documentation/editor.html",
    "title": "Editor",
    "keywords": "Editor *Dokumentations-Editor in Framework Studio Zugang zum Editor der verschiedenen Elemente Da an verschiedenen Elementen im Framework Studio dokumentiert werden kann, werden nachfolgend alle Einsprungpunkte zum Editor aufgezeigt. Documentation-Element Da das Documentation-Element keine andere Funktion hat außer Freitexte in Form von DocML zu verfassen, besteht das Hauptformular eines Documentation-Elements aus dem Editor selbst. Das Documentation-Element besteht praktisch nur aus einem Editor: Form Um ein Form zu dokumentierten, muss dieses geöffnet werden und auf die Registerkarte Documentation gewechselt werden. Zugang zum Editor über den Reiter Documentation : Form Control Controls auf einem Form werden über den Form Designer dokumentiert. Dazu muss das gewünschte Control markiert werden. Mit einem Rechtsklick auf das Control öffnet sich das Kontextmenü in dem der Menüpunkt Edit Documentation aufgeführt wird. Alternativ kann über das Property-Fenster von Framework Studio im Bereich Documentation auf den Button mit den drei Punkten geklickt werden. Der Editor öffnet sich für die Controls als modaler Dialog über dem Form Designer. Aufrufen des Editors für ein Control: Component Property Um ein Property zu dokumentieren, muss in der Component das jeweilige Property ausgewählt sein. Danach kann die Registerkarte Documentation ausgewählt werden. Dokumentation eines Properties: DBColumn Um eine Datenbankspalte zu dokumentieren, muss an der DBTable die gewünschte Spalte ausgewählt werden. Danach kann die Registerkarte Documentation ausgewählt werden. Dokumentation einer DBColumn: Metadatentyp Um einen Metadatentyp zu dokumentierten, muss dieser geöffnet werden und auf die Registerkarte Documentation gewechselt werden. Dokumentation eines Metadatatypen: Arbeiten mit dem Editor Der Dokumentationseditor ist ähnlich intuitiv bedienbar wie z.B. ein normaler Texteditor in Microsoft Word oder anderen Textverarbeitungsprogrammen. Es wird der Text markiert, auf den eine Formatierung angewendet werden soll und das jeweilige Icon in der Werkzeugleiste geklickt, um die Formatierung an- oder auszuschalten. Bei Textbausteinen wie Tabellen oder Listen wird der Cursor an die Stelle gesetzt, an der das gewünschte Element eingefügt werden soll. Rechtschreibprüfung Beim bearbeiten eines Textes erfolgt eine automatische Rechtschreibprüfung. Als fehlerhaft erkannte Worte werden rot unterstrichen. Die Prüfung erfolgt an der angegebenen Language . Folgende Sprachen werden unterstützt: Deutsch (de) Englisch (en) Französisch (fr) Italienisch (it) Info Panel Info Panel und Link zum Chapter Tree im Editor: Über die Radiobuttons im Info Panel kann zwischen verschiedenen Ansichten des Editors umgeschaltet werden. None: Zeigt nur den DocML-Editor für die ausgewählte Sprache. Preview: Zeigt zusätzlich zum DocML-Editor das Vorschaufenster an (wird automatisch aktiviert, wenn in der Werkzeugleiste geklickt wird). Other: Zeigt zusätzlich zum DocML-Editor einen zweiten DocML-Editor im Lesemodus an, um zeitgleich eine andere Sprache oder eine andere Dokumentation aus einem anderen Package bereitzustellen. Tooltip: Wenn eine Dokumentation an einem Control bearbeitet wird, gibt es mit diesem Radiobutton die Möglichkeit ein Panel anzuzeigen, in dem der Tooltip des aktuellen Controls bearbeitet werden kann. Wird keine Dokumentation eines Controls bearbeitet, ist dieser Radiobutton nicht sichtbar. Über den Link Open Documentation Tree kann aus jedem Editor heraus der Kapitel-Baum aufgerufen werden. Siehe Chapter Tree . Werkzeugleiste Combobox Language Hier kann die Sprache eingestellt werden, für die im Dokumentations-Editor dokumentiert werden soll. Die DocML-Scripte für die jeweiligen Sprachen sind völlig unabhängig voneinander und beeinflussen sich somit nicht gegenseitig. Textbox Caption Dieses Textfeld ist nur an Form-Dokumentationen und Documentation-Elementen verfügbar. Hier wird die Kapitelüberschrift für das fertige Dokument eingegeben. Die Kapitel werden im Chapter Tree verwaltet. Neue Section Sie erkennen Neue Section an einem -Icon. Fügt an der Stelle des Cursers im Dokumentations-Editor eine neues Section-Tag ein. Dabei wird automatisch eine neue 32-stellige GUID generiert und in das id-Attribut des Tags eingefügt. Von da an steht die Section für Customizing-Zwecke bereit. Siehe Customizing . Preview anzeigen Sie erkennen Preview anzeigen an einem -Icon. Über diesen Button wird das sich im Editor befindliche DocML in HTML konvertiert und im Preview-Panel angezeigt. Kann das DocML aufgrund von Fehlern nicht korrekt umgewandelt werden, werden die entsprechenden Fehler im Common Errors -Panel von Framework Studio aufgelistet. Syntax-Check Sie erkennen Syntax-Check an -Icons. Über diese Buttons kann das DocML auf Validität geprüft werden. Der erste Button überprüft das sich im Editor befindliche DocML für die ausgewählte Sprache. Der Button mit dem Zusatz All überprüft das DocML für alle verfügbaren Sprachen, die über die Combobox Language auswählbar sind. Bei einem Klick auf den Preview-Button wird automatisch erst eine Validierung des DocML’s für die aktuelle Sprache durchgeführt. Schriftart Sie erkennen Schriftart an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Schriftart. Um die finale Dokumentation der Anwendung möglichst homogen zu halten, stehen nur zwei Schriftarten zur Auswahl Normal: Wird in HTML und Word in Arial konvertiert Code: Wird in HTML in ein <code>-Tag geschrieben, im Word wird Courier New verwendet. Schriftgröße Sie erkennen Schriftgröße an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Schriftgröße. Die Einstellung Normal spiegelt die gängige Standardgröße 11pt in Word wider. Die Schriftgrößenangaben sind relativ gehalten, da aus DocML unterschiedliche Ausgabeformen generiert werden können (HTML, Word). Schriftfarbe Sie erkennen Schriftfarbe an -Icons. Formatiert den im Editor markierten Text in der ausgewählten Schriftfarbe. Es können die Schriftfarbe sowie die Hintergrundfarbe für den Text ausgewählt werden. Textformatierungen Sie erkennen Textformatierungen an -Icons. Umgibt den im Editor ausgewählten Text mit dem entsprechenden Formatierungstag. Zur Auswahl stehen: Fett Kursiv Unterstrichen Durchgestrichen Tiefgestellt Hochgestellt Überschriften Sie erkennen Überschriften an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Überschrift. Ausrichtung Sie erkennen Ausrichtung an -Icons. Richtet den im Editor markierten Text nach Wunsch links, mittig, rechts oder als Blocksatz aus. Die Standardeinstellung ist linksbündig. Liste Sie erkennen Liste an einem -Icon. Öffnet einen Dialog zum Erstellen einer neuen Auflistung: List Type Mit List Type wird die Art der Liste definiert. Unordered stellt eine Liste mit Symbolen dar, während Ordered die Listeneinträge aufsteigend nummeriert. List Symbol Nur verfügbar, wenn als Listentyp “Unordered” ausgewählt wurde. Es kann zwischen Disk, Circle und Square gewählt werden. List Item Count Legt die Anzahl der in der Liste befindlichen li-Tags fest. Diese können anschließend im DocML beliebig erweitert werden. Tabelle Sie erkennen Tabelle an einem -Icon. Öffnet einen Dialog zum Erstellen einer neuen Tabelle. Nach dem Klick auf das Symbol wird zunächst ein Panel angezeigt, in dem die Größe der zu konfigurierenden Tabelle ausgewählt werden muss: Wird mit dem Mauszeiger länger als eine Sekunde auf das Quadrat unten rechts gezeigt, vergrößert sich die Auswahl. Wird mit dem Mauszeiger länger als eine Sekunde auf das Quadrat oben links gezeigt, verkleinert sich die Auswahl. Nach der Auswahl der Tabellengröße wird der Dialog zum Konfigurieren der Tabelle angezeigt: Es können alle Parameter der Tabelle eingestellt werden. Dazu gehören Breite, Ausrichtung und Farbe der Tabelle, Spalten, Zeilen und Zellen. Die Werte der Tabelle können durch Spalten, Zeilen und Zellen überschrieben werden. Die Hierarchie der Überschreibungen sieht wie folgt aus: Tabelle -> Spalte -> Zeile -> Zelle Mit einem Klick auf den Button Ok werden für die konfigurierte Tabelle die entsprechenden Tags in den Editor generiert und können anschließend mit Werten befüllt werden. Bild einbinden Sie erkennen Bild einbinden an einem -Icon. Öffnet einen Dialog zum Einbinden eines Bildes in die Dokumentation. Es können nur Bildressourcen aus Framework Studio in die Dokumentation eingebunden werden. Für Bilder von der Festplatte oder aus dem Internet wird eine entsprechende Bildressource angelegt. Sollte sich beim Öffnen des Dialoges ein Bild in der Zwischenablage befinden, wird automatisch die Option From Clipboard ausgewählt. Einfügen eines Bildes in die Dokumentation: Im Bereich Image Source muss zuerst ausgewählt werden, woher das einzubindende Bild stammt. Wenn das Bild schon als Ressource im Framework Studio verfügbar ist, kann diese aus der Baumansicht ( Existing Resource ) ausgewählt werden. Eine Vorschau des Bildes erscheint auf der rechten Seite. Es kann auch direkt ein Bild aus dem Internet eingebunden werden ( From Url ). Damit das Bild in der Dokumentation angezeigt wird, wenn beim Betrachten keine Internetverbindung besteht, muss dieses mit dem Button Load geladen werden. Danach erscheint das Bild in der Vorschau. Die Url des Bildes muss mit Fehler! Linkreferenz ungültig beginnen. Soll ein Bild von der Festplatte eingebunden werden, muss zuerst der Radiobutton From File aktiviert werden. Danach kann über den Button […] ein Bild von der Festplatte gewählt werden. Bilder können auch direkt aus der Zwischenablage( From Clipboard ) eingebunden werden. Im Feld Name wird der Name der neu anzulegenden Ressource angegeben. Im Bereich Attributes können die Anzeigeeigenschaften des einzubindenden Bildes verändert werden: Original Size Verwendet in der Dokumentation die ursprüngliche Größe des Bildes in cm. Unit Gibt an, welche Maßeinheit in der Dokumentation verwendet werden soll. Zur Auswahl stehen Zentimeter (cm) und Inch (in). Width Breite des Bildes. Height Höhe des Bildes (nur aktiv, wenn Keep aspect ratio deaktiviert ist). Keep aspect ratio Wenn aktiviert (Standard), wird anhand der eingegebenen Breite des Bildes, die zugehörige Höhe anhand des originalen Seitenverhältnisses berechnet. Das Bild wird somit nicht verzerrt. Inline Image Wenn aktiviert, verhält sich das Bild wie ein Schriftzeichen und folgt dem normalen Textfluss. Andernfalls wird vor und nach dem eingefügten Bild ein Zeilenumbruch generiert. Caption Nur verfügbar, wenn die Option Inline Image deaktiviert ist. Es kann eine Bildunterschrift angegeben werden. Warning Wenn das Bild aus dem Internet oder von der Festplatte eingebunden werden soll, wird nach dem Klick auf den Button Ok ein Dialog angezeigt, der darauf hinweist, dass automatisch eine Framework Studio Resource für das Bild angelegt wird. Screenshot Sie erkennen Screenshot an einem -Icon. Öffnet einen Dialog zum Einbinden eines automatisch generierten Screenshots des Formulars in die Dokumentation. Diese Funktion ist nur in der Form-Dokumentation verfügbar. Anhand der Designer-Daten wird ein Screenshot des Formulars generiert. Sollten Tabellen mehr Spalten haben, als in der Breite angezeigt werden können, werden die Spaltenköpfe umgebrochen und mehrzeilig fortgeführt. Im Bereich Attributes können die Anzeigeeigenschaften des einzubindenden Screenshots verändert werden: Original Size Verwendet in der Dokumentation die ursprüngliche Größe des Formulars in cm. Unit Gibt an, welche Maßeinheit in der Dokumentation verwendet werden soll. Zur Auswahl stehen Zentimeter (cm) und Inch (in). Width Breite des Screenshots. Height Die Höhe des Bildes wird automatisch anhand des Seitenverhältnisses des Formulars berechnet. Link Sie erkennen Link an einem -Icon. Öffnet einen Dialog zum Einfügen eines Querverweises oder eines Hyperlinks. Sollte sich beim Öffnen des Dialoges ein Link in der Zwischenablage befinden, wird dieser automatisch in das Textfeld Url eingefügt. Es kann im DocML sehr einfach auf ein anderes Kapitel (Formular oder Documentation-Element) verwiesen werden oder ein Hyperlink ins Internet bereitgestellt werden. Bei einem Querverweis auf ein Kapitel muss das entsprechende Form oder Documentation-Element in dem Textfeld Existing Documentation mithilfe von Autocomplete gesucht werden. Nach der Auswahl einer Dokumentation, wird die Caption(falls verfügbar) der ausgewählten Dokumentation, in der Sprache der Dokumentation, in die der Link eingefügt werden soll, eingefügt. Für einen Hyperlink ins Internet kann eine beliebige URL beginnend mit Fehler! Linkreferenz ungültig eingegeben werden. In der Textbox Text wird festgelegt, wie der Link in der Dokumentation angezeigt werden soll. Indexeintrag Sie erkennen Indexeintrag an einem -Icon. Öffnet einen Dialog zum Einfügen eines Indexeintrages in die Dokumentation. Im Export Wizard kann definiert werden, ob in der gerenderten Dokumentation ein Index erstellt werden soll. Kapitelüberschriften (von Forms und Documentation-Elementen) werden dem Index automatisch hinzugefügt. Über den Dialog ist es möglich, manuell einen Indexeintrag zu generieren. Dabei muss der Haupteintrag definiert werden. Optional kann ein Untereintrag angegeben werden. Basisaufruf Sie erkennen Basisaufruf an einem -Icon. Nur verfügbar in den Dokumentationen von Controls, Component Properties, DBColumns und Metadatentypen. Erstellt ein base-Tag, welches die Basisdokumentation des aktuellen Elements (Controls, Component Properties, DBColumn oder Metadatentyps) in die Dokumentation mit einbindet. Mehr Information hierzu finden Sie im Kapitel Vererbung Linie Sie erkennen Linie an einem -Icon. Erstellt an der Curser-Position im Editor ein line-Tag. Dieses generiert in der Dokumentation eine schwarze Linie über die gesamte Seitenbreite mit anschließendem Zeilenumbruch. Zeilenumbruch Das br-Tag ist sicherlich das am häufigsten verwendete Tag in einer Dokumentation in DocML. Es wäre sehr umständlich, wenn jedes Mal, wenn ein Zeilenumbruch in der Dokumentation eingefügt werden soll, ein Button in der Werkzeugleiste geklickt werden müsste. Dies würde den Schreibfluss mit der Tastatur erheblich behindern. Um ein br-Tag ( [br/] ) an der Cursorposition einzufügen, muss im Editor nur <STRG + Enter> gedrückt werden. Es wird ein br-Tag eingefügt und automatisch in die nächste Zeile gesprungen. Text markieren Alle Formatierungsfunktionen des Editors wie z.B. Fettschrift oder Ausrichtung des Textes funktionieren ähnlich wie in einem WYSIWYG-Editor. Es wird Text markiert und dann die gewünschte Formatierungsoption aufgerufen. Der Unterschied des DocML-Editors ist allerdings, dass sich im markierten Text auch DocML-Tags befinden können, wie folgendes Beispiel zeigt: Dies ist allerdings absolut kein Problem. Soll z.B. der oben markierte Text kursiv geschrieben werden, kann einfach in der Werkzeugleiste der entsprechende Button geklickt werden. Der Editor erkennt die Markierung und alle Tags darin und wendet die neue Formatierung entsprechend an: Es muss also nicht auf Tags geachtet werden, wenn zusätzliche Formatierungen auf schon zuvor formatierte Textstellen angewendet werden. Auch bei Block-Tags wie Listen kann dieses Verhalten auftreten. Nachfolgend soll z.B. eine gesamte Liste fett gedruckt werden. Da Block-Tags (lst-Tags) nicht in Inline-Tags (b-Tags) auftreten dürfen, kümmert sich der Editor selbst darum und ergänzt die Texte in der Liste automatisch mit den entsprechenden Tags. Folgende Liste soll komplett fett gedruckt dargestellt werden: Nach einem Klick auf den Button für Fettschrift in der Werkzeugleiste werden die Listeneinträge automatisch um die jeweiligen b-Tags ergänzt und die Validität des DocML wird erhalten: Beim Markieren von Texten für Formatierungen muss also nicht explizit an schon vorhandene Tags gedacht werden, der Editor erledigt dies alles automatisch. Kommentare DocML bietet die Möglichkeit, in Dokumentationen Kommentare einzufügen, die nicht in die Ausgabe gerendert werden. So können z.B. kleine Notizen oder Erinnerungen in die Dokumentation eingefügt werden. Ein Kommentar-Tag startet mit der Zeichenfolge [-- und endet mit --] . Kommentare sind im DocML an ihrer grünen Farbe zu erkennen und beeinflussen die Ausgabe in keinster Weise. Kommentare können an beliebiger Stelle im DocML platziert werden. Escape-Zeichen Die Sprache DocML beinhaltet einige Steuerzeichen wie z.B. eckige Klammern ( [ und ] ), mit denen die Tags abgebildet werden. Allerdings werden diese Zeichen natürlich auch im Fließtext der Ausgabe benötigt. Dass Framework Studio den Unterschied zwischen einer eckigen Klammer eines Tags und einer normalen eckigen Klammer im Fließtext unterscheiden kann, müssen diese Zeichen mit einem Blackslash ( \\ ) escaped werden. Wie zu sehen ist, werden die Backslashes in der Ausgabe eliminiert. Um einen Backslash als Zeichen in die Dokumentation einzufügen, muss dieser ebenso mit einem weiteren Backslash escaped werden. Panel Other Der Editor bietet die Möglichkeit, ein zusätzliches Fenster einzublenden, welches eine Dokumentation aus einem anderen Package oder in einer anderen Sprache anzeigt. So kann z.B. während die englische Dokumentation für ein Formular erstellt wird, parallel die deutsche Dokumentation angezeigt werden, um besser übersetzen zu können. Language Mit dieser Combobox wird die Sprache der anzuzeigenden Dokumentation gewählt. Package Mit dieser Combobox kann zwischen den Dokumentationen des Elementes in unterschiedlichen Packages gewählt werden. Mehr Informationen über Package-übergreifende Dokumentation und das Customizing befindet sich in den Kapiteln Vererbung und Customizing . Panel Tooltip Wenn eine Dokumentation eines Controls bearbeitet wird, bietet der Editor die Möglichkeit, ein zusätzlichen Fenster-Bereich einzublenden, welches das Bearbeiten des Tooltips erleichtert. Der Tooltip Text kann direkt im Tooltip Panel bearbeitet werden. Wird der Inhalt des Textfeldes bearbeitet, dann wird er fett gedruckt und der Tooltip direkt am Control überschrieben. Der Text des MLKey wird dadruch nicht verändert. Wenn man den kompletten Inhalt des Textfeldes löscht, dann wird wieder Text wieder aus dem MLKey bzw. der Basis gezogen. Mit dem Button […] kann ein anderer MLKey ausgewählt werden. Mit einem Klick auf den blauen Link kann der momentan ausgewählte MLKey bearbeitet werden."
  },
  "doc/documentation/export-wizards.html": {
    "href": "doc/documentation/export-wizards.html",
    "title": "Export Wizards",
    "keywords": "Export Wizards Die wichtigste Funktion des Dokumentationssystems ist der Export in ein gängiges Format. Framework Studio bietet die Möglichkeit, automatisiert alle Dokumentationen, die an Forms, Controls, Metadatentypen usw. getätigt wurden, anhand der im Chapter Tree definierten Kapitelstruktur zu exportieren. Die Dokumentation kann als HTML Webapplikation (zum Hosten auf einem Webserver) oder als Word-Datei (.docx) exportiert werden. Zusätzlich dazu gibt es einen besonderen Modus, mit dem ausschließlich Dokumentationen von Component-Properties exportiert werden können, um diese mittels des Browser-Controls in der Endanwendung anzeigen zu können. HTML Dieser Export-Modus exportiert die gesamte Dokumentation oder ein ausgewähltes Kapitel als Webapplikation, welche auf einem beliebigen Webserver (z.B. IIS, Apache, Nginx) gehostet werden kann und somit von nahezu allen Endgeräten mit Webbrowser erreichbar ist. Der Modus HTML (Properties) ist in diesem Export-Modus integriert. Es werden alle Component-Properties von Components, die mit dem Marker {ExportDoc} markiert sind, exportiert. Der Wizard für den Export der Dokumentation als HTML Webapplikation befindet sich im Menü Tools > Documentation > Export > HTML . Wizard-Optionen Die Baumansicht bietet die Struktur des Release-Knotens an. Hier muss ausgewählt werden, welches Kapitel exportiert werden soll. Wird der Release-Knoten selbst angewählt, wird die gesamte Dokumentation, die im Framework Studio hinterlegt ist, exportiert. Combobox Language Definiert die Sprache, für die die Dokumentation exportiert werden soll. Dies ändert auch die Sprache der automatisch generierten Screenshots (siehe Screenshot ). Beim Export über die FSConsole kann die Sprache über den Parameter \\Iso gesteuert werden. Checkbox Include Tooltips Ist an einem Steuerelement eines Formulars ein Tooltip hinterlegt, wird dieser mit in die Dokumentation des Steuerelements aufgenommen. Checkbox Include DB-Tables Ist diese Checkbox gesetzt, dann wird auf der ersten Ebene ein zusätzliches Kapitel Tabellen-Beschreibungen erzeugt, unter dem die Beschreibung aller Datenbank-Tabellen enthalten ist. Beim Export über die FSConsole kann das über den Parameter \\ExportDBTables gesteuert werden. Checkbox Use License Wenn diese Checkbox aktiviert ist, wird die Lizenz bei dem Export der Dokumentation berücksichtigt. Forms und Controls, die nicht die nötigen Berechtigungen besitzen, werden nicht mit in die Dokumentation aufgenommen. Export-Vorgang Für den eigentlichen Export-Vorgang wird ein Dialog mit Statusinformationen bereitgestellt. Über den Button Abort kann der Vorgang jederzeit abgebrochen werden. Treten beim Export-Vorgang Infos, Warnungen oder Fehler auf, werden diese detailliert in das Ausgabefenster protokolliert und der Statustext ändert ggf. seine Farbe ( orange für Warnungen, rot für Fehler). Webapplikation Nach dem Export-Vorgang befindet sich die Webapplikation im zuvor ausgewählten Ausgabeordner. Die Webapplikation ist eine HTML 5 Anwendung, die ausschließlich auf den Technologien HTML, JavaScript und CSS basiert. Damit ist sie kompatibel zu nahezu allen Endgeräten mit einem Browser ( Webapplikation Vorraussetzungen beachten). Inhalt Nach dem Öffnen der Webapplikation im Browser ist standardmäßig der Bereich Contents selektiert. Hier kann im Baum auf der linken Seite das gewünschte Kapitel ausgewählt werden, welches dann rechts im Viewer angezeigt wird. Bei einem Klick auf einen Link wird der Baum automatisch aktualisiert und zum neuen Kapitel gesprungen. Index Im Bereich Index kann der gesamte Index der Dokumentation durchsucht werden. Ist einem Index-Eintrag nur ein einziges Kapitel zugeordnet, wird dieses sofort nach dem Klick in den Baum ausgewählt. Sind einem Index-Eintrag mehrere Kapitel zugeordnet, kann das gewünschte Kapitel im Bereich Select Chapter links unten im Baum ausgewählt werden. Suche Mit Hilfe der Suchfunktion können alle Kapitel nach Wörtern durchsucht werden. In der Ergebnisliste werden dann alle Kapitel angezeigt, die das eingegebene Wort enthalten. Drucken Um den Inhalt des gerade angezeigten Kapitels zu drucken, steht der Button Print zur Verfügung. Anders als die Druckfunktion des Browsers, welche die gesamte Webapplikation inkl. Baum drucken würde, wir über den Button Print nur der Inhalt des Viewers berücksichtigt. Webapplikation Vorraussetzungen Um die von Framework Studio generierte Webapplikation zu hosten, wird einer der folgenden Webserver vorrausgesetzt: IIS 7 oder höher Apache 2.2.x oder höher Nginx 1.9 oder höher Es wird empfohlen, einen der folgenden Browser zur Anzeige der Webapplikation zu verwenden: Google Chrome Mozilla Firefox Microsoft Edge Microsoft Internet Explorer 11 Warning Internet Explorer 10 und niedriger werden NICHT unterstützt. Export mit FSConsole Neben dem Export-Wizard kann die Webapplikation auch über die FSConsole.exe ( FSConsole ) generiert werden. Hierzu gibt es die neuen Parameter \\DOCUMENTATION, \\ISO und \\OUTPUT. \\DOCUMENTATION Dieser Parameter ist nur ein Marker für die FSConsole, dass die Dokumentation gerendert werden soll. \\ISO Gibt die Sprache an, in der die Dokumentation gerendert werden soll. Der Parameter hat auch Einfluss auf die automatisch generierten Screenshots. \\OUTPUT Gibt das Verzeichnis an, in welches die Webapplikation gerendert werden soll. Zusätzlich zu den neuen Parametern müssen die obligatorischen Connection- und Package-Version Parameter angegeben werden ( \\LABELID , \\SERVER , \\DBUSER usw.) Beispiel: FSConsole.exe \\DOCUMENTATION \\ISO de \\OUTPUT „C:\\Temp\\Dokumentation“ \\PACKAGE MyPackage \\VERSION 3.8 \\CONNECTIONTYPE SqlServer \\SERVER Server01 \\DBUSER demo \\DBPASSWORD demo123 Word Der Wizard für den Export der Dokumentation als Word-Datei (.docx) befindet sich im Menü Tools > Documentation > Export > Word . Wizard-Optionen Die Baumansicht bietet die Struktur des Release-Knotens an. Hier muss ausgewählt werden, welches Kapitel exportiert werden soll. Wird der Release-Knoten selbst angewählt, wird die gesamte Dokumentation, die im Framework Studio hinterlegt ist, exportiert. Title Page Wird diese Option aktiviert, wird in der Word-Datei zusätzlich ein Deckblatt mit dem definierten Titel und Info Text generiert. Language Definiert die Sprache, für die die Dokumentation exportiert werden soll. Dies ändert auch die Sprache der automatisch generierten Screenshots (siehe Screenshot ). Create TOC Erstellt ein Inhaltsverzeichnis für alle in der Dokumentation enthaltenen Kapitel am Anfang der Word-Datei. Create Index Erstellt einen Index für alle Kapitel und manuell in den Dokumentationen definierten Indexeinträgen am Ende der Word-Datei. Die Überschrift jedes Kapitels aus dem Chapter Tree wird automatisch zum Index hinzugefügt. Include Tooltips Ist an einem Steuerelement eines Formulars ein Tooltip hinterlegt, wird dieser mit in die Dokumentation des Steuerelements aufgenommen. Doc2Help Zusätzlich zum Indexeintrag wird jede Kapitelüberschrift mit einer zusätzlichen Formatvorlage versehen, die es Doc2Help erlaubt, einen Verweis über eine Url in der Onlinehilfe auf das jeweilige Kapitel zu generieren. Für mehr Information hierzu siehe Kapitel Doc2Help . Checkbox Use License Wenn diese Checkbox aktiviert ist, wird die Lizenz bei dem Export der Dokumentation berücksichtigt. Forms und Controls, die nicht die nötigen Berechtigungen besitzen, werden nicht mit in die Dokumentation aufgenommen. Export-Vorgang Für den eigentlichen Export-Vorgang wird ein Dialog mit Statusinformationen bereitgestellt. Über den Button Abort kann der Vorgang jederzeit abgebrochen werden. Treten beim Export-Vorgang Infos, Warnungen oder Fehler auf, werden diese detailliert in das Ausgabefenster protokolliert und der Statustext ändert ggf. seine Farbe ( orange für Warnungen, rot für Fehler). Besonderheit bei TOC und Index Wurde im Export Wizard eine der Optionen Create TOC oder Create Index ausgewählt, muss Microsoft Word (2007 oder höher) auf dem PC installiert sein, um das Inhaltsverzeichnis oder den Index nach einem erfolgreichem Exportvorgang zu aktualisieren. Zu diesem Zweck wird nach dem Speichern der docx-Datei auf der Festplatte diese automatisch von Framework Studio aus mit Word geöffnet (als Prozess - es wird kein Fenster geöffnet) und eine Aktualisierung der jeweiligen Kataloge angestoßen. Anschließend wird die Datei nochmals gespeichert und Word geschlossen. Im Ausgabefenster des Export-Vorgangs ist zu erkennen, dass seitens Framework Studio geprüft wird, ob Word installiert ist. Sollte dies nicht der Fall sein, werden im exportierten Dokument zwar ein Inhaltsverzeichnis und ein Index enthalten sein, die jedoch aufgrund der fehlenden Aktualisierung keine Einträge enthalten. In diesem Fall muss die Aktualisierung der Kataloge manuell mit Word durchgeführt werden. HTML (Properties) Zusätzlich zu den anderen Modi steht ein weiterer Export-Modus zur Verfügung. Dieser ist in der Lage, ausschließlich Dokumentationen von Component-Properties in einzelne HTML-Dateien zu rendern. Er renderd also nicht wie der HTML- oder Word-Exporter die gesamte zur Verfügung stehende Dokumentation, sondern nur ausgewählte Component-Properties. Soll die Dokumentation eines Component-Properties z.B. an der Oberfläche der Endanwendung angezeigt werden, ist dies nun mit Hilfe des Browser-Controls möglich. Der neue Export-Modus befindet sich wie nun auch der bisherige Word-Export-Modus im Menü Tools > Documentation > Export > HTML (Properties) . Markieren der Components Eine Endanwendung besteht im Normalfall aus extrem vielen Components und Component-Properties. Der neue Export-Modus wird aber meist nur für einen gewissen Bereich der Anwendung benötigt. Deshalb muss auf Component-Ebene definiert werden, welche Components beim neuen Export-Modus beachtet werden sollen. Um eine Component für den neuen Modus zu markieren, muss die Zeichenfolge \"{ExportDoc}\" in das Description-Feld der Component eingetragen werden. Nun werden beim Export alle dokumentierten Properties der markierten Component exportiert. Wizard-Optionen Wird der neue Export-Dialog aufgerufen, wird eine Übersicht mit allen markierten Components angezeigt. Language Definiert die Sprache, in der die Component-Properties gerendert werden sollen Include Tooltips Definiert, ob an den Component-Properties definierte Tooltips zuzüglich zur eigentlichen Dokumentation gerendert werden sollen. Output Directory Über den Button […] muss ein Zielverzeichnis für den HTML-Export definiert werden. Dieses Verzeichnis muss leer sein. Export-Vorgang Es kann nachvollzogen werden, welche Properties Dokumentationen beinhalten und gerendert werden. Sollte nach dem Export-Vorgang festgestellt werden, dass keine Bilder gerendert wurden, wird das zuvor erstellte Verzeichnis images wieder gelöscht. Ausgabe Beim Export wird jedes Property einer markierten Component durchlaufen und in eine separate .html-Datei geschrieben. Der Name dieser Dateien setzt sich allein aus dem Namespace-Pfad des Properties zusammen. Wird der Export-Ordner nun an einem im Netzwerk zugänglichen Pfad abgelegt (vorzugsweise auf dem Webserver, auf dem auch schon die bisherige Dokumentation liegt), können die Property-Dokumentationen in der Endanwendung mittels eines Browser-Controls eingebunden werden. Struktur der Ausgabe Der größte Vorteil der Generierung der Anwendungsdokumentation mit Framework Studio ist die strukturierte Ausgabe. Ziel ist es, jedes Kapitel bzw. Formular in genau demselben Schema auszugeben. Dokumentations-Elemente sind hier sehr einfach gehalten, da sie nur eine Dokumentation enthalten. Sie werden als einzelnes Kapitel mit dem zugehörigen Text gerendert. Formulare hingegen bestehen aus vielen Steuerelementen und ggf. Menüeinträgen, die wiederum ihre eigene Dokumentation beinhalten. Hier folgt Framework Studio folgendem Schema: Die Dokumentation eines Formulars beginnt wie ein Documentation-Element mit einem eigenen Kapitel. Danach folgt die Formular-Dokumentation. Die Steuerelemente werden anhand ihrer Position auf dem Form abgearbeitet. Es wird von links nach rechts und von oben nach unten gearbeitet. Wenn ein Steuerelement andere Steuerelemente beinhaltet (z.B. Registerkarten oder Tabellen) werden diese inneren Steuerelemente nach demselben Schema abgearbeitet. Sind alle Steuerelemente gerendert, folgt zum Schluss die Ausgabe der Menüeinträge. Zur Verdeutlichung folgen einige Beispiele in Microsoft Word. Ausgabe einer Dokumentation eines Documentation-Elements: Ausgabe eines Formulars unterhalb eines Documentation-Elements: In diesem Beispiel ist zu sehen, dass im Chapter Tree das Formular Kassenparameter unterhalb des Documentation-Elements Kasse eingefügt wurde. In der Formular-Dokumentation wurde ein automatisch generierter Screenshot eingefügt. Ausgabe der Steuerelemente eines Formulars: In diesem Beispiel ist die Ausgabe der Steuerelemente eines Formulars zu sehen. Ist ein Steuerelement ein Container (d.h. beinhaltet andere Steuerelemente) wird dies mit horizontalen Linien verdeutlicht. Es ist zu erkennen, dass die Buttons Speichern , Schließen , Customizing und Hilfe innerhalb des Panels Haupt-Buttonleiste liegen. Zusätzlich ist erkennbar, dass die Bezeichnungsfelder Gutsch.kürzel und Rechn.kürzel Tooltip-Informationen enthalten, die automatisch mit in die Dokumentation aufgenommen wurden (Checkbox Include Tooltips in den Wizard-Optionen ). Ausgabe der Bilder bei Steuerelementen Es gibt einige Steuerelemente in Framework Studio, die Bilder anzeigen (z.B. ImageButtons). Um das Auffinden eines solchen Steuerelements in der Dokumentation zu vereinfachen, kann in der Ausgabe des Steuerelements das zugehörige Bild mit angezeigt werden. ImageButtons mit Bild in der Dokumentation: Ob das Bild in der Dokumentation des Steuerelements mit angezeigt wird oder nicht, hängt von einem Schalter direkt am Steuerelement ab. Einstellung zur Anzeige des Bildes in der Dokumentation des Steuerelements: Diese Einstellung kann auch global über die DefaultControlStyles für den jeweiligen Control-Typ definiert werden. Einstellung der Bildanzeige am DefaultControlStyle: Registerkarten als separate Kapitel ausgeben Registerkarten beinhalten in Anwendungen oft Funktionalitäten, die in einer Dokumentation als separates Kapitel betrachtet werden sollte. Standardmäßig werden Registerkarte in der Dokumentation genauso wie andere Container-Steuerelemente in der Liste der Steuerelemente des Formulars mit ausgegeben. Dieses Verhalten ist nicht immer gewünscht, vor allem wenn eine Registerkarte sehr viele Steuerelemente und komplexere Vorgänge beinhaltet. Um für jede Registerkarte eines Registerkartes unterhalb eines Formulars ein eigenes Kapitel in der Dokumentation zu eröffnen, gibt es die Option ChaptersForTabs am Registerkarte. Registerkarten als separate Kapitel Ausgeben: Wird diese Option auf True gesetzt, werden beim Exportieren des Formulars für jede Registerkarte des Registerkartes ein eigenes Kapitel mit eigenem Indexeintrag erstellt. Generierung separater Kapitel für Registerkarten: In der Liste der Steuerelemente, in der die Registerkarten normalerweise ausgegeben werden, befindet sich dann nur noch ein Link auf das entsprechende Unterkapitel. Caution Die Option ChapterForTabs kann je Formular nur für ein einziges Registerkarte auf True gesetzt werden. Vorschau eines ganzen Formulars Die Preview-Ansicht des Dokumentations-Editors zeigt immer nur die Ausgabe des im Editor befindlichen DocML . Um eine Vorstellung zu bekommen, wie ein ganzes Formular in der Endfassung aussieht, kann dieses komplett mit der Steuerelementauflistung und den Menüeinträgen in ein Vorschaufenster gerendert werden. Hierzu reicht im Documenation-Editor ein Klick auf den Link View Render Chapter . Es wird die in der Combobox Language angegebene Sprache verwendet. Dieser Link steht auch im Documentation-Editor der TabPage zur Verfügung. Diese bilden in der Regel ein eigenes Chapter und werden nicht in der Preview des Forms angezeigt. Vollständige Voransicht eines Formulars rendern: Unterstützung von Themes Die Einstellung des Themes in Framework Studio hat unmittelbare Auswirkungen auf die Ausgabe der Dokumentation mittels des Export Wizards. Diese Abhängigkeit betrifft in Framework Studio eingebundene Ressourcen sowie auch die automatisch generierten Screenshots über das Screenshot-Tag (siehe Screenshot ) in der Formular-Dokumentation. Im folgenden Beispiel wurde eine Dokumentation eines Formulars mit zwei unterschiedlichen Themes exportiert, was zu anderen automatisch generierten Screenshots in der Dokumentation führt. Dokumentation exportiert mit Theme 1: Dokumentation exportiert mit Theme 2: fsconsole! Warning TODO fsconsole link!"
  },
  "doc/documentation/indicators.html": {
    "href": "doc/documentation/indicators.html",
    "title": "Dokumentationsstatus von Steuerelementen",
    "keywords": "Dokumentationsstatus von Steuerelementen Da die Dokumentation der Steuerelemente eines Formulars über den Designer stattfindet, ist nicht immer ersichtlich, welches Steuerelement schon eine Dokumentation beinhaltet oder ob das Steuerelement beim Rendern eine Dokumentation aus der Basis erhält. Um dies zu visualisieren, gibt es in den Framework Studio Optionen die Option Documentation Indicators . Wird diese Checkbox aktiviert, werden für alle Steuerelemente kleine Vierecke in der rechten oberen Ecke angezeigt. Die Quadrate können dabei zwei Farben annehmen: Gelb Das Steuerelement enthält in diesem Formular keine Dokumentation. Es steht aber eine Dokumentation aus der DataSource des Steuerelements (Component Property, DBColumn, Metadatentyp) oder aus einem Basis-Package zur Verfügung und würde bei einem Export ausgegeben. Grün Das Steuerelement enthält in diesem Formular eine Dokumentation. Wenn an einem Steuerelement kein Quadrat existiert, gibt es an diesem Steuerelement keine Dokumentation sowie auch keine Dokumentation aus der DataSource bzw. eines Basis-Packages."
  },
  "doc/documentation/vererbung.html": {
    "href": "doc/documentation/vererbung.html",
    "title": "Vererbung",
    "keywords": "Vererbung Ähnlich wie bei den Tooltips für Steuerelemente bietet auch die Dokumentation eine Vererbung bis auf Metadatentyp-Ebene an. Diese Vererbung soll dazu beitragen, Dokumentationen für Steuerelemente mit derselben Funktion nicht mehrmals verfassen oder kopieren zu müssen. Vererbung einer Dokumentation: Die Abbildung zeigt die Möglichkeit der Vererbung vom Steuerelement auf dem Form bis zum Metadatentyp ggf. auch über mehrere Packages hinweg, gesetzt den Fall, dass dem jeweiligen Steuerelement eine DataSource zugewiesen wurde. Eingebunden werden kann eine Dokumentation aus einem darunter liegenden Element mit Hilfe des base-Tags (siehe Base ). Vererbung in einem einzigen Package Im folgenden Beispiel wird gezeigt, wie mit Hilfe der Vererbung in der Dokumentation des Textfelds T die Dokumentationen aus dessen Component Properties (DataSource), der dazu gehörigen DBColumn und des wiederum damit verbundenen Metadatentyps eingebunden werden kann. Betrachtet wird das Szenario eines einzelnen Packages P1 (blaue Pfeile). Die Dokumentation des Metadatentyps M sieht wie folgt aus: Die Dokumentation der DBColumn D bindet mit Hilfe des base-Tags die Dokumentation des Metadatentyps ein. Beim Rendern wird an die Stelle des base-Tags somit die Dokumentation des Metadatentyps eingebunden: Am Component Property C ist dasselbe Verhalten zu erkennen: Letztlich bindet auch das Textfeld T die Basis-Dokumentation ein, was folgende Ausgabe ergibt: An der Dokumentation des Controls ist nun zu erkennen, dass die Information über das Drücken der F2 -Taste am Control auf dem Formular dokumentiert wurde. Dies könnte auf einem anderen Formular z.B. ein anderer Shortcut sein. Die restliche Dokumentation inklusive des rot markierten Beispiels würde aber automatisch übernommen werden. Diese Art der Vererbung ist also immer dann sinnvoll, wenn auf unterschiedlichen Formularen in der Anwendung Steuerelemente existieren, die genau dieselben DataSources verwenden. Beispiel In einer Anwendung gibt es auf 6 verschiedenen Formularen immer wieder ein Textfeld, welches eine Auftragsnummer anzeigt. Die Funktion des Textfeldes ist auf jedem Form dieselbe und beinhaltet auch immer die Daten desselben Component Properties (die Textfelder haben immer die gleiche DataSource), baut somit immer auf derselben DBColumn auf und ist damit auch vom selben Metadatentyp abhängig. Es wäre nun sehr umständlich, jedes Mal am Steuerelement selbst dieselbe Dokumentation zu hinterlegen. Sollte sich diese ändern, müssten alle 6 Stellen angepasst und erneut auf Fehler überprüft werden. Um dies zu vermeiden, kann die Vererbung genutzt werden. Da die 6 Textfelder immer auf demselben Component Property aufsetzen, kann die gesamte Dokumentation an diesem verfasst werden. Der große Vorteil dieses Vorgehens ist, wenn sich an der Dokumentation etwas ändert, muss nur die Dokumentation des Component Properties angepasst werden und beim nächsten Rendern haben alle abhängigen Textfelder die aktualisierte Dokumentation des Component Properties übernommen. Insgesamt gilt also: Die Dokumentation sollte so tief wie möglich im Framework Studio verfasst und auf möglichst viele Elemente vererbt werden. Entstehen in der Datasource Hierarchy an einer Stelle Lücken in der Dokumentation, wird die Dokumentation aus der nächst tieferen Ebene eingebunden. Befindet sich z.B. in der Dokumentation eines Textfelds T ein base-Tag, wird beim Rendern die Dokumentation aus dem Component Property verwendet. Ist jedoch keine Dokumentation an selbigem verfasst, wird automatisch in der tieferen Ebene nach einer Dokumentation geprüft. In diesem Fall würde die Dokumentation der DBColumn verwendet werden. Ist an selbiger auch keine Dokumentation verfasst, wird die des Metadatentyps eingebunden. Beispiel Eine leere Dokumentation verhält sich wie ein base-Tag: An einem Textfeld ist nicht explizit eine Dokumentation hinterlegt. Das per DataSource zugewiesene Component Property beinhaltet jedoch eine Dokumentation. Wie zu sehen ist, wird automatisch die Dokumentation des Component Properties für das Textfeld gerendert, wenn die Preview angezeigt wird. Eine nicht vohandene Dokumentation in einem Control, einem Property, einer DBColumn oder einem Metadatentyp verhält sich also genauso wie ein base-Tag ohne weiteres DocML. base-Tag ohne weiteres DocML: Das gezeigte base-Tag kann also entfernt werden, da sich die leere Dokumentation äquivalent verhält. Vererbung bei mehreren Packages Liegen mehrere Packages übereinander (grüne und orangene Pfeile), wird immer erst die höchste Customization des jeweiligen Elements betrachtet. Vererbung über mehrere Packages hinweg: Beispiel (grüne Pfeile): Wird die Dokumentation für die Customization vom Textfeld T im Package P2 gerendert, wird für ein base-Tag in P1 nach einer Dokumentation gesucht. Wird dort nichts gefunden oder erfolgt dort ein weiterer Base-Aufruf, wird an der Customization des Component Properties C in P2 gesucht usw."
  },
  "doc/form/control/browser.html": {
    "href": "doc/form/control/browser.html",
    "title": "Browser",
    "keywords": "Browser Properties/Events Actions Mit dem Browser-Control ist es möglich Html-Inhalte oder Grafiken darzustellen. Hierfür bietet das Control zwei verschiedene Modi an. Der Browser-Modus ist für das Anzeigen von Webseiten geeignet und bietet hierzu eine Addressleiste an, mit der zwischen Webseiten hin und her navigiert werden kann. In der Statusleiste kann der Ladefortschritt der aktuellen Seite, sowie die Links zu denen mit der Maus navigiert werden kann, angezeigt werden. Der Content-Modus ist zum Anzeigen von Grafiken oder lokalen Html-Seiten geeignet. Dieser Modus verfügt über keine Navigations- und Statusleiste. In beiden Modi kann zusätzlich eine Zoomleiste eingeblendet werden, mit der Inhalte vergrößert bzw. verkleinert werden können. Der Inhalt kann außerdem mit dem Mausrad und gedrückter STRG-Taste vergrößert bzw. verkleinert werden. Alle angeklickten Links werden konsumiert und müssen, falls gewollt, über das OnLinkClick-Event abgefangen und manuell über eines der Datasources wieder an den Client geschickt werden. Das BrowserControl bietet keinen vollständigen Browserersatz. Viele elementare Funktionen eines echten Browsers, wie das Herunterladen von Dateien oder die Verwendung von Cookies sind nicht vorhanden. Außerdem ist die Browser-Engine nicht auf dem neusten Stand der Technik, unterstützt aber sowohl Html5 wie auch CSS3. Falls Links in einem echten Browser angezeigt werden sollen, kann mit der Funktion ViewDocument(string url) der Standart Browser geöffnet werden."
  },
  "doc/form/control/button.html": {
    "href": "doc/form/control/button.html",
    "title": "Button",
    "keywords": "Button Properties/Events Actions"
  },
  "doc/form/control/checkbox.html": {
    "href": "doc/form/control/checkbox.html",
    "title": "Checkbox",
    "keywords": "Checkbox Properties/Events Actions"
  },
  "doc/form/control/combobox.html": {
    "href": "doc/form/control/combobox.html",
    "title": "ComboBox",
    "keywords": "ComboBox Properties/Events Actions Lazy-Loading Wenn ein Form Comboboxen beinhaltet, die sehr viele Listen-Einträge besitzen, dann kann das zu spürbaren Verzögerungen in der Anwendung führen, weil diese Listen zum einen im XML kommuniziert und auch vom Client aufbereitet werden müssen. Für diesen Fall gibt es einen neuen Mechanismus, bei dem solche Combobox-Listen erst bei Bedarf an den Client übertragen werden - und zwar dann, wenn die Combobox aufgeklappt wird. Comboboxen mit bis zu 50 Listen-Einträgen werden weiterhin komplett übertragen. Bei so kleinen Listen würde sich eine extra Anfrage an den Broker nicht rechnen."
  },
  "doc/form/control/context-menu.html": {
    "href": "doc/form/control/context-menu.html",
    "title": "ContextMenu",
    "keywords": "ContextMenu Properties/Events Actions Buttons und ImageButtons können bei Betätigung ein Kontextmenü öffnen. Dazu muss dem Button über das Property ContextMenu ein ContextMenu zugeordnet werden. Das Control ContextMenu stellt lediglich eine Hülle dar, in der alle Menüeinträge gesammelt werden, die angezeigt werden sollen, wenn das Kontextmenü geöffnet wird. Ein neues ContextMenu lässt sich im Form-Designer ( Allgemeiner Überblick ) auf zwei Arten per Drag&Drop anlegen: Aus der Toolbox ( Registerkarte Toolbox ) heraus auf die DefaultVariant des Forms (also auf den Hintergrund des Forms) im Designer-Fenster: Das Kontextmenü wird angelegt und ist keinem Button zugeordnet. Aus der Toolbox heraus direkt auf einen Button (oder ImageButton ): Das Kontextmenü wird angelegt und dem Button zugeordnet. Der Name wird dabei mit men, gefolgt von dem Namen des Buttons, vorbelegt. Kontextmenüs werden im ClassView ( Registerkarte Class ) immer im Teilbaum unterhalb der DefaultVariant ggf. parallel zum Hauptmenü ( MainMenu ) angezeigt. Am Kontextmenü können im ClassView (wie bei anderen Menüs) neue Menüeinträge über den Eintrag New MenuItem im Kontextmenü des Treeviews angelegt werden. Warning Beim Löschen eines Kontextmenüs wird nicht überprüft, ob das Kontextmenü bereits einem Button zugeordnet ist."
  },
  "doc/form/control/dashboard-container.html": {
    "href": "doc/form/control/dashboard-container.html",
    "title": "DashboardContainer",
    "keywords": "DashboardContainer Properties/Events Actions Der Dashboard Container kann Dashboards enthalten. Dashboards werden in Form von Registerkarten angezeigt und bestehen aus einer oder mehreren Spalte(n), die die Dashboard Items beinhalten. Das Dashboard Container Steuerelement ermöglicht es, mehrere Instanzen eines Formulars in einer vom Benutzer bestimmten Weise anzuzeigen. Das bedeutet, dass der Benutzer diese Instanzen erstellen, verschieben, maximieren, nach dem Maximieren wiederherstellen, vergrößern, verkleinern und schließen kann. Jedoch sind alle Aktionen auf das jeweilige Dashboard beschränkt. Folglich kann kein Dashboard Item aus dem Dashboard Container herausgeschoben werden. Am Dashboard lässt sich eine DataSource festlegen. Darin wird, sobald Änderungen am Layout vorgenommen werden, das neue Layout als XML-string hinterlegt. Wird die DataSource Broker-seitig verändert, so wird das neue Layout vom Client umgesetzt. Zusätzlich gibt es ein OnLayoutChanged-Ereignis am Dashboard Container, welches am Broker aufgerufen wird, sobald am Client eines dieser Layout ändernde Ereignisse auftritt: Positions-/Größenänderung der Dashboard Items Hinzufügen/Entfernen von Dashboard Items Maximieren/Wiederherstellen von Dashboard Items Hinzufügen/Entfernen von Registerkarten Umbenennen von Registerkarten Registerkartenwechsel Damit dies nicht zu oft geschieht, gibt es einen Bearbeitungsmodus, der für solche Aktionen (mit Ausnahme des Registerkartenwechsels) aktiviert sein muss. Der Bearbeitungsmodus kann durch die Methode SetEditable am Dashboard Container Steuerelement gesteuert werden. Ein Dashboard Item kann durch Spezifizierung des Dashboard Containers am Workflow Link geöffnet werden:"
  },
  "doc/form/control/dockpanel.html": {
    "href": "doc/form/control/dockpanel.html",
    "title": "DockPanel",
    "keywords": "DockPanel Properties/Events Actions Mit dem DockPanel ist es möglich, einen Fenster-Bereich in horizontal oder vertikal angeordnete Bereiche aufzuteilen. Alle Child-Controls des Dock-Panels werden abhängig von der am DockPanel eingestellten DockPanelOrientation nebeneinander (Horizontal) oder übereinander (Vertical) platziert. Mit der Einstellung HorizontalOrVertical „klappt“ das DockPanel auf die Seite, wenn der Platz horizontal nicht ausreicht. Jedes Control, welches sich direkt in einem Dock-Panel befindet, hat die Eigenschaft DockPanel.ItemSize . Hier kann eine Gewichtung angegeben werden, mit der der zur Verfügung stehende Platz vom jeweiligen Control aufgefüllt werden soll. Grundsätzlich soll dort möglichst der Wert „100“ eingegeben werden – auch bei mehreren gleichberechtigten Controls („100“, „100“). Verschiedene Gewichtungen werden z.B. mit „100“ / „50“ angegeben. Mit dem Wert „None“ wird das Control in seiner minimalen Größe angezeigt."
  },
  "doc/form/control/editfield.html": {
    "href": "doc/form/control/editfield.html",
    "title": "Editfield",
    "keywords": "Editfield Properties/Events Actions Unterstütztes HTML Wenn die Eigenschaft Editor auf den Wert HTML gesetzt ist, wird am Datasource des Controls HTML Text erwartet. Das Control bietet keine vollständige Unterstützung von Html. Es folgt ein Überblick über die Einschränkungen: Das Control ist zur Darstellung von formatiertem Text gedacht. Daher werden keinerlei Eingabefelder o.ä. unterstützt. Textinhalt müssen (selbstverständlich) HTML-Encodiert dargestellt werden. Das Control kann nur Zeichen darstellen, die im Zeichensatz der eingestellten Schrift enthalten sind. Wenn am Control WordWrap eingeschaltet ist, wird (im Gegensatz zum Plain Text Modus) nur zwischen Worten getrennt. Wenn also ein Wort länger ist als die Control Breite, wird nicht umgebrochen! Dabei ist zu beachten, dass Sonderzeichen wie beispielsweise &nbsp; als Wortteil betrachtet werden. Schriftgrößen, die in Punkten (pt) angegeben sind, werden analog zu allen Schriftgrößenangaben in Framework Studio im Java Client skaliert und in mit Crystal Reports erstellten Dokumenten korrekt angezeigt. Die Definition von Schriftgrößen in einer anderen Einheit als pt wird nicht unterstützt. Ist keine Schriftgröße im Html angegeben, wird am Control die im Form Designer angegebene Größe verwendet, in Reports die dort angegebene Größe. Jeder Textinhalt muss innerhalb eines <p> Tags (Absatz) geklammert sein. Insbesondere werden deshalb die folgenden Tags nicht unterstützt: Überschriften <h1> .. <h6> Horizontale Linie <hr> Tabellen <table> <tr> <td> Aufzählungen <ol> <ul> <li> Scripte <script> Zeilenumbrüche dürfen nicht mit <br> Tags realisiert werden, da mehrere <br> Tags hintereinander vom Crystal Reports nicht korrekt dargestellt werden können. Stattdessen müssen mit den Tags <p style=\"margin-top: 0\"> und </p> Absätze umschlossen werden. <p> Tags können neben der Definition von margin-top im style Attribut weitere Attribute und Stilangaben enthalten sein. Bilder können mithilfe eines <img alt=\"bild\" src=\"data:image/png;base64, BORw0KGgoAAAANSUhEUgA.../> Tags und im base64 Format eingebunden werden. Auch das Einfügen aus der Zwischenablage im Java-Client wird unterstützt. Im Html-Modus liefert der Datasource den Inhalt eines Body-Elements. Gesetzt werden darf auch ein vollständiges Html-Dokument. In diesem Fall wird der Body automatisch extrahiert. Note Hinweise zu Bildern: Reports, die mit DevExpress erstellt werden, unterstützen diese Bilder. Reports, die mit Crystal Report erstellt werden, unterstützen diese Bilder nicht. Wenn Bilder aus der Zwischenablage nicht von dem Dateityp PNG oder JPEG sind, werde diese zu einem der Dateitypen konvertiert. Bei der Konvertierung wird auf die entstehende Dateigröße geachtet und die Datei (entweder PNG oder JPEG) genommen, die am wenigsten Speicher verbraucht. Sollte die PNG Datei bis maximal 20 Prozent größer als die JPEG Datei sein, wird trotzdem wegen der besseren Qualität die PNG Datei verwendet."
  },
  "doc/form/control/erzeugen-suchdialogs-property.html": {
    "href": "doc/form/control/erzeugen-suchdialogs-property.html",
    "title": "Erzeugen eines Suchdialogs durch Property-Funktionalität",
    "keywords": "Erzeugen eines Suchdialogs durch Property-Funktionalität Wenn Sie sich die Properties der Controls aufmerksam angesehen haben, ist Ihnen sicher aufgefallen, dass Sie z.B. Buttons als IsSearchButton und Edit-Felder als IsSearchField deklarieren können. Framework Studio bietet die Möglichkeit, relativ einfach Suchbedingungen anhand der vorhandenen Controls zu erzeugen und auch automatisch einen Load an einer Component oder Collection mit dieser Suchbedingung auszuführen. Die Felder, die sich an der Suchbedingung beteiligen sollen, werden entsprechend mit dem Property IsSearchField gekennzeichnet. Damit das funktioniert, muss den Controls als Datasource ein Property der Component zugeordnet sein, aus der die Suchbedingung erstellt werden soll. Wollen Sie z.B. einen Kundensuchdialog erstellen, werden Suchfelder als DataSource Properties der Komponente Kunden haben. Definieren Sie die Felder entsprechend als IsSearchField und stellen unter SearchOperator den Suchoperator ein. Ein weiteres Element der Suche mit Property-Funktionalität sind Buttons. Buttons können als IsSearchButton deklariert werden. In unserem Beispiel würden Sie einen Button oder ImageButton als solchen kennzeichnen. Jetzt müssen Sie dem Button noch sagen, an welcher Collection der Load ausgeführt werden soll. Dies tun Sie mit der Eigenschaft LoadAtComponent . In unserem Beispiel könnte das die KundenCollection sein. Als letztes müssen Sie noch bestimmen, aus welcher Component die Suchbedingung stammt. Das ist immer die Component, aus der die Properties der Suchfelder stammen, also in dem Beispiel Kunden. Tragen Sie die Component entsprechend unter SearchValuesComponent ein. Ihr Suchdialog ist fertig. Bei einem Klick auf den Such-Button wird geprüft, ob in einem als Suchfeld definierten Control ein Wert hinterlegt worden ist. Ist dies der Fall, wird das Feld entsprechend dem Operator in Ihre Suchbedingung aufgenommen. Ist ein Property einer Komponente als SearchField deklariert, steht Ihrem Form eine Methode mit dem Namen GenerateLoadConditionOnXxxXxx zur Verfügung. Diese Methode baut Ihren Select-String zusammen. Die Einstellungen an dem Such-Button bewirken, dass dieser automatisch einen Load in der Form LoadAtComponent.Load( GenerateLoadConditionOnXxxXxx) erzeugt. Wenn Sie die Suche lieber selber ausprogrammieren, können Sie die Suchbedingung auch modifizieren."
  },
  "doc/form/control/events.html": {
    "href": "doc/form/control/events.html",
    "title": "Events",
    "keywords": "Events Events sind Ereignisse, die durch die Interaktion mit einem Formular entstehen. Der Klick auf einen Button ist z.B. ein OnClick-Event. Sie haben in Framework Studio die Möglichkeit, auf solche Ereignisse zu reagieren. Erzeugen Sie dazu ein Event und binden es an Ihr Control. Sie sollten dabei beachten, dass beim Eintreten eines Events jedes Mal eine Interaktion zwischen dem Webserver und dem Client stattfindet. Workflow-Events dienen der Interaktion mit anderen Dialogen, Form-Events der Abarbeitung von Logik aufgrund eines Ereignisses. Der einfachste Weg ein Event zu erzeugen, ist aus dem Kontext-Menü des Controls den Eintrag Event und anschließend das gewünschte Event auszuwählen. Jetzt müssen Sie noch bestimmen, ob Sie ein Form-Event oder ein Workflow-Event wünschen. Es öffnet sich ein kleines Fenster, über das Sie eine vorhandene Event-Handler Methode auswählen oder einfach eine neue erstellen können. MethodAssignerForm: Manche Events verfügen über spezielle EventArgs, über die Sie Kontext-Informationen des aufgetretenen Events ermitteln können. Siehe ControlDesignViewModel"
  },
  "doc/form/control/fieldpanel.html": {
    "href": "doc/form/control/fieldpanel.html",
    "title": "FieldPanel",
    "keywords": "FieldPanel Properties/Events Actions Das FieldPanel dient dazu, eine zusammenhängende Gruppe primär von Feldern – aber auch von anderen Controls – darzustellen. Die Labels der Controls werden automatisch erzeugt und vor die entsprechenden Controls positioniert. Es sind keine separaten Label-Controls nötig. Ein Field-Panel besteht immer aus den FieldRows , in denen die eigentlichen Controls platziert werden. Die Controls werden linksbündig nebeneinander angeordnet. Wenn ein oder mehrere Controls eine flexible Breite besitzen, dann wird der zur Verfügung stehende Platz komplett gefüllt. Die flexiblen Controls teilen sich dabei den kompletten Platz, gewichtet nach ihrer MinWidth auf."
  },
  "doc/form/control/field-row.html": {
    "href": "doc/form/control/field-row.html",
    "title": "FieldRow",
    "keywords": "FieldRow Properties/Events Actions Stellt eine Zeile in einem Field-Panel dar. Werden Controls in einem FieldPanel platziert, dann erfolgt dies immer mithilfe einer FieldRow."
  },
  "doc/form/control/form-container.html": {
    "href": "doc/form/control/form-container.html",
    "title": "FormContainer",
    "keywords": "FormContainer Properties/Events Actions Der Form Container ist ein Panel, welches genau eine Instanz eines Formulars enthalten kann. Um hierin ein Formular zu öffnen, muss am Workflow Link der Container -Wert gesetzt werden: Wird ein Formular in einem FormContainer geöffnet, der bereits ein Formular beinhält, so wird das alte zuvor entfernt."
  },
  "doc/form/control/grid.html": {
    "href": "doc/form/control/grid.html",
    "title": "Grid",
    "keywords": "Grid Properties/Events Actions Grid Beispiel Das Grid stellt Daten in tabellarischer Form dar. Grid Sortierung Dem Client bietet das Grid außerdem die Möglichkeit die Daten per Mausklick auf den entsprechenden Spaltenkopf sortiert darzustellen. Gedrückthalten der Umschalttaste ermöglicht es, auch mehrere Spalten eines Grid Controls per Mausklick zu sortieren. Dabei hat die zuerst (ohne Umschalttaste) ausgewählte Spalte die höchste Priorität. Durch weitere Klicks mit Umschalttaste kann das zweite, dritte, … Sortier-Kriterium angegeben werden. Wenn der Kopf einer bereits sortierten Spalte erneut mit gedrückter Umschalttaste angeklickt wird, dann wird für diese Spalte die Sortier-Richtung geändert (aufsteigend, absteigend, unsortiert) und sie wird als Sortier-Kriterium niedrigster Priorität hinten angestellt. Das Kontextmenü eines Spaltenkopfs arbeitet ausschließlich im Mehrfach-Sortierungs -Modus und enthält einen weiteren Eintrag, um sämtliche Sortierungen zurückzusetzen: Grid Filter Außerdem kann auch für jede Spalte ein Filter über das Kontextmenü definiert werden. Hier gilt ebenfalls die Regel, dass das Kontextmenü grundsätzlich Mehrfach-Filterung zulässt und eine Möglichkeit zum Zurücksetzen bietet. Der Filterdialog erscheint durch den Kontextmenüeintrag Filter / Filter anpassen . Bei Spalten mit Datumswerten kann durch Rechtsklick auf das darin enthaltene Eingabefeld ein Kalender aufgerufen werden: Für Checkboxen bietet der Client eine spezielle Filteroption. Es kann nach Checked/Aktiviert oder Unchecked/Deaktiviert gefiltert werden. Gibt es Datensätze mit Null-Werten, werden diese bei der Checkbox-Filterung als Unchecked gewertet. Allgemeines zu den Row-Icons Hinter jedem Grid steckt eine Collection und hinter jeder Zeile ein Objekt aus der Collection. Das Row-Icon zeigt den Status dieses Objekts an ( neu , geändert oder gelöscht ). Das Property RowHeader muss auf DisplayRowStatus eingestellt sein, damit die Icons angezeigt werden."
  },
  "doc/form/control/grid-column.html": {
    "href": "doc/form/control/grid-column.html",
    "title": "Grid-Column",
    "keywords": "Grid-Column Properties/Events Actions Ist einem Grid eine Collection als Datasource zugewiesen, können die Properties des Collection-Objekts dem Grid als Columns zugewiesen werden."
  },
  "doc/form/control/image-button.html": {
    "href": "doc/form/control/image-button.html",
    "title": "Image Button",
    "keywords": "Image Button Properties/Events Actions Ein Image-Button ist ein Bild, das sich wie ein Push-Button verhält. Wenn Sie dem Image-Button als Bild eine GIF-Datei mit transparentem Hintergrund zuweisen, können Sie, wie die Abbildung zeigt, Buttons in beliebigen Formen erstellen. Dem Button können Sie vier verschiedene Bilder zuweisen. Ein Bild für den normalen Zustand, eins das angezeigt wird, wenn der Button disabled ist, eins das angezeigt wird, wenn sich die Maus über dem Button befindet und eines, das dann angezeigt wird, wenn auf den Button geklickt wird."
  },
  "doc/form/control/is-visible-editable-au.html": {
    "href": "doc/form/control/is-visible-editable-au.html",
    "title": "IsVisibleAU / IsEditableAU",
    "keywords": "IsVisibleAU / IsEditableAU Die Control-Eigenschaften IsVisibleAU und IsEditableAU stellen jeweils eine Liste von AccessUnit Objekten verknüpft mit je einem AUPermissionType dar. Für jeden dieser Listeneinträge wird bei der Initialisierung der Form-Controls mit Hilfe der Methode IGlobalObjects.AUHelper.Granted(AccessUnit, AUPermissionType) geprüft, ob der Zugriff gewährt wird. Falls dies bei keinem der Einträge zutrifft und die Liste nicht leer ist, so wird das entsprechende Control unsichtbar (bei IsVisibleAU ) bzw. kann nicht bearbeitet werden (bei IsEditableAU ). Wenn das Property IsVisible bzw. IsEditable bereits auf false gesetzt wurde, haben die Properties keine Auswirkungen. Eine spezielle Access Unit ist die FormAccessUnit. Sie ist, worauf der Name bereits hinweist, dem Form zugeordnet. Im Fall von IsVisibleAU und IsEditableAU ist die äußerste Spezialisierung in der Vererbungskette relevant. Wird eine Eigenschaft in einem vererbten From oder im Customizing überschrieben, so wirken die Listeneinträge als wären sie mit denen aus der Basis vereinigt. Warning Bei kritischen Aktionen sollte weiterhin eine Prüfung der Access Units auf funktionaler Ebene erfolgen. Controls könnten durch Überschreibungen von IsVisibleAU / IsEditableAU oder den Actions SetVisible(bool) / SetEnabled(bool) sichtbar bzw. zugänglich gemacht werden. Der Dialog zum Festlegen der Properties IsVisibleAU und IsEditableAU , der beim Klick auf den Button im Property Grid erscheint, zeigt links eine AccessUnit-Textbox und die FormAccessUnit zur Auswahl an. Rechts sind die in der Liste enthaltenen Access Units. Die in der Mitte befindlichen Buttons fügen eine im linken Bereich ausgewählte AccessUnit aus der Textbox oder die FormAccessUnit ein (Alle Buttons mit diesem Pfeil: ). Eine selektierte AccessUnit auf der rechten Seite kann über den Button entfernt werden. Dialog zur Bearbeitung von IsVisibleAU/IsEditableAU"
  },
  "doc/form/control/label.html": {
    "href": "doc/form/control/label.html",
    "title": "Label",
    "keywords": "Label Properties/Events Actions Das Label dient dazu, Text in einer Maske anzuzeigen. Sie können einem Label einen festen Text zuweisen und somit z.B. andere Controls mit einer Beschriftung versehen. Dieser Text wird mehrsprachig hinterlegt. Es ist auch möglich einem Label einen Datasource zuzuweisen. So können Sie auch Inhalte von Properties anzeigen."
  },
  "doc/form/control/listbox.html": {
    "href": "doc/form/control/listbox.html",
    "title": "Listbox",
    "keywords": "Listbox Properties/Events Actions Bei einer Listbox handelt es sich im Grunde um eine Combobox, die immer ausgeklappt ist."
  },
  "doc/form/control/listview.html": {
    "href": "doc/form/control/listview.html",
    "title": "ListView",
    "keywords": "ListView Properties/Events Actions Note Dieses Control funktioniert nur im Mobile-Client . Im Java-Client wird das Control nicht angezeigt. ListView Template Editor Der ListView Template Editor bietet die Möglichkeit, das HTML/CSS Template für ListItems sprachabhängig zu definieren. Dabei können Template DataSources definiert werden, auf welche aus dem HTML heraus mittels Template Variablen verwiesen wird. So können sehr einfach Businessdaten ins HTML eingebettet und formatiert werden. Der Editor kann im Property-Grid über das Property Template geöffnet werden. Allgemein Dropdown für Sprachauswahl Das HTML und CSS eines ListItems kann, wenn gewünscht, für jede Sprache einzeln definiert werden. Ist für eine Sprache kein Template definiert, wird auf Deutsch zurückgegriffen. Button Validate Über diesen Button können die im HTML eingebetteten Template Variablen und Template MLKeys überprüft werden. Es werden folgende Fälle geprüft: Ist der Template MLKey parsebar und ist der MLKey-Name gültig? Ist die Template Variable parsebar? Passt das angegebene Format zum Datentyp? Zeigt die Template Variable auf eine existierende Template DataSource? Ist jeder Template DataSource eine valide DataSource zugeordnet Template DataSources Auf der rechten Seite der Registerkarte HTML befindet sich die Liste der definierten Template DataSources. Jede Template DataSource zeigt auf ein Property der der ListView zugeordneten DataSource Collection. Im Beispiel ist der ListView die cdArticleColl aus dem FSDemo als DataSource zugewiesen. Somit stehen einer Template DataSource alle Properties des cdArticle -Objekts zur Verfügung. Wie im Bild zu sehen, verweist die Template DataSource Price auf das Property decPrice von cdArticle . Der Name einer Template DataSource muss eindeutig sein. Aus dem HTML kann nun mittels einer Template Variable auf die Template DataSource zugegriffen und der Wert wie gewünscht im HTML formatiert werden. HTML Auf der linken Seite der Registerkarte HTML befindet sich der HTML-Codeeditor, in dem das HTML für das ListItem definiert werden kann. Note Das benutzerdefinierte HTML wird zur Laufzeit vom HTML Client (Angular) compiliert und optimiert. Grobe Fehler wie z.B. nicht geschlossene Tags oder invalides HTML können zu Anzeigefehlern führen, die unter Umständen auch andere Bereiche des HTML Clients betreffen. ListView Templates sollten vor dem produktiven Einsatz in allen verfügbaren Browsern ausgiebig getestet werden. Button Use Base Mit dem Button Use Base kann das HTML Template z.B. nach einem Customizing wieder auf die Basis zurückgesetzt werden. Button Template Variable Mit dem Button Template Variable kann eine neue Template Variable erstellt, oder eine bestehende geändert werden. Button MLKey Mit dem Button MLKey wird das MLKey-Wörterbuch geöffnet. Dort kann ein neuer Template MLKey erstellt, oder ein bestehender geändert werden. HTML Aufbau Der benutzerdefinierte HTML Code wird im HTML Client in ein <div> -Tag mit der CSS-Klasse lvItem verpackt. Es ist also nicht unbedingt nötig, um den eigenen HTML Code ein <div> -Tag als Container zu implementieren. Der Code aus dem Beispiel sieht im HTML Client z.B. so aus: <hc-listitem-content _nghost-wvt-c19 class=\"ng-star-inserted\"> <div _ngcontent-wvt-c19 class=\"lvItem\"> <img _ngcontent-wvt-c19 src=\"http://localhost:8080/Dev/NV286_1_ListView40_FSDemo_4.0_user1/FSDempApplication//images/NVNew1.png\"> <span _ngcontent-wvt-c19>Laptop SILBER kostet 1,899.00€</span> </div> </hc-listitem-content> Das <div> -Tag mit der CSS-Klasse lvItem kann im CSS wie gewünscht angepasst werden, ohne einen eigenen Container oder eine eigene CSS-Klasse verwenden zu müssen. Placeholder Die Konstante %FILESURL% kann im HTML verwendet werden, um zur Laufzeit die Broker-Url zu erhalten. Dadurch können z.B. in <img> -Tags auf Bilder, welche als Ressourcen im Framework Studio hinterlegt wurden, zugegriffen werden. Dynamische Bilder können über eine binäre Template-Variable realisiert werden. (siehe Abschnitt Images im ListViewItem ) Template Variablen Über den Button Template Variable öffnet sich der Template Variable Editor . Befindet sich der Cursor im Codeeditor auf einer bestehenden Template Variable, wird diese im Editor vorselektiert. Auf der linken Seite werden alle zur Verfügung stehenden Template DataSources aufgelistet. Auf der rechten Seite kann für die Template Variable ein passendes Format und/oder FormatPattern definiert werden. Durch die Aufteilung in Template DataSources und Template Variablen werden die Daten und deren Formatierung im HTML strikt voneinander getrennt. Beispielsweise könnte der Wert einer Template DataSource im englischen HTML anders formatiert werden als im deutschen HTML. Template Variablen werden im HTML-Code wie folgt angezeigt: {{ ds:[Name]|f:[Format]|fp:[FormatPattern] }} Dabei verweist [Name] auf den Namen der zugehörigen Template DataSource, [Format] und [FormatPattern] definieren das im Template Variable Editor ausgewählte Format und FormatPattern. PreviewValue ist derjenige Wert, der für die Template Variable angezeigt wird, wenn das Template auf der Registerkarte Preview zur Vorschau gerendert wird. Der Wert wird zur Laufzeit ignoriert. Note Es wird empfohlen, Template Variablen und Template MLKeys immer über den jeweiligen Editor zu ändern, um Syntaxfehler zu vermeiden. Template MLKey Template MLKeys werden im HTML-Code wie folgt angezeigt: {{ mlkey:[MLKey-Name] }} Dabei verweist [MLKey-Name] auf den Namen des zugehörigen MLKeys. Zum Beispiel \"SYS_OK\". CSS Das benutzerdefinierte HTML kann mittels CSS im CSS-Codeeditor auf der Registerkarte CSS beliebig angepasst werden. Beispiel: .lvltem { display: flex; flex-direction: row; align-items: center; background-color: azure; border-radius: 0.3rem; border: 0.1rem solid gray; padding: 0.3rem; padding-right: 2.8rem; } .lvItem[lvdisabled] { background-color: #cccccc; } img { display: inline; } Wie im Kapitel HTML beschrieben, wird ein ListItem mit einem <div> -Tag der CSS-Klasse lvItem umgeben. Im CSS-Code kann somit über den CSS-Selector .lvItem auf das Element zugegriffen werden. Globales CSS für ListViewItems Es ergiebt durchaus Sinn, grundelegende Styles von ListViewItems global zu definieren. ListViewItems könnten z.B. eine einheitliche Border oder Hintergrundfarbe besitzen. Für diesen Zweck existiert der globale CSS Editor für ListViewItems am FSGeneral.Controls.BaseControl . Über das Property ListVIewItem unter der Kategorie Global CSS öffnet sich der CSS Editor. Die globalen Styles können je Sprache definiert werden. Ist für eine Sprache kein CSS definiert, wird auf Deutsch zurückgegriffen. Alle globalen Styles werden vom individuellen CSS am Control überschrieben, wie das folgende Beispiel zeigt: Globales CSS: .lvItem { color: white; background-color: green; } CSS an ListView LV1 : .lvItem { background-color: blue; } Die global definierte grüne Hintergrundfarbe wird im CSS von ListView LV1 überschrieben. So haben alle ListViewItems von LV1 eine blaue Hintergrundfarbe und weißen Text. REM anstatt Pixel Im CSS sollten Größenangaben ausschließlich mit rem angegeben werden. Der HTML Client skaliert die gesamte Anzeige anhand der vom Browser vorgegebenen Schriftgröße. Im HTML Client wird global für das HTML- und das BODY-Tag folgendes definiert: html { font-size: 62.5%; } body { font-size: 1.4rem; } In Desktop-Browsern wie z.B. Chrome, Firefox oder Edge ist der Standardwert der Schriftgröße 16px . 1rem ist per Definition genauso groß wie die Schriftgröße des HTML-Tags, also im Standardfall erst einmal 16px . Setzt man nun die font-size des HTML-Tags auf 62.5% , ergibt sich eine Schriftgröße von 10px , womit 1rem nun ebenfalls 10px groß ist. Da meist in Desktop-Browsern entwickelt und getestet wird, ergibt diese Anpassung Sinn, da es viel einfacher zu verstehen ist, mit Faktor 10, als mit Faktor 16 zu arbeiten. 0.5rem sind 5px , 5rem sind 50px usw. Deshalb wird im BODY-Tag auch die Schriftgröße auf 1.4rem gesetzt, was letztenendes 14px sind. Dies spiegelt die Standardschriftgröße des HTML Clients wieder. Probleme können nun enstehen, wenn REM- und Pixelwerte gemischt werden! Ein Beispiel: .tpl .remClass { width: 10rem; } .tpl .pxClass { width: 100px; } Nehmen wir an, es gibt zwei HTML-Elemente im Template mit den Klassen remClass und pxClass . Liefert der Browser eine Standardgröße von 16px , besteht kein Problem, die beiden Elemente sind exakt gleich groß, da 65.5% von 16px = 10px . Damit sind 10rem exakt 100px . Anders sieht es aber aus, wenn z.B. ein mobiler Browser eine Standardschriftgröße von 14px liefert. 62.5% von 14px = 8.75px , damit sind 10rem exakt 87.5px und die beiden HTML-Elemente sind plötzlich unterschiedlich groß. Dies kann je nach Gerät und verwendetem Browser zu unvorhersehbaren Skalierungsfehlern führen. Tip Es wird ausdrücklich empfohlen, im HTML/CSS des ListItems rem als Größeneinheit zu verwenden. IsEditable Im CSS kann auch ein Style für deaktivierte ListItems in einem nicht editierbaren ListView hinterlegt werden. Wird ein ListView im Designer oder per Action auf isEditable = false gesetzt, so wird am <div> -Tag lvItem das HTML-Attribut lvdisabled hinzugefügt: <hc-listitem-content _nghost-wvt-c19 class=\"ng-star-inserted\"> <div _ngcontent-wvt-c19 class=\"lvItem\" lvdisabled=\"true\"> [...] </div> </hc-listitem-content> Im CSS-Code kann über den Attribute-Selector .lvItem[lvdisabled] genau dieser Fall abgefragt werden. Im Beispiel wird der Hintergrund des ListItems auf grau ( #cccccc ) gesetzt. Preview Wenn der HTML-Code gültig ist, wird auf der Registerkarte \"Preview\" eine gerenderte Vorschau des Templates angezeigt. Für die Vorschau werden die PreviewValues für die einzelnen Template Variablen verwendet. Sollte ein PreviewValue nicht gesetzt sein, wird stattdessen der DataSource Name angezeigt. Template MLKeys zeigen den im Wörterbuch hinterlegten Text an. Fallback für die Standartsprache Wenn für eine Sprache eines bestimmten HTML-Codes nicht gibt, wird den HTML-Code des Standartsprache (Deutsch) verwendet. Diese Regel wird auch für den CSS-Code anwenden. Anderseits, wenn kein Code auch für die Standardsprache gibt, wird die Meldung TEMPLATE NULL angezeigt. Images im ListViewItem Eine Besonderheit ist das Anzeigen von Bildern in einem ListViewItem mittels <img /> , wenn dieses über ein byte[] aus der Datenbank gebunden werden soll. Ein Anwendungsfall wäre z.B. das Anzeigen von Artikelbildern. Beispiel: <img class=\"img\" src=\"data:{{ ds:MimeType }};base64,{{ ds:Image }}\" /> Um ein Bild an ein HTML img-Tag zu binden sind zwei Template Variablen notwendig. Das byte[] mit den Bildinformationen alleine reicht abhängig vom genutzten Browser nicht immer aus (siehe Hinweis). Es muss zusätzlich der HTML Mime-Type spezifiziert werden, sodass der Browser weiß, um welches Bildformat es sich handelt. {{ ds:MimeType }} ist eine Template Variable vom typ FSstring oder string und gibt z.B. den Mime-Type \"image/png\" oder \"image/jpg\" zurück. {{ ds:Image }} ist eine Template Variable vom Type FSByteArray oder byte[] . Binärdaten werden als Base64-String zum Client übertragen. Da das HTML src -Attribut Base64 versteht, ist keine weitere Formatierung der Daten nötig. Tip Die Angabe des Mime-Types ist in den meisten Browsern wie Chrome, Firefox, Safari oder Edge (auch auf mobilen Geräten) nicht zwingend nötig. Manche proprietären Browser auf mobilen Geräten haben jedoch Schwierigkeiten, ohne die Angabe des Mime-Types, das Bild korrekt darzustellen. Sollten diese Browser keine Rolle für die Anwendung spielen, kann auch folgendes HTML genutzt werden: <img class=\"img\" src=\"data:;base64,{{ ds:Image }}\" /> Das Semicolon vor base64 ist ohne die Angabe des Mime-Types zwingend notwendig."
  },
  "doc/form/control/menu-item.html": {
    "href": "doc/form/control/menu-item.html",
    "title": "Menu-Item",
    "keywords": "Menu-Item Properties/Events Actions"
  },
  "doc/form/control/picture.html": {
    "href": "doc/form/control/picture.html",
    "title": "Picture",
    "keywords": "Picture Properties/Events Actions Das Picture-Control dient als Positionsrahmen für Bilder. Ziehen Sie dazu das Control Picture per Drag & Drop auf das Form und hinterlegen Sie anschließend die URL für das Bild. Über den Datasource lassen sich auch dynamisch Bilder zuordnen. Das Picture-Control unterstützt, wie der Image-Button, die Formate GIF, JPG und PNG."
  },
  "doc/form/control/radiobutton.html": {
    "href": "doc/form/control/radiobutton.html",
    "title": "Radio-Button",
    "keywords": "Radio-Button Properties/Events Actions Mit Radio-Buttons können Sie den Benutzer zwischen einer definierten Anzahl von Möglichkeiten wählen lassen. Es ist immer ein Radio-Button ausgewählt. Wird ein zweiter Radio-Button geklickt, wird der erste automatisch deaktiviert. Um dies zu ermöglichen, besitzen Radio-Buttons einen gemeinsamen DataSource, über den sie gesetzt werden. Für jeden Radio-Button wird definiert, bei welchem Wert er aktiv ist. Radio-Buttons werden auf einem Panel zusammengefasst, dessen Property ButtonGroupDataSource als gemeinsamer DataSource dient."
  },
  "doc/form/control/tabbedwindow.html": {
    "href": "doc/form/control/tabbedwindow.html",
    "title": "Tabbed-Window",
    "keywords": "Tabbed-Window Properties/Events Actions Durch das Tabbed Window können Sie Registerkarten auf ihrem Formular positionieren. Durch dieses gestalterische Mittel vergrößern Sie deshalb die Oberfläche Ihres Formulars und haben zugleich die Möglichkeit, ihre Controls in einen Kontext zu bringen. Über das Kontext-Menü des Tabbed-Windows können Sie neue Tab-Karteikarten hinzufügen."
  },
  "doc/form/control/tabpage.html": {
    "href": "doc/form/control/tabpage.html",
    "title": "Tab-Page",
    "keywords": "Tab-Page Properties/Events Actions Einzelne Registerkarten eines Tabbed Windows werden TabPage genannt. Sie können entweder über das Kontext-Menü des Tabbed Windows im Form-Designer oder über das Kontext-Menü des Tabbed Windows auf der Registerkarte Class (Default Variant) hinzugefügt werden. TabPages können als separates Control innerhalb eines Tabbed Windows ausgewählt werden, um auf die Properties zuzugreifen."
  },
  "doc/form/control/template.html": {
    "href": "doc/form/control/template.html",
    "title": "Template Control",
    "keywords": "Template Control Properties/Events Actions Note Dieses Control funktioniert nur im Mobile-Client . Im Java-Client wird das Control nicht angezeigt. Template Editor Der Template Editor bietet die Möglichkeit, das HTML/CSS Template für das Template Control sprachabhängig zu definieren. Dabei können Template DataSources definiert werden, auf welche aus dem HTML heraus mittels Template Variablen verwiesen wird. So können sehr einfach Businessdaten ins HTML eingebettet und formatiert werden. Der Editor kann im Property-Grid über das Property Template geöffnet werden. Allgemein Dropdown für Sprachauswahl Das HTML und CSS eines Template Controls kann, wenn gewünscht, für jede Sprache einzeln definiert werden. Ist für eine Sprache kein Template definiert, wird auf Deutsch zurückgegriffen. Button Validate Über diesen Button können die im HTML eingebetteten Template Variablen und Template MLKeys überprüft werden. Es werden folgende Fälle geprüft: Ist der Template MLKey parsebar und ist der MLKey-Name gültig? Ist die Template Variable parsebar? Passt das angegebene Format zum Datentyp? Zeigt die Template Variable auf eine existierende Template DataSource? Ist jeder Template DataSource eine valide DataSource zugeordnet Ist die DataSource einer Template DataSource weder private noch internal Template DataSources Auf der rechten Seite der Registerkarte HTML befindet sich die Liste der definierten Template DataSources. Jede Template DataSource zeigt auf ein Property des Forms in dem sich das Template Control befindet. Im Beispiel hat das Form ein Property oAddress vom Typ cdAddress (eine Component), welches wiederum einige Unterproperties hat. Wie im Bild zu sehen, verweist die Template DataSource Street auf das Property sStreet von oAddress . Der Name einer Template DataSource muss eindeutig sein. Aus dem HTML kann nun mittels einer Template Variable auf die Template DataSource zugegriffen und der Wert wie gewünscht im HTML formatiert werden. HTML Auf der linken Seite der Registerkarte HTML befindet sich der HTML-Codeeditor, in dem das HTML für das Template Control definiert werden kann. Note Das benutzerdefinierte HTML wird zur Laufzeit vom HTML Client (Angular) compiliert und optimiert. Grobe Fehler wie z.B. nicht geschlossene Tags oder invalides HTML können zu Anzeigefehlern führen, die unter Umständen auch andere Bereiche des HTML Clients betreffen. Templates sollten vor dem produktiven Einsatz in allen verfügbaren Browsern ausgiebig getestet werden. Button Use Base Mit dem Button Use Base kann das HTML Template z.B. nach einem Customizing wieder auf die Basis zurückgesetzt werden. Button Template Variable Mit dem Button Template Variable kann eine neue Template Variable erstellt, oder eine bestehende geändert werden. Button MLKey Mit dem Button MLKey wird das MLKey-Wörterbuch geöffnet. Dort kann ein neuer Template MLKey erstellt, oder ein bestehender geändert werden. HTML Aufbau Der benutzerdefinierte HTML Code wird im HTML Client in ein <div> -Tag mit der CSS-Klasse tpl verpackt. Es ist also nicht unbedingt nötig, um den eigenen HTML Code ein <div> -Tag als Container zu implementieren. Der generierte Code aus dem Beispiel sieht im HTML Client z.B. so aus: <hc-tpl-ctrl-content class=\"ng-star-inserted\"> <div class=\"tpl\"> <div class=\"wrapper\"> <div class=\"icon\"> <img class=\"img\" src=\"data:image/png;base64,iVBORw...\"> </div> <div class=\"text\"> <span class=\"header\">Adresse</span> <span>Max Mustermann</span> <span>Musterstraße 7a</span> <span>78333 Musterstadt</span> </div> </div> </div> </hc-tpl-ctrl-content> Das <div> -Tag mit der CSS-Klasse tpl kann im CSS wie gewünscht angepasst werden, ohne einen eigenen Container oder eine eigene CSS-Klasse verwenden zu müssen. Placeholder Die Konstante %FILESURL% kann im HTML verwendet werden, um zur Laufzeit die Broker-Url zu erhalten. Dadurch können z.B. in <img> -Tags auf Bilder, welche als Ressourcen im Framework Studio hinterlegt wurden, zugegriffen werden. Dynamische Bilder können über eine binäre Template-Variable realisiert werden. (siehe Abschnitt Images im Template ) Template Variablen Über den Button Template Variable öffnet sich der Template Variable Editor . Befindet sich der Cursor im Codeeditor auf einer bestehenden Template Variable, wird diese im Editor vorselektiert. Auf der linken Seite werden alle zur Verfügung stehenden Template DataSources aufgelistet. Auf der rechten Seite kann für die Template Variable ein passendes Format und/oder FormatPattern definiert werden. Durch die Aufteilung in Template DataSources und Template Variablen werden die Daten und deren Formatierung im HTML strikt voneinander getrennt. Beispielsweise könnte der Wert einer Template DataSource im englischen HTML anders formatiert werden als im deutschen HTML. Template Variablen werden im HTML-Code wie folgt angezeigt: {{ ds:[Name]|f:[Format]|fp:[FormatPattern]|pv:[PreviewValue] }} Dabei verweist [Name] auf den Namen der zugehörigen Template DataSource, [Format] und [FormatPattern] definieren das im Template Variable Editor ausgewählte Format und FormatPattern. PreviewValue ist derjenige Wert, der für die Template Variable angezeigt wird, wenn das Template auf der Registerkarte Preview zur Vorschau gerendert wird. Der Wert wird zur Laufzeit ignoriert. Note Es wird empfohlen, Template Variablen und Template MLKeys immer über den jeweiligen Editor zu ändern, um Syntaxfehler zu vermeiden. Template MLKey Template MLKeys werden im HTML-Code wie folgt angezeigt: {{ mlkey:[MLKey-Name] }} Dabei verweist [MLKey-Name] auf den Namen des zugehörigen MLKeys. Zum Beispiel \"SYS_OK\". CSS Das benutzerdefinierte HTML kann mittels CSS im CSS-Codeeditor auf der Registerkarte CSS beliebig angepasst werden. Beispiel: .tpl { display: flex; flex-direction: column; background-color: lightyellow; border: 0.1rem solid gray; border-radius: 0.3rem; } .tpl[tpldisabled] { background-color: grey; } .wrapper { flex: 1; display: flex; justify-content: left; padding: 1rem; padding-left: 1.5rem; line-height: 1.7rem; } .icon { flex: 0 0 auto; display: flex; flex-direction: column; align-items: center; justify-content: center; } .text { flex: 1; display: flex; flex-direction: column; justify-content: left; padding-left: 1.5rem; line-height: 1.7rem; } .img { max-height: 6rem } .header { font-weight: bold; margin-bottom: 0.3rem; } Wie im Kapitel HTML beschrieben, wird ein ListItem mit einem <div> -Tag der CSS-Klasse tpl umgeben. Im CSS-Code kann somit über den CSS-Selector .tpl auf das Element zugegriffen werden. Globales CSS für Template Controls Es ergiebt durchaus Sinn, grundelegende Styles von Template Controls global zu definieren. Sie könnten z.B. eine einheitliche Border oder Hintergrundfarbe besitzen. Für diesen Zweck existiert der globale CSS Editor für Template Controls am FSGeneral.Controls.BaseControl . Über das Property TemplateControl unter der Kategorie Global CSS öffnet sich der CSS Editor. Die globalen Styles können je Sprache definiert werden. Ist für eine Sprache kein CSS definiert, wird auf Deutsch zurückgegriffen. Alle globalen Styles werden vom individuellen CSS am Control überschrieben, wie das folgende Beispiel zeigt: Globales CSS: .tpl { color: white; background-color: green; } CSS an Template Control TPL1 : .tpl { background-color: blue; } Die global definierte grüne Hintergrundfarbe wird im CSS von Template Control TPL1 überschrieben. Somit hat dies eine blaue Hintergrundfarbe und weißen Text. REM anstatt Pixel Im CSS sollten Größenangaben ausschließlich mit rem angegeben werden. Der HTML Client skaliert die gesamte Anzeige anhand der vom Browser vorgegebenen Schriftgröße. Im HTML Client wird global für das HTML- und das BODY-Tag folgendes definiert: html { font-size: 62.5%; } body { font-size: 1.4rem; } In Desktop-Browsern wie z.B. Chrome, Firefox oder Edge ist der Standardwert der Schriftgröße 16px . 1rem ist per Definition genauso groß wie die Schriftgröße des HTML-Tags, also im Standardfall erst einmal 16px . Setzt man nun die font-size des HTML-Tags auf 62.5% , ergibt sich eine Schriftgröße von 10px , womit 1rem nun ebenfalls 10px groß ist. Da meist in Desktop-Browsern entwickelt und getestet wird, ergibt diese Anpassung Sinn, da es viel einfacher zu verstehen ist, mit Faktor 10, als mit Faktor 16 zu arbeiten. 0.5rem sind 5px , 5rem sind 50px usw. Deshalb wird im BODY-Tag auch die Schriftgröße auf 1.4rem gesetzt, was letztenendes 14px sind. Dies spiegelt die Standardschriftgröße des HTML Clients wieder. Probleme können nun enstehen, wenn REM- und Pixelwerte gemischt werden! Ein Beispiel: .tpl .remClass { width: 10rem; } .tpl .pxClass { width: 100px; } Nehmen wir an, es gibt zwei HTML-Elemente im Template mit den Klassen remClass und pxClass . Liefert der Browser eine Standardgröße von 16px , besteht kein Problem, die beiden Elemente sind exakt gleich groß, da 65.5% von 16px = 10px . Damit sind 10rem exakt 100px . Anders sieht es aber aus, wenn z.B. ein mobiler Browser eine Standardschriftgröße von 14px liefert. 62.5% von 14px = 8.75px , damit sind 10rem exakt 87.5px und die beiden HTML-Elemente sind plötzlich unterschiedlich groß. Dies kann je nach Gerät und verwendetem Browser zu unvorhersehbaren Skalierungsfehlern führen. Tip Es wird ausdrücklich empfohlen, im HTML/CSS des Template Controls rem als Größeneinheit zu verwenden. IsEditable Im CSS kann auch ein Style für das Template hinterlegt werden, wenn IsEditable auf false gesetzt wird. Wird ein Template Control im Designer oder per Action auf isEditable = false gesetzt, so wird am <div> -Tag tpl das HTML-Attribut tpldisabled hinzugefügt: ```html <hc-tpl-ctrl-content class=\"ng-star-inserted\"> <div class=\"tpl\" tpldisabled> [...] </div> </hc-tpl-ctrl-content> Im CSS-Code kann über den Attribute-Selector .tpl[tpldisabled] genau dieser Fall abgefragt werden. Im Beispiel wird der Hintergrund des Templates auf grau gesetzt. Preview Wenn der HTML-Code gültig ist, wird auf der Registerkarte \"Preview\" eine gerenderte Vorschau des Templates angezeigt. Für die Vorschau werden die PreviewValues für die einzelnen Template Variablen verwendet. Sollte ein PreviewValue nicht gesetzt sein, wird stattdessen der DataSource Name angezeigt. Template MLKeys zeigen den im Wörterbuch hinterlegten Text an. Preview Size Mit der Preview Size kann im Editor die Größe der Vorschau geändert werden. Damit kann sehr einfach überprüft werden, wie sich das Template in unterschiedlichen Größen verhält. Diese Einstellung hat keinen Einfluss auf die Laufzeit. Fallback auf die Standardsprache Sollte für die im Template Editor ausgewählte Sprache (z.B. Englisch) kein HTML oder CSS vorhanden sein, so wird das HTML oder CSS der Standardsprache (Deutsch) verwendet. So kann z.B. für \"Englisch\" nur das HTML überschrieben werden. im Preview und zur Laufzeit wird dann das englische HTML mit dem deutschen CSS kombiniert. Images im Template Eine Besonderheit ist das Anzeigen von Bildern in einem Template Control mittels <img /> , wenn dieses über ein byte[] aus der Datenbank gebunden werden soll. Ein Anwendungsfall wäre z.B. das Anzeigen von Icons. Beispiel: <img class=\"img\" src=\"data:{{ ds:MimeType }};base64,{{ ds:Image }}\" /> Um ein Bild an ein HTML img-Tag zu binden sind zwei Template Variablen notwendig. Das byte[] mit den Bildinformationen alleine reicht abhängig vom genutzten Browser nicht immer aus (siehe Hinweis). Es muss zusätzlich der HTML Mime-Type spezifiziert werden, sodass der Browser weiß, um welches Bildformat es sich handelt. {{ ds:MimeType }} ist eine Template Variable vom typ FSstring oder string und gibt z.B. den Mime-Type \"image/png\" oder \"image/jpg\" zurück. {{ ds:Image }} ist eine Template Variable vom Type FSByteArray oder byte[] . Binärdaten werden als Base64-String zum Client übertragen. Da das HTML src -Attribut Base64 versteht, ist keine weitere Formatierung der Daten nötig. Tip Die Angabe des Mime-Types ist in den meisten Browsern wie Chrome, Firefox, Safari oder Edge (auch auf mobilen Geräten) nicht zwingend nötig. Manche proprietären Browser auf mobilen Geräten haben jedoch Schwierigkeiten, ohne die Angabe des Mime-Types, das Bild korrekt darzustellen. Sollten diese Browser keine Rolle für die Anwendung spielen, kann auch folgendes HTML genutzt werden: <img class=\"img\" src=\"data:;base64,{{ ds:Image }}\" /> Das Semicolon vor base64 ist ohne die Angabe des Mime-Types zwingend notwendig."
  },
  "doc/form/control/treenode.html": {
    "href": "doc/form/control/treenode.html",
    "title": "TreeNode",
    "keywords": "TreeNode Properties/Events Das Funktionsprinzip des Tree-Views ist ähnlich dem einer Combobox: Sie wählen einen Eintrag des Tree-Views aus und bekommen den Objektverweis an den DataSource des Tree-Views zurückgeliefert. Durch abfangen der entsprechenden Events können Sie mit dieser Information operieren. Um eine einfache Auflistung in Baumform zu erstellen, erzeugen Sie eine TextCollection mit den Einträgen und benutzen diese als NodeDataSource. An dieser Stelle soll nun exemplarisch auf den Aufbau eines Baumes eingegangen werden. Am Anfang machen Sie sich bitte Gedanken darüber, woher Sie Ihre Informationen für die Darstellung des Baumes nehmen möchten. Eine gute Möglichkeit besteht in der Schaffung einer Component, wie unter Tree-View beschrieben. Positionieren Sie ein TreeView-Control auf Ihrem Form. Generieren Sie über den Tree-View Column Dialog die gewünschten Spalten, die der Tree-View beinhalten soll. In diesem Beispiel benötigen Sie eine einzige Spalte. Wählen Sie anschließend aus dem Kontext-Menü des Tree-Views den Eintrag New Node. In dem Baum des Controls wird ein neuer Knoten erzeugt, mit dem Sie operieren können. Weisen Sie die erzeugte Component Ihrem TreeNode als NodeDataSource und die Properties als Eigenschaften des NodeDataSource zu. Jetzt dürfen Sie nicht vergessen, die Component auch mit Daten zu füllen. Schreiben Sie eine entsprechende Load-Bedingung in die OnLoad-Methode des Forms. Damit nicht alle Einträge aus der Datenbanktabelle in dem TreeView dargestellt werden, müssen Sie den Load noch auf die Bedingung einschränken, dass bei den gesuchten Datensätzen die ItemIDParent null oder 0 sein soll und nur Datensätze Ihres gewünschten Typs ausgewählt werden. Der nächste Schritt ist das Anzeigen von Unterknoten. Jeder Eintrag des Tree-Views ist ein Objekt. Entsprechend sollten alle Unterknoten Elemente einer Collection sein, die als Property in das Objekt eingebunden ist. Erzeugen Sie deshalb eine Collection als IndividualReadOnly-Property. Diese Collection laden Sie über die Get-Methode. Um das Beispiel aus Tree-View weiterzuführen, werden alle Elemente geladen, die als ItemIDParent die ItemID des Objekts haben. Um unnötige Loads auf die Datenbank zu unterbinden, sollten Sie wieder eine Membervariable anlegen, die unnötige Loads verhindert. Get-Methode der Collection: // Load nur durchführen, wenn noch nicht zuvor geschehen. if (this.oTreeviewItemCollMember == null) { // Laden aller Unterobjekte this.oTreeviewItemCollMember = new cdTreeviewItemColl(this.Global); // Setzen des Merkers this.oTreeviewItemCollMember.Load( \"[lngItemIDParent] = \" + lngItemID ); } return this.oTreeviewItemCollMember; Nutzen Sie dieses Collection-Property als NodeDataSource des TreeNode zweiter Ebene. Sind die Display Member, Value Member und Icons richtig eingestellt, ist ihr Navigationsbaum fertig. Benötigen Sie eine tiefergehende Unterschachtelung, können Sie einfach einen TreeNode dritter Ebene hinzufügen und die gleichen Einstellungen wie bei dem Treenode zweiter Ebene vornehmen. Da jedes Objekt des Collection-Properties wiederum ein Collection Property besitzt, das über die Get-Methode alle untergeordneten Objekte liest, brauchen Sie keine weiteren Properties o.ä. schaffen. Um andere Elemente hinzuzufügen wird empfohlen, für jeden Typ einen eigenen Tree-Node anzulegen und eine Collection des jeweiligen Element-Typs als IndividualReadOnly-Property der Component hinzuzufügen. Durch Definition der Get-Methoden können Sie die Collections entsprechend füllen. Tree-Node Lazy-Loading Der TreeView ist in der Lage, ein Lazy-Loading von TreeNodes auszuführen. Beinhaltet ein TreeNode sehr viele SubNodes, werden standardmäßig die ersten 50 Einträge angezeigt und zusätzlich ein Node mit „…“. Durch Klick auf diesen Node können dann die restlichen Nodes nachgeladen werden."
  },
  "doc/form/control/treeview.html": {
    "href": "doc/form/control/treeview.html",
    "title": "TreeView",
    "keywords": "TreeView Properties/Events Actions Multicolumn Tree-Views werden typischerweise zum Darstellen von Baumstrukturen genutzt. Sie bestehen aus den Elementen Tree-View und Tree-Node. Zum Verwalten der Spalten und deren Properties existiert ein Dialog, welcher am TreeView über das PropertyGrid oder Kontextmenü geöffnet werden kann. Sie haben verschiedene Möglichkeiten einen Baum zu erstellen. Die Erstellung von Tree-Views unter Framework Studio ist vor allem wegen der Unterstützung der Mehrsprachigkeit komplex. Sie werden in der Regel für jeden Tree-View eine eigene Component benötigen, in denen die Properties über eine Query oder Get / Set Methoden gefüllt werden. Für eine einfache Auflistung ohne Verschachtelung und grafische Elemente können Sie auch eine einfache TextCollection nutzen. Wird ein Element aus dem Baum durch Klicken ausgewählt, wird die GUID des Elements an den DataSource des Tree-Views zurückgegeben. Deshalb muss der DataSource des Tree-Views entweder den Typ der Baumelemente besitzen, wenn dieser aus homogenen Elementen besteht, oder den allgemeinen Typ Object bzw. DevFrameworkObject haben. Sie müssen für jeden Tree-Node in den Properties eine ObjectCollection als NodeDataSource hinterlegen. Das Databinding für die einzelnen beim TreeView definierten Spalten wird an dieser NodeDataSource eingestellt. Unter Displaymembers werden alle Spalten in alphabethischer Reihenfolge aufgelistet. Aus dem in NodeDataSource ausgewählten Objekt wählen Sie Properties als Eigenschaft für den jeweiligen Display-Member der im TreeView definierten Columns, den Value-Member, das ClosedIcon, das OpenIcon und das HasSubNodes-Flag. Da es sich bei den Icons um graphische Elemente handelt, sollten die Properties einen relativen oder absoluten Pfad zu den Grafiken enthalten. Es empfiehlt sich, eine Datenbank-Tabelle anzulegen, welche alle benötigten Properties als Columns besitzt (ItemIDParent, ItemID, Image1, Image2, Pos, Type). Um die Einträge mehrsprachig zu definieren, erzeugen Sie jetzt eine TextCollection. In einer Text-Collection ist es notwendig eine ID zu definieren, die der ItemID aus der Datenbank-Tabelle entsprechen sollte. Anschließend können Sie zu jeder ID mehrsprachig die Bezeichnungen hinterlegen, die in dem Tree-View angezeigt werden sollen. Wenn Sie aus der Datenbanktabelle mit den Baum-Informationen eine Component und die dazugehörige Collection erstellt haben, öffnen Sie die Component und fügen ein IndividualReadonly-Property (sText) hinzu, das die Bezeichnung über eine Get-Methode aus der Text-Collection ermittelt. In dem Beispiel wurde zusätzlich eine private Membervariable sTextval hinzugefügt, damit die Bezeichnung aus der TextCollection nur das erste Mal ermittelt wird. Die sText Get-Methode könnte folgendermaßen aussehen: // sTextVal ist eine Membervariable, die sich merkt, // ob bereits ein Load ausgeführt wurde if (sTextVal == ““) { // Instanziieren der TextCollection ctTreeviewItemText oTreeviewItemText = new ctTreeviewItemText(this.Global); if (oTreeviewItemText.GetOnID( lngItemID ) == null) { // Kein Eintrag für die ID in der TextCollection vorhanden sTextVal = \"<no entry for\" + lngItemID + \">\"; } else { // Zuweisung der Bezeichnung sTextVal = oTreeviewItemText.GetOnID( lngItemID ).Text; } } return sTextVal; Bei dem Zugriff auf das sText-Property, wird Ihnen automatisch die sprachspezifische Bezeichnung aus der Text-Collection zurückgegeben. Die aufgezeigte Möglichkeit zur Unterstützung von Mehrsprachigkeit bei Properties kann selbstverständlich auch in vielen anderen Fällen angewandt werden. Sie müssen nicht für jedes Treeview separate Komponenten erstellen, sondern können die vorhandenen durch Einschränkung der Load-Bedingung auf einen Typ mehrfach verwenden. Tree-View - Rekursiver Baum Um einen rekursiven Baum abzubilden, benötigt man eine rekursive Objekt-Struktur. Dabei ist wichtig, dass alle Objekte denselben Component-Type besitzen. Es müssen 2 Tree-Nodes angelegt werden. Der erste Tree-Node erhält als NodeDataSource eine Collection – z.B. ein Form-Property. Diesem Tree-Node können die Eigenschaften unterhalb dem NodeDataSource (Icons, DisplayMember, …) zugewiesen werden. Unterhalb wird ein zweiter TreeNode angelegt. Dem wird in den Properties bei der Eigenschaft ContinueEqiuvalent der erste Tree-Node zugewiesen. Als NodeDatasource muss eine Collection angegeben werden, die denselben Typ besitzt wie der NodeDataSource des ersten TreeNodes. Unterhalb dem NodeDataSource müssen dieselben Einstellungen vorgenommen werden, wie im ersten TreeNode."
  },
  "doc/form/control/wrappanel.html": {
    "href": "doc/form/control/wrappanel.html",
    "title": "Wrap Panel",
    "keywords": "Wrap Panel Properties/Events Actions Controls werden innerhalb des Panels wie in einem Fließtext angeordnet. Wenn der Platz ausgeht, dann erfolgt ein Umbruch. Dies ist z.B. ideal für Button-Leisten. Besonders ist bei der Eigenschaft WrapArrangement der Wert Vertical. Die Controls werden dabei erst in Spalten von oben nach unten und dann von links nach rechts angeordnet. Dabei wird die Höhe aber so klein wie möglich gewählt und so viele Spalten wie möglich erzeugt. Werden auf diese Weise mehrere Field-Panels platziert, dann ergibt sich die für eNVenta typische spaltenweise Anordnung. Abbildung 148: WrapPanel mit Vertical WrapArrangement"
  },
  "doc/form/default-control-styles.html": {
    "href": "doc/form/default-control-styles.html",
    "title": "Default Control Styles",
    "keywords": "Default Control Styles Default Control Styles sind Standardvorlagen für alle verfügbaren Controls. Durch diese Vorlagen können für alle Eigenschaften der Controls Standardwerte vorbelegt werden. Default Control Styles werden auf der Registerkarte Namespaces im Namespace FSGeneral / Controls angezeigt. Wenn Sie ein Default Control Style auf einem Form verwenden wollen, ziehen Sie das Control von der Registerkarte Toolbox des Framework-Designers auf die Registerkarte DefaultVariant des geöffneten Form-Designers (siehe dazu Design des Forms ). Um Eigenschaften eines Default Control Styles zu ändern, öffnen Sie den Control Style Designer durch Doppelklick auf das Default Control Style im Objektbaum auf der Registerkarte Namespaces. Auf der Registerkarte Default Control Style werden in einem Property Grid alle Eigenschaften des Controls angezeigt. Eine komplette Liste der Eigenschaften der einzelnen Default Control Styles finden Sie unter Layout-Konzept . Wenn Eigenschaften an einem Default Control Style statt an der Instanz eines Controls auf einem Form festgelegt werden, hat das den Vorteil, dass diese Eigenschaften einheitlich in der gesamten Anwendung verwendet werden. Wenn dann nachträglich eine Eigenschaft (z.B. Hintergrundfarbe) an einem Default Control Style geändert wird, zieht diese Änderung automatisch an allen Stellen, an denen der Default Control Style benutzt wird und die Eigenschaft nicht explizit überschrieben wird. Custom Control Default Style Editor: Sie haben die Möglichkeit, eigene Default Control Styles zu definieren. Dazu müssen Sie eine Ableitung von einem der Basis Default Control Styles erstellen (Kontextmenü Derive im Objektbaum auf der Registerkarte Namespaces ). Für das so erstellte Default Control Style können Sie die Eigenschaften frei definieren, ohne das Original Default Control Style zu ändern. Dadurch erhalten Sie eine weitere Control-Vorlage, die Sie in Ihren Forms verwenden können. Basis Default Control Styles sind Button, Checkbox, Combobox, Editfield, Grid, ImageButton, Label, Line, Listbox, MainMenu, Panel, Picture, RadioButton, TabbedWindow, TrafficLight und TreeView."
  },
  "doc/form/designer.html": {
    "href": "doc/form/designer.html",
    "title": "Forms",
    "keywords": "Forms Der Form-Designer ist ein Tool, ähnlich dem Designer in Visual Studio, in dem Sie Controls per Drag & Drop auf einem Form positionieren und mit Funktionalität beleben können. Er wird entweder durch einen Doppelklick auf ein entsprechendes Form-Element auf der Registerkarte Namespaces oder durch das Erstellen eines neuen Form-Elements geöffnet. Allgemeiner Überblick Kontextabhängige Registerkarten Ist ein Form-Element geöffnet, verhalten sich die Registerkarten auf der linken Seite entsprechend diesem Kontext. Die Registerkarte Class zeigt alle Elemente an, über die das Forum verfügt. Über die Registerkarte fügen Sie auch auf gewohnte Weise über das Kontext-Menü des Namespaces neue Properties, Methods, Reports oder Workflow-Events dem Form hinzu. Anschließend können Sie die Properties nutzen, um sie z.B. per Drag & Drop auf dem Form zu positionieren. Es wird entsprechend das für das Property hinterlegte Standard-Control dargestellt. Ist kein Control als Standard-Control für das Property hinterlegt, wird ein Editfield gewählt. Sind mehrere Controls hinterlegt, wird zunächst das Standard-Control angezeigt. Dieses lässt sich aber ändern, indem Sie das Control auf dem Form auswählen und aus dem Kontext-Menü des Controls den Eintrag Change Visualisation auswählen. Dieser Eintrag erscheint nur, wenn zu dem Property mehr als ein Control hinterlegt ist. Interessant in diesem Zusammenhang dürfte auch der Eintrag Default-Variant auf der Registerkarte Class sein. Unterhalb des Eintrags sehen Sie eine Auflistung der Controls, die auf dem Formular angezeigt werden. Wenn Sie ein Control z.B. auf einem Panel positionieren, sind die Koordinaten des Controls relativ zur Position des Panels. Wenn Sie wollen, dass sich ein Control in diesem relativen Zusammenhang verhält oder dieser Zusammenhang versehentlich erzeugt wurde, können Sie diesen durch Verschiebung des Controls im Baum per Drag & Drop ändern. Die Registerkarte Inheritance zeigt den Vererbungsbaum des ausgewählten Forms. Ist das Form nicht abgeleitet, wird lediglich ein Eintrag mit der Bezeichnung des Forms angezeigt. Auf der Registerkarte Properties sehen Sie die Eigenschaften des im Hauptfenster ausgewählten Elements. Sie haben zudem die Möglichkeit, über die Combobox oben auf der Registerkarte zu den Eigenschaften eines ausgewählten Elements zu springen. Auf die Eigenschaften zu den Controls wird in der Beschreibung zu den jeweiligen Controls eingegangen. Letztlich zeigt die Registerkarte Toolbox eine Auswahl aller zu Verfügung stehenden Controls an. Die Controls werden ebenso wie die Properties per Drag & Drop auf dem Formular positioniert. Es werden alle Standard-Controls, also auch Controls angeboten, welche von Ihnen im Default Style Editor definiert wurden. Form Designer Registerkarte Toolbox: Registerkarte Property Auf der Registerkarte Property können Sie die einzelnen Properties des Forms bearbeiten. Wählen Sie dazu das gewünschte Property aus der Tabelle aus, oder doppelklicken Sie auf das entsprechende Property auf der Registerkarte Class . Sie können die Properties sortieren, indem Sie auf die Spaltenüberschrift des gewünschten Sortierkriteriums klicken. Neue Properties können Sie über New / Public Property bzw. New / Protected Property im Kontextmenü, im Menü des Form Designers oder über den entsprechenden Button anlegen. Alternativ dazu können Sie auch eine Component aus dem Namespace Treeview in die Tabelle ziehen. Dadurch wird automatisch ein Property vom Typ der Component angelegt. Um ein Property zu löschen, wählen Sie Delete entweder aus dem Kontextmenü des Properties in der Tabelle oder im Class View. Name Dient zum Benennen oder Umbenennen des Properties. Access Level Steuert den Access Level des Properties. Datatype Ist als Datentyp eine Component oder Collection ausgewählt, ist das Property ein entsprechendes Objekt. Wenn der Datentyp dagegen ein .Net Datentyp oder ein FS-Datentyp ist, können Sie das Property wie eine formweite Membervariable nutzen. Siehe Datentyp bearbeiten Description Hier können Sie eine Beschreibung für die Dokumentation hinterlegen. Alle in ein Form eingebundenen Properties werden beim Öffnen eines Forms zur Laufzeit automatisch in der Methode Init() instanziiert. Registerkarte Method Auf der Registerkarte Method können analog zu den Components Methoden hinterlegt werden. Sie können prinzipiell 2 Arten von Methoden unterscheiden. Zum einen gibt es ganz normale Methoden, die durch einen Funktionsaufruf angestoßen werden. Zum anderen gibt es sogenannte Form-Events. Sie unterscheiden sich nur durch ihre Deklaration von den anderen Methoden und können auf Events von Controls reagieren. Registerkarte Functional Controls Auf dieser Registerkarte werden alle Functional Custom Controls des Forms angezeigt. Registerkarte Available Reports Vorbereitung für spätere Funktionalität. Sie können bislang einen ReportDocumentType definieren, was Ihnen das Einbinden einer Referenz erspart. Der Code zum Erzeugen des Reports muss aber bislang manuell ausprogrammiert werden. Registerkarte Access Units Zu der Access Unit, die in der Combobox ausgewählt ist, werden in den übrigen Feldern die Details angezeigt. Name Name der Access Unit. Dieses Feld ist insbesondere für die spezielle Form Access Unit, die das Form selbst repräsentiert, nicht editierbar. Name in code Kompilierbarer Name der AccessUnit, der im Source Code verwendet wird. Um Missverständnisse zu vermeiden, sollten Sie darauf achten, dass der Name einer Access Unit keine ungültigen Sonderzeichen enthält, so dass Name und Name in code übereinstimmen. Is form AccessUnit Diese Checkbox zeigt an, ob die Access Unit die spezielle Access Unit ist, die das Form selbst repräsentiert. Für jedes Form wird diese Access Unit automatisch angelegt. Die Eigenschaft kann nicht geändert werden. Description Hier können Sie eine Beschreibung der Access Unit hinterlegen. Parents Die Liste zeigt alle Access Units, unter der die Access Unit in der Access Unit Hierarchie eingebunden ist. Diese Eigenschaft ist hier rein informativ und kann nur über den Menüpunkt Tools / Access Unit Treeview ... (Access Unit Hierarchie) geändert werden. Erstellen, Bearbeiten und Löschen eines Forms Erstellen eines Forms Elemente erstellen Bearbeiten eines Forms Elemente bearbeiten Design des Forms Löschen eines Forms Elemente löschen Design des Forms Gestaltet wird das Form auf der Registerkarte DefaultVariant . Um Controls auf dem Formular zu erstellen, gibt es mehrere Möglichkeiten: In der Registerkarte Toolbox werden alle zur Verfügung stehenden Controls angeboten. Es sind auch die selbst definierten Default-Styles enthalten. Wenn Sie mit der Maus ein Control aus dieser Liste auf das Form ziehen (per Drag & Drop), wird ein entsprechendes Control erstellt. Das Control erhält als Vorgabe die Eigenschaften, die in den Default-Styles definiert sind. Werden die Eigenschaften in den Default-Styles geändert, wirkt sich das automatisch auf alle Controls aus, die aus diesem Default-Style erstellt wurden (auch nachträglich). Wenn allerdings die Eigenschaften manuell geändert werden, haben diese Änderungen höhere Priorität und sie werden nicht nachgezogen. Eine weitere Möglichkeit besteht darin, eine Membervariable auf das Form zu ziehen. Es werden automatisch ein Control und dazu auch ein Label erstellt. Das Label erhält den Wert, der im Property oder im dahinterliegenden Metadatentypen als Default-Label hinterlegt ist. (Siehe dazu Metadatentypen und Components). Als Control wird das gezogen, welches im Property oder im Metadatentypen als Default-Control hinterlegt und als Default gekennzeichnet wurde. Sind noch weitere Default-Controls hinterlegt, können Sie die Darstellung nachträglich ändern. Im Context-Menu des Controls gibt es dazu einen Punkt Change Visualization . Dort werden alle Default-Controls angeboten und das, welches gerade verwendet wird, ist mit einem Haken versehen. Weitere Informationen dazu finden Sie im Abschnitt Membervariablen/Databinding . Actions SetApplicationTitle(string title) Mit dieser Methode kann der Titel der Applikation zur Laufzeit festgelegt werden. Unter Windows wird der Titel sowohl im Java Client-Fenster als auch in der Taskleiste angezeigt. SetDialogPlacement(int value) Standardmäßig werden modale Dialoge in Framework Studio mittig im Hauptfenster der Anwendung angezeigt. Dies lässt sich über die Action SetDialogPlacement(int value) am Form ändern. Beispiel: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.SetDialogPlacement(1); // Absolute } Die Action nimmt einen Integer zwischen 0 und 2 als Parameter: 0 = None 1 = Absolute 2 = Relative None Der JavaClient zeigt alle modalen Dialoge zentriert zur Anwendung an. Absolute Der JavaClient speichert sich die absolute Position und Größe aller modalen Dialoge beim Schließen. Die Dialoge werden genau an der Stelle geöffnet, an der sie geschlossen wurden. Relative Der JavaClient speichert sich die relative Position der modalen Dialoge, bezogen auf die Position der Anwendung und die Größe. Die Dialoge werden relativ zur Anwendung wieder geöffnet. Note Der JavaClient speichert sich den per SetDialogPlacement() übergebenen Wert NICHT . Es muss von der Anwendung aus bei jedem Start die Action aufgerufen werden (z.B. beim Laden des ersten Formulars der Anwendung). SetToolTipDelays(int initialDelay, int dismissDelay) Mit dieser Action kann im JavaClient die Anzeigezeit für Tooltips geändert werden. Die Einstellung gilt dann für den gesamten JavaClient. Der Parameter initialDelay gibt die Zeit in Millisekunden an, wie lange es dauert, bis der Tooltip angezeigt wird, nachdem der Mauszeiger über ein Control bewegt wurde. Der Parameter „dismissDelay“ gibt die Zeit in Millisekunden an, wie lange der Tooltip angezeigt werden soll. Die Action ist an der Form-Klasse zu finden. Beispiel: this.SetToolTipDelay(3000, 10000); Nach diesem Beispiel würde ein Tooltip nach 3 Sekunden eingeblendet werden und dann für 10 Sekunden zu sehen sein. Soll bei einem Aufruf der Action nur ein Parameter geändert werden, muss der andere mit dem Wert -1 übergeben werden: Beispiel: this.SetToolTipDelay(-1, 10000); Somit wird nur die Anzeigedauer der Tooltips auf 10 Sekunden geändert. Beep(long length, double frequency) Erzeugt einen einheitlichen Beep-Ton. length Länge des Tons in Millisekunden. frequency Frequenz des Tons in Herz. Beispiel: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.Beep(500, 750); } Dieser Code erzeugt einen Beep-Ton von einer halben Sekunde bei 750Hz. BeepDouble(long length1, long length2, double frequency1, double frequency2) Erzeugt einen Ton aus zwei Frequenzen, die hintereinander abgespielt werden. Damit lassen sich z.B. Bestätigungs- oder Fehler-Sounds erstellen. length1 Länge des ersten Teils des Tons in Millisekunden. length2 Länge des zweiten Teils des Tons in Millisekunden. frequency1 Frequenz des ersten Teils des Tons. frequency2 Frequenz des zweiten Teils des Tons. Beispiel 1: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.BeepDouble(200, 200, 500, 2000); } Dieser Code erzeugt einen Beep-Ton mit einer Gesamtlänge von 400ms. Die ersten 200ms werden mit 500Hz wiedergegeben, die zweiten 200ms mit 2000Hz. Dies ist ein klassischer Bestätigungs-Sound. Beispiel 2: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.BeepDouble(200, 350, 1000, 400); } Dieser Code erzeugt einen Beep-Ton mit einer Gesamtlänge von 550ms. Die ersten 200ms werden mit 1000Hz wiedergegeben, die restlichen 350ms mit 400Hz. Dies könnte z.B. ein akustisches Signal bei einem Fehler sein. BeepMultiple(int beepCount, long beepLength, long breakLength, double frequency) Erzeugt mehrere Beep-Töne hintereinander mit Pausen dazwischen. beepCount Anzahl der abzuspielenden Töne. beepLength Länder eines einzelnen Tons in Millisekunden. breakLength Länge der Pause zwischen den Tönen in Millisekunden. frequency Frequenz der einzelnen Töne. Beispiel: protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e) { this.BeepMultiple(3, 200, 100, 800); } Dieser Code erzeugt 3 Beep-Töne hintereinander mit einer Einzellänge von 200ms und jeweils einer 100ms langen Pause dazwischen. Die Töne werden mit 800Hz abgespielt. Events Damit in einem Form eine Aktion ausgeführt werden kann, sind sogenannte Events notwendig. Events reagieren auf Ereignisse, die im Form auftreten. Es ist möglich, diese Events mit Funktionalität zu verbinden. Events können auf unterschiedliche Ereignisse reagieren: öffnen eines Forms, ändern des Inhalts eines Editfields, Klick auf einen Button usw. Es gibt unterschiedliche Arten von Events: Form-Events, Workflow-Events. Form-Events Form-Events spielen sich sozusagen im Form ab. Damit ein Form-Event etwas tut, müssen Sie ihm eine Methode aus dem Form zuordnen. Es wird dann beim Eintreten des entsprechenden Ereignisses die im Form-Event hinterlegte Methode aufgerufen. Ein Form-Event ist immer eine Anfrage an den Broker. Wurden vor dem Absenden des Events im Client Daten im Form geändert, stehen diese Änderungen in den entsprechenden Membervariablen zur Verfügung. Werden im Form-Event Daten der Membervariablen geändert, werden diese Änderungen dem Client mitgeteilt und er ändert die Daten in der Anzeige entsprechend ab. Bevor ein Form-Event an den Broker gesendet wird, werden die in den Metadatentypen hinterlegten Gültigkeitsprüfungen durchgeführt. Workflow-Events Workflow-Events stellen eine Schnittstelle aus dem Form heraus dar. Auf die im Form hinterlegten Workflow-Events kann später im Workflow reagiert werden. So kann z.B. zwischen verschiedenen Forms kommuniziert werden. Warning Sind für ein Ereignis ein Form-Event und ein Workflow-Event hinterlegt, wird zuerst das Form-Event ausgeführt und anschließend das Workflow-Event. Workflow-Events können auch manuell aus einer Form-Method heraus angestoßen (gefeuert) werden. Dazu bietet jedes Workflow-Event eine Fire-Methode an. Beispiel: Zu einem Workflow-Event WE_btnSearch_OnClick existiert eine Methode FireWE_btnSearch_OnClick() . Beim Aufruf dieser Methode wird das Workflow-Event WE_btnSearch_OnClick angestoßen. // FormEvent btn_Search_OnClick public void FE_btnSearch_OnClick(FrameworkButtonClickEventArgs e) { if (!this.GenerateLoadConditionOnoCustomer.IsNull) { FireWE_btnSearch_OnClick(); } } Bearbeiten von Control-Events Die Events von Controls werden in einem Dialog bearbeitet. Dieser öffnet sich z.B. mit einem Doppelklick auf das Control. Dieser Dialog kann auf folgenden Wegen geöffnet werden: Mit einem Doppelklick auf ein Control. Über das Context-Menü des Control – dort gibt es einen Menü-Punkt Events. Über das Property-Grid. Das Control bietet eine Eigenschaft Control Events an. Der Dialog zeigt erst einmal nur an, welche Events dem Control bereits zugeordnet sind. Erst bei Bedarf können diese dann geändert werden. Wenn ein Event in einem Basis-Form oder einem Basis-Package zugeordnet wurde, dann wird dies mit grauem Text angezeigt. Ein Tooltip gibt Information, aus welchen Form oder Package diese Event-Zuordnung genau kommt und in welchem Form oder Package ggf. die letzte Überschreibung der Form-Methode existiert. Ist die Form-Methode im aktuellen Form überschrieben, dann wird der Link mit blauer Schrift dargestellt. Mit einem weiteren Mausklick können folgende Aktionen durchgeführt werden: Mit dem Button Cancel (oder mit Esc, Enter oder Leertaste) wird der Dialog geschlossen. Mit Klick auf den Event-Link wird die entsprechende Form-Methode geöffnet bzw. das Workflow-Event im Class-View angezeigt. Dies funktioniert auch für Events aus einem Basis-Form oder Basis-Package. In diesem Fall wird die letzte überschriebene Form-Methode geöffnet. Mit dem Button kann man ein neues Event anlegen und zuordnnen. Der Dialog wird sofort geschlossen. Bei einem Form-Event wird unmittelbar in die entsprechende Form-Methode gesprungen und ein Workflow-Event wird im Class-View angezeigt. Ist das Event in der Basis zugeordnet, dann wird dieser Befehl unterhalb des Buttons angeboten. Durch diesen Befehl wird die Basis-Event-Zuordnung ausgeblendet, was zur Folge hat, dass es nicht mehr ausgeführt wird. Es dann nur das neu zugeordnete Event ausgeführt. (Anders wäre es, wenn man z.B. eine Form-Event-Methode überschreibt.) Mit dem Button kann eine im Basis-Form zugewiesene Form-Methode im aktuellen Form überschrieben werden. Der Button wird nur angeboten, wenn die Methode virtual ist und wenn sie nicht bereits im aktuellen Form überschrieben ist. Mit dem Button kann ein vorhandenes Event zugeordnet werden. In einem Context-Menü werden alle gültigen Events angeboten. Nach einer Auswahl wird der Dialog sofort geschlossen. Mit dem Button kann eine Event-Zordnung entfernt werden. Nach einer Rückfrage wird die Zuordnung gelöscht und der Dialog geschlossen. Die Form-Event-Methode bzw. das Workflow-Event werden dabei nicht gelöscht.. Properties / Databinding Ein Form dient ja in erster Linie dazu, Daten anzuzeigen und zu verändern. Es ist aber so, dass ein Control selber keinen Wert hat (eine Ausnahme sind Labels). Dies wird über das sogenannte Databinding gelöst. Das funktioniert, indem einem Control eine Membervariable des Forms zugewiesen wird. Diese Zuordnung findet im Property Datasource auf der Registerkarte Property statt. Ist die Zuordnung erfolgt, zeigt das Form im entsprechenden Control den Wert der Membervariablen an. Wird der Wert im Control durch eine Eingabe geändert, wird der neue Wert bei der nächsten Anfrage an den Broker in die Membervariable zurückgeschrieben. Die Controls bieten unterschiedliche Möglichkeiten, Datasources zuzuordnen: Editfields haben einen Datasource. Diesem Datasource kann eine Membervariable vom Typ String, Number (long, int, short...) oder Datum zugewiesen werden. Das Editfield zeigt den entsprechenden Wert an. Labels haben ebenfalls einen Datasource. Diesem kann ebenfalls (wie dem Editfield) eine Membervariable zugeordnet werden. Ist dem Label ein Datasource zugeordnet, wird das, was im Property Caption angegeben ist, ignoriert. Zudem besitzen Labels ein Property LabelOfControl . Ist ein Label einem Control zugeordnet und Control hat ein Property als DataSource, wird in dem Label automatisch die Caption angezeigt, die zu dem Property als DefaultLabel hinterlegt ist. Comboboxen und Listboxen haben neben dem Datasource eine Property List. Der Datasource gibt an, welchen Wert die Combobox repräsentieren soll. Unter List wird angegeben, woher die Werte der Liste hergenommen werden sollen. Hier sind Collections und Textcollections möglich. Nachdem List ausgewählt wurde, müssen noch DisplayMember und ValueMember angegeben werden. DisplayMember: Gibt an, welches Property aus der Component der Collection angezeigt werden soll. (Sollen zusammengesetzte Properties dargestellt werden, muss in der Component dafür ein extra Property erstellt werden, welches dann hier ausgewählt werden kann). ValueMember: Gibt an, welches Property der Component mit dem Datasource verknüpft werden soll. Tabbed Windows können als Datasource eine Membervariable vom Typ short besitzen. Der Inhalt dieser Membervariablen gibt an, welches Tab gerade aktiv ist. Durch Ändern der Membervariable in einem FormEvent kann somit auch beeinflusst werden, welches Tab aktiv sein soll. Radio-Buttons / Panels: Radiobuttons besitzen selber keinen Datasource. Bei Radiobuttons bilden immer mehrere Controls eine logische Einheit, zwischen denen gewechselt werden kann. Um dies zu lösen, werden die Radiobuttons auf einem Panel positioniert. Das Panel, welches die Radiobuttons beinhaltet, bekommt dann im Property ButtonGroupDataSource ein Datasource zugeordnet. Den Radiobuttons wird im Property DatasourceOnValue gesagt, bei welchem Wert er aktiv sein soll. Pictures bekommen im Datasource gesagt, welches Bild dargestellt werden soll. Ist im Picture ein Datasource zugeordnet, wird die Angabe im Property Image ignoriert. Damit ist es möglich, ein Bild dynamisch anzuzeigen. Grids bekommen als Datasource eine Collection. Diese Collection stellt die Tabelle dar, die angezeigt werden soll. Anschließend können Sie aus dem Kontext-Menü des Grids über den Eintrag Grid-Columns / New die Properties aus der Component zu der Collection als Grid-Columns übernehmen. Nur in der Component enthaltene Properties können zu Spalten werden. Es ist nicht möglich, darüber hinaus weitere Spalten zu definieren. Bei Bedarf müssen Sie in der Component zusätzliche Properties definieren und diese dynamisch über die Get/Set-Methoden befüllen. Grids bieten einen weiteren Datasource SelectedRows an. Hier kann eine Membervariable vom Typ System.Framework.SelectedRowsCollection zugeordnet werden. Diese Collection enthält Guids (eindeutige ID eines Objekts), die angeben, welche Zeilen in der Tabelle markiert sind. Die Guids repräsentieren also eine Untermenge der Objekte aus der Datasource-Collection. TreeViews stellen einen Baum aus Objekten dar. Als Datasource muss ein ganzes Objekt angegeben werden. Wenn der TreeView Objekte nur eines Typs darstellt, muss der Datasource denselben Typ besitzen. Stellt der TreeView Objekte verschiedener Typen dar, muss als Datasource ein Objekt vom Typ Object gewählt werden. In dem Fall müssen Sie in den Form-Methoden entsprechende Typenkonvertierungen vornehmen. Framework Studio bietet auch eine ganz einfache Möglichkeit, ein Control mit Datasource zu erstellen. Sie können die Membervariable einfach auf das Form ziehen. Es wird das entsprechende hinterlegte Default-Control erzeugt. Es erhält einen Namen, angelehnt an den der Membervariable. Der Datasource wird automatisch eingetragen und es wird zum Control ein Label erstellt, welches das in der Membervariable hinterlegte Default-Label enthält."
  },
  "doc/form/label-of-control-cleanup.html": {
    "href": "doc/form/label-of-control-cleanup.html",
    "title": "LabelOfControl Cleanup",
    "keywords": "LabelOfControl Cleanup LabelOfControl Cleanup ist eine Wartungs-Routine mit der die veraltete Control-Eigenschaft LabelOfControl am Label-Control bereinigt werden kann. Sie kann in der IDE über das Menu Tools / Checks / LabelOfControl Cleanup aufgerufen werden. Mit dem Button Analyze wird lediglich eine Analyse durchgeführt und die gefundenen Controls in einer Liste ausgegeben. Bitte führen sie zuerst die Analyse durch und prüfen sie ggf. stichprobenartig ob die gelisteten Controls plausible Treffer sind. Mit dem Button Cleanup wir die Bereinigung durchgeführt. Die Routine durchsucht alle Forms nach Label-Controls, an denen die Eigenschaft LabelOfControl gesetzt ist, checkt die betroffenen Forms aus, überträgt die Caption und den Tooltip des zugeordneten Controls, sofern diese nicht bereits am Label-Control überschrieben sind, entfernt die Eigenschaft LabelOfControl vom Label-Control und speichert das Form. Nach dem Cleanup müssen die verarbeiteten Form kompiliert und eingecheckt werden. Hintergrund Das Property LabelOfControl wird seit der Version 4.0 nicht mehr im Form-Designer angeboten. Mit dem neuen Layout zur Version 4.0 wurde die Eigenschaft LabelOfControl überflüssig. Die Beschriftungen der Controls wurden durch automatisch erzeugte Labels abgelöst. Bei der Konvertierung des Layouts wurden deshalb die alten Label-Controls größtenteils nicht in das neue Layout übernommen. In einigen speziellen Fällen, wurden die Labels aber gezielt übernommen und mit ihnen auch die Eigenschaft LabelOfControl . Im Hintergrund hat das immer noch dafür gesorgt, dass die Caption und der Tooltip des zugeordneten Controls in das Label-Control übernommen wurde. Andere Funktionen, wie das automatische Ausblenden mit dem zugeordneten Control haben nicht mehr funktioniert. Mit dem Umbau des Data-Bindings zur Version 4.3 musste auch dieses Feature entfernt werden. Das hat zur Folge, dass jetzt bei betroffenen Labels die Beschriftungen nicht mehr gezogen werden."
  },
  "doc/form/layout-konzept.html": {
    "href": "doc/form/layout-konzept.html",
    "title": "Layout-Konzept",
    "keywords": "Layout-Konzept Control-Hierarchie Die Controls eines Forms sind in einem Baum organisiert. Dabei spielen die Hierarchie und vor allem die Reihenfolge in diesem Baum eine wichtige Rolle. Das Form wird mithilfe von verschiedenen Containern (DockPanel, WrapPanel, FieldPanel), in denen die Controls platziert werden, strukturiert. Ausschließlich die Hierarchie und Reihenfolge der Controls definieren deren Anordnung im Form. Absolute Positionen können nicht angegeben werden. In Ableitungen bzw. im Customizing können neue Container und Controls in der Hierarchie eingefügt werden. Bestehende Container oder Controls können an eine andere Stelle in der Hierarchie verschoben werden. Die Controls ordnen sich auch dann wieder automatisch an. Besonders vorteilhaft ist dies, wenn Sie mehrere Packages miteinander kombinieren. Überlagerungen von Controls kann es so nicht geben – Überlagerungen sind technisch auch gar nicht möglich. Größe von Controls Die Größe von Text-Feldern und Grid-Columns wird durch den Metadatentyp gesteuert. Dort gibt es die Eigenschaften DisplayMinLength , DisplayMaxLength und für Multiline-Felder DisplayMinLines und DisplayMaxLines. Diese Eigenschaften sind in der kompletten Kette von Metadatentyp über DBColumn und Component-Property bis zum Control verfügbar. Am ControlStyle FSGeneral.Controls.BaseControl wird das Property MeasureText angeboten. Die Display-Length-Eigenschaften werden vom Client mithilfe dieses Textes in die realen Größen umgerechnet. Zuzüglich Padding und Border ergibt sich so die Gesamt-Größe des Controls. Die Display-Length Einstellungen sollten soweit wie möglich am Metadatentyp erfolgen. Eine gute Hilfe dabei ist die DataSource Hierarchy Search im Form-Designer. Die Control-Eigenschaften MinSize , MaxSize bzw. GridColumn. Width sollten nur in Ausnahmefällen gesetzt werden, weil dadurch das Control nicht mehr, z.B. auf Änderungen der Schriftgröße, reagieren kann. Tab-Reihenfolge Die Tab-Reihenfolge der Controls wird durch deren Position im Baum bestimmt. Wenn Sie den kompletten Baum von oben nach unten durchlaufen, ergibt sich so die komplette Tab-Reihenfolge. Eine davon abweichende Tab-Reihenfolge kann nicht definiert werden. Individuelle oder von der Situation abhängige Tab-Reihenfolgen können mit dem OnLeave/OnValidate -Event und der SetFocus -Action realisiert werden. Mit dem Property TabStop kann ein Control in der Tab-Reihenfolge übersprungen werden. Deprecated Layout / Migration Öffnen Sie ein „altes“ Form, dann wird mit der Registerkarte Deprecated Layout der alte Form-Designer angezeigt. Dieser funktioniert ganz normal bis zur Umstellung. Form-Designer mit Deprecated Form: Mit dem Button Convert Deprecated Layout wird die Konvertierung in das neue Layout gestartet. Dies geht aber erst wenn alle Basis-Forms in allen Base-Packages dieses Forms umgestellt sind. Es öffnet sich neben dem neuen Form-Designer ein weiteres Fenster Convert Deprecated Layout . Dieses kann auf dem 2. Monitor platziert werden. Convert Deprecated Layout: Form-Designer mit teilwiese migriertem Form: ALLE Controls müssen in den neuen Baum eingehängt werden. Dazu muss das entsprechende Control aus dem alten Control-Baum per Drag & Drap an die richtige Stelle in den Control-Baum des neuen Form-Designers verschoben werden. Im alten Baum wird das Control dann mit einem grünen Hintergrund als verarbeitet markiert. Controls, die nicht in das neue Layout übernommen werden, werden von der Konvertierung ausgeschlossen und mit einem roten Hintergrund markiert. Das sind Controls, die es im neuen Layout nicht mehr gibt (z.B. Panel, StackPanel, Line) – diese sind automatisch ausgeschlossen. Einige Controls können auch vom Entwickler (rechte Maustaste / Exclude ) oder einem Automatismus ausgeschlossen werden (Picture, Label). Ist ein Control verarbeitet, erhält es einen grünen Haken . Ein Container erhält diesen Haken erst dann, wenn auch alle seine Unter-Controls verarbeitet sind. Ziel ist es, dass der komplette Baum – also der oberste Knoten DefaultVariant – verarbeitet ist und diesen grünen Haken erhält. Dann kann das Form kompiliert, getestet und die Konvertierung mit dem Button Complete abgeschlossen werden."
  },
  "doc/fsclientlauncher/fsclientlauncher-common.html": {
    "href": "doc/fsclientlauncher/fsclientlauncher-common.html",
    "title": "Framework Studio Client Launcher",
    "keywords": "Framework Studio Client Launcher Allgemeine Informationen Für das Ausführen einer Framework-Studio-Anwendung wird auf dem Client-Rechner eine Laufzeit-Umgebung benötigt. Diese wird durch das Programm \"Framework Studio Client Launcher\" bereit gestellt. Der Client-Launcher wird immer mit der aktuellsten Version installiert. Diese ermöglicht auch die Arbeit mit älteren Programm-Versionen (z.B. Framework Studio 3.11 / eNVenta 3.6) Der Aufruf der Anwendung erfolgt über die Client Start Page, welche vom Anwendungs-Server bereitgestellt wird. Die von der Start Page erzeugten Links können auch kopiert und auf andere Weise zugänglich gemacht werden. Bei der Aktualisierung auf eine neue Version kann es jedoch Änderungen an den Links geben, sodass diese ggf. aktualisiert werden müssen. Starten der Anwendung Der Client-Launcher wird direkt gestartet. Ggf. muss im Browser einmalig die Verwendung der Anwendung FSClientLauncher akzeptiert werden. Der Start erfolgt über einen Link, der alle in der Startseite getroffenen Einstellungen beinhaltet. Er hat bspw. das folgende Format: fsclientlauncher:launch?title=eNVenta%20ERP&broker=http://nvapp01/eNVenta_40/&language=en,de Dieser Link kann auch in eine eigene Verknüpfung – z.B. auf den Desktop kopiert werden. Mit dem eigenen Protokoll fsclientlaucher erfolgt der Start des Client Launchers direkt ohne einen extra Umweg über den Server. Manche Umgebungen – z.B. Content-Management-Systeme wie SharePoint – haben ggf. Probleme mit diesem Link. In diesem Fall kann als Workaround der Download-Link verwendet werden und am Ende das dl=1 durch ein dl=0 ersetzt werden. In diesem Fall wird über den Browser der Server kontaktiert, der dann auf den korrekten Start-Link umleitet. Der jeweilige Link kann im Browser über \"Verknüpfung / Link-Adresse kopieren\" kopiert werden. Download Start File Über diesen Link wird eine Datei mit der Endung .fsclient heruntergeladen. Diese beinhaltet ebenfalls die auf der Client Start Page getroffenen Einstellungen. Der Link hat das folgende Format: http://nvapp01/eNVenta_40/api/fsclient?lang=en,de&themeid=DefaultID&metal=1&nodomainauth=false&dl=1"
  },
  "doc/fsclientlauncher/fsclientlauncher-configuration.html": {
    "href": "doc/fsclientlauncher/fsclientlauncher-configuration.html",
    "title": "Konfiguration",
    "keywords": "Konfiguration Allgemeines Wird der FS Client Launcher direkt über das Start-Menü gestartet, dann öffnet sich das Konfigurations-Fenster. Gespeichert werden alle Einstellungen im Benutzer-Kontext in folgender Datei: %userprofile%\\FSClientLauncher\\launcherconfig.json Console Der Client-Launcher gibt Fehler und Informationen über ein Konsole-Fenster aus. Dieses wird bei der ersten Ausgabe eingeblendet und am Ende zusammen mit dem Java-Client beendet. Display Java Console : Die Console-Ausgaben des Java-Clients werden in einem Console-Fenster angezeigt. Trace-Level : Treten Errors auf, dann werden diese im Console-Fenster angezeigt. Durch ändern des Trace-Levels können weitere Informationen – z.B. über den Download der jar-Dateien – im Console-Fenster angezeigt werden. Log Files Directory : Alle Ausgaben werden in automatisch in Log-Datei gespeichert. Diese werden in dem Ordner abgelegt, der mit dem Link geöffnet werden kann. Log-Dateien, die älter sind als 30 Tage werden automatisch gelöscht. Jar File Caching Der Client Launcher speichert die vom Broker heruntergeladenen Jar-Dateien in einem Cache auf der lokalen Festplatte zwischen. Dieser Cache wird automatisch bereinigt. Auto Cleanup : Gibt an, wie viele Tage nach dem letzten Aufruf eine Anwendung aus dem Cache gelöscht werden soll. Directory : Hier kann der Cache-Ordner im Explorer geöffnet werden. Clear Cache : Löscht den kompletten Cache. Network Siehe Abschnitt Proxy-Einstellungen . Java Settings Use Java Version : Über diesen Schalter kann die Java-Laufzeitumgebungs-Version eingestellt werden. Welche Java-Laufzeitumgebung verwendet werden soll kann alternativ auch über Umgebungsvariablen konfiguriert werden, siehe Java-Laufzeitumgebung . Recommended verwendet aktuell die JRE8 Supported verwendet entweder JRE8 oder JDK11 (64 Bit), dies entscheidet der Broker Experimental verwendet aktuell das JDK11 (64 Bit) VM Arguments : Hier können Argumente für die Java-Runtime angegeben werden. Die hier angegebenen Argumente haben die höchste Priorität. Sie überschreiben die Standard- Argumente des Client Launchers und die vom Broker vorgegebenen Argumente. Mehrere Argumente werden durch einen Zeilenumbruch getrennt. Beispiele: -Xmx1024M Setzt die maximale Speicher-Auslastung auf 1024 MB -Xms250M Setzt die initiale Speicher-Auslastung auf 250 MB Proxy-Einstellungen Direct Connection Das ist die Standard-Einstellung. Im Java-Client wird die Verwendung von Proxies deaktiviert und alle Anfragen werden direkt an den Server gesendet. Das umfasst sowohl sie Anfragen an den Broker-Server als auch alle anderen HTTP-Anfragen z.B. durch ein Browser-Control. Der Java-VM wird dafür das folgende Argument übergeben: -Djava.net.useSystemProxies=false Bei Bedarf können individuelle Proxy-Einstellungen auch über die VM Arguments im Konfigurations-Dialog vorgenommen werden. Details zu den Argumenten befinden sich in der Dokumention von Java: https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html Es ist wichtig, ggf. auch an https zu denken. Eine individuelle Proxy-Einstellung sieht z.B. so aus: -Dhttp.proxyHost=192.168.124.37 -Dhttp.proxyPort=3118 -Dhttp.nonProxyHosts=srv-erp-as-test|srv-erp-as01|srv-erp-as02|localhost|127.*|[::1] -Dhttps.proxyHost=192.168.124.37 -Dhttps.proxyPort=3119 -Dhttps.nonProxyHosts=srv-erp-as-test|srv-erp-as01|srv-erp-as02|localhost|127.*|[::1] Caution Die individuellen Proxy-Einstellungen greifen nur innerhalb des eigentlichen Java-Clients. Beim Start-Vorgang werden durch den Client-Launcher auch Informationen vom Anwendungs-Server geladen. Dabei greifen immer die Windows-Einstellungen. Windows Settings Der Java-Client greift auf die Proxy-Einstellungen des Client-Windows-Betriebssystems zurück. Es muss also sichergestellt sein, dass Windows den Anwendungs-Server erreichen kann. Der Java-VM wird dafür das folgende Argument übergeben: -Djava.net.useSystemProxies=true Bei den Proxy-Ausnahmen müssen ggf. die lokalen Adressen localhost; 127.0.0.1 ergänzt werden, auch wenn die CheckBox \"Proxyserver nicht für lokale Adressen\" gesetzt ist. SSL Ein Betrieb wird nur mit vertrauenswürdigen Zertifikaten unterstützt. Wird der Broker per SSL angesprochen, dann ist es erforderlich, dass das Client-Windows-Betriebsystem dem SSL-Zertifikat des Servers vertraut. Der Java-VM wird dafür das folgende Argument übergeben: -Djavax.net.ssl.trustStoreType=Windows-ROOT Java-Laufzeitumgebung Der Client Launcher beinhaltet eine eigene Java Laufzeitumgebung, mit der der Client gestartet wird. Die Installation einer separaten Java Laufzeitumgebung ist für den Betrieb des Client-Launchers nicht erforderlich. Mit der Umgebungsvariablen FSCL_JRE8 und FSCL_JDK11 kann bei Bedarf eine abweichende selbst installierte Java Laufzeitumgebung konfiguriert werden. Das kann sinnvoll sein, wenn man beispielsweise eine andere Version oder eine 64-Bit Variante der Java Laufzeitumgebung genutzt werden möchte. Diese Umgebungsvariable kann in der System-Steuerung von Windows auf Benutzer- oder System-Ebene definiert werden. Nach der Änderung der Einstellung ist ggf. ein Neustart des Prozesses (z.B. auch der Framework Studio IDE) nötig, damit die Einstellung zieht. Important Unter Umständen kann es schwierig sein alle abhängigen Prozesse zu beenden, es empfiehlt sich den Benutzer ab- und wieder anzumelden oder alternativ den Rechner neu zu starten. Es ist aber auch möglich z.B. durch eine Batch-Datei die Umgebungsvariable nur temporär für die aktuelle Situation zu überschreiben. rem Zeigt auf das Verzeichnis für die JRE8 Laufzeitumgebung (Recommended) set FSCL_JRE8=C:\\JAVA\\JRE8 rem Zeigt auf das Verzeichnis für die JDK11 Laufzeitumgebung (Experimental) set FSCL_JDK11=C:\\JAVA\\JDK11_x64 rem Start des Client Launchers mit dem \"Start Application\" Link aus der Broker Start-Seite \"%ProgramFiles%\\Framework Systems\\FS Client Launcher\\FSClientLauncher.exe\" \"fsclientlauncher:launch?broker=http://.....\" Tip Wurde ein falsches Verzeichnis angegeben, beendet sich der Launcher mit einem Fehler, das der \"JVM Launcher\" nicht gefunden wurde. Der \"JVM Launcher\" wird in bin/javaw.exe gesucht, es muss also das Installationsverzeichnis der Java Laufzeitumgebung und nicht dessen bin Verzeichnis angegeben werden."
  },
  "doc/fsclientlauncher/fsclientlauncher-installation.html": {
    "href": "doc/fsclientlauncher/fsclientlauncher-installation.html",
    "title": "Installation",
    "keywords": "Installation System-Voraussetzungen Betriebssystem (jeweils 32 Bit oder 64 Bit): Windows 8 – oder höher Windows 7 SP1 Windows Vista SP2 Windows Server 2012 – oder höher Windows Server 2008 R2 SP1 Windows Server 2008 SP2 Software: Microsoft .NET Framework Version 4.5 oder höher Hinweis Der Client Launcher kann mittels des Standard- oder MSI-Installers installiert werden. Dabei ist zu beachten, dass die beiden Optionen nach Möglichkeit nicht vermischt werden sollten, um volle Upgrade-Fähigkeit zu garantieren. Caution Ist der Client Launcher auf einem System mittels des Standard-Installers installiert worden, sollte dieser nicht durch eine MSI-Installation aktualisiert werden! In diesem Fall muss zuerst die alte Version deinstalliert werden! Standard-Installer Der Standard-Installer liefert eine einfache Benutzeroberfläche zur Installation des Programms und kann ggf. auch per Kommandozeile im Silent-Modus ausgeführt werden. Der Standard-Installer ist im Requirements-Paket enthalten und steht auch als separater Download zur Verfügung. Standard Installation ausführen FSCL_4.4.X_Setup_x64.exe ausführen und der Installations-Routine folgen. Diese Installations-Routine beinhaltet die 32-Bit Version der Java-Runtime. Die FSCL_4.4.X_Setup_x64.exe ist ausschließlich für 64 Bit Betriebssysteme vorgesehen. Die FSCL_4.4.X_Setup_x86.exe ist ausschließlich für 32 Bit Betriebssysteme vorgesehen. Kommandozeilen-Parameter Die Setup-Routine kann mit folgenden Kommandozeilen-Parametern aufgerufen werden. Damit ist eine Automatisierung der Installation möglich. -uninstall Deinstallation ausführen -s Silent-Installation / Update ohne Benutzerinteraktion. Das Programm erkennt die installierte Version und führt bei Bedarf ein Update durch. Es sind Administrationsrechte notwendig. -s -uninstall Silent-Deinstallation ohne Benutzerinteraktion. Es sind Administrationsrechte notwendig. -l <logfile> Erzeugt ein Logfile zur Analyse von Problemen bei der Ausführung des Installers MSI-Installer Der Client Launcher wird zusätzlich auch als MSI-Installer angeboten, um die Installation über GPO zu ermöglichen. Dieser Installer bietet bis auf Progress-Anzeigen keinerlei Benutzeroberfläche an und arbeitet somit vollständig automatisch. MSI Installation ausführen FSCL_4.0.X_Setup_x64.msi direkt oder per Kommandozeile ausführen. Diese Installations-Routine beinhaltet die 32-Bit Version der Java-Runtime. Die FSCL_4.0.X_Setup_x64.msi ist ausschließlich für 64 Bit Betriebssysteme vorgesehen. Die FSCL_4.0.X_Setup_x86.msi ist ausschließlich für 32 Bit Betriebssysteme vorgesehen. Kommandozeilen-Parameter (nur Installation) Die Setup-Routine kann mit mit allen Parametern des MSI-Systems manipuliert werden. Nachfolgend die wichtigsten. /q Silent-Installation / Update ohne Benutzerinteraktion. Das Programm erkennt die installierte Version und führt bei Bedarf ein Update durch. Es sind Administrationsrechte notwendig. /L*v <logfile> Erzeugt ein Logfile zur Analyse von Problemen bei der Ausführung des Installers. Deinstallation MSI-Pakete können ausschließlich über die Systemsteuerung oder Msiexec.exe deinstalliert werden: Msiexec.exe /x FSCL_4.0.X_Setup_x64.msi /q /L*v <logfile> Die folgenden Parameter sind dabei optional: /q Silent-Installation / Update ohne Benutzerinteraktion. Das Programm erkennt die installierte Version und führt bei Bedarf ein Update durch. Es sind Administrationsrechte notwendig. /L*v <logfile> Erzeugt ein Logfile zur Analyse von Problemen bei der Ausführung des Installers."
  },
  "doc/fsclientlauncher/fsclientlauncher-javaruntime.html": {
    "href": "doc/fsclientlauncher/fsclientlauncher-javaruntime.html",
    "title": "Java-Runtime",
    "keywords": "Java-Runtime Lizenz Oracle hat im Februar 2019 für kommerzielle Nutzer den kostenlosen Support von Java 8 eingestellt. Der Client Launcher verwendet die letzte kostenlos verfügbare Version Java 8 Update 202. Der Einsatz einer aktuelleren Version ist auf eigene Rechnung möglich. Dafür müssen entsprechende Lizenzen direkt bei Oracle erworben werden. Eine abweichende Laufzeitumgebung kann konfiguriert werden. Sicherheit Die Sicherheits-Risiken durch den Einsatz einer veralteten Java-Runtime begründen sich durch die enge Integration der Runtime in das System. Dabei spielen insbesondere 3 Aspekte eine wesentliche Rolle: 1.) Integration der installierten Java-Runtime in den Internet-Explorer. Dadurch werden Angriffe über entsprechend präparierte Webseiten ermöglicht. Für den Einsatz von Java Web Start ist die Aktivierung dieser Integration zwingend erforderlich. 2.) Java Web Start selber stellt eine entscheidende Lücke dar, weil damit eine fast beliebige Anwendung / jnlp-Datei aus dem Internet gestartet werden kann. Code-Signierung kann das verhindern - sofern der Benutzer aufmerksam genug ist und nicht jedem Herausgeber blind vertraut. 3.) Globale Erreichbarkeit der Installierten Java-Runtime für alle Java-Programme. Das wird z.B. durch die Umgebungs-Variable java_home erreicht. Der Client-Launcher besitzt seine eigene Java-Runtime. Diese wird in keiner Weise im System registriert. Damit weiß das System und Insbesondere die Browser nichts von dieser Runtime. Der Start einer Anwendung erfolgt mithilfe eines eigenen Dateiformats. Die oben genannten Sicherheits-Risiken bestehen damit nicht."
  },
  "doc/fsconsole/fsconsole.html": {
    "href": "doc/fsconsole/fsconsole.html",
    "title": "FSConsole",
    "keywords": "FSConsole Allgemeines FSConsole.exe ist ein Kommandozeilen-Programm, mit dem man viele Operationen automatisieren kann. Das sind unter anderem: Kompilieren von Package-Version Export und Import von Packages Dieses Programm wird von Framework Studio selber z.B. im Compile-Wizard verwendet. Es kann aber auch für eigene Automatisierungen,, z.B. nächtliche Compile-Läufe, verwendet werden. Kommandozeilen-Parameter Wenn FSConsole.exe ohne Parameter aufgerufen wird, wird eine Beschreibung der Parameter in der Konsole ausgegeben. \\LOGINXML <pathToXML> Pfad einer XML-Datei mit einer Compile-Wizard-Konfiguration. Die Login-Informationen und die zu kompilierenden Labels werden aus dieser Datei gelesen. Mit anderen Parametern angegebene Login- oder Label-Informationen werden ignoriert. So eine Datei kann im Compile-Wizard über das Menü File / Export Settings erzeugt werden. Beispiel: \\LoginXML \"c:\\temp\\FSDemo.xml\" \\ConnectionType <connType> Datenbank-Typ: SqlServer oder Oracle. \\SERVER <servername> \\DATABASE <database> \\DBUser <user> \\DBPassword <passwd> Verbindungsdaten für das Repository. Wenn kein Benutzer angegeben ist, wird Windows-Authentifizierung verwendet. Der Parameter \\ConnectionType muss ebenfalls angegeben werden. Beispiel SQL-Server mit Windows-Authentication: \\ConnectionType SqlServer \\SERVER db01 \\DATABASE Repository Beispiel SQL-Server mit SQL-Server-Authentication: \\ConnectionType SqlServer \\SERVER db01 \\DATABASE Repository \\DBUser sa \\DBPassword Xt4r5w Beispiel Oracle: \\ConnectionType Oracle \\DATABASE OraRep \\DBUser fs \\DBPassword Xt4r5w \\LOGFILE <logFilePath> Pfad der Log-Datei. Platzhalter: $datetime$: Startzeit des Processes im dem Format yyyy-MM-dd_HH-mm-ss Beispiel: \\LogFile \"C:\\CompileLogs\\FSDemo_$datetime$.log\" \\CompileRun <CompileRunName> Kompiliert alle Package-Versionen, bei denen im Package-Manager das Feld Compile Run mit dem entsprechenden Namen angegeben wurde. Der Name ist nicht case-sensitiv. Beispiel: \\CompileRun \"Daily\" \\RefreshWS Aktualisiert den Workspace. Wenn es mit \\Compile kombiniert wird, dann wird die Aktualisierung als erstes ausgeführt werden. \\DebugCode Es werden zusätzlich Debug-Stände kompiliert. \\Compile Führt einen Compile durch. Die Parameter \\Package und \\Version oder \\LabelID müssen angegeben werden. \\Package <name> \\Version <name> Beispiel: \\Package \"MyPackage1\" \\Version \"1.0\" \\OBJECTTYPE <type> Gibt an, welcher Element-Typ kompiliert werden soll. Mögliche Typen: AccessUnitOwner, CodeFile, Component, CustomControl, DBTable, Form, GlobalObject, Interface, Metadatatype, ReportDocument, Resource, Workflow \\LabelID Interne ID einer Package-Version. Beispiel: \\LabelID \"17ab3fe4de22146f87edf715faedcb56\" \\NewProcessPerStep Jeder Element-Typ wird nacheinander in einem separaten Prozess kompiliert. \\Verbose In der Log-Datei werden mehr Detail-Informationen ausgegeben. \\LoginUser <username> Wenn nicht angegeben, wird FrameworkCompiler verwendet. \\CHECK valid values: None,WorkflowBranchAndSwitch,All \\Export <fileName> Exports the label to the file fileName. \\Import <fileName> Imports the file fileName to the repository. \\PUBLISH Führt einen Publish mit dem angegebenen Setting durch (siehe \\SETTING). \\PUBLISH2GO Erstellt ein Publish2Go mit dem angegebenen Setting (siehe \\SETTING). \\SETTING Definiert das Setting, welches bei \\PUBLISH oder \\PUBLISH2GO verwendet wird. Kann entweder als Name des Settings im Repository oder als Datei angegeben werden. Beispiel 1: \\SETTING Test_Setting Beispiel 2: \\SETTING “C:\\Temp\\Test_Setting.FSSetting” \\DOCUMENTATION Rendert die gesamte Dokumentation als HTML 5 Webapplikation. Benötigt die Parameter \\ISO und \\OUTPUT. Beispiel: \\DOCUMENTATION \\ISO de \\ExportDBTables \\OUTPUT “C:\\Temp\\Dokumentation” \\ISO Gibt an in welcher Sprache die Dokumentation gerendert werden soll. Beispiel: \\ISO de \\ExportDBTables Gibt an, dass die Tabellen-Beschreibungen mit exportiert werden sollen. \\OUTPUT Gibt das Verzeichnis an, in welches die Dokumentation gerendert werden soll. Beispiel: \\OUTPUT “C:\\Temp\\Dokumentation” \\USELICENSE Wenn dieser Parameter gesetzt ist, wird die Runtime-Lizenz aus dem Setting verwendet, welches via \\SETTING übergeben wurde. In der Folge wird nur der Teil der Dokumentation exportiert, der mit der Runtime-Lizenz sichtbar ist."
  },
  "doc/global-events/global-events.html": {
    "href": "doc/global-events/global-events.html",
    "title": "Global Events",
    "keywords": "Global Events Global Events sind dazu da, Events zu feuern, die in der ganzen Anwendung abgefangen werden können. Sie können z.B. dazu dienen, allen offenen Workflows und Forms mitzuteilen, dass sie ihre Daten aktualisieren sollen, weil sich Stammdaten geändert haben. Ein Global Event besteht aus zwei Teilen: einem Sender. einem Event-Handler. Die Global Events können zudem auch eine beliebige Anzahl von Parametern jedes Typs erhalten. Somit können mit dem Event auch Daten an jede Stelle der Anwendung übertragen werden. Global Events sind durch das -Icon gekennzeichnet. Global Events anlegen / löschen Ein neues Global Event legen Sie an, indem Sie den Namespace markieren, unter dem das neue Event angelegt werden soll. Anschließend drücken Sie den Button (New) und wählen den Eintrag Global Event aus. Das Global Event wird angelegt und geöffnet. Ein Global Event kann in jedem beliebigen Namespace angelegt werden. Es ist aber empfehlenswert, die Events alle in einen Namespace zu packen. Löschen können Sie ein Global Event, indem Sie das Event in der Namespaces-Registerkarte markieren und den Button ( Delete ) drücken. Das Löschen wird erst mit dem Button ( Save All ) wirksam. Global Events bearbeiten Sie öffnen ein Global Event, indem Sie einen Doppelklick auf das Event der Namespaces-Registerkarte machen. Es öffnet sich der GlobalEvent-Designer im rechten Teil des Framework Designers . Name Gibt den Namen des Global Events an. Parameters In diesem Teil des Fensters werden die Parameter des Global Events verwaltet. Ein Global Event kann beliebig viele Parameter der unterschiedlichsten Datentypen besitzen. In der Listbox werden alle Parameter mit ihrem Namen aufgelistet. Rechts daneben werden die Eigenschaften des ausgewählten Parameters bearbeitet. Parameters Name Name des Parameters. Parameters Datatype Gibt den Datentyp des Parameters an. Zur Auswahl stehen .NET-Datentypen, FS-Datentypen, Metadatentypen und Components. Button Add Fügt einen neuen Parameter in die Liste ein. Button Delete Löscht den momentan markierten Parameter aus der Liste. Global Events verwenden Global Events können im Workflow verwendet werden. Nähere Informationen dazu finden Sie im Kapitel Workflows. ( Global Events )"
  },
  "doc/globalobjects/globalobjects.html": {
    "href": "doc/globalobjects/globalobjects.html",
    "title": "Global Objects",
    "keywords": "Global Objects In Framework Studio – bzw. in der Anwendung – gibt es ein globales Objekt, welches überall verfügbar ist. Es kann jederzeit mit this.Global angesprochen werden. Damit das Global Object überall zur Verfügung steht, muss es beim Erzeugen eines neuen Framework-Studio Objektes mit dem Constructor übergeben werden. Variante mit dem new-Operator cdComponent oObject = new cdComponent( this.Global); Nutzen der Interfaces und Factory-Klassen IcdComponent oObject2 = cdComponentFactory.Create( this.Global ); Im automatisch generierten Code werden alle Objekte (Components, Forms, Workflows) in gleicher Weise erstellt. Somit ist dieses Global jederzeit und überall verfügbar. Das Global Object eignet sich hervorragend, um z.B. System- oder Benutzerdaten in der gesamten Anwendung zur Verfügung zu stellen. Welche Daten/Variablen dieses Objekt anbietet, wird im Namespace FSGeneral.GlobalObjects. definiert. Alle Elemente dort werden beim Start der Applikation instanziiert. Global Object Designer: Button New Es wird eine neue Variable angelegt. Sie können gleich den Namen der Variablen eingeben. Button Delete Löscht die markierte Variable. Name Name der Variablen bzw. des Objekts. Datatype Gibt den Datentyp der Variablen an. Über die Combobox kann der Datentyp geändert werden. Es öffnet sich der Namespace-Baum, über den das gewünschte Struct, Metadatatype oder Component ausgewählt werden kann. Autocreate Ist diese Checkbox aktiviert, wird die Variable automatisch beim Start der Anwendung initialisiert. Wenn nicht, wird die Variable einfach nur angelegt, ohne ihr einen Wert zuzuweisen. Dies können Sie dann im Code-Fenster festlegen. Redirect to ocGlobal Wenn diese Checkbox aktiviert ist, dann werden alle Zugriffe auf dieses GlobalObject in das gleichnamige Property in der Component FSGeneral.cGlobal umgeleitet. Dies betrifft Lese- und ggf. auch Schreibvorgänge. Wenn es sich bei dem cGlobal-Property um ein Readonly Property handelt, dann erkennt dies Framework Studio und wird das GlobalObject selber auch entsprechend readonly erzeugen. Das cGlobal-Property kann wie gewohnt als Individual Property mit Membervariable gestaltet werden, welches die Daten erst beim ersten Zugriff aufbereitet. So ist es möglich, ein GlobalObject erst beim ersten Zugriff zu initialisieren und so den Start der Anwendung zu beschleunigen. Init Code Im Code-Fenster können Sie angeben, was mit der Variable beim Start der Anwendung geschehen soll. Sie können den Variablen beispielsweise Werte zuweisen oder wenn Sie eine Component mit einer Query eingebunden haben, an dieser einen Load ausführen, damit die entsprechenden Daten aus der Datenbank gelesen werden. Methoden am GlobalObject Das Globale Objekt stellt neben den selbst definierten Properties auch System-seitig Methoden und Properties bereit. Siehe Methoden am GlobalObject Properties am GlobalObject Siehe Methoden am GlobalObject ocGlobal public IcGlobal ocGlobal Gibt ein Objekt vom Typ IcGlobal zurück. Dieses Objekt ist eine Instanz der Component cGlobal , die im Namespace FSGeneral im SystemPackage definiert ist. Für weitere Informationen siehe cGlobal . SafeInitializing Siehe SafeInitializing"
  },
  "doc/html-client/android-app.html": {
    "href": "doc/html-client/android-app.html",
    "title": "Android App",
    "keywords": "Android App Für die volle Integration des HTML-Clients in die mobile Welt, stellen wir im Google Play Store den Client als Android App zur Verfügung. Die App basiert auf demselben Sourcecode wie die Browser-Version. Einzelne Features greifen im Gegensatz zu einem Browser aber direkt auf die Hardware des mobilen Geräts zu und integrieren sich dadurch besser in die App. Name der App : Framework Studio Mobile Client Store Link : https://play.google.com/store/apps/details?id=com.fs.htmlclient Note Apple verweigert Apps per Richtlinie, dynamische Benutzeroberflächen von einer extenen Quelle (Broker) zu laden und am Client aufzubauen. Durch diese Limitierung sind wir leider nicht in der Lage, den Framework Studio Mobile Client auf IOS bereitzustellen. Systemvoraussetzungen Unterstützt werden Handys und Tablets mit Android 6.0 oder höher. Caution Auf Geräten mit Android 7.X oder niedriger muss Google Chrome parallel zwingend installiert sein, da die integrierte WebView nicht mehr unterstützt wird Der Framework Studio Mobile Client ist eine App basierend auf dem Ionic Capacitor Framework, welches HTML-Applikationen mit Hardware-Unterstützung auf mobile Endgeräte bringt. Ist auf dem Endgerät Google Chrome nicht installiert, so wird zur Anzeige der HTML-Applikation die integrierte Android WebView verwendet. Diese basiert wie Google Chrome ebenfalls auf der Chromium Engine, ist aber auf vielen - vor allem älteren - Endgeräten nur in einer sehr betagten Version verfügbar. Dies kann ggf. zu Fehlern führen. Es gelten folgende Regeln: Ist Google Chrome installiert, wird dessen Chromium Engine für die Ausführung des Framework Studio Mobile Client verwendet Ist Google Chrome nicht installiert, wird die Android WebView verwendet Note Auch auf neueren Geräten ab Android 8.0 empfehlen wir, die aktuellste Version von Google Chrome zu installieren, um die breiteste Unterstützung von Features und die fehlerfreie Darstellung der App zu garantieren. Einrichten eines Brokers Es muss natürlich definiert werden, mit welchem Broker sich der Mobile Client verbinden soll. Nach dem Start der App wird der Login angezeigt. Über den Button „+ New“ können beliebig viele Broker zur Liste hinzugefügt werden. Es ist auch möglich, Urls von Development Brokern hinzuzufügen. Dabei ist zu beachten, dass der Mobile Client nur auf den Development Broker zugreifen kann, wenn dieser über das Netzwerk erreichbar ist. Dazu muss Framework Studio mit Administrator-Rechten ausgeführt werden. Ob der Development Broker vom Netzwerk aus zugreifbar ist, kann über das Tray-Icon geprüft werden:"
  },
  "doc/html-client/controls.html": {
    "href": "doc/html-client/controls.html",
    "title": "Controls",
    "keywords": "Controls Symbol Bedeutung + Property oder Event wird vollständig unterstützt - Property oder Event wird nicht unterstützt o Property oder Event wird teilweise unterstützt (Anmerkung beachten) Allgemein Die folgende Auflistung beinhaltet diejenigen Properties und Events, die an allen verfügbaren Controls im HTML-Client vorhanden sind. Properties Name Unterstützt Anmerkung Alignment + BackColor + BorderColor + BorderRadius + BorderThickness + ButtonGroupDataSource + Caption + DockPanel.ItemSize + Font Family - Ist im Client hart definiert auf die Hierarchie Arial -> Helvetica -> Sans-Serif. Font Bold + Font Italic + Font Underline + ForeColor + IsEditable + LabelTemplate + MapEnterToTabAction - Margin + MaxSize + MinSize + Name + Padding + Shortcut - TabStop + ToolTip + Visibility + Events Name Unterstützt OnCanDrop - OnDrag - Form Properties Name Unterstützt BadgeImage DataSource + HideModalHeader + IsCloseIconVisible + MainMenu - PreferredSize - SymbolImage - Title + VerticalScrollbarOverlay - Events Name Unterstützt OnLoad + OnClose + Dock Panel Properties Name Unterstützt Anmerkung BackgroundImage - BackgroundScaleMode - DockPanelOrientation + Scrolling o Es wird immer VerticalOverlay verwendet, auch wenn Normal ausgewählt wurde, da in vielen Browsern die Breite der Scrollbar nicht berechnet werden kann. Spacing + Events Name Unterstützt OnEnter - OnLeave - Wrap Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - ContentAlignment + InvertFlowDirection + Spacing + WrapArrangement + Events Name Unterstützt OnEnter - OnLeave - Field Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - RowLabelTemplate + SynchronizeColumns + Events Name Unterstützt OnEnter - OnLeave - Field Row Properties Name Unterstützt FieldRowSize + LabelMode + OptimizeGeneratedLabels + Button Properties Name Unterstützt ShowCaption + TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + ImageButton Properties Name Unterstützt BadgeImage DataSource + CaptionAlign - ContextMenu - DataSource - DisabledImage + HighlightImage - Image + MouseOverImage + PressedImage + ScaleMode - ShowCaption + SymbolImage - TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + Label Properties Name Unterstützt DataSource + TextAlign + Events Name Unterstützt OnEnter + OnLeave + CheckBox Properties Name Unterstützt DataSource + ShowCaption + Events Name Unterstützt OnClick + OnEnter + OnLeave + Editfield Properties Name Unterstützt Anmerkung CaptionAsPlaceholder + DataSource + DisabledBackColor o Wird dynamisch im Client berechnet DisplayLength + Editor o Nur \"PlainText”, \"HTML” wird nicht unterstützt Format + FormatPattern o Funktioniert nur mit Format \"Decimal\" Multiline + PasswordChar + Client generiert ein Password-Feld, wenn gesetzt. Das Passwort-Zeichen selbst kann aber nicht geändert werden (in Web Browsern technisch nicht möglich). ScrollBars + SelectionEnd - SelectionStart - TabStop + TextAlign + WordWrap + Events Name Unterstützt OnEnter + OnLeave + OnValidated + ComboBox Properties Name Unterstützt CaptionAsPlaceholder + DataSource + DisplayLength + EditStyle + List + ListOrder + MaxDropDownSize + TabStop + Events Name Unterstützt OnEnter + OnLeave + OnSelectionChanged + RadioButton Properties Name Unterstützt CaptionDataSource + DataSourceOnValue + Events Name Unterstützt OnEnter + OnLeave + OnClick + Picture Siehe Picture . Note Im HTML Client muss einem Picture Control eine MinSize zugewiesen werden. Eine automatische Größenanpassung eines Picture Controls an den Inhalt ist nicht möglich. Properties Name Unterstützt CaptionAlign + DataSource + ScaleMode + ShowCaption + Events Name Unterstützt OnClick + OnEnter - OnLeave - ListView Siehe ListView . Properties Name Unterstützt DataSource + ItemArrangement + ItemSize + SelectedItems + SelectionMode + SelectorPosition + Spacing + Template + Events Name Unterstützt OnEnter - OnLeave - OnItemActivated + OnItemSelectionChanged + Template Control Siehe Template Control . Properties Name Unterstützt Template + Events Name Unterstützt OnEnter - OnLeave - Tabbed Window Properties Name Unterstützt DataSource + TabTemplateActive + TabTemplateDisabled + TabTemplateInactive + Events Name Unterstützt OnSelectedTabPageChange + OnSelectedTabPageChanged +"
  },
  "doc/html-client/fokussystem.html": {
    "href": "doc/html-client/fokussystem.html",
    "title": "Hinweis zum Fokussystem",
    "keywords": "Hinweis zum Fokussystem Ein besonderes Augenmerk muss auf die SetFocus Action in Verbindung mit den OnEnter und OnLeave Events an Controls gelegt werden, da in diesem Zusammenhang der JavaClient und HTML Client unterschiedlich reagieren. Vergleich zum JavaClient In der Programmierung für den JavaClient wird sehr oft der Fokus in einem OnLeave Event in ein anders Control gesetzt, welches nicht das direkt nachfolgende ist. Z.B. werden nach der Eingabe mehrere Textfelder übersprungen oder der Fokus in ein Grid gelegt. Diese Art der Programmierung funktioniert im JavaClient, da dessen Eventsystem synchron aufgebaut ist. D.h., der JavaClient kann bei einem OnLeave Event auf eine Antwort des Brokers warten, bevor er den Fokus tatsächlich in das gewünschte Control setzt. Dadurch wird das Fokussystem auch durch länger andauernde Requests nicht \"gestört\". Asynchrones Eventsystem in Browsern Das Eventsystem eines Web Browsers läuft hingegen asynchron ab. Bei einem Fokuswechsel kann zwar ein Broker Request abgesetzt werden (z.B. in einem OnLeave Event an einem Textfeld), auf dessen Response kann allerdings nicht gewartet werden. Dies hat zur Folge, dass der Fokus vom Browser ggf. in das nachfolgende Control gesetzt wird, bevor der Broker Request abgeschlossen ist. Je nachdem wie viel Zeit der Broker Request benötigt, kann dies in Verbinung mit der SetFocus Action zu seltsamen Effekten am Client führen. Das kann im schlimmsten Fall einen \"Focus-Lock\" hervorrufen, bei dem der Fokus in einem Control \"festhängt\". Dieses Dilemma kann technisch nicht gelöst werden. Aus diesem Grund gilt für die HTML Client Programmierung folgende Gundregel: Note In einem OnEnter oder OnLeave Event darf niemals eine SetFocus Action aufgerufen werden!"
  },
  "doc/html-client/funktionsumfang.html": {
    "href": "doc/html-client/funktionsumfang.html",
    "title": "Funktionsumfang",
    "keywords": "Funktionsumfang Der HTML-Client befindet sich noch in der agilen Entwicklung. Verglichen mit dem ausgereiften JavaClient ist der Funktionsumfang des HTML-Clients noch überschaubar. Neue Funktionen und die Unterstützung für weitere Controls werden kontinuierlich weiter entwickelt und veröffentlicht. Note Wird in diesem Kapitel etwas nicht erwähnt, wie z.B. ein Property eines Controls, eine Action oder andere Client-Funktionalitäten, so muss davon ausgegangen werden, dass diese noch nicht unterstützt werden. Handhabung von nicht unterstützten Funktionalitäten Es gibt im Form Designer oder im Code Editor von Framework Studio keine Limitierungen, die den Entwickler auf den Funktionsumfang des HTML-Clients einschränken. Werden Controls, Actions oder anderweitige Funktionalitäten genutzt, die vom HTML-Client nicht unterstützt werden, so werden diese (so weit es möglich ist) vom Client ignoriert. Wenn z.B. ein Grid-Control in ein Form eingebaut wird, so wird dieses erst garnicht vom HTML-Client interpretiert. Dasselbe gilt für nicht unterstützte Properties an Controls. Frameset Der HTML-Client besitzt kein Frameset. Alle geöffneten Forms werden in einer einzigen Liste organisiert. Es ist irrelevant, welchem Frame ein Form in einem Workflow zugeordnet ist. MessageBox und ExceptionBox Werden vollständig unterstützt inkl. Buttons, Icons, DialogResult und EventHandler. Werden im Client als modale Popups angezeigt. Modale Forms Modale Forms, die das Wechseln zu einem anderen Form unterdrücken, werden vom HTML-Client vollflächig angezeigt. Dabei wird der Menü-Button ausgeblendet. Verhalten beim Drücken des „Zurück“-Button auf einem mobilen Gerät: Wenn am Form das Property IsCloseIconVisible auf true gesetzt ist, wird der modale Dialog geschlossen. Wird dem Form über die Action SetCloseButton ein Button zugewiesen, dessen Click-Event beim Schließen ausgelöst werden soll, wird dies beim Drücken des Zurück-Button ebenfalls ausgelöst. Ist das Property HideModalHeader am Form auf true gesetzt, so wird der Header mit dem Titel und ggf. dem Close Button komplett ausgeblendet, um mehr Platz für Controls zu schaffen. In diesem Fall muss das Schließen des Dialogs über einen eigens implementierten BUtton erfolgen, der am Form die Methode Close() aufruft. Drag & Drop Drag & Drop und alle damit verbundenen Events werden vom HTML Client nicht unterstützt. Shortcuts und ToolTips Da für den HTML-Client die mobile Welt im Vordergrund steht, werden Shortcuts und ToolTips noch nicht unterstützt, da diese auf einem Handy bzw. Tablet keinen Sinn machen. Control Styles Control Styles werden für alle im HTML-Client verfügbaren Controls unterstützt. Wird im Form Designer einem Control ein Control Style zugeordnet, so werden dessen Properties korrekt interpretiert bzw. die Property-Hierarchie beachtet. Actions Es werden derzeit folgende Actions unterstützt: Beep (ab FS 4.4) BeepDouble (ab FS 4.4) BeepMultiple (ab FS 4.4) GetGeoLocation ScanBarcode SetCaption SetCloseButton SetEnabled SetImage SetTitle SetVisible TakePhoto PrintReport ViewDocument ViewDocument Action Die ViewDocument Action ist im HTML Client auf folgende Url-Schemen limitiert: fsbroker://*/* http://*/* https://*/* mailto:* geo:* tel:* sms:* Zurück-Button auf mobilen Geräten Mobile Geräte (z.B. Android) besitzen teilweise einen Zurück-Button. Der HTML Client unterstützt diesen kontextabhängig. Es gibt drei Prioritätsebenen, die nacheinander durchlaufen werden. Wird in einer Ebene auf das Drücken des Zurück-Buttons reagiert, so werden die darunter liegenden Ebenen nicht mehr behandelt. Die Ebenen geordnet nach Priorität sind: Overlays Modale Dialoge Normale Anzeige Overlays Als Overlay definiert sich alles, was sich mit einem ausgegrauten Hintergrund über die restliche Anzeige legt, wie z.B. MessageBoxen oder die ComboBox-Auswahl. Wenn ein Overlay geöffnet ist und der Zurück-Button gedrückt wird, wird das Overlay geschlossen. Eine MessageBox kann nur durch den Zurück-Button geschlossen werden, wenn ein Abbrechen-Button vorhanden ist. Modale Dialoge Modale Dialoge können mit dem Zurück-Button geschlossen werden, wenn das Property IsCloseIconVisible am Form auf true gesetzt ist. Wurde dem Form über die Action SetCloseButton ein Button mit einem Click-Event zugeordnet, so wird beim Drücken des Zurück-Buttons das Click-Event ausgelöst. Normale Anzeige Befindet sich der HTML Client in einem normalen Form, wird beim Drücken des Zurück-Buttons das Beenden der Application angestoßen, was mit der Rückfrage, ob die Session beendet werden soll, einher geht. Befindet sich der HTML Client im Broker-Auswahldialog, wird die Anwendung ohne Rückfrage geschlossen. Szenarien beim Schließen des letzten Forms Wird das letzte Form der Applikation geschlossen, so muss die Session beendet werden, da eine Applikation ohne Forms keinen Sinn ergibt. Allerdings müssen 2 Szenarien bei der Entwicklung bedacht werden, die auftreten können, wenn das letzte Form geschlossen wird: Das letzte Form hat keinen CloseButton zugewiesen und sendet beim Schließen somit keinen Request zum Broker. Wird dieses Form über das \"X\" (vorausgesetzt IsCloseIconVisible am Form ist auf auf true gesetzt) geschlossen, so wird eine Rückfrage angezeigt, ob die Session beendet werden soll. Wird diese mit \"Ja\" beantwortet, beendet der HTML Client die Session und zeigt die Broker-Auswahl an. Wird \"Nein\" ausgewählt, so bleibt das Form sowie die Applikation offen. Das letzte Form hat einen CloseButton zugewiesen, über dessen Handler brokerseitig mit der CloseForm() Action das Form geschlossen wird. Wird im gleichen Request kein anderes Form geöffnet und existiert somit nach dem Request kein offenes Form, so wird die Applikation vom Client ohne Rückfrage geschlossen. Da das Schließen des Forms vom Broker ausgeht, hat der Client \"kein Mitspracherecht\" mehr. Eine Rückfrage müsste brokerseitig über eine MessageBox implementiert werden. Wird im gleichen Request ein neues Form geöffnet, so wird die Applikation nicht beendet und ganz normal das neue Form am Client angezeigt. Beispielsweise könnte nach dem Schließen des letzten Forms ein Login-Dialog angezeigt werden."
  },
  "doc/html-client/index.html": {
    "href": "doc/html-client/index.html",
    "title": "HTML-Client",
    "keywords": "HTML-Client Neben dem Java Client bietet Framework Studio auch einen HTML-Client für Desktop- sowie mobile Geräte an. Dieser unterstützt noch deutlich weniger Funktionen und Controls als der Java Client. Was derzeit schon mit dem HTML-Client möglich ist, erfahren Sie in diesem Kapitel. Aktivieren des HTML-Clients Damit der HTML-Client über den Run Wizard und die Broker-Startseite gestartet werden kann, muss in der Application die Checkbox Supports Html Client gesetzt werden. Dies soll vermeiden, dass bisher existierende Applikationen ohne Weiteres im HTML-Client gestartet werden können, da diese sehr wahrscheinlich auf Controls und Funktionalitäten aufbauen, die derzeit vom HTML-Client noch nicht oder nicht vollständig unterstützt werden. Browser-Unterstützung Desktop Der HTML-Client basiert auf modernster Webtechnologie und benötigt deshalb auch einen aktuellen Browser für die Ausführung. Für Desktopsysteme empfehlen wir folgende Browser : Chrome Firefox Auch alle weiteren Browser, basierend auf der Chromium-Engine (Edge, Vivaldi, Opera), funktionieren problemlos. Note Microsoft Edge (ohne Chromium) und Internet Explorer 11 werden nicht unterstützt. Mobile Endgeräte Eine auf den HTML-Client ausgelegte Applikation kann über die Broker-Startseite natürlich auch von einem beliebigen mobilen Gerät aus gestartet werden, welches über einen aktuellen Browser verfügt. Die Unterstützung der Browser im mobilen Umfeld ist sehr schwer zu beurteilen, da es gerade auf Android eine extrem große Auswahl gibt. Wir empfehlen deshalb folgende mobilen Browser : Chrome Firefox Edge Dolphin Safari (ab iOS 10)"
  },
  "doc/html-client/lizenzen.html": {
    "href": "doc/html-client/lizenzen.html",
    "title": "Hinweis zu Lizenzen",
    "keywords": "Hinweis zu Lizenzen Timeout Aus technischen Gründen kann der HTML-Client weder im Browser, noch in der App auf einem mobilen Gerät dem Broker mitteilen, dass er beendet wurde. Z.B. kann auf einem Android-Gerät nicht unterschieden werden, ob eine App nur in den Ruhezustand gewechselt hat oder komplett geschlossen wurde. Dies hat zur Folge, dass Broker-Sessions, die von einem HTML-Client aus gestartet wurden, offen bleiben, bis der Broker sie von sich aus verwirft. Diese Zeitspanne beträgt 12 Stunden . ClientID Um dem Verbrauch von Lizenzen entgegen zu wirken, wird im HTML-Client eine ClientID generiert, die den Browser bzw. das mobile Gerät identifiziert und mit zum Broker geschickt wird. Im Browser ist die ClientID eine UUIDv4, die im Code generiert wird, auf mobilen Geräten wird die Cordova-Geräte-ID herangezogen. Über die ClientID kann der Broker den Browser bzw. das mobile Gerät identifizieren und bei einem erneuten Start einer Anwendung diesem die bisherige Lizenz zuordnen. Zusatz für mobile Geräte Die ClientID auf mobilen Geräten ist immer gleich. Ein mobiles Gerät verbraucht am Broker eine Lizenz unabhängig vom Benutzer. Zusatz für Browser Ein Browser hat keinen Zugriff auf das Betriebssystem und den Computer. Die generierte ClientID wird deshalb im sogenannten „Local Storage“ des Browsers gespeichert. Dieser Speicher ist je nach Konfiguration benutzerabhängig. Beispiel: Ist auf einem Computer, den drei Benutzer verwenden, Firefox als Browser installiert, so hat jeder Benutzer seinen eigenen Local Storage. Dies bedeutet, dass jeder Benutzer seine eigene ClientID bekommt und somit auch drei Lizenzen am Broker verbraucht werden. Dies gilt auch, wenn ein Benutzer dieselbe Applikation einmal im Firefox und einmal im Chrome öffnet. Die beiden Browser haben separate Local Storages und verbrauchen somit auch wieder zwei Lizenzen am Broker."
  },
  "doc/html-client/mobile/barcode.html": {
    "href": "doc/html-client/mobile/barcode.html",
    "title": "Barcode Scanner",
    "keywords": "Barcode Scanner Note Dieses Feature steht nur in der Android-App zur Verfügung. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser. Über die in einem mobilen Gerät integrierte Kamera können im HTML Client Barcodes unterschiedlicher Formate eingescannt werden. Unterstützte Formate Name Beispiel Name Beispiel AZTEC EAN_13 CODABAR ITF CODE_39 PDF_417 CODE_93 QR_CODE CODE_128 UPC_A DATA_MATRIX UPC_E EAN_8 Action ScanBarcode() Der Scan-Vorgang wird am Form über die Action ScanBarcode() gestartet. Note Es wird dringend empfohlen, nur diejenigen Barcode-Formate zu übergeben, die auch tatsächlich beim Scan-Vorgang unterstützt werden sollen, um Fehler beim Scannen zu vermeiden. Je geringer die Anzahl der unterstützten Formate ist, desto unwahrscheinlicher ist es, dass der Scan fehlschlägt. // Aufruf der Action beim Click des Scan-Buttons protected virtual void FE_btnScanArticle_OnClick(FrameworkButtonClickEventArgs e) { this.ScanBarcode( this.ScanBarcodeCallback, BarcodeFormat.EAN_8 | BarcodeFormat.EAN_13, \"Article\" ); } Wenn der Scan-Vorgang am Client abgeschlossen ist, wird die übergebene Callback-Methode aufgerufen. In ihr können die gescannten Daten weiterverarbeitet werden. Der Callback-Methode wird dafür ein Objekt mit dem Typ IFrameworkBarcodeScanInfo übergeben. // Callback-Methode protected virtual void ScanBarcodeCallback(IFrameworkBarcodeScanInfo e) { if (e.HasError) { this.sValue = e.ErrorMessage; } else if (e.Cancelled) { this.sValue = \"Cancelled\"; } else { if (e.Identifier == \"Article\") { this.sArticle = e.Value; } else { this.sAmount = e.Value; } this.sFormat = e.Format.ToString(); } } Berechtigung für Kamera Der Barcode Scanner benötigt auf dem mobilen Gerät Zugriff auf die Kamera. Diese muss z.B. auf einem Android-Gerät einmalig erteilt werden:"
  },
  "doc/html-client/mobile/deeplinks.html": {
    "href": "doc/html-client/mobile/deeplinks.html",
    "title": "Deep Links",
    "keywords": "Deep Links Der Android Mobile Client unterstützt das Öffnen von Deep Links. Damit kann z.B. aus einem Browser heraus per Link der Mobile Client geöffnet und automatisch ein Login an einem Broker ausgeführt werden. Zudem kann der Broker-Liste ein Eintrag hinzugefügt werden. Beispiel im HTML : <a href=\"fsbroker://framework-systems.de?name=Demo&url=http%3A%2F%2FAwesomeServer%3A8080%2FAwesomeApplication&login=true&save=true\">Open Deep Link</a> Der Link beginnt immer mit der Custom-Url fsbroker://framework-systems.de . Diese wird vom Mobile Client im Android-System registriert und sorgt für das Öffnen der App. Zusätzlich kann die Url aus bis zu vier der folgenden Parameter bestehen: Parameter Typ Benötigt Funktion name string (url-encoded) Ja Der Name des Brokers url string (url-encoded) Ja Die Broker-Url login boolean (true/false) Nein Steuert, ob sich die App nach dem Öffnen sofort am gegebenen Broker angemelden soll. Bei false wird lediglich die Startseite angezeigt. Der Standardwert ist true . save boolean (true/false) Nein Steuert, ob der angegebene Broker in der Login-Liste des Mobile Client gespeichert werden soll. Existiert ein Eintrag mit demselben namen, so wird dessen Url überschrieben. Der Standardwert ist false . Die Parameter name und url müssen immer url-enkodiert sein. So muss wie im Beispiel statt http://AwesomeServer:8080/AwesomeApplication die url-enkodierte Variante http%3A%2F%2FAwesomeServer%3A8080%2FAwesomeApplication angegeben werden. Einen entsprechenden Url-Encoder finden Sie z.B. unter https://www.urlencoder.org Note Ein Klick auf einen Deep Link wird vom Mobile Client nur dann interpretiert, wenn folgende Bedingungen erfüllt sind: Die App ist nicht bereits an einem Broker angemeldet Die App findet beim Start keine alte Session, die fortgeführt werden kann"
  },
  "doc/html-client/mobile/index.html": {
    "href": "doc/html-client/mobile/index.html",
    "title": "Funktionalitäten für mobile Endgeräte",
    "keywords": "Funktionalitäten für mobile Endgeräte Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser."
  },
  "doc/html-client/mobile/kamera.html": {
    "href": "doc/html-client/mobile/kamera.html",
    "title": "Kamera",
    "keywords": "Kamera Über die in einem mobilen Gerät integrierte Kamera können im Mobile Client Bilder gemacht und zum Broker geschickt werden. Alternativ können schon vorhandene Bilder aus der Bildergallerie ausgewählt werden. Action TakePhoto() Der Vorgang wird am Form über die Action TakePhoto() gestartet. // Aufruf der Action beim Click eines Buttons protected virtual void FE_btn_OnClick(FrameworkButtonEventArgs e) { this.TakePhoto(this.TakePhotoCallback, CameraSource.CAMERA, \"Camera\"); } Wenn der Vorgang am Client abgeschlossen ist, wird die übergebene Callback-Methode aufgerufen. In ihr können die empfangenen Bilddaten weiterverarbeitet werden. Der Callback-Methode wird dafür ein Objekt mit dem Typ IFrameworkPhotoInfo übergeben. public virtual void TakePhotoCallback(IFrameworkPhotoInfo info) { this.Reset(); if (info.HasError) { this.sMessage = info.ErrorMessage; } else if (info.ImageBytes == null) { this.sMessage = \"ImageData is null\"; } else { if (info.Identifier == \"Camera\") { this.sMessage = \"Image from camera\"; } else { this.sMessage = \"Image from gallery\"; } this.binImage = info.ImageBytes; } } Berechtigung für Kamera und SD-Karte Die TakePhoto-Action benötigt auf dem Endgerät Berechtigungen für die Benutzung der Kamera sowie für das Lesen und Schreiben von Daten (Bildern) auf die SD-Karte bzw. den internen Gerätespeicher. Diese Berechtigungen müssen z.B. auf einem Android-Gerät einmalig erteilt werden."
  },
  "doc/html-client/mobile/standort.html": {
    "href": "doc/html-client/mobile/standort.html",
    "title": "Standortbestimmung",
    "keywords": "Standortbestimmung Der Mobile Client unterstützt die Bestimmung des aktuellen Standorts. Abhängig vom Gerät und abhängig davon, ob GPS aktiviert ist, wird entweder der GPS-Sensor angesprochen oder eine Annäherung des Standoprtes über das Mobile Netzwerk angestoßen. Action GetGeoLocation() Der Vorgang wird am Form über die Action GetGeoLocation() gestartet. // Aufruf der Action beim Click eines Buttons protected virtual void FE_btn_OnClick(FrameworkButtonEventArgs e) { this.GetGeoLocation(this.GetGeoLocationCallback, \"Start\"); } Wenn der Vorgang am Client abgeschlossen ist, wird die übergebene Callback-Methode aufgerufen. In ihr können die empfangenen Standortdaten weiterverarbeitet werden. Der Callback-Methode wird dafür ein Objekt mit dem Typ IFrameworkGeoLocationInfo übergeben. public virtual void GetGeoLocationCallback(IFrameworkGeoLocationInfo info) { this.Reset(); if (info.HasError) { this.sError = info.ErrorMessage; } else { if (info.Identifier == \"Start\") { this.sInfo = \"Start location of our journey\"; } else { this.sInfo = \"Destination location of our journey\"; } this.sIdentifier = \"Identifier: \" + info.Identifier; this.sLatitude = \"Latitude: \" + (info.Latitude.HasValue ? info.Latitude.ToString() : \"N/A\"); this.sLongitude = \"Longitude: \" + (info.Longitude.HasValue ? info.Longitude.ToString() : \"N/A\"); this.sAltitude = \"Altitude: \" + (info.Altitude.HasValue ? info.Altitude.ToString() : \"N/A\"); this.sAccuracy = \"Accuracy: \" + (info.Accuracy.HasValue ? info.Accuracy.ToString() : \"N/A\"); this.sHeading = \"Heading: \" + (info.Heading.HasValue ? info.Heading.ToString() : \"N/A\"); this.sSpeed = \"Speed: \" + (info.Speed.HasValue ? info.Speed.ToString() : \"N/A\"); this.sTimestamp = \"Timestamp: \" + (info.Timestamp.HasValue ? info.Timestamp.ToString() : \"N/A\"); } } Note Wie an den Nullable-Typen zu sehen ist, können Abhängig vom Gerät und dessen Sensorik ggf. einzelne Werte der oben gegebenen Auflistung nicht verfügbar sein. Es ist zwingend nötig, vor der Verarbeitung immer auf die Verfügbarkeit der Werte zu prüfen. Berechtigung für die Bestimmung des Standortes Die GetGeoLocation-Action benötigt auf dem Endgerät die Berechtigung zur Bestimmung des Gerätestandortes. Diese muss z.B. auf einem Android-Gerät einmalig erteilt werden."
  },
  "doc/html-client/only-android.include.html": {
    "href": "doc/html-client/only-android.include.html",
    "title": "",
    "keywords": "Note Dieses Feature steht nur in der Android-App zur Verfügung. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser."
  },
  "doc/ide/allgemeine-funktionalitaeten.html": {
    "href": "doc/ide/allgemeine-funktionalitaeten.html",
    "title": "Allgemeine Funktionalitäten",
    "keywords": "Allgemeine Funktionalitäten Buttons Einige der nachfolgend beschriebenen Buttons werden in unterschiedlichen Zusammenhängen angeboten. Die angebotene Funktion des Buttons bezieht sich daher immer auf den Kontext, in dem der Button dargestellt wird. New: Dieser Button erzeugt ein neues Element. Beim Klick auf den Button wird ein Kontext-Menü angezeigt, mit dem Sie auswählen, was für ein Element erzeugt werden soll. Im Detailfenster einer Component zum Beispiel, können Sie mit diesem Button der Component ein neues Property oder eine neue Methode hinzufügen. Auf der Registerkarte Namespaces können Sie mit diesem Button dem im Objekt-Baum (unterer Baum) dargestellten Namespace neue Namespace Elemente hinzufügen, wie zum Beispiel Metadatentypen , Components , Forms . Delete: Das Element im aktuellen Kontext wird mit dem Button Delete gelöscht. Der Löschvorgang wird erst mit betätigen des Buttons Save All wirksam. Wird das ausgewählte Element noch von einem anderen Element benutzt, wird eine Fehlermeldung mit dem entsprechenden Hinweis angezeigt: Mit dem Button Details wird eine Liste aller Verwendungen angezeigt. Derive: Wenn Sie diesen Button betätigen, wird das ausgewählte Element vererbt. Dies funktioniert bei Metadatentypen, Reports, Forms und Workflows. Customize: Im aktiven Package, also in dem Package, an dem Sie sich angemeldet haben, wird von dem ausgewählten Element eine Customization angelegt. Das bedeutet, dass ein Element, das in einem Basis-Package definiert bzw. programmiert wurde, im aktiven Package geändert werden kann. Diese Funktion steht nur dann zur Verfügung, wenn die verwendete Package-Lizenz (PKL) des Ursprungs-Packages Customizing für diesen Elementtyp freigeschaltet ist. Save: Speichert die Änderungen des Elements im aktuellen Kontext ab. Alle Änderungen werden erst beim Save in das Repository zurückgeschrieben. Geänderte, aber noch nicht gespeicherte Elemente werden mit einem Stern nach dem Namen gekennzeichnet. Save All: Alle Änderungen im gesamten Projekt werden über diesen Button gespeichert. Undo Until Last Save: Mit diesem Button nehmen Sie alle Änderungen seit der letzten Speicherung zurück. Source-Control In Framework Studio kann immer nur ein Entwickler an einem Element arbeiten. Dazu muss dieser das zu bearbeitende Element auschecken. Die anderen Entwickler können das Element weiterhin in dem Stand öffnen, wie es war, bevor es ausgecheckt wurde. Wenn alle Änderungen an dem Element durchgeführt wurden, kann es wieder eingecheckt werden. Ab diesem Zeitpunkt werden die Änderungen auch für alle anderen Entwickler sichtbar. Warning Ein Element kann immer nur von einem Entwickler ausgecheckt werden. Für die Bedienung der Source-Control-Funktionalität stehen folgende Buttons zur Verfügung: Check Out: Checkt das Element aus, d.h. sperrt es für Änderungen durch andere Entwickler, damit Sie es bearbeiten können. Ist das Element bereits von einem Entwickler ausgecheckt, bekommen Sie eine entsprechende Fehlermeldung. Check In: Der Button Check In checkt das Element ein. Alle Entwickler sehen ab jetzt das von Ihnen aktualisierte Element. Ein anderer Entwickler kann das Element jetzt erneut auschecken. Undo Check Out: Hiermit machen Sie einen Check Out rückgängig. Dabei werden alle Änderungen, die nach dem Check Out gemacht wurden, verworfen. Bevor diese Funktion ausgeführt wird, werden alle Änderungen an ungespeicherten Elementen gespeichert ( Save All ). Sollte aufgrund von Abhängigkeiten beim Undo Check Out ein Problem auftreten, so startet Framework Studio neu, um weiterhin Datenkonsistenz garantieren zu können. Warning Diese vier Befehle können Sie auch über das Kontext-Menü des Elements aufrufen. Source Control im Kontext-Menü: C#-Code Editor Format Code: Hiermit wird der Code in dem C#-Code Editor formatiert. Compile Compile Options: Der Button Compile Options öffnet ein Kontextmenü, in dem Sie alle Optionen für den nächsten Kompiliervorgang festlegen können. Außerdem können Sie über dieses Kontextmenü einen Kompiliervorgang starten. Ergänzende Informationen erhalten Sie im Abschnitt Code Builder . Applications: Öffnet den Applications–Optionen-Dialog, in dem Sie u.a. einstellen können, in welchem Verzeichnis der IL-Code hinterlegt werden soll und wie sich der Session-Storage verhalten soll. Außerdem werden dort einige grundlegende Einstellungen bezüglich Design und Frameset der jeweiligen Anwendung festgelegt. Ergänzende Informationen können Sie dem Abschnitt Applications entnehmen. References: Der References–Dialog dient dem Einbinden von Assemblies. Wenn Sie weitere Informationen dazu benötigen, lesen Sie bitte den Abschnitt References . Icons Is Not Checked Out: Dieses Icon vor einem Element bedeutet, dass dieses Element bei dem angemeldeten Entwickler eingecheckt ist. Wollen Sie ein Element bearbeiten, müssen Sie es zuvor auschecken. Is Checked Out: Steht dieses Icon vor einem Element, ist das Element bereits von Ihnen ausgecheckt und kann bearbeitet werden. Wenn Sie mit der Bearbeitung fertig sind, können Sie das Element wieder über das Source-Control einchecken. Haben Sie ein Element versehentlich ausgecheckt, können Sie den Checkout-Vorgang mit Undo Checkout rückgängig machen. Warning Sie sollten darauf achten, dass Sie einen kompilierbaren Stand haben,bevor Sie ein Element wieder einchecken. Dazu ist es erforderlich auch in Zusammenhang stehende Elemente einzuchecken. Version History Sowohl über das Kontextmenü eines Objekts im Objektbaum auf der Registerkarte Namespaces als auch über das Hauptmenü können Sie sich unter dem Menüpunkt View/Version History einen Überblick über die einzelnen Entwicklungsstufen eines Objektes verschaffen. Dazu werden von allen bisher eingecheckten Versionen Versionsnummer, Benutzer, Datum, Kommentar und die Information, ob die Version bereits inspiziert wurde, angezeigt. Version History Report: Objekttyp und Name sowie der vollständige Name des Objektes (mit Namespaces) werden im Kopf des Reports angezeigt. Wenn zum Zeitpunkt der Reporterstellung ein Benutzer das Objekt ausgecheckt hat, so wird das mit dem blau gefärbten Kommentar „Checked out.“ unter der neuesten Versionsnummer ebenfalls in der Tabelle dargestellt. Über die Symbole am oberen Fensterrand wird Ihnen die Möglichkeit zum Drucken, Vergrößern, Blättern und Speichern des Reports bereitgestellt. Dieser Report steht Ihnen für alle Access Units, Components, Collections, Control Default Styles, Custom Controls, Datasources, DBTables (Tabellen im Database Editor), Forms, Global Events, Global Objects, Metadatatypes, Namespaces, Report Document Types, Resources and Workflows zur Verfügung. Source Control History Über den Menüpunkt Source Control/History im Hauptmenü von Framework Studio wird ein Report geöffnet, der einen Überblick über alle Check-In und Check-Out Vorgänge innerhalb des aktuellen Labels ermöglicht. Mit diesem Report können Sie sich einen guten Überblick darüber verschaffen, was sich seit einem bestimmten Datum geändert hat, welche Elemente im Moment noch ausgecheckt sind und welche Elemente noch nicht vom FrameworkCompiler kompiliert wurden. Ein Vergleich des generierten Codes mit der Vorgängerversion oder der aktuellen Version ist ebenfalls möglich. Source Control History: Es gibt zwei Modi: Checked In: Es werden nur eingecheckte Elemente ab dem angegebenen Datum angezeigt. Checked Out: Es werden alle im Moment ausgecheckten Elemente angezeigt. Mit dem Button Refresh wird die Tabelle aktualisiert. Durch Anklicken der Spaltenüberschrift kann nach allen Spalten sortiert werden. Die Tabelle kann über die Zwischenablage in andere Programme kopiert werden. Die Druckvorschau und der Druckdialog lassen sich über das Kontextmenü der Tabelle und mit den Buttons Print bzw. Preview öffnen. Besondere Spalten: Date: Ist der Text hellrot hinterlegt, wurde dieses Element noch nicht vom FrameworkCompiler kompiliert (Datum größer als das Datum des letzten „Refresh Workspace“ des FrameworkCompilers). Ist der Text gelb hinterlegt, wurde dieses Element zwar noch nicht vom FrameworkCompiler kompiliert, aber vom Benutzer über Get latest Check Ins im Workspace aktualisiert. Name: Durch anklicken eines Elements in dieser Spalte wird das Element im Designer geöffnet. Version: Durch anklicken einer Version kann der generierte Code des Elements mit der aktuellen Version oder der Vorgängerversion verglichen werden. Dazu öffnet sich nach dem Anklicken ein Dialog, in dem Sie die Vergleichsversion auswählen können. Get latest Check Ins Über den Menüpunkt Source Control/Get latest Check Ins kann ein Dialog aufgerufen werden, über welchen der Benutzer-Workspace bis zu einem bestimmten Zeitpunkt aktualisiert werden kann, ohne dass ein FrameworkCompiler angestoßen werden muss. Der Dialog ist ähnlich der Source Control History aufgebaut. Er zeigt allerdings nur Elemente, die die folgenden zwei Kriterien erfüllen: Sie sind NACH dem letzten Refresh Workspace des Users eingecheckt Sie sind von anderen Usern eingecheckt Anders ausgedrückt zeigt die Liste alle von anderen Usern eingecheckten Elemente, die dem Workspace des aktuellen Users noch nicht bekannt sind. Beispiel: Benutzer demo1 und Benutzer demo2 holen sich nach einem nächtlichen Compilerlauf den FrameworkCompiler-Workspace. demo1 checkt Elemente aus, ändert sie und checkt sie wieder ein. Versucht demo2 diese Elemente nun auszuchecken, wird FS feststellen, dass neuere Versionen der Elemente verfügbar sind, die dem aktuellen Workspace noch unbekannt sind. Diese Elemente werden dann in der Liste von „Get latest Check Ins“ angezeigt (siehe Bild). In der Source Control History werden diese Elemente rot markiert dargestellt, da sie nach dem Compilerlauf eingecheckt wurden und dem aktuellen Workspace von demo2 nicht bekannt sind. Im Dialog hat der Benutzer nun die Möglichkeit, über die Checkboxen auszuwählen, bis zu welchem Zeitpunkt/Element er seinen Workspace updaten will. Nach dem Klick auf Refresh Elements startet sich Framework Studio automatisch neu. Dabei wird der Benutzer-Workspace genau bis zum ausgewählten Zeitpunkt/Element (im Beispiel frmCompany, 04.11.2011 14:20:23) aktualisiert. Die Elemente CompanyName , cdCompany und frmCompany können nun vom Benutzer demo2 ausgecheckt und bearbeitet werden, obwohl noch kein FrameworkCompiler gelaufen ist. In Get latest Check Ins verbleibt nur noch das Element OrderText . In der Source Control History erscheinen die aktualisierten Elemente nun gelb . Important Bei der Auswahl des Zeitpunkts/Elements bis zu dem aktualisiert werden soll, muss auf zusammenhängende Check Ins geachtet werden. Wenn z.B. frmCompany den Metadatentyp OrderText benötigt, dieser jedoch nicht mit aktualisiert wird (wie im Beispiel), kann es anschließend zu Compile-Fehlern kommen, da OrderText im Workspace nicht gefunden werden kann. Alle über Get latest Check Ins aktualisierten Elemente werden nach dem Neustart von Framework Studio automatisch zur Compile-Liste hinzugefügt. Copy Fullname. In allen Editoren gibt es im Menü Edit den Menüpunkt Copy Fullname . Dieser legt den Namen des Elementes inkl. Namespace in die Zwischenablage. So kann dieser z.B. in Dokumentationen eingefügt werden. GoTo Customization Top: Wechsel zur obersten Customization. Customization Up: Wechsel zur nächst höheren Customization. Customization Down: Wechsel zur nächst tieferen Customization. Customization Root: Wechsel zur Definition des Elements, also dem Basiselement, auf das die unterste Customization aufsetzt. Vorwärts- und Rückwärtsnavigation Framework Studio merkt sich bei jedem Verlassen eines Code Editors, über den grundsätzlich Methodencode bearbeitet werden kann, die aktuelle Cursorposition zusammen mit der Information, welche Methode gerade verlassen wird. Dies gilt für Methoden an Forms, Components, Proxies, Services, Service Hosts und in den Get- und Set-Methoden von Individual Properties an Components. Neben den Code-Editoren kann zusätzlich zwischen den LabeldRecords und den Controls des Form-Designers hin und her navigiert werden. Es werden maximal 25 Einträge gespeichert. Wenn ein Eintag eingefügt werden soll und alle 25 Speicherplätze bereits belegt sind, wird zuvor der älteste Eintrag verworfen. Mit dem Menüpunkt View/Navigate Backward (Tastenkombination ALT + Pfeil Links ) kann jeweils zum zuvor gespeicherten Eintrag navigiert werden. Mit dem Menüpunkt View/Navigate Forward (Tastenkombination ALT + Pfeil Rechts ) kann zum jeweils nächsten gespeicherten Eintrag navigiert werden, wenn zuvor rückwarts navigiert wurde. Des Weiteren ist die Navigation über die beiden Navigationstasten an der Seite der Maus möglich. Method History Browser Bei allen Elementen, die Methoden enthalten (z.B. Forms, Components, Services, FSTransformations, …) können Sie im Designer-Fenster mit dem Menüpunkt View / Method History Browser oder über das Kontextmenü im Editor, Methoden in verschiedenen Versionen innerhalb des Packages des Elements vergleichen. Dazu wählen Sie zunächst die Package-Version, anschließend die Element-Version und zuletzt die Methode aus, die betrachtet werden soll. Mit dem Button Compare with current kann diese Version der Methode mit der aktuellen Version verglichen werden. Mit dem Button Compare with previous kann die ausgewählte Version mit der ersten Vorgängerversion verglichen werden, die eine Änderung aufweist. Zum Vergleich wird ein externes Programm verwendet, welches mit dem Menüpunkt Tools / Options im Hauptfenster konfiguriert werden muss. Dort muss auf der Registerkarte Utilities der Pfad zum Werkzeug bei Diff Tool eingetragen werden. Bei Diff Tool Data Dir muss ein Verzeichnis ausgewählt werden, in das temporär die zu vergleichenden Dateien geschrieben werden können. Gut geeignet ist beispielsweise das frei verfügbare Vergleichswerkzeug WinMerge . Element History Browser Im Designer Fenster aller Elemente für die Code generiert wird (Components, Forms, Workflows, …), lässt sich über den Menüpunkt View / Element History Browser analog zum Method History Browser ein Dialog öffnen, mit dem die Historie des Elements im Package des Elements betrachtet werden kann. Der Element History Browser zeigt den generierten Code zu der ausgewählten Version an und ermöglicht über den Button Compare with current einen Vergleich mit der aktuellen Version. Mit dem Button Compare with previous kann mit der direkten Vorgängerversion verglichen werden. Methoden-Wächter Für Form-Methoden, Component-Methoden, ServiceProxy-Methoden, FsTransformation-Methoden, ServiceHost-Methoden, sowie get- und set-Methoden von Individual und DataContract Properties steht ein Methoden-Wächter zur Verfügung. Dieser kann bei überschriebenen Methoden alle Basis-Methoden und deren Änderungsstatus überwachen. Wird bei einem Compile festgestellt, dass sich in einer Basis-Methode etwas geändert hat, wird eine Compiler-Warning ( FSWarn[2029] ) ausgegeben: Methoden-Wächter Warnung: Der Wächter lässt sich über den Button in der Toolbar aktivieren: Aktivierung Methoden-Wächter: Ist der Wächter aktiviert, ändert sich das Symbol des Buttons in ein Refresh-Icon und der Button zum Deaktivieren des Wächters wird aktiv. Refresh- und Disable Buttons: Befinden sich mehrere Packages unter dem aktuellen Package, in dem der Methoden-Wächter aktiviert ist, wird nicht nur die direkte Basis-Methode überwacht, sondern der gesamte Basispfad bis zur virtual -Methode. Werden bei einem Compile Änderungen an einer der Basis-Methoden festgestellt, kann der Methoden-Wächter aktualisiert werden. Damit wird vom Entwickler bestätigt, dass die Änderung in der Basis-Methode keine Auswirkung auf den aktuellen Code hat. Mit dem Aktualisieren des Methoden-Wächters wird auch die Warnung während des Compile-Vorgangs eliminiert. Aktualisierung des Methoden-Wächters: Sollten beim Deaktivieren des Wächters noch nicht bestätigte Änderungen in den Basis-Methoden vorhanden sein, wird zuvor nochmals explizit gewarnt: Warnung beim Deaktivieren:"
  },
  "doc/ide/anwendung-starten.html": {
    "href": "doc/ide/anwendung-starten.html",
    "title": "Anwendung Starten / Fehlersuche",
    "keywords": "Anwendung Starten / Fehlersuche Hintergrundinformationen Application-Broker Das Brokerverzeichnis für den Application-Broker wird mit dem Button Broker Management im Application Dialog erzeugt. Dabei werden die folgenden Dateien in das Verzeichnis kopiert: Alle Ressourcen der Anwendung (z.B. Bilder) Java-Client Framework Studio Laufzeit-Assemblies Assemblies der Applikation (vom Benutzer FrameworkCompiler ) Ein Request des Clients ruft im IIS eine ASP.net Seite auf. Der IIS kopiert dann automatisch alle benötigten Assemblies aus dem Brokerverzeichnis in ein temporäres Verzeichnis und verwendet dann diese temporären Kopien, um den Request zu verarbeiten. Der Vorteil des Kopierens liegt darin, dass die original Assemblies nicht direkt vom IIS verwendet werden und dadurch auch nicht blockiert werden. Auf diese Weise wird gewöhnlich der Echtbetrieb einer Anwendung realisiert. Development-Broker Warning TODO! FSBrokerHost beschreiben Compile-Verzeichnis Beim Kompilieren der Anwendung werden alle Dateien in dieses Verzeichnis geschrieben. Das aktuell verwendete Compile-Verzeichnis kann über den Menüpunkt Compile / Open Compile Directory in Explorer geöffnet werden. Auf einem Rechner wird pro Framework Studio Entwickler, pro Package und pro Package-Version je ein eigenes Compile-Verzeichnis verwendet. Falls das aktuell zu verwendende Verzeichnis beim Start von Framework Studio noch nicht existiert, wird es automatisch angelegt. In den Compile-Verzeichnissen existieren immer die folgenden Unterordner: bin: Enthält alle Assemblies und ggf. Textdateien mit den benutzten Referenzen src: Enthält alle Source Dateien, die von Framework Studio generiert wurden. Durch das Kompilieren dieser Dateien werden die Assemblies der Anwendung (im Verzeichnis bin) erzeugt. Anwendung zum Testen starten Wenn Sie Ihre Anwendung während der Entwicklung zum Testen starten wollen, verwenden Sie dazu den Development-Broker . Dieser wird mit den Menüpunkt Compile / Run (oder mit der Taste F5 ) mit den zuletzt im Run-Wizard vorgenommenen Einstellungen gestartet. Wenn Sie die Einstellungen für den Start der Applikation (z.B. andere Business Datenbank verwenden) ändern möchten, öffnen Sie mit dem Menüpunkt Compile / Run… (oder der Tastenkombination Umschalt + F5 ) den Run-Wizard . Dort können alle Einstellungen vorgenommen werden. Wenn Sie den Wizard anschließend mit Run beenden, wird die ausgewählte Applikation mit den vorgenommenen Einstellungen gestartet. Debugging Die Anwendung kann mit einem beliebigen .NET Debugger (z.B. Visual Studio) debuggt werden. Dazu müssen Sie die für Sie relevanten Teile der Anwendung Debuggable kompiliert haben ( Compile ). Dadurch werden entsprechende .cs- und .pdb-Dateien in das Unterverzeichnis \\src des Compileverzeichnisses ( Compile-Verzeichnis ) geschrieben. Nach dem Start der Anwendung muss der Debugger an den Prozess FSDevBrokerHost.exe angehängt werden (Visual Studio: Menüpunkt Debug / Attach to process ). Gegebenenfalls müssen Sie noch die relevanten .cs-Dateien im Debugger öffnen, um beispielsweise einen Breakpoint setzen zu können. Protokollieren der XML-Kommunikation In manchen Fällen ist es hilfreich, die Kommunikation zwischen Client und Broker zu analysieren. Dazu können sowohl die Anfragen des Clients (Request) als auch die Antworten des Brokers (Response) geloggt werden. Mit dem Menüpunkt Compile / Logging ... öffnen Sie den folgenden Dialog: Im Eingabefeld Directory wird das Verzeichnis angegeben, in das die Protokollierungsdaten geschrieben werden sollen. Das Verzeichnis wird beim Verlassen des Dialogs automatisch angelegt, wenn es noch nicht existiert. Der Benutzer Account, unter dem der IIS (Internet Information Services) läuft, muss Schreibzugriff auf dieses Verzeichnis haben. Es stehen vier Modi zur Auswahl: No Logging: Die Protokollierung ist abgeschaltet (Standardeinstellung) Log only last request and last response: Es werden genau zwei Dateien in das angegebene Verzeichnis geschrieben. In der einen Datei wird jeweils die letzte Anfrage des Clients gespeichert, in der anderen Datei jeweils die letzte Antwort des Brokers. Log each request and response to a unique file: Jede Anfrage des Clients und jede Antwort des Brokers wird in eine eigene Datei (mit Zeitstempel und aufsteigender Nummerierung) in das angegebene Verzeichnis geschrieben. Log each request and response to a unique file, for each token a new folder: Für jede Sitzung wird ein eigener Ordner im angegebenen Verzeichnis angelegt, in dem für jede Anfrage des Clients und für jede Antwort des Brokers eine eigene Datei geschrieben wird. Warning Es werden unter Umständen sehr viele Dateien auf der Festplatte angelegt! Diese müssen manuell wieder gelöscht werden. Die Log-Dateien können mit einem beliebigen XML-Viewer betrachtet werden."
  },
  "doc/ide/application.html": {
    "href": "doc/ide/application.html",
    "title": "Application",
    "keywords": "Application Um Ihre Anwendung erzeugen zu können, müssen Sie zunächst Ihre Anwendung geeignet konfigurieren. Mit einem neuen Repository wird unter dem Namespace FSGeneral > Applications automatisch ein Application-Element angelegt. Dieses kann aus dem Namespace-Tree oder über den Menüeintrag Compile > Application aufgerufen werden. Start Workflow: Hier wird angegeben, welchen Workflow die Applikation starten soll, nachdem sie gestartet wurde. Export: Über dieses Häkchen wird definiert, ob die Application bei einem Package-Export mit exportiert werden soll oder nicht. Registerkarte Broker General Supports Html Client Mit dieser Checkbox kann definiert werden, ob die Application mit dem HTML-Client gestartet werden kann. Ist die Checkbox gesetzt, dann wird in der Broker-Startseite der HTML-Client angeboten. Wird der HTML-Client aktiviert, muss sichergestellt werden, dass alle Fenster, die in der Application vom Benutzer erreicht werden auch vollständig vom HTML-Client unterstützt werden. (Siehe auch HTML-Client ) Disable Form Navigation (HTML Client) Mit dieser Checkbox kann die Form-Navigation im HTML Client deaktiviert werden. Es ist dem User damit nicht mehr möglich, zwischen Forms zu wechseln. Der Applikations-Workflow muss entsprechend vom Entwickler vorgegeben werden. Service Name Name des Services unter dem der Broker erreichbar ist. Service Address Wenn Sie in der Checkbox Service Address einen Haken setzen, können Sie im dazu gehörigen Textfeld manuell die Adresse angeben, über welche die Applikation zu erreichen ist. Directory Hier wird das Web-Verzeichnis angegeben, in welches die vom Broker benötigten Dateien kopiert werden sollen. Über den Button haben Sie auch die Möglichkeit, das Verzeichnis über einen Auswahldialog zu suchen. Configuration Hier kann die Applikation manuell erweitert werden. Registerkarte Design Auf dieser Registerkarte werden allgemeine Design-Einstellungen für die Anwendung vorgenommen. Beispiele dafür sind: Start- und Hintergrundbild Größe auf dem Bildschirm Icon der Anwendung Unterstützung von Transparenz Standardfarben (z.B. Hintergrundfarbe der Menüs) Anwendungstitel DockLayoutXml Dieses XML ist das initiale Layout für das Docking-Framework des Java-Clients. Beendet ein Benutzer den Java-Client, speichert sich dieser das aktuelle Layout auf dem Client-Rechner. Beim nächsten Programm-Start liest er es wieder ein. Ist kein Layout gespeichert – z.B. beim ersten Start der Anwendung oder nach dem Zurücksetzen des Layouts durch den Benutzer – dann zieht diese Einstellung aus der Application. Das XML muss durch den Java-Client erzeugt und darf nicht von Hand bearbeitet werden. Mit den folgenden Schritten können Sie das XML aktualisieren: Am Client-Rechner das Layout der Anwendung zurücksetzen. Wenn die Anwendung keinen Befehl dafür kennt, dann im Ordner %USERPROFILE%\\FSJavaClient\\ den entsprechenden Ordner löschen. Die Anwendung neu starten. Alle Fenster wie gewünscht anordnen. Dabei können auch Fenster aus dem Arbeitsbereich in einen Docking-Bereich platziert werden. Es sollten ausschließlich die notwendigen Fenster angeordnet werden, um unnötige Informationen zu verhindern. Achten Sie darauf, dass sich die gewünschten Fenster im Vordergrund befinden. Beenden Sie die Anwendung. Das Layout wird jetzt vom Client gespeichert. Es befindet sich im entsprechenden Ordner unter %USERPROFILE%\\FSJavaClient\\ Öffnen Sie die Datei docking.xml mit einem Editor und fügen Sie deren Inhalt in das Property DockLayoutXml ein. Registerkarte Frameset Wenn in der Checkbox Use General Frame Set ein Haken gesetzt ist, wird ein Standard-Frameset verwendet. Dieses Standard-Frameset können Sie mit dem Button General Frame Set modifizieren. Wenn in der Checkbox Use General Frame Set kein Haken gesetzt ist, können Sie ein eigenes Frame Set im Textfeld Frame Set definieren. In der Combobox legen Sie den Frame fest, in dem Formulare standardmäßig geöffnet werden, wenn für ein solches nicht explizit angegeben wird, in welchem Frame es geöffnet werden soll. Registerkarte Authentication Wenn die Benutzer der Anwendung authentifiziert werden sollen, können Sie auf dieser Registerkarte das Authentifizierungssystem von Framework Studio aktivieren und die nötigen Einstellungen vornehmen. Zum Aktivieren der Authentifizierung muss in der Checkbox Enable Authentication ein Haken gesetzt werden. Im Bereich Default Login wird der Standardbenutzer angegeben, der automatisch von der Anwendung am Authentifizierungsdienst angemeldet wird, bis sich der Benutzer mit eigenem Namen und Passwort angemeldet hat. Programmbereiche, die diesem Default-Benutzer zur Verfügung gestellt werden, können also von allen noch nicht an der Anwendung angemeldeten Benutzern eingesehen werden. Dazu muss insbesondere das Login-Fenster gehören. Default User Name Name des Standardbenutzers Default User Password Passwort des Standardbenutzers Im Bereich Application Identity werden Eigenschaften festgelegt, mit denen sich die Anwendung am Authentifizierungsdienst (als Service) anmeldet. Service Name Unter diesem Namen wird die Anwendung im Authentifizierungsdienst angezeigt. Service ID Über diese Nummer (vom Typ Guid ) wird die Anwendung eindeutig identifiziert. Wenn diese Nummer geändert wird, betrachtet der Authentifizierungsdienst diese Anwendung als eine andere Anwendung, auch wenn der Name identisch ist. Mit dem Button New Guid kann automatisch eine neue, eindeutige ID generiert werden. Warning Wenn Benutzern Rollen für eine Anwendung zugeordnet wurden und anschließend die Anwendung eine neue ID bekommt und somit als eine andere Anwendung am Authentifizierungsdienst erkannt wird, dann gelten die Rollen der Benutzer nicht für die Anwendung mit der neuen ID! Service Description In diesem Feld können Sie eine Beschreibung der Anwendung angeben. Diese Beschreibung wird im Verwaltungswerkzeug für den Authentifizierungsdienst angezeigt."
  },
  "doc/ide/bearbeiten-von-elementen.html": {
    "href": "doc/ide/bearbeiten-von-elementen.html",
    "title": "Bearbeiten von Elementen",
    "keywords": "Bearbeiten von Elementen Die Elemente, die in Framework Studio bearbeitet werden können, werden alle auf der Registerkarte Namespaces verwaltet. Es folgt eine Übersicht der Elemente im Framework Studio: Namespace Namespaces bilden eine Ordnerstruktur, in der alle anderen Elemente geordnet abgelegt werden. Ein Namespace kann auch wiederum andere Namespaces beinhalten. Resource Eine Ressource stellt eine beliebige Datei dar, die beim Kompilieren in das Brokerverzeichnis kopiert wird. Dadurch kann die Anwendung diese Datei (z.B. ein Bild oder eine externe DLL) verwenden. ( Resources ) Access Unit Über Access Units wird die Anwendung in einzelne Bereiche eingeteilt. Diese Bereiche können dann durch Laufzeitlizenzen und abhängig von den Rollen eines Benutzers gesperrt werden. ( Access Units , Laufzeitlizenzen )) Metadatentype Ein Metadatentyp ist ein erweiterter Datentyp, der mehr Informationen enthält als ein normaler Datentyp unter .NET. Weitere Informationen sind z.B. Labels, Format und Controls. ( Metadatentypen ) Datasource Ein Datasource definiert eine Datenbankverbindung, die von der Anwendung zum Lesen und Schreiben der Anwendungsdaten benutzt werden kann. ( Datasource ) DBTable Ein DBTable ermöglicht Komponenten den Zugriff auf eine Datenbanktabelle, die über einen Datasource angesprochen werden kann. ( DBTable ) Code File Ein Code File ermöglicht individuellen Code zu definieren. ( CodeFile ) Component / Collection / Textcollection Eine Component ist eine funktionale Klasse, die bereits Grundfunktionalitäten wie das Lesen und Schreiben von Daten in eine Datenbank beherrscht. Eine Textcollection ist eine Sammlung von mehrsprachigen Texten. ( Component / Collections , Textcollections ) Report Document Type Hier werden ausdruckbare Reports und deren Schnittstelle definiert. ( Report Document Type ) Custom Control Durch Custom Controls ermöglicht Framework Studio das Hinzufügen von eigenen, spezialisierten Controls, die nicht zu den Standard-Controls gehören. ( Custom Controls ) Form Forms dienen der Visualisierung der Daten am Bildschirm. Sie enthalten Controls, welche die Daten anzeigen und bearbeiten können. ( Form ) Global Event Global Events dienen dazu, anwendungsweit Nachrichten zu senden. ( Global Events ) Workflow In Workflows wird die Kommunikation zwischen den Forms und dem Arbeitsablauf des Anwenders definiert. Workflows können Forms, Global Events, Links, Branches, Switches und andere Workflows enthalten. ( Workflow Designer ) Data Contract Data Contracts definieren komplexe Datenstrukturen für Service-Schnittstellen. ( Data Contract ) Service Contract Service Contracts legen fest, welche Operationen ein Service beinhaltet.( Service Contract ) Service Implementiert die im Service Contract definierten Operationen. ( Service ) Service Host Legt Endpunkte und Übertragungsparameter für den Service fest. ( Service Host Properties ) Service Proxy Kapselt einen Service Host nach außen. ( Service Proxy ) Transformation Transformationen werden genutzt, um einen Eingangsdatentyp in einen Ausgangsdatentyp umzuwandeln. Häufig wird dies in Bezug auf Data Contracts verwendet. ( Transformation ) Elemente erstellen Ein neues Element lässt sich erstellen, indem Sie auf der Registerkarte Namespaces den Namespace auswählen, in dem das Element abgelegt werden soll. Mit dem Button der Registerkarte Namespaces oder dem entsprechenden Eintrag aus dem Menü wird im markierten Namespace ein neues Element angelegt. Es wird auch gleich im Hauptfenster geöffnet. Direkt nach dem Anlegen des Elements steht der Cursor in dem sich öffnenden Designer-Fenster auf dem Feld Name . Geben Sie hier den Namen des neuen Elements ein. Der Name lässt sich auch nachträglich noch ändern. Dazu öffnen Sie das Element und ändern die Bezeichnung im Feld Name oder wählen Sie aus dem Kontext-Menü des Elements auf der Registerkarte Namespaces den Eintrag aus. Warning Wird das Element bereits verwendet, kann es zu Problemen kommen, da nicht an allen Stellen der Name automatisch nachgezogen werden kann. Es empfiehlt sich, die Namen folgendermaßen zu vergeben: Namespace: XxxXxx Metadatentyp: mdt XxxXxx oder XxxXxx Component, die eine Datenbank-Tabelle anbietet: cd XxxXxx Andere Components: c XxxXxx Collections: cd XxxXxx Coll bzw. c XxxXxx Coll Textcollections: ct XxxXxx ReportDocumentTypes: rpt XxxXxx Form: frm XxxXxx Global Event: gev XxxXxx Workflow: wfl XxxXxx Elemente bearbeiten Um ein Element zu bearbeiten, öffnen Sie es mit einem Doppelklick auf der Registerkarte Namespace . Im Hauptteil von Framework Studio öffnet sich dann ein Desginer-Fenster für das ausgewählte Element. Dort können die gewünschten Änderungen vorgenommen werden. Mit dem Button Save werden die Änderungen gespeichert. Warning Namespaces können nicht geöffnet werden. Mit einem Doppelklick wird der Namespace auf- oder zugeklappt. Elemente löschen Löschen können Sie ein Element mit dem Menüeintrag File / Delete … . Dazu wird das gewünschte Element im Objekt-Baum markiert. Diese Funktion können Sie auch über das Kontext-Menü eines Elements im Objekt-Baum nutzen. Der Löschvorgang wird erst wirksam, wenn Sie den Button (Save All) drücken. Warning Durch das Speichern eines gelöschten Elements wird im Hintergrund automatisch ein CheckIn durchgeführt. Es werden auch alle Änderungen an anderen, geöffneten Elementen gespeichert. Elemente kopieren / einfügen Es ist möglich, verschiedene Elemente zu kopieren oder auch zusammenzuführen (mergen). Das funktioniert auch, wenn es sich bei Quelle und Ziel um unterschiedliche Repositories handelt. Folgende Elemente können kopiert und gegebenfalls zusammengeführt werden: MDT ServiceHost 1 Workflow Resource DBTable Service Proxy 2 DataContract Namespace 1 Collection Report ServiceContract Component TextCollection GlobalEvent 1 Service 2 Form Warning 1 Element kann nicht gemerged werden. 2 Ableitung des Elements kann weder kopiert noch gemerged werden. Allgemein Copy Über das Kontextmenü eines Elements, über den Menüpunkt Copy im Edit -Menü oder über die Copy & Paste Buttons kann ein Element kopiert werden. Paste Wird ein Element ohne Basis und ohne ID kopiert, kann es überall eingefügt werden. Wird ein Element mit ID kopiert, kann dies nur eingefügt werden, wenn ein Element mit derselben ID noch nicht existiert. Eine Customization kann nur erstellt werden, wenn im Package noch keine Customization vorhanden ist und die passende Basis existiert. Grundsätzlich wird zwischen zwei verschiedenen Arten unterschieden, um ein Element einzufügen: Element am Namespace eingefügt: Über das KontextMenü am Namespace kann das kopierte Element in den Namespace eingefügt werden. Dabei wird ein neues Element erstellt. Falls ein Element mit derselben ID bereits existiert wird über ein Dialog vorgeschlagen das kopierte Element in das bestehende Element einzufügen. Element in ein bestehendes Element des gleichen Typs einfügen: Über das Kontextmenü eines Elements oder über den Menüpunkt Paste im Edit-Menü kann das kopierte Element in ein bestehendes Element desselben Typs eingefügt werden. Dieser Vorgang stand in älteren Versionen schon unter Merge bei Components zur Verfügung. Dialog zum Zusammenfügen von Elementen mit gleicher ID: Kompatibilität Elemente bei denen Copy & Paste bereits vorhanden war (Components, Forms) können zwischen der alten und neuen Version kopiert werden. Das Kopieren mit ID wird jedoch erst ab FS 3.11 unterstützt. Paste Dialog Allgemein Über den Paste Dialog kann beim Kopieren in ein bestehendes Element ausgewählt werden, welche Unterelemente wie kopiert werden. Zu beachten ist, dass der Paste Dialog sehr viele Freiheiten bietet. Dies ermöglicht natürlich auch fehlerhafte Stände zu erstellen. Dieser Mechanismus ist für versierte Benutzer konzipiert. Grundsätzlich sollte der Benutzer wissen, was er tut und VOR der Aktion sicherstellen, dass alle benötigten Elemente am Ziel vorhanden sind. Die zu kopierenden Unterelemente sind in Gruppen auf verschiedene Registerkarten aufgeteilt. Jeder Paste Dialog enthält eine Summary und die NeededTypes . Im obersten Bereich des Paste-Dialogs werden der Type und der Pfad des kopierten Elements angezeigt. Der Pfad des kopierten Elements ist nur für Elemente sichtbar, die aus einer Version ≥ FS 3.11 kopiert wurden. Angaben zum kopierten Element: Registerkarte Summary Die erste Registerkarte beinhaltet immer die Summary. Diese zeigt, ob beim Paste oder Merge Konflikte auftreten. Framework Studio versucht grundsätzlich bei der Aktion die benötigten Elemente im Ziel-Package auf folgenden Wegen zu finden: Über die interne ID: Das funktioniert meist dann, wenn Quell- und Ziel-Package identisch sind oder wenn Elemente aus einem gemeinsamen Basis-Package verwendet werden. Über den Namen: Wenn über die ID nichts gefunden wird, wird nach einem gleichnamigen Element (z.B. Metadatentyp, Component, Property) gesucht. Das ist vor allem dann sehr nützlich, wenn nach und nach mehrere Elemente in ein anderes Package kopiert werden. Wenn diese Wege nicht zum Ziel führen, wird dies als Konflikt betrachtet und der Benutzer muss nach einer Lösung suchen. Teilweise kann das auf den restlichen Registerkarten erfolgen. Manchmal ist es aber auch nötig, die Aktion abzubrechen, erst die Voraussetzungen zu schaffen (z.B. eine DBTable anlegen) und die Aktion anschließend noch einmal auszuführen. Für einige Elemente gelten Sonderregeln für das Kopieren und Zusammenfinden von Elementen. Diese sind dem Kapitel ( Kopieren von IDs ) zu entnehmen. Über verschiedene Buttons kann ausgewählt werden, welche Unterelemente der Registerkarte selektiert und beim Einfügen berücksichtigt werden. Select all: Alle Unterelemente werden selektiert. Select none: Alle Unterelemente werden deselektiert. Select new: Es werden nur neu hinzugefügte Unterelemente selektiert. Beim Einfügen eines Elements am Namespace kann außerdem ausgewählt werden, ob die ID des Elements kopiert werden soll. Note Die Registerkarte Summary zeigt die initialen Merge Actions (Replace oder Insert) der Elemente an. Zu beachten ist, dass diese Übersicht nicht aktualisiert wird, wenn bspw. die Merge Action an einem Element geändert wurde. Registerkarte NeededTypes Bei den Needed Types werden alle Typen aufgelistet, die nicht zum Standard gehören. Diese können beliebig ausgetauscht werden. Das kann z.B. dann sinnvoll sein, wenn ein benötigtes Element vorher auch schon kopiert wurde und jetzt ggf. unter einem anderen Namen in einem anderen Namespace zu finden ist. Zusammenführen von Elementen Mit einem Merge kann erreicht werden, dass Änderungen in einer Kopie nachgezogen werden. Was nicht möglich ist, sind gelöschte Elemente durch den Merge zu entfernen. Es werden nur neu hinzugekommene oder geänderte beachtet. Beim Kopieren in ein bestehendes Element werden zusätzlich alle zu kopierenden Unterelemente gruppiert und in verschiedenen Registerkarten dargestellt. Die Unterelemente sind wiederum nach MergeAction und Name sortiert. Für jedes Unterelement kann separat entschieden werden, ob und wie es im Ziel eingefügt wird. Unterelemente: Unterelemente können einzelne Werte oder komplexere Elemente wie Methoden oder Properties darstellen. Alle Elemente werden gruppiert und in verschiedenen Registerkarten dargestellt. Die einzelnen Elemente können aus einer Liste ausgewählt werden. Für jedes Element kann separat entschieden werden, ob und wie es gemerged wird. Elemente, die im Ziel noch nicht vorhanden sind (Insert) werden in der Liste Grün dargestellt. Merge Action: Es stehen verschiedene Merge-Operationen zur Verfügung: Insert Das Element wird im Ziel neu eingefügt Der Eintrag wird in der Liste Grün dargestellt Replace Unter Target kann das Element, das im Ziel ersetzt werden soll, ausgewählt werden Replace with Das ausgewählte Source -Element ersetzt das „Target“-Element Target: Dieses Element wird beim Mergen ersetzt Source: Das Source -Element ersetzt das „Target“-Element beim Merge Merge Info: Bietet Informationen über das Merge Element z.B. die Art der Übereinstimmung im Ziel Kopieren von IDs Um Parallelentwicklungen zu realisieren, ohne dass die internen IDs von Elementen in verschiedenen Versionen auseinanderlaufen, besteht nun die Möglichkeit die ID von Elementen zu kopieren. In der obersten Leiste des Paste Dialogs ist farblich gekennzeichnet, ob die IDs kopiert oder neu angelegt werden (siehe Bilder). Kopieren von IDs Aktiv: Kopieren von IDs Inaktiv: Für das Kopieren von IDs gelten folgende Regeln: Wenn das zu kopierende Element am Namespace eingefügt wird und aus demselben Package aber unterschiedlicher Version stammt, ist das Kopieren der IDs optional. Beim Zusammenführen von Elementen im selben Package aber unterschiedlicher Version wird die ID automatisch kopiert, wenn die IDs der beiden Elemente übereinstimmen, ansonsten nicht. Wenn das zu kopierende Element aus einem anderen Package stammt, ist das Kopieren der IDs nicht möglich. Kopieren von Unterelementen Es ist möglich Methoden, Controls, Form- und Component-Properties zu kopieren. Methoden können unabhängig von dem Parent-Element eingefügt werden. Die ID wird bei Unterelementen nur dann übernommen, wenn in demselben Package aber unterschiedlichen Versionen kopiert wird und die ID der Parent-Elemente übereinstimmt. Elemente aus einer älteren Version werden nicht mit ID kopiert. Beim Einfügen von Unterelementen in ein anderes Parent-Element wird der Paste-Dialog angezeigt. Beim Einfügen von Unterelementen aus einer älteren Version wird der Dialog nicht angezeigt. Sonderfälle Es gibt Ausnahmen oder Sonderfälle beim Kopieren oder Mergen, die nachfolgend aufgelistet sind: Metadatentype Merge von Indices Falls die ID oder der Name identisch sind, wird ein Replace angeboten. Falls die ID und der Name nicht übereinstimmen, aber dieselbe Konstellation von Spalten im Ziel enthalten ist und ASC/DSC identisch sind, wird ebenfalls ein Replace angeboten. In allen anderen Fällen wird ein Insert angeboten. TextCollection Merge von TextEntries Wenn der PK identisch ist, wird ein Replace vorgeschlagen. Wenn die ID´s oder die Namen identisch sind, aber der PK abweicht, wird ein Replace mit entsprechender Warning angezeigt. Beim Mergen werden ID und Namen als Felder zum Bearbeiten angeboten. Texte, die nicht bekannt sind (ISO nicht bekannt), werden nicht gemerged. Service Elemente Ableitungen von Service Elementen können weder kopiert noch gemerged werden. Report Data Source Die angehakten Checkboxen von DataSources werden beim Kopieren von Ableitungen oder Customizations nicht mit kopiert. Die angehakten Checkboxen von DataSources werden beim Merge nicht berücksichtigt. GlobalEvent Das GlobalEvent kann nicht gemerged werden. Workflow Merge Allgemein Die Position oder Größe eines Elements wird beim Mergen nicht berücksichtigt. Wenn der Name oder die ID eines Elements identisch ist, wird, falls sich eine Eigenschaft geändert hat, ein Replace angeboten. Ein Merge-Konflikt wird angezeigt, wenn: Switch das Event (Name oder ID) nicht identisch sind Branch die Condition abweicht Link eine Eigenschaft des Links geändert wurde Form ISModal , ISEntranceInstance oder IsStartInstance geändert wurde Workflow IsEntranceInstance geändert wurde Resource Ressources können nicht gemerged werden Namespaces Namespaces können nicht gemerged werden Namespace References werden nicht kopiert"
  },
  "doc/ide/code-builder.html": {
    "href": "doc/ide/code-builder.html",
    "title": "Code Builder",
    "keywords": "Code Builder Das Menü, mit dem Sie zum einen die Optionen zur Codegenerierung und zum Kompilieren festlegen, und zum anderen einen Kompiliervorgang starten können, wird über den Button Compile Options geöffnet. In diesem Fenster sehen Sie in der Zeile, beginnend mit Active Application , welche Applikation ausgewählt ist. Für diese Applikation werden dann durch das Starten des Kompiliervorgangs die Dynamic Link Librarys (DLLs) erzeugt. Mit den unten aufgeführten Checkboxen ( ) legen Sie fest, für welche Elementtypen der generierte Code neu kompiliert werden soll. Es ist nicht immer notwendig und wird aus Zeitgründen auch nicht empfohlen, alle Elemente in einem Namespace zu kompilieren. Stattdessen sollten Sie nur die Elemente kompilieren, an denen Sie auch tatsächlich Änderungen vorgenommen haben. Optionen beim Kompilieren Um einen Kompiliervorgang zu starten, stehen Ihnen mehrere Möglichkeiten zur Auswahl: Compile Namespace Der Code für den im Objekt-Baum dargestellten Namespace wird generiert. Danach werden die Dlls erzeugt und in das Compile-Verzeichnis ( Compile-Verzeichnis ) geschrieben. Die darunter liegenden Namespaces werden nicht berücksichtigt. Compile Namespace Recursively Auch die untergeordneten Namespaces werden in den Kompiliervorgang mit eingebunden. Über die Tastenkombination [Strg]+[Shift]+[B] können Sie aus Framework Studio direkt einen Kompiliervorgang für den Elementtyp des aktuell geöffneten Elements anstoßen, ohne vorher das Menü Compile Options öffnen zu müssen. Checkboxen Checkbox Resources Wählen Sie Resources , um alle Ressourcen neu ins Brokerverzeichnis zu kopieren. Checkbox Access Units Wählen Sie Access Units , wenn Sie neue Access Units (z.B. durch Hinzufügen eines neuen Forms) hinzugefügt haben und diese im Code ansprechen wollen. Warning Wenn Sie für die Anwendung keine Developer-Lizenz verwenden und neue Access Units hinzugekommen sind oder die Hierarchie geändert wurde, müssen Access Units mit dem Benutzer FrameworkCompiler recursive from root kompiliert werden. Checkbox Metadatatypes Wählen Sie Metadatatypes , um die Metadatentypen in einem Namespace zu kompilieren. Checkbox DBTables Wählen Sie DBTables , wenn Sie Änderungen an den DB-Tables vorgenommen haben. Checkbox Interfaces Wählen Sie Interfaces , wenn Sie Änderungen an Komponenten vorgenommen haben, welche die Methodendefinitionen, Methodenparameter oder Properties betreffen. Warning Der Sinn von Interfaces liegt darin, zirkulare Referenzen zu vermeiden. Die Interfaces werden daher grundsätzlich über alle Namespaces hinweg kompiliert. Checkbox Components Wählen Sie Components , wenn Sie Änderungen an den Komponenten vorgenommen haben, welche Methodendefinitionen, Methodenparameter, Properties oder Codes innerhalb von Methoden betreffen. Checkbox Global Objects Wählen Sie Global Objects , wenn Sie Änderungen an diesen vorgenommen haben und wenn Sie neue Komponenten angelegt haben. Checkbox Report Document Types Wählen Sie Report Document Types , wenn Sie Änderungen an diesen vorgenommen haben. Checkbox Custom Controls Wählen Sie Custom Controls , wenn Sie Änderungen an diesen vorgenommen haben. Checkbox Forms Wählen Sie Forms , wenn Sie Änderungen an den Forms vorgenommen haben. Checkbox Workflows Wählen Sie Workflows , wenn Sie diese geändert haben. Mit dem Button wählen Sie alle genannten Elemente aus, mit keines. Mit den darunter angeordneten Checkboxen legen Sie weitere Optionen zur Codeerzeugung und zum Kompilieren fest. Checkbox Use Saved Code Um die Codegenerierung zu beschleunigen, besteht die Möglichkeit, Framework Studio anzuweisen, auf bereits generierten und im Repository hinterlegten Code (sogenannten Saved Code) zurückzugreifen. Das hat den Vorteil, dass nicht der gesamte Code vor dem Kompilieren neu generiert werden muss, sondern lediglich die Teile, welche sich geändert haben. Falls es dabei allerdings zu Problemen kommt, können Sie Framework Studio anweisen, den Code komplett neu zu generieren. Checkbox Debuggable Um den erzeugten Code zur Laufzeit mit Microsoft Visual Studio bereinigen zu können, aktivieren Sie die Option Debugable . Das führt dazu, dass im Applikations-Verzeichnis, zusätzlich zu den Dynamic Link Librarys (DLL) auch noch Programmdatenbankendateien und Quellcodedateien (.cs) von den einzelnen Namespaces erzeugt werden. Diese können mit Visual Studio geöffnet werden."
  },
  "doc/ide/compile-menu.html": {
    "href": "doc/ide/compile-menu.html",
    "title": "Compile Menü",
    "keywords": "Compile Menü In den folgenden Abschnitten werden die Menüpunkte im Menü Tools beschrieben. Compile Manager Wenn viele Namespaces kompiliert werden sollen und der Kompiliervorgang durch einen Fehler unterbrochen wird, kann mit dem Compile Manager der Kompiliervorgang fortgesetzt werden. In Verbindung mit dem FCUser ist das vor allem bei Update-Szenarien sehr vorteilhaft. Mit den Buttons in der Gruppe Add Namespaces to List werden die zu kompilierenden Elemente typweise in die Liste übernommen. In der Liste auf der rechten Seite werden alle Namespaces gesammelt. Beim Erstellen der Liste wird nicht geprüft, ob ein Namespace auch tatsächlich Elemente eines bestimmten Typs (z.B. Forms) beinhaltet. Es landen immer alle existierenden Namespaces in der Liste. Diese Liste versteht sich als eine Aufgabenliste, die durch kompilieren abzuarbeiten ist. Das Abarbeiten kann auf 2 Arten erfolgen: Der Button Compile in diesem Fenster. Es öffnet sich ein ganz normales Compile-Fenster, das wie z.B. beim Compile-CheckedOut die entsprechenden Namespaces kompiliert. Durch einen herkömmlichen Kompiliervorgang (über das Namespace-Registerkarte, aus einem Element heraus und auch Compile Checked Out). Ganz gleich, von wo aus der Compile gestartet wird, immer wenn ein Namespace erfolgreich kompiliert wurde, wird dieser aus der Liste entfernt. Mit dem Button Save kann die aktuelle Liste in eine Datei gespeichert werden. Die Datei wird in das Compile-Directory geschrieben. Mit dem Button Load kann diese Liste wieder aus einer Datei eingelesen werden. Das ist nützlich, wenn Framework Studio zwischendurch verlassen werden muss. So kann nach dem Neustart dort weitergemacht werden, wo zuletzt aufgehört wurde. Mit dem Button Complete FrameworkCompiler wird der FrameworkCompiler-Vorgang abgeschlossen. Dieser Button wird nur angezeigt, wenn ein FCUser oder der FrameworkCompiler angemeldet ist. Folgende Aktionen werden ausgeführt: Prüfen, ob etwas ausgecheckt ist. Für diese Aktion muss alles eingecheckt sein. Refresh des FrameworkCompiler-Workspaces (nur wenn man als FCUser angemeldet ist). Beim Arbeiten mit dem FCUser können Elemente aus- und eingecheckt werden. Die SavedCodes und Assemblies wurden generiert und jetzt muss noch der Workspace vom FrameworkCompiler aktualisiert werden, damit dieser wieder zu den generierten Informationen passt. Das ist notwendig, wenn das Package exportiert werden soll oder anschließend andere User beim Refresh des eigenen Workspaces den vom FrameworkCompiler verwenden ( FrameworkCompiler Version and checked out im Login-Dialog). Aktualisieren des Compile-Stamps. Das beinhaltet die Information, dass der FrameworkCompiler erfolgreich gelaufen ist und sorgt dafür, dass die rote Kennzeichnung im Package-Manager verschwindet. Beim normalen Kompilieren in FrameworkStudio wird das nicht durchgeführt, weil dieser Stempel sicherstellen soll, dass ALLES kompiliert wurde. Warning Diese Aktion sollte nur dann ausgeführt werden, wenn sichergestellt ist, dass auch wirklich alles kompiliert wurde. Complete FrameworkCompiler mit FCUser Sind Sie als FCUser bzw. als User mit aktiviertem FrameworkCompiler-Mode angemeldet, beendet sich FrameworkStudio automatisch, nachdem Sie den FrameworkCompiler-Vorgang (\"Complete FrameworkCompiler\") abgeschlossen haben. Der FCUser ist so definiert, dass vor dem Schließen FrameworkStudios ein Complete FrameworkCompiler durchgeführt werden sollte. Schließen Sie FrameworkStudio normal, wird Ihnen deshalb folgende Meldung angezeigt: Dies soll Sie darauf hinweisen, dass der FrameworkCompiler-Vorgang entgegen unserer Definition nicht abgeschlossen wurde. Compile Checked Out Mit dem Menüeintrag Compile Checked Out werden alle vom Benutzer ausgecheckten Elemente kompiliert. Falls nötig, werden weitere Elemente kompiliert. Das betrifft insbesondere die folgenden Fälle: Wenn mindestens eine Component ausgecheckt ist, werden auch Interfaces und GlobalObjects kompiliert. Wenn mindestens ein Form ausgecheckt ist, werden auch Access Units mit kompiliert. Diese Funktion verwendet im Hintergrund den Compile Manager . Wenn beim Kompilieren ein Fehler auftritt, dann kann der Kompiliervorgang im Compile-Manager fortgesetzt werden. Compile Changes Es werden alle geänderten Elemente kompiliert. Run Mit dem Menüeintrag Run werden die Testumgebung ( Start / Stop current development FSDomain ) und ein Client für die Applikation gestartet. Es werden dazu die zuletzt im Run-Wizard vorgenommenen Einstellungen verwendet. Mit dem Menüeintrag Run… wird zunächst der Run-Wizard gestartet und anschließend die Testumgebung mit Client für die Applikation gestartet. Run Without Compile Mit dem Menüeintrag werden die Testumgebung (Start / Stop current development FSDomain) und ein Client für die Applikation gestartet. Es werden dazu die zuletzt im Run-Wizard vorgenommenen Einstellungen verwendet. Sollten sich seit dem letzten Compile Elemente geändert haben, werden diese zuvor nicht kompiliert. Run Wizard… Siehe hierzu Run Wizard Start / Stop current development FSDomain Mit dem Menüeintrag Start current development FSDomain starten Sie alle im Run-Wizard konfigurierten Dienste (Service Hosts) und den Development Broker ( Development-Broker ). Mit dem Menüeintrag Stop development FSDomain wird der Development Broker beendet. Open Client Start Page Zunächst werden die Elemente, welche sich geändert haben und kompiliert werden müssen, kompiliert. Anschließend öffnet sich die Client Start Page im Browser. Es wird die Start Page angezeigt, über die Sie Application starten können. Development Service Host Options Mit dem Menüpunkt Development Service Host Options können die folgenden beiden Schalter gesetzt werden: Compile forces stop of Development Broker Service Host: Ist diese Option mit einem Häkchen versehen, wird der Development-Broker automatisch beendet, wenn in Framework Studio ein Kompiliervorgang gestartet wird. Andernfalls werden Sie beim Start eines Kompiliervorgangs gefragt, ob der laufende Development-Broker beendet werden soll. Die Beendung des Development-Brokers ist nötig, um kompilieren zu können. Der Schalter ist im Standard gesetzt. Autostop of Development Broker Service Host after run of application: Ist diese Option mit einem Häkchen versehen, wird der Development-Broker automatisch beendet, wenn die Testapplikation geschlossen wird. Logging Mit dem Menüpunkt Logging wird ein Dialog geöffnet, in dem alle Einstellungen zur Protokollierung der Xml Kommunikation zwischen Client und Broker vorgenommen werden. Siehe Protokollieren der XML-Kommunikation AutoCompile Report Dieser Menüpunkt gibt im Output Fenster einen Callstack über die zuletzt hinzugefügten Elemente zum Compile for Run aus. Open Compile Directory In Explorer Mit dem Menüpunkt Open Compile Directory In Explorer wird das Kompilierverzeichnis ( Compile-Verzeichnis ) im Windows Explorer geöffnet. Open Development Broker Directory In Explorer Mit dem Menüpunkt Open Development Broker Directory In Explorer wird das im IIS freigegebene Verzeichnis des Development-Brokers ( Development-Broker ) im Windows Explorer geöffnet. Open User Directory In Explorer Mit dem Menüpunkt Open User Directory In Explorer wird das Verzeichnis im Windows Explorer geöffnet, in dem Framework Studio benutzerbezogene Daten ablegt. Dazu gehören verschiedene Konfigurationsdateien sowie ggf. Trace- und Log-Dateien. Application… Siehe hierzu Application Get Dlls Mit diesem Menüpunkt können die Dlls vom FrameworkCompiler in das eigene Compile-Verzeichnis geschrieben werden. Beachten Sie, dass ausgecheckte Elemente anschließend kompiliert werden müssen. Des Weiteren besteht die Option alle Änderungen zu kompilieren. Ist eben diese Compile Changes -Option aktiviert, können zudem alle, keine oder nur bestimmte Compile Object Types debuggable kompiliert werden. Die Vorbelegung dieses Feldes wird aus den Options verwendet und kann im GetDLL-Dialog temporär verändert werden."
  },
  "doc/ide/dokumentation.html": {
    "href": "doc/ide/dokumentation.html",
    "title": "Dokumentation",
    "keywords": "Dokumentation Einer der größten Kostentreiber eines jeden Softwareprojektes sind schlechte Dokumentationen, welche die Wiederverwendbarkeit von Code einschränken und die Wartung erschweren. Je besser Ihr Code dokumentiert ist, desto effektiver werden Sie ihn nutzen können. Allgemeines Um die Übersichtlichkeit, Wiederverwendbarkeit und Wartbarkeit Ihres Codes zu gewährleisten, sollten Sie ihre Metadatentypen, Properties und Methoden entsprechend beschreiben. Um Metadatentypen und Components mit Kommentaren zu versehen, öffnen Sie diese im Framework-Designer und tragen die Beschreibung in das Feld Description ein. Dabei muss die Eingebesyntax, wie im Folgenden ausgeführt, beachtet werden. Zu Properties können Sie Kommentare hinterlegen, indem Sie die Component, die das Property enthält, über die Combobox auf der Registerkarte Property auswählen und auf der Property-Registerkarte Description einen Kommentar hinterlegen. Component: Bei Methoden sollten Sie Kommentare, Beschreibungen der Parameter, Beispiele u.ä. im Methodenkopf, also noch vor Deklaration der Methode hinterlegen. Ist der Code ordentlich dokumentiert, haben Sie mit NDoc eine einfache Möglichkeit, eine Entwicklerdokumentation im Stil der MSDN zu erstellen. Warning Dazu ist es allerdings notwendig, dass die Kommentare auch in MSDN-konforme Tags eingeschlossen sind. Syntax Damit die Kommentare von NDoc richtig verarbeitet werden, ist es wichtig, diese in Tags einzufassen. Ein Tag ist einfach eine Beschreibung, die den Inhalt definiert. XML benötigt für eine Beschreibung immer 2 Tags, einen öffnenden und einen schließenden. Der schließende Tag unterscheidet sich dabei von dem öffnenden, dass er ’\\’ vor der Tag-Bezeichnung trägt. Wenn Sie verschachtelte Tags benutzen, müssen diese von innen nach außen wieder aufgelöst werden. <summary> Zusammenfassung </summary> Tags, die Sie zum Beschreiben benötigen, sind: <summary> Beschreibung </summary> <param name =\"Parametername\"> Beschreibung </param> <returns> Returnparameter </returns> <remarks> Anmerkungen </remarks> <example> Beispiel </example> Sie können auch ein Code-Template anlegen, welches schon eine komplette Beschreibungsstruktur aufweist, so dass Sie die Tags nicht jedes Mal neu anlegen müssen. Wie Sie es vielleicht auch schon von Visual Studio her kennen, werden Kommentare im Code, die für externe Dokumentationszwecke gedacht sind, durch 3 führende Slashs ( /// ), interne dagegen durch 2 führende Slashs definiert. Beispiel eines Description-Templates: ///<summary> ///??? ///</summary> /// ///<param name=\"???\">???</param> /// ///<returns>???</returns> /// ///<remarks> ///??? ///</remarks> /// ///<example> ///??? ///</example> public void WriteView() Wenn Sie Kommentare in die Description-Felder eingeben, brauchen Sie keinen Slash voranstellen. Diese sind nur direkt im Code, wie bei Methoden notwendig. Weitere gültige Tags können Sie der NDoc-Hilfe entnehmen."
  },
  "doc/ide/framework-compiler.html": {
    "href": "doc/ide/framework-compiler.html",
    "title": "FrameworkCompiler",
    "keywords": "FrameworkCompiler Der FrameworkCompiler ist ein besonderer Benutzer innerhalb von Framework Studio . Seine Hauptaufgabe besteht darin, den kompilierten Code einer Anwendung, den sog. Saved-Code, in das Repository zu schreiben. Hintergrund ist das Entwicklungsmodell von Framework Studio . Mehrere Entwickler arbeiten an einer Anwendung, checken Elemente aus und ein. Der FrameworkCompiler ist die Instanz, die alle Änderungen zu einem gesamten funktionierenden Stand zusammenfügt. Dies könnte z.B. nachts über einen Job stattfinden, da zu dieser Zeit normalerweise auch kein Entwickler angemeldet ist. Warning Der FrameworkCompiler kann selbst keine Objekte auschecken und bearbeiten. Siehe hierzu Benutzer bearbeiten TODO! Link. Ein Compile-Vorgang mit dem FrameworkCompiler hat folgenden Ablauf: Als erstes wird der Workspace des FrameworkCompiler aktualisiert. Hier werden alle von den Entwicklern eingecheckten Objekte herangezogen. Danach wird der gesamte Code kompiliert. Der Quellcode (Saved Code) sowie die daraus erzeugten Assemblies werden nach einem erfolgreichen Compile-Vorgang in die Datenbank geschrieben. Nun wird der Compile-Stamp des FrameworkCompilers aktualisiert. Hieran wird festgesetzt, ob die Entwickler mit einem aktuellen Workspace arbeiten oder nicht. Ein erfolgreicher Durchlauf des FrameworkCompilers stellt somit sicher, dass sich im Repository ein sauberer Entwicklungsstand mit jeglichem Source Code und jeglichen Assemblies befindet, auf dem die Entwickler ihre tägliche Arbeit aufbauen können."
  },
  "doc/ide/framework-designer.html": {
    "href": "doc/ide/framework-designer.html",
    "title": "Framework Studio IDE",
    "keywords": "Framework Studio IDE Mit dem Framework Designer gestalten Sie auf komfortable Weise Resources , Access Units , Metadatatypes , Datasources , DBTables , Components , Global Objects , Reports , Custom Controls , Forms und Workflows . Diese grundlegenden Elemente sind über die Registerkarte Namespaces ( Registerkarte Namespaces ) erreichbar. Andere Elemente wie Code-Templates , Laufzeitlizenzen und die Access Unit Hierarchie sind über das Menü Tools erreichbar. Nachfolgend werden die Registerkarten auf der linken Seite erklärt. Anschließend folgen allgemeine Funktionalitäten."
  },
  "doc/ide/references.html": {
    "href": "doc/ide/references.html",
    "title": "References",
    "keywords": "References Wenn innerhalb eines Namespaces Klassen eines weiteren Namespaces genutzt werden sollen, müssen diese über ein using -Statement eingebunden werden. Dasselbe gilt, wenn Sie externe Klassen nutzen wollen, wie z.B. die des .Net Frameworks. Über den Dialog References können Sie sowohl interne, als auch externe Referenzen erzeugen. Wenn Sie als Datentyp für ein Property eine Klasse aus einem anderen Namespace auswählen, wird automatisch ein using für diesen Namespace generiert. Referenzen anlegen / löschen Um eine Referenz hinzuzufügen, wählen Sie zunächst den Namespace auf der Registerkarte Namespaces aus, dem die Referenz hinzugefügt werden soll. Öffnen Sie anschließend den Dialog References , in dem Sie im unteren Bereich der Registerkarte das Kontext-Menü zu dem Namespace aufrufen und den Eintrag References... aufrufen oder auf den Button (References) klicken. Erzeugen Sie anschließend eine neue Referenz, indem Sie in der Combobox den Bereich auswählen, für den die Referenz erzeugt werden soll und drücken den Button (New) . Sie sehen die neue Referenz jetzt als Eintrag in der Listbox. Nun werden noch die Einstellungen für die Referenz angepasst, wie nachfolgend beschrieben. Löschen können Sie eine Referenz, indem Sie in der Combobox den gewünschten Bereich auswählen und anschließend in der Listbox die zu löschende Referenz markieren. Mit dem Button (Delete) wird die Referenz gelöscht. Wenn ein anderer Namespace innerhalb von Framework Studio referenziert werden soll, wählen Sie als Reference-Type \"Framework Studio\" . Über die Combobox Namespace haben Sie dann die Möglichkeit den Namespace auszuwählen, der eingebunden werden soll. Sollten Sie externe Klassen nutzen wollen, geben Sie als Reference-Type External an. Über den Datei-Auswahl-Dialog können Sie anschließend die .Net Assembly auswählen, die Sie einbinden möchten. Referenzen bearbeiten Name Hier können Sie die Namen der Referenz angeben. Framework Studio belegt diesen Namen mit ReferenceXX vor. Combobox Object Type Object-Type definiert, zu welchem Bereich die Referenz gehört. Da die einzelnen Bereiche eigene Assemblies erzeugen, ist dieser hier ebenfalls zu definieren. Der Standardtyp wird Component sein, da zumeist auf Components referenziert werden wird. Checkbox Use In Sub Namespaces Über diese Checkbox können Referenzen an Sub Namespaces vererbt werden. Die vererbten Referenzen werden in den Sub Namespaces als Derived mit dem Zusatz, aus welchem Namespace die Referenz stammt, dargestellt. Sie können hier nicht bearbeitet werden. Radion Button Framework Studio Reference Wählen Sie diesen Radio-Button, wenn Sie eine Framework-Studio-interne Referenz haben wollen. Namespace Hier benennen Sie für eine interne Referenz den Namespace, der verwendet werden soll. Combobox Referenced Object Type Hier geben Sie für eine interne Referenz an, welcher Bereich eingebunden werden soll. Es können grundsätzlich alle Object-Types angegeben werden, die vor oder mit dem eigenen Object-Type compiliert werden. Der Wert Component sollte jedoch nur dann verwendet werden, wenn Interface nicht ausreicht. Wenn man im Methoden-Code eine Component aus einem anderen Namespace verwenden möchte, dann wird in der Regel mit deren Interface bzw. der Factory-Klasse gearbeitet. In diesem Fall reicht eine Reference auf Interface völlig aus. Radio Button External Reference Wählen Sie diesen Radio-Button, wenn Sie eine externe Assembly einbinden möchten. Assembly Hier können Sie ein Assembly angeben, das eingebunden werden soll. Mit dem Button Browse öffnen Sie eine Datei-Auswahl, in der Sie ein Assembly angeben können. In dieser Zeile können folgende Präfixe verwendet werden: $CodeDirectory : Definiert das Compile-Verzeichnis des Brokers. So können Resources aus dem Ordner bin\\ referenziert werden. Beispiel: $CodeDirectory\\MyOwnAssembly.dll $DotNetDirectory : Definiert das Verzeichnis des .NET Framework 4.8 Beispiel: $DotNetDirectory\\System.Drawing.dll $GAC : Die Assembly soll aus dem Global Assembly Cache geladen werden Beispiel: $GAC\\ADODB, Version=7.0.3300.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a $FS : Wird von Framework Studio für Namespace-Referenzen verwendet. Diesen Präfix nicht bei externen Referenzen verwenden. Beispiel: $FS\\NV.ERP.Base.Customer_C.dll From GAC Siehe Referenzen auf GAC-Assemblies Usings Hier können Sie angeben, welche Namespaces der eingebundenen Assembly als using verwendet werden sollen. Die Namespaces müssen zeilenweise in das Textfeld geschrieben werden. Beispiel: System System.Collections System.Text System.Text.RegularExpressions Referenzen auf GAC-Assemblies Es können Assemblies aus dem GAC (Global Assembly Cache) in Framework Studio referenziert werden. From GAC Button: Nach dem Klick auf den Button erscheint eine Auflistung mit allen Assemblies, die im GAC des aktuellen PC‘s oder Servers vorhanden sind: GAC-Assembly Auswahldialog: Wird eine Assembly ausgewählt, erscheint diese mit dem Prefix $GAC und dem starken Namen im References-Dialog: Wie gewohnt können dann Usings definiert und die Assembly im Code verwendet werden. Stammt die ausgewählte Assembly aus dem .net Framework, dann wird diese nach der Auswahl automatisch auf $DotNetDirectory umgestellt. Bestehende $GAC -Referenzen können mit der Reference Cleanup Maintenance-Routine gefunden und korrigiert werden. Caution Welche GAC-Assemblies auf einem PC oder Server vorhanden sind, ist unterschiedlich und von installierter Software abhängig. Wird eine Framework Studio Applikation auf einem PC oder Server veröffentlicht oder kompiliert, auf dem die referenzierten GAC-Assemblies nicht vorhanden sind, kann es zu Laufzeit- oder Compilierfehlern kommen. Es muss dann sichergestellt werden, dass etwaige Drittsoftware korrekt installiert ist."
  },
  "doc/ide/registerkarten.html": {
    "href": "doc/ide/registerkarten.html",
    "title": "Registerkarten im Framework Designer",
    "keywords": "Registerkarten im Framework Designer Registerkarte Namespaces Diese Registerkarte ist noch mal in 2 Teile gegliedert. Im oberen Teil ist der Namespace-Baum abgebildet. In Framework Studio werden zu jedem Package ( Packages ) die Klassen wie in .NET üblich in Namespaces strukturiert. Diese Namespaces sind wie ein Baum unter ihrem Package aufgebaut und können beliebig tief verschachtelt sein. Im unteren Teil werden die Elemente des im oberen Baum ausgewählten Namespace im so genannten Objekt-Baum angezeigt. Mit einem Doppelklick können diese geöffnet werden. Es öffnet sich für jedes Element ein Designer-Fenster im Hauptfenster. Die Toolbar im mittleren Teil der Registerkarte bezieht sich auf den darunter dargestellten Objekt-Baum. Die einzelnen Elemente der Toolbar werden im Abschnitt Allgemeine Funktionalitäten erläutert. Außer der Registerkarte Search beziehen sich alle anderen Registerkarten, die im Folgenden beschrieben werden, immer auf das gerade aktive Designer-Fenster bzw. das dort ausgewählte Element. Ein Wechsel auf diese Registerkarten ist nur möglich, wenn bereits ein Designer-Fenster geöffnet wurde. Registerkarte Class Die Registerkarte Class zeigt alle Members des geöffneten Elements an. Über das Kontext-Menü des Elements (oberster Eintrag) können auch neue Member hinzugefügt werden. Mit einem Doppelklick auf einen Eintrag dieses Baums wird das entsprechende Member im Designer-Fenster auf der rechten Seite geöffnet bzw. ausgewählt. Über das Kontext-Menü eines Members lässt sich dieses aus dem Objekt löschen, umbenennen oder ein weiteres Member gleichen Typs erzeugen. Registerkarte Inheritance In dieser Registerkarte wird der Vererbungsbaum für das geöffnete Objekt angezeigt. Warning Nur Metadatentypen, Reports, Forms und Workflows lassen sich vererben. Registerkarte Properties Hier können die Eigenschaften der Elemente eines Objektes geändert werden. Es werden immer die Eigenschaften des im aktiven Designer-Fensters ausgewählten Elements angeboten. Sie können ein Element wählen, indem Sie es im Designer-Fenster anklicken. Diese listet alle Elemente auf, die im Zusammenhang zu der im aktiven Designer-Fenster ausgewählten Registerkarte stehen. Sortierung nach Kategorien: Standardmäßige Sortierreihenfolge der Properties. Sortierung Alphabetisch: Alternativ können Sie sich die Properties alphabetisch sortiert anzeigen lassen. Warning TODO! ++ Vererbte und Fett gedruckte Property-Werte ++ Zurücksetzen auf default-Wert ++ Ggf. Spezielle Editoren Registerkarte Toolbox Handelt es sich bei dem ausgewählten Objekt um ein Form oder einen Workflow, wird diese Registerkarte zugänglich. Bei Forms werden dort alle verfügbaren Controls angeboten. Ein Control kann per Drag & Drop auf dem Form positioniert werden. Bei Workflows werden über diese Registerkarte Links, Branches und Switches angeboten, welche per Drag & Drop in den Workflow gezogen und dort positioniert werden können. Ergänzende Informationen zu den Tools finden Sie in den Abschnitten zu Form und Workflows Designer(!TODO LINK). Registerkarte Search Auf dieser Registerkarte werden verschiedene Suchfunktionen zur Verfügung gestellt. Für die Suche gelten folgende allgemeine Funktionen: Suchbegriffeingabe Die Combobox unter der Suchdomänenauswahl ist zur Eingabe des Suchbegriffs vorgesehen. Sie speichert die 15 zuletzt verwendeten Suchbegriffe. Kommt ein sechzehnter Suchbegriff hinzu, so wird der älteste Eintrag verdrängt. Wird ein Suchbegriff verwendet, der schon in der Liste enthalten ist, so wird der Eintrag an den Anfang der Liste verschoben. Button Search Mit dem Button Search wird die Suche gestartet und die Ergebnisse werden in der Liste im unteren Bereich angezeigt. Suchergebnis-Historie Die Links/Rechts Pfeil-Buttons ermöglichen das chronologische Wechseln (links = zurück, rechts = vor) zwischen Suchergebnissen, die in der Suchergebnis-Historie abgelegt wurden. Sobald eine neue Suche ausgeführt wird, wird das Ergebnis dieser Suche ans Ende der Historie angehängt und angezeigt. Die Historie speichert maximal 15 Einträge. Außerdem erscheinen beim Blättern zusätzliche Informationen zum jeweiligen Eintrag unterhalb der Suchergebnisse. Suchergebnis-Historie mit zusätzlichen Informationen Result view style Hier kann ausgewählt werden, ob die Ergebnisse in einer Liste oder in einem Namespace-Baum angezeigt werden sollen. Zusätzlich besteht die Möglichkeit nur Methoden anzuzeigen. Diese Einstellung kann auch nach der Suche verändert werden. Ergebnis-Liste Die Ergebnisse werden wie gewünscht als Liste oder in einem Namespace-Baum angezeigt. Beim Namespace-Baum sind die Einträge mit grauem Text nicht Bestandteil der Ergebnis-Menge sondern dienen dazu, die Ergebnisse in einem Baum anzuordnen. In dieser Ansicht ist das Einchecken von Elementen inklusive aller Unterelemente über das Kontextmenü möglich. So können beispielsweise, nach der Suche nach ausgecheckten Elementen, alle ausgecheckten Elemente des Benutzers in einem Vorgang eingecheckt werden. Durch Doppelklick auf ein Suchergebnis wird das Ergebnis geöffnet. Nun folgt die Beschreibung der verschiedenen Such-Mechanismen. Volltext-Suche in generierten Code Die Suche auf den generierten Code ist ein guter Mechanismus, um z.B. nach bestimmten Verwendungen zu suchen. Der generierte Code beinhaltet sowohl alle im Designer angegebenen Informationen als auch den selbst geschriebenen Code. Der generierte Code wird mit entsprechenden Marken versehen, sodass die Suche bei einem Treffer die gefundene Code-Zeile einem Element (z.B. Component, Form) oder einem Teil (z.B. Property, Methode) zuordnen kann. Wird z.B. eine Zeile in einer selbst geschrieben Methode gefunden, kann diese Code-Zeile aus der Treffer-Liste heraus direkt angesprungen werden. Sie können in dem Textfeld einen zu suchenden Text angeben. Es wird dabei nach dem kompletten Text gesucht. Search Domain Hier wird angegeben, in welchem Bereich die Suche erfolgen soll. Sie können ein gesamtes Package durchsuchen oder den Suchbereich auf einen Namespace mit allen darunter liegenden Namespaces einschränken. Der Suchbereich kann auch über den Menüeintrag Search... im Objektbaum auf der Registerkarte Namespaces oder über den Menüeintrag Edit/Search... im Designerfenster eines LabeledRecords auf einen einzelnen LabeledRecord, also z.B. auf ein Form oder eine Textcollection eingeschränkt werden. Search in Component: In diesem Fall wird der Button Select Namespace angezeigt, mit dem der Suchbereich wieder auf einen beliebigen Namespace festgelegt werden kann. Grundsätzlich gilt: Je kleiner der Suchbereich, desto schneller die Suche. Bei einer großen Anwendung kann die Suche über alle Namespaces sehr lange dauern. Checkbox Case sensitive Bei der Suche wird nach Groß- und Klein-Schreibung unterschieden. Checkbox Regular Expressions Bei dem Suchtext handelt es sich um einen regulären Ausdruck. Es muss ein gültiger Ausdruck angegeben werden. Checkbox Use Saved Code Für die Suche soll der gespeicherte generierte Code verwendet werden. Es wird empfohlen, diese Option zu verwenden, da ansonsten der Code für die Suche komplett neu erzeugt werden muss. Das kann bei einer großen Anwendung sehr lange dauern. Combobox Element type Hier können Sie angeben, in welcher Art von Elementen die Suche durchgeführt werden soll. (z.B. Components, Forms, …) Suche in Textcollections Mit der Suche in Textcollections ist es möglich, gezielt die in den Textcollections angegebenen Texte zu durchsuchen. Suche in Textcollections: Search Domain Hier wird angegeben, in welchem Bereich die Suche erfolgen soll. Sie können in allen Textcollections eines Packages oder in allen Textcollections, die unterhalb eines bestimmten Namespaces liegen, suchen. Der Suchbereich kann außerdem über den Menüeintrag Search... im Objektbaum auf der Registerkarte Namespaces oder über den Menüeintrag Edit/Search... im Designerfenster einer Textcollection auf eine spezielle Textcollection eingeschränkt werden. Checkbox Textcollection Mit dieser Checkbox wird dieser Suchmodus aktiviert. Combobox Language Hier kann angegeben werden, in welcher Sprache gesucht werden soll. Checkbox Case sensitive Bei der Suche wird nach Groß- und Klein-Schreibung unterschieden. Checkbox Regular Expressions Bei dem Suchtext handelt es sich um einen regulären Ausdruck. Es muss ein gültiger Ausdruck angegeben werden. Wird z.B. als Suchtext ein regulärer Ausdruck ^$ angegeben und es wird eine Sprache ausgewählt, lassen sich alle Texte finden, bei denen der Text in dieser Sprache nicht gefüllt ist. ( ^ ist ein Zeilen-Anfang, $ ist ein Zeilenende und dazwischen soll nichts stehen.) Suche nach ausgecheckten Elementen In diesem Suchmodus werden alle ausgecheckten Elemente des Benutzers im aktuellen Package angezeigt. Checkbox Checked out Damit wird der Suchmodus aktiviert. Es werden alle anderen Controls inklusive des Namespace-Baumes deaktiviert. In der Ergebnis-Liste besteht die Möglichkeit, ein Check In oder ein Undo Check Out durchzuführen. Dabei können auch mehrere Elemente gleichzeitig verarbeitet werden. Dazu gibt es für die Ergebnisse ein Kontext-Menu, welches mit der rechten Maustaste aufgerufen werden kann. Nach einem Check In oder ein Undo Check Out wird die Ergebnis-Liste nicht aktualisiert. Es muss anschließend ggf. noch einmal neu gesucht werden, um die Liste zu aktualisieren. Während der Check In in einem Rutsch durchgeführt wird, wird der Undo Check Out für jedes Element einzeln durchgeführt. Dabei erscheint jedes Mal eine Meldung, die bestätigt werden muss. Es kann auch vorkommen, dass ein Undo Check Out mal nicht durchgeführt werden kann, weil dies durch eine bereits existierende Referenz verhindert wird. Der Vorgang muss ggf. wiederholt werden. Es folgt die Beschreibung des Kontext-Menus. Je nach Ergebnis können die Menu-Einträge variieren. Check In Checkt das einzelne Element ein. Check In all sub records Checkt alle, unterhalb eines Namespaces liegenden Elemente ein – auch über mehrere Ebenen hinweg. Check In with all its sub records Checkt den Namespace und alle unterhalb diesem Namespace liegenden Elemente ein – auch über mehrere Ebenen hinweg. Undo Check Out Führt einen Undo Check Out für das einzelne Element durch. Undo Check Out all sub records Führt einen Undo Check Out für alle unterhalb einem Namespace liegenden Elemente durch – auch über mehrere Ebenen hinweg. Undo Check Out with all its sub records Führt einen Undo Check Out für den Namespace und alle unterhalb dieses Namespace liegenden Elemente durch – auch über mehrere Ebenen hinweg. Suche nach Elementnamen Dieser Suchmodus wird mit der Checkbox Element Name aktiviert und dient dem schnellen Auffinden von Elementen über ihren Namen. Suche nach Elementnamen: Checkbox Case sensitive Bei der Suche wird nach Groß- und Klein-Schreibung unterschieden. Checkbox Regular Expressions Bei dem Suchtext handelt es sich um einen regulären Ausdruck. Es muss ein gültiger Ausdruck angegeben werden. Combobox Element type Hier kann die Suche auf einen Elementtyp (z.B. Components, Forms, ...) eingeschränkt werden. Suche nach Abhängigkeiten Sucht alle Elemente, die vom aktuellen Element abhängig sind. Mit dieser Funktion können Sie beispielsweise von einem Form zu Workflows wechseln, in denen das Form verwendet wird: von einer Component zu anderen Components oder zu Forms wechseln, die diese Component verwenden von einem Metadatentypen zu Components oder Forms wechseln, die den Metadatentypen verwenden von Workflows zu anderen Workflows wechseln, die diesen Workflow verwenden Data Source Hierarchiesuche Eine spezielle Form der Abhängigkeitssuche ist die Data Source Hierarchiesuche. Diese wird an einem Control innerhalb eines Forms ausgelöst und listet eine geordnete Kette von Elementen auf, die sich aus der Datenquelle des Controls ergeben: Das Control, für das die Suche ausgeführt wurde. Das Form-Property. Wenn eine Component beteiligt ist, wird das entsprechende Component-Property ebenfalls dargestellt – wie z.B. cdCall.oPCSInfo. Das Component-Property Die Tabellen-Spalte Der Metadatentyp und ggf. Basis-Metadatentypen Checkbox Dependencies Da diese Option eine spezielle Suchdomäne benötigt, kann die Suche nur durch das Menü Edit/Search Dependencies im Designerfenster bzw. über das Kontextmenü an einem Form Control erfolgen und die Checkbox Dependencies wird erst dann aktiv. Erst wenn das Häkchen entfernt wurde, kann wieder eine normale Suche durchgeführt werden. Registerkarte Comment Auf der Registerkarte Comment können Methoden dokumentiert werden. Wird z.B. ein Form geöffnet und auf der Registerkarte Methods eine Methode ausgewählt, wird die Comment-Registerkarte freigeschaltet. Registerkarte Check In Comment Auf der Registerkarte Check In Comment kann für ein Element (z.B. Form, Workflow, Component usw.) ein Kommentar hinterlegt werden, der beim nächsten Check In verwendet werden soll."
  },
  "doc/ide/start.html": {
    "href": "doc/ide/start.html",
    "title": "Framework Studio starten",
    "keywords": "Framework Studio starten Beim Start des Programms Framework Studio öffnet sich ein Dialog für die Verwaltung der Repositories, die Ihnen für Ihre Arbeit zur Verfügung stehen. Als Repository bezeichnet man eine Datenbank, in der die Quellcodes gespeichert werden. Repositories pflegen und auswählen Repository-Auswahl Mit dem Button New können Sie ein neues Repository in die Liste hinzufügen. Anschließend geben Sie folgende Daten ein: Button Remove Mit dem Button Remove können Sie das ausgewählte Repository aus der Liste entfernen. Name Name der Verbindung, den Sie frei wählen können. Connection Einstellungen Sind im Kapitel Connection Einstellungen beschrieben. Button Test Connection Mit dem Button Test Connection können Sie prüfen, ob eine Verbindung zum Repository hergestellt werden kann. Button OK Um die Arbeit auf einem Repository zu beginnen, wählen Sie den entsprechenden Eintrag in der Tabelle aus und klicken auf OK. Es öffnet sich ein Dialog, mit dem Sie sich an das Repository anmelden können ( Login). Weitere Funktionalität im Hauptmenü Unter dem Menüpunkt Repository werden die folgenden Funktionen angeboten: Create new repository [...] Dieser Menüpunkt ermöglicht das Anlegen eines neuen Repositories. Weitere Informationen dazu finden Sie unter Erstellen eines Repositories . FSDemo In diesem Untermenü werden die folgenden beiden Menüpunkte zusammengefasst: Create FSDemo repository [...] Es wird ein neues Repository angelegt, in dem bereits eine einfache Demo-Applikation enthalten ist (siehe auch Erstellen eines Repositories ). Create FSDemoData Database [...] Mit diesem Menüpunkt lässt sich eine Datenbank mit Demo-Daten für die Demo-Applikation anlegen. Mit dem Menüpunkt Licenses / Choose License Server ... können Sie die Datenbank angeben, in der die Lizenz für die Benutzung von Framework Studio abgelegt ist. Wird Use existing license database ausgewählt, so kann eine bereits bestehende Datenbank über Eingabefelder im unteren Dialogbereich konfiguriert werden. Wird Create new license database gewählt, kann eine neue Lizenzdatenbank erzeugt werden. Dazu muss im Feld Framework Studio License File eine Lizenzdatei für Framework Studio angegeben werden. Diese Lizenz wird dann in die neu erstellte Lizenzdatenbank kopiert. Mit dem Button wird ein Dateiauswahldialog geöffnet, mit dem die Lizenzdatei ausgewählt werden kann. Durch die folgenden Angaben wird die Lizenzdatenbank spezifiziert. Connection Type Typ der Datenbank. Zur Auswahl stehen SqlServer und Oracle (native) . Server (nur bei Connection Type SqlServer) Name oder IP Adresse des Rechners, auf dem die Datenbank eingerichtet werden soll. Auf diesem Rechner muss der entsprechende Datenbankdienst bereits installiert und in Betrieb sein. Database Name der Lizenzdatenbank. Use Windows NT Integrated Security (nur bei Connection Type SqlServer) Zur Anmeldung am Datenbanksystem wird die Windows Authentifizierung verwendet. Use a specific user name and password Wird diese Option gewählt, kann die Authentifizierung am Datenbanksystem durch Benutzername und Password durchgeführt werden. Dazu muss der Benutzername im Feld Username und das Passwort im Feld Password angegeben werden. Mit dem Button Test Connection kann überprüft werden, ob mit den angegebenen Daten eine Verbindung zum Datenbanksystem hergestellt werden kann. Mit dem Button OK werden die Angaben übernommen und gegebenenfalls das neue Repository erstellt. Mit dem Button Cancel verlassen Sie den Dialog, ohne dass Änderungen übernommen werden. Login Mit dem Login-Dialog können Sie sich am zuvor ausgewählten Repository anmelden. Listbox Package Eine Liste der existierenden Packages. Importierte Packages werden mit dem Suffix (readonly) gekennzeichnet. Beim Login merkt sich Framework Studio das ausgewählte Package. Es wird beim nächsten Login wieder vorbelegt. Listbox Version Eine Liste der Package-Versionen. Es werden die Versionen des ausgewählten Packages angezeigt. Die Versionen sind nach Versions-Nummer absteigend sortiert. Eine Sortierung ist nur dann gewährleistet, wenn übliche gültige Versionsnummern verwendet werden. Ist eine Package-Version mit einer anderen FS-Version erstellt, dann wird dies in dieser Liste angezeigt (z.B. [FS 3.11] – diese Package-Version kann nur mit FS Version 3.11 bearbeitet werden). Ein Login ist in diesem Fall nicht möglich. Sie müssen den Package-Manager verwenden, um die Package-Version auf eine aktuellere FS-Version zu bringen. Ist ein Package-Version versiegelt, dann wird dies in der Liste mit dem Suffix (sealed) angezeigt. Ein Login ist möglich, es kann jedoch nicht bearbeitet werden. Beim Login merkt sich Framework Studio die zuletzt ausgewählte Version. Die Information wird für jedes Package separat gespeichert. Beim nächsten Login wird bei der Auswahl des Packages die zuletzt gewählte Version vorbelegt. Combobox User Eine Liste aller existierenden Benutzer. Diese Combobox arbeitet mit Autovervollständigung. Man braucht also nur die ersten Buchstaben eintippen. Das ist vorteilhaft bei langen Benutzernamen. Beim Login merkt sich Framework Studio den zuletzt verwendeten Benutzer. Diese Information wird für jede Package-Version separat gespeichert. Beim nächsten Login wird bei der Auswahl einer Version der zuletzt gewählte Benutzer vorbelegt. Wenn Sie sich als FrameworkCompiler anmelden, dann wird die letzte Vorbelegung nicht gespeichert. Wenn Sie nach dem Öffnen des Login-Dialogs einmal einen anderen Benutzer auswählen, wird dieser nicht mehr automatisch verändert. Der FrameworkAdministrator kann sich nicht an einem Package anmelden. Mit diesem Benutzer öffnet sich die Benutzer-Verwaltung . Wenn man diesen Benutzer auswählt, dann werden alle Optionen deaktiviert. Weitere Informationen zu Packages und Version finden Sie unter Package Manager . Password Geben Sie das Kennwort des Benutzers ein. Sollten Sie Ihr Passwort einmal vergessen, gibt es die Möglichkeit über das Menü Benutzer-Verwaltung ein neues Passwort zu vergeben. Checkbox Get latest FrameworkCompiler workspace Gibt an, ob der Workspace aktualisiert werden soll. Bei einem normalen Benutzer wird der eigene Workspace auf den Stand des FrameworkCompiler Workspaces aktualisiert. Gibt es einen neueren vollständig kompilierten und abgeschlossenen FrameworkCompiler Workspace, dann ist diese Checkbox zugänglich und automatisch gesetzt. Ist der eigene Workspace bereits auf dem aktuellsten Stand, dann ist ein erneuter Refresh nicht möglich. Enthält der Benutzer in seinem Workspace bereits aktuellere Elemente als der FrameworkCompiler, dann behält er diese. Auch vom Benutzer ausgecheckte Elemente bleiben im eigenen Workspace erhalten. Alle Elemente, deren Version vom FrameworkCompiler Workspace abweichen, werden mit der Checkbox Compile Changes automatisch kompiliert. Checkbox Get Latest Version Wenn Sie sich als FrameworkCompiler anmelden, dann wird der Workspace auf die \"Latest Version\", also auf den aktuellsten eingecheckten Stand aller Elemente aktualisiert. Bei einer offnenen Package-Version enthält der so neu erzeugte Workspace keinen SavedCode und keine DLLs. Diese werden durch einen vollständigen Compile erzeugt. Der Framework Compiler startet somit den Compile auf der \"grünen Wiese\". Bei einer Service-Release Version werden SavedCode und DLLs aus dem vorherigen abgeschlossenen Workspace kompiliert. Somit müssen nur noch die im Service-Release geänderten Elemente neu kompiliert werden. Checkbox Get DLLs Gibt an, ob die vom FrameworkCompiler erzeugte DLLs geholt werden sollen. Checkbox Compile Changes Gibt an, ob automatisch alle Elemente kompiliert werden sollen, die nicht zum FrameworkCompiler Workspace passen. Das betrifft ausgecheckte Elemente und auch z.B. nach dem Start des FrameworkCompilers eingecheckte Elemente. Während dieses Compiles wird die Compiler-Option \"Use Saved Code\" aktiviert und die Option \"Debuggable\" wird deaktiviert. Anschließend werden die Compiler-Optionen wieder auf die letzte Benutzer-Einstellung zurückgesetzt. Diese Option kann nur in Verbindung mit Get DLLs verwendet werden. Wenn Sie sich als FrameworkCompiler anmelden, steht diese Option nicht zur Verfügung. Wenn der letzte FrameworkCompiler erfolgreich war und der eigene Workspace veraltet ist (älter als der vom FrameworkCompiler), dann werden bei der Auswahl einer Version oder beim Wechseln des Benutzers die Checkboxen Refresh Workspace mit der FrameworkCompiler-Option, Get DLLs und Compile CheckedOut automatisch vorbelegt. Option AutoDebug DLLs Diese Option ist aktiv, sobald die Checkbox Compile Changes aktiviert wird. Die initiale Vorbelegung stammt aus dem Options -Dialog, kann jedoch temporär im Login -Dialog geändert werden. Wird All bei der AutoDebug-Option angegeben, werden alle Namespaces jedes Typen debuggable kompiliert. Bei der Option Service, Component werden alle vorgenommenen Änderungen (Compile Changes) und Services und Components debuggable kompiliert. Mit None wird die AutoDebug-Option entsprechend \"deaktiviert\" und nur die vorgenommen Änderungen (Compile Changes) werden normal/nicht debuggable kompiliert. Informationen Bei der Auswahl einer Version werden unter den Checkboxen einige Informationen ausgegeben. Diese können je nach Anwendungs-Fall variieren. Last FrameworkCompiler succeeded Wird angezeigt, wenn der letzte FrameworkCompiler erfolgreich war. Der letzte FrameworkCompiler wurde erfolgreich abgeschlossen, nachdem der Workspace vom FrameworkCompiler aktualisiert wurde. Last FrameworkCompiler failed Wird angezeigt, wenn der letzte FrameworkCompiler fehlgeschlagen ist. Es wurde ein Refresh Workspace durchgeführt, nachdem der letzte Compiler gelaufen ist. Zusätzlich gibt es noch einige Felder, die immer verfügbar sind: Last Refresh Workspace Gibt an, wenn der Benutzer zuletzt seinen eigenen Workspace aktualisiert hat. Es wird die Differenz in Minuten, Stunden oder Tagen angegeben. Zusätzlich gibt es einen Tooltip mit der kompletten Datum-Zeit-Angabe. Wenn der Benutzer noch keinen Workspace hat, dann wird (no workspace) ausgegeben. Wenn Sie den FrameworkCompiler auswählen, dann wird diese Information ausgeblendet. Last FrameworkCompiler refresh Gibt an, wann der Workspace des FrameworkCompilers zuletzt aktualisiert wurde. Es wird die Differenz in Minuten, Stunden oder Tagen angegeben. Zusätzlich gibt es einen Tooltip mit der kompletten Datum-Zeit-Angabe. Wenn der FrameworkCompiler noch keinen Workspace hat, dann wird (no workspace) ausgegeben. Last FrameworkCompiler compile Gibt an, wenn der letzte FrameworkCompiler erfolgreich durchgelaufen ist. Es wird die Differenz in Minuten, Stunden oder Tagen angegeben. Zusätzlich gibt es einen Tooltip mit der kompletten Datum-Zeit-Angabe. Wenn noch nie ein FrameworkCompiler gelaufen ist, dann wird (never) ausgegeben. Note Diese Information wird generiert, wenn man den Compiler aus dem Package-Manager heraus startet, oder mit dem Programm FSConsole.exe durchführt. Checkbox Maintenance Mode Ist diese Checkbox gesetzt, wird Framework Studio im Wartungsmodus gestartet (siehe Maintenance Mode). Button Login (Eingabetaste) Mit diesem Button erfolgt die Anmeldung am Repository. Auf einem Repository kann sich ein Benutzer nur einmal an einem Label (Package Version) anmelden. Ein Benutzer kann sich dagegen gleichzeitig an verschiedenen Labels anmelden. Dabei wird pro Benutzer nur eine Framework Studio Lizenz verbraucht. Wenn Sie mit mehreren Benutzern in einem Label entwickeln möchten, ist es erforderlich, dass sich jeder mit einem anderen Namen an dem Repository anmeldet. Wenn noch eine Anmeldung mit diesem Benutzer existiert, erscheint eine entsprechende Meldung. Diese Meldung erscheint auch dann, wenn sich Framework Studio unkontrolliert beendet hat (oder beendet wurde) und keine saubere Abmeldung erfolgt ist. In diesem Fall ist das Übernehmen der existierenden Anmeldung unproblematisch. Wird die Anmeldung übernommen, wird der bereits angemeldete Entwickler automatisch abgemeldet, weil ein Benutzer nur einmal angemeldet sein darf. Arbeitet ggf. noch jemand anderes mit diesem Benutzer, wird dessen Anwendung automatisch beendet. Nach erfolgreicher Anmeldung öffnet sich das Hauptfenster von Framework Studio . Button Cancel (Escape-Taste) Damit wird der Anmeldevorgang abgebrochen und es wird wieder die Repository-Auswahl angezeigt. Maintenance Mode Um Framework Studio im Wartungsmodus zu starten, muss im Login-Dialog die Checkbox Maintenance Mode gesetzt werden (siehe Login). Die im Folgenden beschriebenen Funktionalitäten stehen dann in Framework Studio zur Verfügung. Upgrade Workflow Parameters In älteren Framework Studio Versionen (bis einschließlich 2.5) wurden Parameter in Methodenaufrufen von Workflow-Links anhand ihrer Bezeichnung identifiziert. Das hatte zur Folge, dass durch Umbenennung eines Parameters die Verknüpfung zerstört wurde. An solche Parameter wurde dann automatisch der Wert \"null\" übergeben. Da dies meist keinen Kompilierfehler verursacht hat, wurden dadurch ausgelöste Probleme erst spät erkannt. Mit dem Menüpunkt Tools / Upgrade all old workflow parameters wird ein Vorgang gestartet, der dafür sorgt, dass alle Parameter zukünftig über ihre Position identifiziert werden. Ein nachträgliches Umbenennen von Parametern ist dann zukünftig problemlos möglich. Der Vorgang kann nicht mit dem Benutzer FrameworkCompiler ausgeführt werden, da alle Workflows zur Bearbeitung ausgecheckt werden. Dieser Vorgang findet im Hintergrund statt, ohne dass der Benutzer Statusmeldungen erhält. Ist der Vorgang beendet, erscheint eine Meldung mit dem Hinweis auf die automatisch erzeugte Protokoll-Datei. In dieser Protokoll-Datei wird auch festgehalten, welche Links an einen Parameter ein \"null\" übergeben. Diese Links sollten daraufhin überprüft werden, ob durch den oben beschriebenen Fehler bereits ein Parameter abhandengekommen ist. Im Anschluss müssen alle Workflows manuell eingecheckt werden. Dazu bietet es sich an, nach ausgecheckten Elementen zu suchen (siehe Registerkarte Search ), da dort über das Kontextmenü alle Elemente in einem Vorgang eingecheckt werden können."
  },
  "doc/ide/tools-menu.html": {
    "href": "doc/ide/tools-menu.html",
    "title": "Tools Menü",
    "keywords": "Tools Menü In den folgenden Abschnitten werden die Menüpunkte im Menü Tools beschrieben. Registered Databases In diesem Dialog werden die im Repository verwendeten Datenbankverbindungen verwaltet. Die Verbindung mit dem Namen RuntimeConnection stellt die Verbindung zum Repository dar. Die in diesem Dialog angelegten Verbindungen stehen allen Benutzern in allen Packages des Repositories zur Verfügung. Caution Die Angaben stehen nicht unter der Versionskontrolle. Sie können von allen Benutzern zu jeder Zeit verändert werden. Die Änderungen wirken sich auf alle Benutzer gleichermaßen aus. Es sollte daher beachtet werden, dass andere Benutzer dadurch nicht behindert werden. Die Verbindungs-Einstellungen sind im Kapitel Connection Einstellungen beschrieben. Access Unit Treeview Über den Menüpunkt Tools / Access Unit Treeview... kann das Fenster zum Bearbeiten der Access Unit Hierarchie aufgerufen werden. Siehe dazu Access Unit Hierarchie . Code Snippets Editor Der Code Snippets Editor ist ein hilfreiches Werkzeug, wenn Sie einen Code haben, der immer wieder auftaucht. Was für einen Code Sie im Endeffekt hinterlegen, bleibt dabei Ihnen überlassen. Es könnten z.B. Templates für die Dokumentation sein, Code-Strukturen oder Schleifenkonstrukte. Auch Methoden, die Sie laufend bei Vererbung benötigen, könnten hilfreich sein. Sie können die hinterlegten Code-Snippets im Code-Editor über die Tastenkombination <Strg+J> aufrufen. Es öffnet sich eine Listbox, über die Sie das gewünschte Snippet auswählen können. Auch über die Toolbox können die Snippets per Drag und Drop in den Code-Editor oder dem Comment-Editor gezogen werden. Die Code-Snippets werden im Repository an der aktuellen Package-Version gespeichert. Sie werden zusammen mit der Package-Version exportiert und so in das Ziel-Repository übertragen. Das ursprüngliche manuelle Exportieren und Importieren der Code-Snippets entfällt. Im Code-Snippet-Editor können die Code-Snippets für die aktuelle Package-Version bearbeitet werden. Zusätzlich werden die Code-Snippets aus den Basis-Packages zusammen mit dem Package-Namen angezeigt – sie sind readonly. Überschreiben können Sie ein Code-Snippet indem Sie im aktuellen Package ein weiteres Code-Snippet mit identischem Namen erstellen. In der Liste sind die Code-Snippets nach der Package-Hierarchie angeordnet, sodass Überschreibungen gut zu erkennen sind. Beispiel: Das aktuelle Package hat FSDemoCustomize und FSDemo als Basis und dementsprechend werden auch die Code-Snippets dieser Packages angezeigt. In dem Code-Snippet Editor werden die Snippets folgendermaßen dargestellt: Snippet1 Snippet1 [FSDemoCustomize] Snippet1 [FSDemo] Snippet2 [FSDemoCustomize] Snippet2 [FSDemo] Snippet3 [FSDemo] Snippet4 Snippet4 [FSDemo] Von den im Code-Snippet-Editor angezeigten Einträgen gewinnt jeweils der erste. Die grauen Einträge werden im Intellisense und der Toolbox nicht angezeigt. Checked Out Report Im Menu Tools / Checked Out Report öffnet sich ein Report-Fenster. Checked Out Records: Dieser Report zeigt die ausgecheckten Elemente aller Benutzer an. Die Anzeige ist nach Benutzern gruppiert. Eine Legende mit den Bedeutungen der Farben befindet sich am Ende dieses Reports. Change Password Im Menu Tools / Change Password öffnet sich ein Dialog zum Ändern des eigenen Passworts. Change Password Dialog: In diesem Dialog müssen Sie im Feld Old Password das zurzeit gültige Passwort eingeben. In New Password können Sie das neue Passwort eingeben, welches in Confirm New Password bestätigt werden muss, um Fehleingaben zu verhindern. Mit dem Button OK wird das neue Passwort gesetzt. Wenn Sie kein neues Passwort eingeben und mit dem Button OK bestätigen, wird das Passwort gelöscht und Sie können sich ab sofort ohne Passwort mit Ihrem Benutzernamen anmelden. Wenn Sie im Team mit mehreren Entwicklern arbeiten, wird aus Sicherheitsgründen empfohlen ein Passwort zu verwenden. Sollten Sie Ihr Passwort einmal vergessen, gibt es die Möglichkeit über die Benutzer-Verwaltung ein neues Passwort zu vergeben. Adjust moved customizations Wird ein Element aus einem Basis-Package gecustomized, dann merkt sich Framework Studio aus Performance-Gründen auch im Customizing-Package den Namespace, in dem sich dieses Element befindet. Nun kann es passieren, dass im Basis-Package ein Element mit der Funktion Change Namespace in einen anderen Namespace verschoben wird. Dies führt zu Compile-Fehlern im Customizing-Package. Mit der Routine Adjust moved customizations wird der Namespace der gecustomizten Elemente korrigiert. Diese werden dazu ausgecheckt und müssen anschließend wieder eingecheckt werden, bevor ein Framework Compiler gestartet wird. FSConsole Command Prompt Startet ein Konsolen-Fenster. Dort ist als aktuelles Verzeichnis das Framework Studio Programm-Verzeichnis gesetzt. Runtime Licenses Über den Menüpunkt Tools / Runtime Licenses kann der Runtime License Manager geöffnet werden. Details zur Verwaltung von Laufzeitlizenzen mit dem Runtime License Manager finden Sie unter Laufzeitlizenzen ."
  },
  "doc/ide/view-menu.html": {
    "href": "doc/ide/view-menu.html",
    "title": "View Menü",
    "keywords": "View Menü Track Active Item Ist der Menüeintrag Track Active Item mit einem Häkchen versehen, so wird auf der Registerkarte Namespaces automatisch der Namespace ausgewählt, in dem das aktuell fokussierte Element im Framework Designer (z.B. ein Form oder eine Component) angelegt ist. Ist der Menüeintrag nicht mit einem Häkchen versehen, ist dieser Automatismus abgeschaltet. Stattdessen wird in den Designer Fenstern ein zusätzlicher Button (Track Item) angeboten, mit dem auf der Registerkarte Namespaces in den Namespace des Elements gewechselt werden kann."
  },
  "doc/ide/window-menu.html": {
    "href": "doc/ide/window-menu.html",
    "title": "Window Menü",
    "keywords": "Window Menü Beim Verlassen von Framework Studio wird das aktuelle Layout automatisch abgespeichert. Es wird beim nächsten Start wieder ausgelesen. Das betrifft die Anordnung, Größe und Position der dockbaren Fenster. Menüpunkt Reset Window Layout: Setzt das Layout auf den Standard zurück. Menüpunkt Save Window Layout to file: Man kann das Layout also die Anordnung, Größe und Position der dockbaren Fenster in eine Datei speichern. Das ist sehr praktisch, wenn man z.B. auch über eine Remote-Verbindung auf seinem Rechner arbeitet. So kann man für die entsprechende Situation sein eigenes Layout erzeugen. Es wird eine Datei mit der Endung *.FS30Layout.xml erzeugt. Diese Dateien können nur mit der passenden Version von Framework Studio verwendet werden. Menüpunkt Load Window Layout from file: Lädt eine Layout-Datei und passt das Layout entsprechend an. Es können nur Layout-Dateien verwendet werden, die zu dieser Version von Framework Studio passen. Andere Dateien können dazu führen, dass einige Fenster falsch oder auch gar nicht angezeigt werden. Menüpunkt Close All Documents: Schließt alle offenen Elemente."
  },
  "doc/index.html": {
    "href": "doc/index.html",
    "title": "Framework Studio Technische Dokumentation",
    "keywords": "Framework Studio Technische Dokumentation"
  },
  "doc/kommandozeilen-parameter/kommandozeilen-parameter.html": {
    "href": "doc/kommandozeilen-parameter/kommandozeilen-parameter.html",
    "title": "Kommandozeilen-Parameter",
    "keywords": "Kommandozeilen-Parameter Allgemeines Die Datei FrameworkStudio.exe kann mit Parametern gestartet werden. Die Parameter ermöglichen beispielsweise automatisiert den Kompiliervorgang für den FrameworkCompiler anzustoßen. Die Parameter können in beliebiger Reihenfolge angegeben werden. Eine Liste aller möglichen Parameter mit Beschreibung folgt im nächsten Kapitel ( Tabellarische Übersicht aller Parameter ). Beispiel: FrameworkStudio2_5.exe \\CONNECT \"ConnectionString\" \\CONNECTIONTYPE \"SqlServer\" \\LOGIN \"demo:\" \\PACKAGE \"FSDemo\" \\VERSION \"1.0\" Durch diesen Aufruf wird Framework Studio auf dem durch ConnectionString spezifizierten SqlServer Repository am Package FSDemo in der Version 1.0 für den Benutzer demo gestartet. Tabellarische Übersicht aller Parameter \\CONNECT \"ConnectionString\" Repository Connections-String Beispiel: \"data source=Server;initial catalog=Repository;persist security info=true;User ID=sa;Password=sa;;Pooling=false;\" \\CONNECTIONTYPE \"Type\" Mögliche Werte für Type: Oracle SqlServer \\LOGIN \"UserName:\" Der Benutzername mit dem sich am Repository angemeldet werden soll. z.B \"FrameworkCompiler:\" \\PACKAGE \"PackageName\" Der Name des Packages \\VERSION \"PackageVersion\" Die Version z.B. \"1.0.1\" \\APPLICATION \"ApplicationName\" Gibt an, welche Application gesetzt werden soll. Das ist vor allem dann notwendig, wenn mit dem Parameter \\REFRESHWS gearbeitet wird, damit die Assemblies auch in den richtigen Broker-Ordner geschrieben werden. \\REFRESHWS \"true\" Wenn dieser Parameter mit dem Wert \"true\" angegeben ist, wird ein Refresh Workspace durchgeführt. Ein Compile mit dem FrameworkCompiler macht nur Sinn, wenn dessen Workspace aktualisiert wird, und er die frisch eingecheckten Versionen kompiliert. \\COMPILE \":0000000000000000\" Wenn der Parameter gesetzt ist, wir der Compile automatisch gestartet. Die Ziffern sind eine Folge aus 0en und 1en, die die Schalter für den Compile-Vorgang angibt. Es folgt eine Liste der Schalter. Es müssen immer alle Ziffern entweder mit 0 oder 1 angegeben werden. Ziffer) Recursive Ziffer) Debugable Ziffer) XmlDoc Ziffer) Use Saved Code Ziffer) Muss immer „1“ sein. Ziffer) Ressources Ziffer) AccessUnits Ziffer) Metadatentypen Ziffer) DB-Tables Ziffer) Interfaces Ziffer) Components Ziffer) GlobalObjects Ziffer) ReportDocumentTypes Ziffer) CustomControls Ziffer) Forms Ziffer) Workflows Ein typischer Compile wäre z.B. \":1001111111111111\" Dabei wird alles mit Use SavedCode kompiliert. Note Nach dem Compile wird FrameworkStudio nicht beendet, sondern bleibt am Bildschirm stehen. Wenn beim Compile ein Fehler auftritt, bleibt er an dieser Stelle stehen und der Fehler wird wie bei einem normalen Compile angezeigt."
  },
  "doc/konzepte/fs-types.html": {
    "href": "doc/konzepte/fs-types.html",
    "title": "FS-Datentypen",
    "keywords": "FS-Datentypen FS-Datentypen verhalten sich fast genauso wie die .NET-Datentypen mit ähnlich lautenden Namen. Der Unterschied zu den .NET-Datentypen besteht darin, dass sie einen Null-Wert verstehen. Die FS-Datentypen sind die Basis für die Metadatentypen. Sie können aber auch als Datentyp für Properties oder einfach frei im Code verwendet werden. Sie sollten immer dann verwendet werden, wenn die Null-Information nicht verloren gehen darf. Mit diesen Datentypen ist es möglich, Null-Werte aus einer Datenbank auszuwerten und auch wieder in die Datenbank zurückzuschreiben. Außerdem können z.B. Datenfelder in Forms, die eine Zahl oder ein Datum enthalten, komplett leer sein, was z.B. bei Suchfeldern wichtig ist. Bei den FS-Datentypen handelt es sich ebenfalls um Structs. Die Wertzuweisungen zwischen verschiedenen FS-Datentypen erfolgen also ByValue – wie bei den .NET-Datentypen auch. Variablen und Properties von einem FS-Datentyp können genauso verwendet werden wie Variablen und Properties von .NET-Datentypen. Es können auch Zuweisungen zwischen den verschiedenen Datentypen erfolgen. Es erfolgt in den meisten Fällen eine implizite Konvertierung der Datentypen. Die Null-Information geht dabei aber verloren. Properties der FS-Datentypen Value: (Property) Wert des FS-Datentyps als .NET-Datentyp. D.h.: FSdecimal.Value liefert einen Wert vom Typ dezimal. Dieser Wert kann sowohl gelesen als auch geschrieben werden. Ist der Wert der Variable Null, liefert Value den in der folgenden Tabelle angegebenen Wert aus der Spalte Null-Value zurück. Das Setzen des Wertes der Variable auf einen Null-Value hat aber nicht zur Folge, dass die Variable Null wird. Einzige Ausnahme ist FSstring: IsNull bedeutet Value=““ und Value=““ bedeutet IsNull. Beispiel: FSdecimal decVar1 = 0; // Wert auf 0 oder Null prüfen if (decVar1.Value == 0) { … } // Variante ohne Value if (decVar1.IsNull || decVar1 == 0 ) { … } // Wert zuweisen: decVar1 = 5; //oder decVar1.Value = 5; IsNull (Property) Ist vom Typ bool . Gibt an, ob der Wert der Variable Null ist. Um einem FS-Datentypen explizit ein Null zuzuweisen, gibt es zwei Möglichkeiten: Sie weisen dem Property IsNull true zu, oder Sie weisen der Variable FSxxx.Null zu FSdecimal decVar1 = 0; // Wert nur auf Null prüfen if (decVar1.IsNull) { … } // Wert auf Null setzen decVar1.IsNull = true; // oder decVar1 = FSdecimal.Null; Null (Statisches Property) Liefert eine Variable mit einem Null-Wert. // Variable mit Null initialisieren FSdecimal decVar2 = FSdecimal.Null; Es folgt eine Tabelle mit allen FS-Datentypen und deren Null-Value. .NET-Datentyp FS-Datentyp Null-Value bool FSBool false byte FSbyte 0 DateTime FSDateTime DateTime.MinValue decimal FSdecimal 0 double FSdouble 0 float FSfloat 0 int FSint 0 long FSlong 0 short FSshort 0 string FSstring String.Empty HasValue (Property) Ist vom Typ bool . Man kann mit IsNull prüfen, ob ein FSType ( FSstring , FSdecimal , …) null ist. Wenn das Gegenteil geprüft werden soll, kann das Property HasValue verwendet werden. So wird der Code deutlich lesbarer, vor allem dann, wenn das zu prüfende Property tief verschachtelt ist. Beispiel: // herkömmlicher Weg (Das Ausrufezeichen wird schnell überlesen): if (!this.oOrder.oCustomer.sCompany1.IsNull) // neuer Weg: if (this.oOrder.oCustomer.sCompany1.HasValue) FSDateTime.Now Statisches Property am Typ FSDateTime , welches das aktuelle System-Datum sekundengenau zurückgibt. Wenn man mit der Datenbank oder auch mit Benutzer-Eingaben arbeitet, werden in der Regel sekundengenaue Werte verarbeitet. Wenn man mit dem System.DateTime.Now arbeitet, erhält man einen um mehrere Zehnerpotenzen genaueren Wert. Bei Vergleichen mit Benutzereingaben weichen diese dann von System.DateTime.Now ab. Es wird daher empfohlen, alle Daten, die mit dem aktuellen Datum initialisiert werden sollen, mit FSDateTime.Now zu initialisieren. Beispiel: // Variable mit sekundengenauem Wert der aktuellen Zeit initialisieren FSDateTime dtMyDate = FSDateTime.Now; Wenn mit genaueren Werten gearbeitet werden soll, ist die folgende Initialisierung ebenfalls möglich: // Variable möglichst genau mit der aktuellen Zeit initialisieren FSDateTime dtMyAccurateDate = DateTime.Now;"
  },
  "doc/konzepte/property-changed.html": {
    "href": "doc/konzepte/property-changed.html",
    "title": "PropertyChanged",
    "keywords": "PropertyChanged Die Components und Forms implementieren das Standard-Interface INotifyPropertyChanged . Das Event konsumieren Über das Event PropetyChanged werden Änderungen an Properties gemeldet. Dieses Event transportiert als Argument PropertyChangedEventArgs mit der Eigenschaft PropertyName . oArticle.PropertyChanged += OnArticleChanged; // Der EventHandler: protected void OnArticleChanged(object sender, PropertyChangedEventArgs args) { // reagieren auf Änderungen } Prüfung des Property-Namen Um gezielt auf die Änderung bestimmter Properties zu reagieren muss die eigenschaft PropertyName ausgewertet werden. Dabei müssen auch einige Sonderfälle beachtet werden. Ist der PropertyName leer ( null oder Empty ) bedeutet, dass sich alle Properties geändert haben. Genauso sollte man es auch betrachten, wenn gar keine EventArgs übergeben werden. // Ausführliche Prüfung if (args == null || string.IsNullOrEmpty(args.PropertyName) || args.PropertyName == nameof(sArticleID)) ... Framework Studio bietet mit der Methode IsProperty eine praktische Erweiterung, um diese Prüfung zu vereinfachen. Man kann dieser Methode bei bedarf auch mehrere Property-Namen übergeben. // Einfache Prüfung analog zu oben if ( args.IsProperty(nameof(sArticleID)) ) ... // mit mehreren Properties: if ( args.IsProperty(nameof(decPrice1), nameof(decPrice2)) ) // ein Preis hat sich geändert ... Soll bewusst auf die Änderung exakt eines Properties gehört werden - also nicht wenn sich alles ändert - dann ist die folgende Schreibweise zu empfehlen: // Es wurde explizit die Artikel-Nummer geändert if ( args?.PropertyName == nameof(sArticleID) ) ... Generell ist es empfehlenswert, wie in den Beispielen demonstriert, mit nameof(...) zu arbeiten, damit die Namen der Properties vom Compiler geprüft werden. Das kann auf je nach Situation auf eine der folgenden Arten passieren Das Property direkt in der eigenen Klasse: nameof(this.sArticleID) Das Property an einer vorhandenen Instanz: nameof(oArticle.sArticleID) Das Property über das Interface oder die Klasse verwenden. nameof(IcdArticle.sArticleID) Aufrufen des Events Innerhalb der Component bzw. des Forms kann das Event durch Aufruf der Methode FirePropertyChanged(string propertyName) ausgelöst werden. Ach hier gilt: wird als PropertyName der Wert null oder String.Empty übergeben, bedeutet es, dass sich alles geändert hat. Davon sollte allerdings nur sehr bedacht Gebrauch gemacht werden."
  },
  "doc/maintenance/constructor-cleanup.html": {
    "href": "doc/maintenance/constructor-cleanup.html",
    "title": "Constructor Cleanup",
    "keywords": "Constructor Cleanup Constructor Cleanup ist eine Maintenance-Routine, die ungültige Konstruktor-Deklarationen korrigiert. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit Sie verfügbar ist. Sie kann in der IDE über das Menü Tools / Checks / Constructor Cleanup aufgerufen werden. Mit dem Button Analyze wird eine Analyse gestartet ohne, dass Änderungen durchgeführt werden. Die Resultate werde in der Error-Liste ausgegeben. Der Button CleanUp führt die Änderungen aus. Dazu werden die betroffenen Components ausgecheckt, geändert und gespeichert. Nach erfolgreichen Compile müssen die Components wieder eingecheckt werden. Beschreibung Es war einige Zeit üblich, alle Methoden einschließlich der Konstruktoren als virtual zu deklarieren. Bei Konstruktoren ist das aber nicht zulässig - dieses sind im .net von Haus aus virtuell. public virtual cdCustomer(IFSGlobalObjects global, FSlong id) : this(global) { // ... } Mit Framework Studio 4.4 werden ungültige Konstruktor-Deklarationen erkannt und als Error ausgegeben. Notwendig ist das, weil Framework Studio jetzt die Methoden-Deklarationen mit offiziellen .net-Mechanismen analysiert um z.B. Tupel korrekt zu behandeln. Das führt bei ungültigen Deklarationen zu Fehlern. Die Routine scannt alle Components, findet die fehlerhaften Konstruktoren und entfernt das virtual Schlüsselwort. public cdCustomer(IFSGlobalObjects global, FSlong id) : this(global) {"
  },
  "doc/maintenance/references-cleanup.html": {
    "href": "doc/maintenance/references-cleanup.html",
    "title": "References Cleanup",
    "keywords": "References Cleanup References Cleanup ist eine Maintenance-Routine, die ungültige Namespace-Referenzen bereinigt oder korrigiert. Im Login-Dialog muss der Maintenance-Mode aktiviert werden, damit Sie verfügbar ist. Sie kann in der IDE über das Menü Tools / Checks / References Cleanup aufgerufen werden. Checkbox Invalid external references Diese Routine sucht und entfernt Referenzen auf externe Assemblies die nicht (mehr) existieren. Checkbox External $GAC references Stellt Referenzen von $GAC auf $DotNetDirectory um, wenn das möglich ist. Framework Studio bringt sein eigenes Set an .net Framework Assemblies mit, die beim Compile referenziert werden. Das stellt sicher, dass das kompilierte Programm auch auf anderen Rechnern ausgeführt werden kann, auch wenn dort eine etwas andere Version des .net Frameworks installiert ist. Referenzen auf .net Framework Assemblies werden deshalb mit einem eigenen Präfix $DotNetDirectory gekennzeichnet - z.B. $DotNetDirectory\\System.Drawing.dll . Gleichzeitig sind diese Assemblies auch über den Global Assembly Cache verfügbar. Referenzen auf den Global Assembly Cache werden mit dem Präfix $GAC gekennzeichnet - z.B. $GAC\\System.Drawing, Version=4.0.0.0 . Mit dem Button Analyze wird eine Analyse gestartet ohne, dass Änderungen durchgeführt werden. Die Resultate werde in der Error-Liste ausgegeben. Der Button CleanUp führt die Änderungen aus. Dazu werden die betroffenen Namespaces ausgecheckt, die Referenzen geändert und gespeichert. Nach erfolgreichen Compile müssen die Namespaces wieder eingecheckt werden."
  },
  "doc/mdt/format-pattern.html": {
    "href": "doc/mdt/format-pattern.html",
    "title": "Format-Pattern im Metadatentyp",
    "keywords": "Format-Pattern im Metadatentyp Je nachdem, welcher Datentyp ausgewählt wurde, ändern sich die Einstellungen für das Format-Pattern. Format Pattern für Zeichenketten Bei Zeichenketten können im Format reguläre Ausdrücke eingegeben werden. Die Zeichenketten müssen dann dem definierten regulären Ausdruck entsprechen. Im Java-Client wird bereits bei der Eingabe überprüft, ob die Zeichenkette dem Ausdruck genügt. Format-Pattern für Zahlen Bei Zahlen können gewöhnliche Zahlenformate eingegeben werden. Neben dem Feld Format-Pattern wird eine Beispiel-Zahl für das eingegebene Format dargestellt. Warning Es ist aber zu beachten, dass als Tausender-Trennzeichen das Komma und als Dezimal-Trennzeichen der Punkt dient. Gültige Formate wären z.B. #,##0.00 ergibt 1.234,56 0.00 ergibt 1.234,56 #,##0.00 ’EUR’ ergibt 1.234,56 EUR Format-Pattern für Datum Bei Datum können gewöhnliche Datum-Formate eingegeben werden. Neben dem Feld Format-Pattern wird als Beispiel das aktuelle Systemdatum entsprechend formatiert dargestellt. Der Button Default Values setzt die Werte auf die vom Framework Studio vorgegebenen Standardwerte zurück."
  },
  "doc/mdt/metadatentypen.html": {
    "href": "doc/mdt/metadatentypen.html",
    "title": "Metadatentypen",
    "keywords": "Metadatentypen Die Idee der Metadatentypen kommt daher, dass bestimmte Felder innerhalb einer Anwendung immer wieder auftauchen (z.B. Artikelnummer, Kundennummer, ...). Deshalb können solche Felder an einer zentralen Stelle definiert werden, was Fehler in der Felddefinition verhindert und Redundanzen minimiert. Dabei werden Informationen wie das Label, das Datenformat, das zugehörige Control, die mehrsprachige Bezeichnung usw. hinterlegt, so dass sich der Arbeitsaufwand bei der späteren Arbeit mit dem Metadatentypen minimiert. Sie erkennen Metadatentypen an einem - Icon vor der Bezeichnung. Metadatentypen bearbeiten Um einen Metadatatypen zu bearbeiten, doppelklicken Sie den entsprechenden Eintrag auf der Registerkarte Namespaces . Der Metadatentyp wird im Hauptfenster des Framework Designers angezeigt. Der Metadatentyp kann in verschiedenen Teilen der Anwendung zum Einsatz kommen: Er kann auf unterster Ebene der Spalte einer DBTable zugeordnet werden. Er kann in Components oder Forms als Datentyp für Properties verwendet werden. Deshalb nehmen Sie an einem Metadatentyp verschiedene Einstellungen vor: Name : Geben Sie die Bezeichnung des Metadatentyps an. Datatype Database : Benennen Sie den Datentyp der Spalte in der Datenbank. Datatype Application : Gibt den FS-Datentyp des Metadatentyps an. Dieser Datentyp wird später in den Components und Forms gezogen. Die folgende Tabelle zeigt, welche Database-Datentypen mit welchem Application-Datatype kombiniert werden können: FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring Binary X Boolean X Byte X Date X DateTime X Time X Double X Currency X X X Single X X X Decimal X X Big Int X Integer X X Smallint X X X Tiny Int X X X Ansi String X Long Varchar X String X null X X X X X X X X X X X Warning Wenn Sie die Datentypen nachträglich ändern, kann das evtl. Auswirkungen auf Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren. Die Einstellungen für Size, Precision und Scale hängen von der Auswahl des Datatype Database ab. Je nachdem, ob der Datenbank-Datentyp Zeichen, Ganzzahlen oder Gleitkommazahlen unterstützt, sind die Felder für Eingaben zugänglich. Size : Definiert die Feldlänge bei Zeichenfeldern. Precision : Anzahl der Stellen inkl. eventueller Nachkommastellen bei numerischen Feldern. Scale : Anzahl der Nachkommastellen bei Dezimal -Feldern. Format : Gibt das Anzeige-Format des Felds an. Das Format wirkt sich in der Darstellung des Felds auf einem Form aus. Format Pattern : Wird im Feld Format User Defined gewählt, ist es möglich hier selbst ein Format anzugeben. Es können Formate für Zahlen, Daten und Zeichenketten entsprechend der Standard-Definition für reguläre Ausdrücke eingegeben werden. Siehe auch Format-Pattern Registerkarte Description Hier kann eine Beschreibung des Metadatentyps eingegeben werden. Registerkarte Values Für einen Metadatentypen kann definiert werden, welche Werte er annehmen darf. Wird hier nichts angegeben, sind alle Werte möglich, die der entsprechend hinterlegte Datentyp zulässt. Es können mehrere Werte oder Wertebereiche angegeben werden. From : Gibt die untere Grenze eines Wertebereichs an. Warning Ist nur dieses Feld gefüllt (und To nicht), wird dies als Wert und nicht als Wertebereich angesehen. To : Gibt die obere Grenze eines Wertebereichs an. Button Add New Range : Mit dem Button Add New Range kann ein neuer Bereich hinzugefügt werden. Button Remove Range : Mit dem Button Remove Range kann ein Bereich gelöscht werden. Registerkarte Default Label Einem Metadatentypen kann ein Label zugewiesen werden. Dieses Label wird im Form links neben dem Control des Metadatentyps angezeigt. Das Label kann mehrsprachig hinterlegt werden. Tip Es ist möglich, dieses Label in den Components und im Form zu überschreiben. Registerkarte Control Types Die Registerkarte ControlTypes zeigt an, welche Controls später im Form zur Verfügung stehen sollen. Es ist möglich, einem Metadatentypen mehrere Controls zuzuordnen. Es kann aber maximal ein Control als Default gekennzeichnet sein. Das als Default gekennzeichnete Control wird zunächst angezeigt, wenn ein Property (welches diesen Metadatentypen verwendet) in ein Form gezogen wird. Das Default-Control kann dann auf weitere, hier hinterlegte Controls geändert werden. Diese Liste von Controls kann auch im DBTable oder in der einer Component ergänzt werden. Ist kein Control als Standard-Control hinterlegt, wird ein Editfeld angenommen. Mit dem Button Add wird ein neuer Control-Type hinzugefügt. Es öffnet sich das Fenster Assign Controls. In diesem Fenster sind alle Controls aufgelistet, einschließlich der Controls, die Sie in den Control Default Styles definieren können (siehe Kapitel Control Default Styles). Wählen Sie hier ein Control aus und setzen Sie ggf. die Checkbox is Default . Mit dem Button OK wird das Control der Liste hinzugefügt. Mit dem Button Change können Sie das Control ändern. Es öffnet sich wieder wie bei Add das Fenster Assign Controls . Sie können hier ein anderes Control auswählen und dann mit OK bestätigen. Mit dem Button Delete wird das markierte Control gelöscht."
  },
  "doc/mdt/validierung.html": {
    "href": "doc/mdt/validierung.html",
    "title": "Metadatentyp-Validierung",
    "keywords": "Metadatentyp-Validierung Die Einstellungen, die am Metadatentyp zu sehen sind (z.B. Größe, Formatierung, Wertebereich, …), werden bei der Arbeit mit Properties herangezogen, um die Werte zu validieren und ggf. zu korrigieren. Auch der Client nutzt diese Informationen, um falsche Eingaben so früh wie möglich zu unterbinden. Die Zusammenhänge werden durch folgendes Schaubild erläutert: Die folgende Tabelle stellt dar, was passiert, wenn mit einem Wert gearbeitet wird, der denen am Metadatentyp definierten Kriterien nicht entspricht. Einstellung Lesen von Properties aus der Datenbank, die falsche Werte beinhalten Setzen von Properties Client Allgemein Values Value Ranges Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Strings Size Bei zu langen Strings wird auf dieser auf die Size gekürzt. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Uppercase, Lowercase Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Die Eingabe lässt nur Groß- bzw. Kleinbuchstaben zu. Format-Pattern (Regulärer Ausdruck) Es wird FSstring.Null zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Es wird zuvor noch versucht, den String mit Uppercase oder Lowercase zu korrigieren, wenn der reguläre Ausdruck selber Uppercase bzw. Lowercase ist. Wenn das funktioniert, dann wird der Wert in Uppercase bzw. Lowercase konvertiert. Numerische Werte Precision Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Scale (bei Dezimal-Zahlen) Der Wert wird „kaufmännisch“ gerundet. Der Wert wird „kaufmännisch“ gerundet. Die Eingabe wird begrenzt. Positive Integer, Negative Integer (bei Ganzzahlen) Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Das Minus-Zeichen wird bei der Eingabe unterdrückt bzw. automatisch hinzugefügt. Der Java-Client gibt bei der Eingabe eines falschen Wertes die folgenden Fehlermeldungen aus: Wenn das Format-Pattern (der reguläre Ausdruck) verletzt wird: Wenn ein Wertebereich verletzt wird:"
  },
  "doc/mdt/vererbung.html": {
    "href": "doc/mdt/vererbung.html",
    "title": "Vererbung von Metadatentypen",
    "keywords": "Vererbung von Metadatentypen Es ist möglich, Metadatentypen zu vererben. Das macht dann Sinn, wenn Metadatentypen aufeinander aufbauen und z.B. ein gemeinsames Format-Pattern verwenden. Sie können so in einem Basis-Metadatentyp mit allen Datentypen Controls und einem Default-Label definieren. Anschließend brauchen Sie diesen nur abzuleiten und die Ableitung hat die gleichen Eigenschaften wie die Basis. Dann können Sie noch z.B. das Label oder den Wertebereich ändern. In der Ableitung werden die nachträglich geänderten Werte fettgedruckt dargestellt. Eine Ableitung können Sie auf zwei Wegen erstellen: Einen Metadatentypen ableiten, indem Sie den Metadatentyp im Overview auswählen, den Button ( Derive ) drücken und in der Namespace-Auswahl angeben, in welchem Namespace die Ableitung angelegt werden soll. Einem vorhandenen Metadatentypen im Feld Base eine Basis (oder auch eine andere Basis) zuweisen. Warning Wird beim Ändern der Basis auch der Datentyp geändert, kann das evtl. Auswirkungen auf die Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren."
  },
  "doc/mlkey/enventa-regeln.html": {
    "href": "doc/mlkey/enventa-regeln.html",
    "title": "eNVenta Regeln für MLKeys",
    "keywords": "eNVenta Regeln für MLKeys Allgemeine Regeln Texte aus den Test-Namespaces : Diese sollen nicht ins Wörterbuch aufgenommen werden. Unübersetzbare Texte : Texte, die nicht übersetzt werden können wie z.B. Eigennamen, müssen mit dem Kommentar untranslatable versehen werden. Sind weitere Hinweise im Kommentar nötig, beginnt der Kommentar mit untranslatable gefolgt von einem Zeilenumbruch. Der Text soll in diesem Fall nur in der deutschen Sprache angegeben werden. Abkürzungen im Namen eines MLKeys : Werden im Namen eines MLKeys bewusst Großbuchstaben als Abkürzungen für Teilworte verwendet, weil z.B. der Name sonst zu lang würde, so muss die Abkürzung nach folgendem Schema im Comment erläutert werden: {Abkürzung1} = {Begriff1}, {Abkürzung2} = {Begriff2} Beispiele: LBL_CCServicePort : Comment = CC = Cross Company LBL_CCNameDebit : Comment = CC = Cost Center Bezeichnung von MLKeys Normalfall Begriffe: LBL_{englische Bezeichnung} Beispiel: LBL_Search Sätze: MSG_{GUID} Beispiel: MSG_f39ceca46b3341ee8b9862d34cfd06b6 Einheiten LBL_{englische Bezeichnung}_Unit Beispiel: LBL _mm_Unit Zeichen LBL_{englische Bezeichnung}_Sign Beispiel: LBL_Plus_Sign für den Text „+“ Ziffern LBL_{englische Bezeichnung}_Digit oder LBL_{englische Bezeichnung}_Digits (Plural) Beispiele: LBL_Nine_Digit für den Text „9“, LBL_EightOClock_Digits für den Text „08:00“ Prozentzeichen LBL_{englischer Prefix}Percent (kein Unterstrich) Beispiel: LBL_DiscountPercent (de = „Skonto %“, en = „Discount %“) Abkürzungen / Ausgeschriebene Texte Wenn für einen englischen Begriff im deutschen am häufigsten eine abgekürzte Schreibweise verwendet wird, so wird der MLKey für den Text mit Abkürzung normal mit LBL_{englische Bezeichnung} benannt. Wird parallel dazu auch der im deutschen (oder anderen Fremdsprachen) ausgeschriebene Text benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Full benannt. Wird zu einem Begriff, zu dem es schon eine ausgeschriebene Schreibweise gibt eine Abkürzung benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Abbrev bezeichnet. Beispiele: LBL_ClerkScanner (de = „SB-Scanner“), LBL_ClerkScanner_Full (de = „Sachbearbeiter Scanner“) LBL_Reminder (de = „Wiedervorlage“), LBL_Reminder_Abbrev (de = „Wiedervorl.“) Spezialfall: Ein Buchstabe als Abkürzung LBL_{englische Bezeichnung}_Char Beispiele: LBL_Order_Char (de = „B“, en= „O“) LBL_Container_Char (de = „B“, en = „C“) Beschriftung von Mini-Buttons LBL_{englische Bezeichnung}_Mini Wird ein MiniButton (Control Style = MiniEmpty) auf einer Maske mit einer Caption von 1 bis 2 Buchstaben versehen (die typischerweise eine Abkürzung darstellen), so wird der MLKey dazu mit der eigentlichen Bezeichnung, ergänzt um _Mini beschriftet. Dabei ist darauf zu achten, dass die Beschriftungen pro Sprache eindeutig sind. Beispiele: LBL_Customer_Mini (de = „K“, en = „Cu“) LBL_CrossOver_Mini (de = „C“, en = „Cr“) Zwei unterschiedliche deutsche Begriffe, die im Englischen gleich heißen Wenn zwei unterschiedliche Begriffe im englischen durch den gleichen Text beschrieben werden, so werden die Bezeichnungen der MLKeys durch Anhängen eines Zählers beginnend mit 1 im Format _{Zähler} unterschieden. Beispiel: de = „Herkunft“, en = „Source“ => MLKey = LBL_Source de = „Quelle“, en = „Source“ => MLKey = LBL_Source_1 Tooltips Wenn ein Tooltip eindeutig einem einfachen Begriff zugeordnet werden kann, so wird der MLKey mit TTT_{englische Bezeichnung} benannt. Andernfalls wird das Format TTT_{GUID} verwendet. Beispiele: TTT_Fatal (de = „Fatale Einträge anzeigen“) `TTT_584b58008ed04cd2b40b78b70e52402c' (de = „Wert für die Kreditorenvorerfassung-Pufferzeit definieren.“) Note Wenn man einen Tooltip verwenden möchte, zu dem es bereits einen exakt passenden LBL_ Eintrag gibt, so soll dazu kein TTT_ Eintrag angelegt werden! Diese Einträge wären sonst ja logisch äquivalent. Kleingeschriebene Begriffe Sollte man ein Text (z.B. wegen einer Verwendung in einer Textcollection) berechtigterweise klein geschrieben sein und es soll trotzdem ein sprechender Key generiert werden, so ist dieser ebenfalls klein zu schreiben. Beispiel: de = „eins“, en = „one“ => MLKey = LBL_one Texte Alle Texte in allen Sprachen beginnen mit einem großen Buchstaben. Ausnahmen: Abgekürzte Einheiten (z.B. mm) Einträge in Textcollections, soweit diese zwingend alle klein geschrieben werden müssen. Vor Satzzeichen werden keine Leerzeichen verwendet. Ganze Sätze werden mit einem Satzzeichen beendet. Im Englischen werden bei Texten mit bis ca. 4 Worte (Beschriftungen von Eingabefeldern, Menüs, Buttons usw.) alle Worte bis auf Füllwörter wie of , to , in , ... groß geschrieben."
  },
  "doc/mlkey/import-export.html": {
    "href": "doc/mlkey/import-export.html",
    "title": "MLKey Import / Export",
    "keywords": "MLKey Import / Export"
  },
  "doc/mlkey/mlkey-cleanup.html": {
    "href": "doc/mlkey/mlkey-cleanup.html",
    "title": "MLKeys Cleanup",
    "keywords": "MLKeys Cleanup MLKeys-Cleanup ist eine Wartungs-Routine, die Bereinigungen im Wörterbuch durchführt. Sie kann in der IDE über das Menu Tools / Checks / MLKeys Cleanup aufgerufen werden. Checkbox Reset identical overrides Es werden Texte gesucht, die im aktuellen Package denselben Inhalt haben wie im Basis-Package. Die Bereinigung entfernt diese Überschreibungen. Checkbox Find untranslatable (1) Es werden MLKeys gesucht, an denen die Texte in allen gepflegten Sprachen identisch sind. Es wird vorgeschlagen diese auf untranslatable zu setzen. Dazu kann der Button Untranslatable verwendet werden. Die Treffer werden als Information ausgegeben. (2) Es werden MLKeys gesucht, die als untranslatable gekennzeichnet sind, aber in Fremdsprachen einen Text besitzen. Die Treffer werden als Warnung ausgegeben. Note Es findet keine Bereinigung der Treffer statt. Dies muss bei Bedarf manuell erfolgen. Checkbox Find unused MLKeys Es werden MLKeys angezeigt, die nicht verwendet werden. Es wird dazu der komplette generierte Code nach Verwendungen von MLKeys durchsucht. Dieser Vorgang kann einige Zeit dauern, er kann aber bei Bedarf abgebrochen werden. Note Es findet keine Bereinigung der Treffer statt. Dies muss bei Bedarf manuell erfolgen. Checkbox Find missing MLKeys Es wird nach MLKeys im Code gesucht, die im Wörterbuch nicht existieren. Es wird dazu der komplette generierte Code nach Verwendungen von MLKeys durchsucht. Dieser Vorgang kann einige Zeit dauern, er kann aber bei Bedarf abgebrochen werden. Versehentlich gelöschte MLKeys können über die History wiederhergestellt werden. Button Analyze Dieser Button führt für die ausgewählten Operationen lediglich eine Analyse durch. Die gefundenen Treffer werden im Error-Fenster ausgegeben. Button Cleanup Nach einer Sichtung der mit dem Button Analyze gefundenen Treffer, kann mit diesem Button die Bereinigung ausgeführt werden."
  },
  "doc/mlkey/mlstring.html": {
    "href": "doc/mlkey/mlstring.html",
    "title": "MLString",
    "keywords": "MLString Framework Studio bietet eine durchgängige Unterstützung für die Mehrsprachigkeit. An allen Stellen, an denen für den Anwender sichtbare Beschriftungen, Tooltips oder Meldungstexte gepflegt werden bietet Framework Studio einen Editor zur Bearbeitung von mehrsprachigen Texten (Multi Language String / MLString ) an. Der Editor wird in Form einer Tabelle angezeigt, in der die Verschiedenen Sprachen des Textes angezeigt und bei Bedarf auch bearbeitet werden. Die fett gedruckten Angaben sind an dieser Stelle überschrieben. Die normal gedruckten Angaben sind aus dem Basis-Package oder dem Basis-Record geerbt. Siehe auch Abschnitt Vererbung . An erster Stelle steht immer der MLKey . Dieser stellt einen Verweis auf das Wörterbuch dar. Es kann direkt ein MLKey eingeben werden oder mit dem Auswahl-Button ein Such-Dialog geöffnet werden. Dabei handelt es sich um den voll funktionsfähigen Multilanguage Text Editor erweitert um eine Auswahl-Funktion. In diesem Dialog können, wenn kein passender MLKey gefunden wurde, auch ein neuer Key erfasst werden. Die Texte in den einzelnen Sprachen werden im Designer und auch zur Laufzeit der Anwendung aus dem Wörterbuch ermittelt. Die angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Important Ist ein MLKey angegeben, dann ist es davon abzuraten, einzelne Texte zu überschreiben. Im Property-Grid wird der MLString in einer Zeile dargestellt, die zur Anzeige der einzelnen Sprachen erweitert werden kann. Die einzeilige Anzeige stellt einen kombinierten Text in Format @{MLKey} - {deutscher Text} dar. In diesem Text man auch direkt mit vorangestellten @ -Zeichen einen anderen MLKey eintragen - z.B. @LBL_ArticleID . Ein MLKey kann auch (wie oben beschrieben) am entsprechenden MLKey-Eintrag eingetragen oder ausgewählt werden. Vererbung Mit den verschiedenen Records in Framework Studio werden auch die entsprechenden MLStrings vererbt. Dadurch werden im Idealfall die am Metadatentyp definierten Texte über die komplette Kette bis hin zu den Form-Controls durchgereicht. Ein vererbter Text kann an jeder beliebigen Stelle in der Kette überschrieben werden. Es gibt 2 Möglichkeiten: Einen anderen MLKey zuweisen Damit werden alle anderen Texte aus der Basis inkl. MLKeys und den überschriebenen Texten ausgeblendet. Auch wenn der neue MLKey z.B. keinen Text für fr definiert hat, wird ein in der Basis definierter fr Text ausgeblendet. Einen einzelnen Text überschreiben: Warning Darauf sollte möglichst verzichtet werden. Wenn lediglich die Übersetzung gepflegt wird, dann erfolgt dies besser im Wörterbuch. Wenn eine abweichende Bedeutung gewünscht ist, dann sollte ein anderer MLKey angegeben werden. Das überschreibt nur den Text der entsprechenden Sprache. Die anderen nicht überschriebenen Sprachen werden weiter aus der Basis gezogen. Caution In der eNVenta/WS Standard-Entwicklung ist das verboten. Das folgende Bild zeigt eine Vererbungs-Hierarchie. Die Pfeile stellen den Weg dar, über den der Text für das Control ermittelt wird. Dabei wird hier die Sprache fr mit den Fallback-Sprachen en und de verwendet. Der erste Text der auf diesem Weg gefunden wird, wird ausgegeben."
  },
  "doc/mlkey/programmierung.html": {
    "href": "doc/mlkey/programmierung.html",
    "title": "Programmierung mit MLKeys",
    "keywords": "Programmierung mit MLKeys Klasse MLKeys Framework Studio generiert aus dem Wörtebuch eine Klasse MLKeys , die alle MLKeys beinhaltet. Sie wird im Compile-Schritt Ressource compiliert und steht somit in der kompletten Applikation zur Verfügung. Sie erbt die MLKeys aus dem Basis-Package - so z.B. auch die SYS_ -Keys aus dem System-Package. Die Klasse wird z.B. folgendermaßen verwendet: this.Global.GetMLText( MLKeys.LBL_Amount ); Alle Quellcodes, die mit MLKeys arbeiten, greifen auf diese Klasse zu - sowohl selbst geschriebener Methoden-Code als auch der von Framework Studio generierte Code. Dadurch findet der CSharp-Compiler alle Probleme, die im Zusammenhang mit MLKeys auftreten können: Compile-Error, wenn ein MLKey nicht mehr existiert. Auch wenn diese z.B. in einem Metadatentypen oder einem Form-Control verwendet werden. Eine Obsolete-Warning, wenn ein mit einer Obsolete-Message versehener MLKey verwendet wird. Die Obsolete-Message wird als Obsolete -Attribut vor den MLKey generiert. Eine Warning, wenn in einem Customizing-Package ein identischer MLKey definiert ist. Die generierte MLKeys -Klasse sieht in etwa so aus: public class MLKeys : BasisPackage_MLKeys { public static readonly MLKey LBL_Amount = new MLKey(\"LBL_Amount\"); public static readonly MLKey LBL_Article = new MLKey(\"LBL_Article\"); public static readonly MLKey TTT_Article = new MLKey(\"TTT_Article\"); public static readonly MLKey MSG_0da9815a719049ae806d3c0ba7d824ff = new MLKey(\"MSG_0da9815a719049ae806d3c0ba7d824ff\"); public static readonly MLKey MSG_0f2ad9d4385b49fc9667ed7eff2d925f = new MLKey(\"MSG_0f2ad9d4385b49fc9667ed7eff2d925f\"); [Obsolete(\"Please use LBL_Amount\")] public static readonly MLKey LBL_Amount2 = new MLKey(\"LBL_Amount2\"); } Warning Es sollten keine eigenen MLKey-Instanzen aus Strings erzeugt werden. Diese können vom Compiler nicht validiert werden. Code Editor Der Code-Editor bietet diverse Unterstützung bei der Arbeit mit der Klasse MLKeys . Im Intellisense werden alle MLKeys angeboten und im jeweiligen Tooltip wird zur besseren Orientierung der deutsche Text angezeigt. Fährt man mit der Maus über einen MLKey, dann wird ein Info-Tooltip mit dem deutschen Text angezeigt. Wird auf einem MLKey der Befehl Goto Definition (F12) ausgeführt, dann öffnet sich der Multilanguage Text Editor und es wird der entsprechende Eintrag selektiert. Methoden am Global-Object Das GlobalObject bietet mehrere Methoden an, mit denen ein MLKey in ein Text überführt werden kann. GetMLText(mlkey) GetMLText(mlkey, iso) GetMLKeyText(mlkey) FormatMLText(mlkey, args) FormatMLKeyText(mlkey, args) Für die Format-Funktionen wird die Client-Culture verwendet. Für die Verwendung einer spezifischen Culture gibt es entsprechende Überladungen: FormatMLText(culture, mlkey, args) FormatMLKeyText(culture, mlkey, args) cGlobal EntryPoint In der Klasse cGlobal gibt es einen zentralen Entry-Point GlobalGetMLText . Dieser wird JEDES MAL aufgerufen, wenn aus einem MLKey ein Text erzeugt wird."
  },
  "doc/mlkey/text-collections.html": {
    "href": "doc/mlkey/text-collections.html",
    "title": "Text-Collections",
    "keywords": "Text-Collections Text-Collections arbeiten ebenfalls mit MLKeys. Im Grunde sind sie eine Auflistung von MLKeys. Arbeitsweise Das Wörterbuch wird in xml-Dateien gespeichert. Diese liegen im Broker-Verzeichnis im Ordner lang . Die Dateien werden separat prop Package und Sprache mit dem folgenden Datei-Namen abgelegt: <package>.<iso>.lang.xml Beispiel: <broker-directory> |--lang | |--CustomPackage.de.lang.xml | |--eNVenta.de.lang.xml | |--eNVenta.en.lang.xml | |--eNVenta.fr.lang.xml | |--SystemPackage.de.lang.xml | |--SystemPackage.en.lang.xml Zur Laufzeit werden diese Dateien bei Bedarf einmalig für die benötigten Sprachen eingelesen. Dabei wird die Package-Hierarchie berücksichtigt."
  },
  "doc/mlkey/woerterbuch.html": {
    "href": "doc/mlkey/woerterbuch.html",
    "title": "Wörterbuch",
    "keywords": "Wörterbuch Alle mehrsprachigen Texte der Anwendung werden in einem zentralen Wörterbuch abgelegt. Organisiert werden die Einträge mit einem eindeutigen alphanumerischen Schüssel - dem MLKey . Die MLKeys und deren Texte können folgendermaßen genutzt werden: In den MLString -Properties überall in Framework Studio Im selbst geschriebenen Methoden-Code (siehe Programmierung ) In den Code-Messages (Exceptions, Message-Boxen) Multilanguage Text Editor Die Bearbeitung des Wörterbuchs erfolgt über den Multilanguage Text Editor . Dieser wird über das Menü Tools / Multilanguage Text Editor geöffnet. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Die Bearbeitung des Wörterbuchs funktioniert ohne Checkout-Mechanismus. Wenn mehrere Benutzer zur gleichen Zeit an denselben MLKeys arbeiten sollten, dann gewinnt derjenige, der zuletzt den Button Save drückt. Der Editor sammelt alle vorgenommenen Änderungen (Add, Edit, Delete) im Hintergrund. Mit dem Button Save werden diese in das Repository gespeichert. Dabei wird in einer Transaktion zuerst der aktuelle Stand frisch aus dem Repository gelesen, dann die Änderungen erneut auf diesen (evtl. durch einen anderen Benutzer veränderten) Stand angewendet und zuletzt der neue Stand wieder zurück in das Repository gespeichert. Das hat die Folge, dass nach einem Save Änderungen sichtbar sind, die zuvor von einem anderen Benutzer vorgenommen wurden. Eine Ausnahme sind die Basis-Packages. Diese werden aus einem Stand gezogen, den der FrameworkCompiler zum Zeitpunkt des Compile-Laufs in den Workspace gespeichert hat. Suchen von MLKeys Essentiell für die tägliche Arbeit ist das Auffinden von existierenden MLKeys. Dazu wird das Search Feld angeboten. Die Suche scannt alle Felder des MLKeys: MLKey, Comment, Obsolete, Texte. Die Groß-Klein-Schreibung wird nicht berücksichtigt. Es können mehrere Worte eingegeben werden. Dann müssen alle Worte oder Wortteile in irgend einem Feld auftauchen. z.B. MSG_ Artikel Save sucht nach Messages die mit Artikel und Save zu tun haben. Generell wird nach Wortteilen gesucht. Wenn man das Wort oder den Text in Anführungszeichen setzt, wird nach einem exakten Treffer und ganzen Worten gesucht. Das funktioniert auch mit mehreren Worten und in Kombination mit der normalen Suche. z.B. LBL_ \"Kunde\" Ziel des Wörterbuches ist es, Texte wiederzuverwenden und die Anzahl der Einträge auf das Nötigste zu reduzieren. Aus diesem Grund sollte man immer zuerst nach einem MLKey suchen, bevor man einen neuen erfasst. Zu einem logischen Begriff sollen keine zwei MLKeys existieren. Tip Die Suche sollte durchaus kreativ gestaltet werden - besonders bei Texten die eigentlich schon vorhanden sein müssten. Ein Beispiel dafür ist das Wort Einfügen . Möchte man dieses mit der englischen Bezeichnung Add nutzen, stellt man fest, dass es Einfügen schon mit mehreren Übersetzungen gibt, jedoch keine mit der englischen Bezeichnung Add . Sucht man dann aber direkt nach Add , so findet man den statt Einfügen zu verwendenden deutschen Text Hinzufügen . Dependencies von MLKeys suchen Mit der Betätigung des Buttons Search Dependencies , werden alle Abhängigkeiten von jedem MLKey gesucht. Nach erfolgreicher Suche wird eine neue Spalte Dependencies eingeblendet, in der die Anzahl der gefundenen Abhängigkeiten abgebildet wird. Mit einem Doppelklick auf einen Eintrag in der neu hinzugefügten Spalte wird eine detaillierte Ansicht mit den gefundenen Abhängigkeiten für den ausgewählten MLKey angezeigt. Erfassen neuer MLKeys Mit dem Button Add öffnet sich ein Dialog, in dem der neue MLKey erfasst werden kann. Textfeld MLKey Hier wird der MLKey angegeben. Im Customizing-Package wird der Package-Code automatisch vorbelegt. Note Der MLKey kann zu einem späteren Zeitpunkt nicht mehr geändert werden. Der MLKey kann frei vergeben werden, es gibt jedoch ein paar Regeln und Empfehlungen: Es handelt sich um einen C#-Identifier, der auch im Quellcode verwendet wird. Buchstaben, Zahlen, Unterstrich Groß-Klein-Schreibung ist relevant Der sprechende Name sollte sich nach Möglichkeit an den englischen Text anlehnen. z.B. LBL_Article Wenn der Text zu komplex ist - z.B. bei Messages oder Tooltips, dann kann der Name eine Guid enthalten. Diese kann mit dem Button Generate Guid angefügt werden. z.B. MSG_1c9f3024dfc340dfba0651cb92d90ad6 In Customizing-Packages erhält der MLKey einen Package-Code. Dieser wird automatisch vorbelegt. z.B. LBL_K87_SpecialArticle In der eNVenta/WS Standard-Entwicklung sind entsprechende Namensregeln einzuhalten. Wird dieser Dialog aus der MLKey-Suche heraus geöffnet, dann wird abhängig vom jeweiligen Context auch ein passender Präfix vorbelegt: LBL_ / LBL_<PackageCode>_ : Der Suchdialog wurde z.B. aus einem Caption- oder Default-Label-Property aufgerufen. TTT_ / TTT_<PackageCode>_ : Der Suchdialog wurde aus dem Tooltip-Property aufgerufen. MSG_ / MSG_<PackageCode>_ : Der Suchdialog wurde aus dem MessageBox- bzw. Exception-Wizard aufgerufen. Feld Comment Der Kommentar beschreibt bei Bedarf den MLKey genauer. Das ist sinnvoll, wenn der Text oder auch der MLKey erklärungsbedürftige Abkürzungen beinhaltet oder wenn es ähnliche Texte mit verschiedenen Verwendungszwecken gibt. Textfeld Obsolete Ein MLKey kann durch die Eingabe einer Obsolete-Message als veraltet markiert werden. Der Compiler wird bei Verwendung dieses MLKeys diese Message als Warning ausgeben. Weil das Löschen von MLKeys vor allem im Hinblick auf Customizing-Packages Compile-Errors erzeugt, sollte davon abgesehen und stattdessen diese Obsolete-Message verwendet werden. Ein Hinweis auf einen alternativ zu verwendenden MLKey ist empfehlenswert. Textfeld German Die Eingabe eines deutschen Textes ist Pflicht, weil Deutsch immer der letzte Fallback ist, wenn eine Fremdsprache nicht gepflegt ist. Fremdsprachen Über die Radio-Buttons kann festgelegt werden, welche Sprache im 2. Textfeld angezeigt oder bearbeitet werden soll. Diese Texte sind optional. Die angebotenen Fremdsprachen und deren Reihenfolge kann in den Options mit der Einstellung Languages in designer eingestellt werden. German lässt sich in diesem Dialog aber nicht steuern - diese Sprache wird immer im separaten Feld angezeigt. In der eNVenta/WS Standard-Entwicklung muss der englische Text gepflegt werden. Button Untranslatable Es gibt Texte, die nicht übersetzt werden können wie z.B. Eigennamen oder Einheiten. Dieser Button löscht alle Fremdsprachen-Texte und Schreibt den Text untranslatable in das Comment Feld. Mit der Routine MLKeys Cleanup ist es möglich, systematisch nach Texten zu suchen, die dafür geeignet sind. Bearbeiten von MLKeys Mit dem Button Edit wird für den selektierten MLKey der Bearbeitungs-Dialog geöffnet. Durch einen Doppelklick in das Grid kann der Bearbeitungs-Dialog ebenfalls geöffnet werden. Dabei wird der Fokus automatisch in das Feld gesetzt, das der angeklickten Grid-Zelle entspricht. Das ist praktisch, wenn man z.B. gezielt eine Fremdsprache bearbeiten möchte. Außerdem können einzeilige Texte direkt im Grid bearbeitet werden. Note Die logische Bedeutung des MLKeys darf zu einem späteren Zeitpunkt nicht mehr geändert werden. Der Dialog ist gleich aufgebaut wie der Add-Dialog. Es werden zusätzlich das Create Date des MLKeys und die Edit -Informationen der Fremdsprachen-Texte (Datum und Benutzer der letzten Bearbeitung) angezeigt. Note Der Benutzer wird bei alten Texten ggf. nicht angezeigt, weil dieses Feature erst zu einem späteren Zeitpunkt implementiert wurde. Der MLKey kann nicht bearbeitet werden. Wird im Customizing-Package ein MLKey aus dem Basis-Package geöffnet, dann sind einige weitere Felder für die Bearbeitung gesperrt: Comment / Button Untranslatable , Obsolete Die Texte können bearbeitet werden. Mit dem Button View History wird ein weiteres Fenster geöffnet, in dem die Version des Eintrages vor der letzten Bearbeitung angezeigt wird. Siehe Abschnitt History . Copy Entry / Paste Entry Wenn man ein oder mehrere Einträge selektiert hat, kann man mit dem Button Copy Entry diese in die Zwischenablage kopieren. Mit dem Button Paste Entry können diese Einträge z.B. in einer anderen Version des Packages eingefügt werden. Intern benutzt diese Funktion den Import- / Export-Mechanismus . Dieser verwendet ein XML im TMX-Format. Dadurch ist es möglich, das XML vor dem Paste Entry bei Bedarf in einem Text-Editor zu manipulieren, z.B. um den PackageCode des MLKey anzupassen. Mit Paste Entry werden neue MLKeys hinzugefügt. Enthält die Zwischenablage existierende Keys, dann wird vor dem Einfügen ein Auswahl-Dialog angezeigt. Ignore : Es werden keinerlei Einträge ersetzt. Lediglich unbekannte, neue MLKeys werden hinzugefügt. Replace : Es wird der komplette existierende Eintrag ersetzt. Wenn in der Zwischenablage ein Wert nicht gesetzt ist, dann wird dieser entfernt. Merge : Die beiden Einträge werden zusammengeführt. Dabei gewinnt jeweils der Text mit dem neueren Edit-Date. Mit dem Button Cancel wird die komplette Aktion abgebrochen. Dann werden auch keine MLKeys hinzugefügt. Customizing Jedes Customizing-Package verwaltet sein eigenes Wörterbuch. Es können neue MLKeys angelegt werden. Diese müssen den Package-Code enthalten, damit es in Zukunft keine Kollisionen mit Basis-Packages gibt. Bevor ein neuer MLKey angelegt wird, sollte immer geprüft werden, ob es nicht doch einen passenden MLKey gibt. Texte aus Basis-Packages können überschrieben bzw. ergänzt werden. So können z.B. Übersetzungen für Fremdsprachen gepflegt werden. Es muss darauf geachtet werden, dass die Bedeutung des MLKeys nicht geändert wird, weil dieser ggf. an mehreren Stellen in der Anwendung verwendet wird. Wird an einer bestimmten Stelle in der Anwendung ein anderer Text benötigt (in eNVenta kann das z.B. der Text \"Code1\" sein, der ersetzt werden soll) dann muss an dieser Stelle (jedoch möglichst weit unten in der DBColumn oder Metadatentyp) ein anderer MLKey zugeordnet werden. (siehe auch MLString-Vererbung ) Im Customizing-Package übersetzte Texte können exportiert und in das Basis-Package importiert werden. Zu einem späteren Zeitpunkt können die dann redundanten Übersetzung mit der MLKeys Cleanup Routine bereinigt werden. History Bei jeder Bearbeitung im Wörterbuch wird die Vorgänger-Version des MLKeys in einen separaten History-Bereich geschrieben. Aus dem Edit-Dialog heraus kann diese Information mit dem Button View History geöffnet werden. Gibt es keine Informationen, ist der Button deaktiviert. Die History arbeitet pro Sprache. Wird z.B. der englische Text bearbeitet, wird auch nur der alte englische Text mit seinem alten Änderungs-Datum in den History-Bereich übertragen. Die History-Informationen der anderen Sprachen bleiben unverändert. Eine leere Eigenschaft wird nicht historisiert - das gilt insbes. für Comment und Obsolete Message . Wird eine dieser Eigenschaften geleert, dann verbleibt der alte Text auch dann in der History, wenn später wieder ein neuer Text gesetzt wird. Wird ein MLKey gelöscht , wird der komplette Eintrag mit allen Sprachen in die History übertragen. Dieser kann jedoch zu einem späteren Zeitpunkt nicht mehr ohne weiteres gegriffen werden. Tip Wurde ein MLKey versehentlich gelöscht und es gibt einen Compile-Error mit dem entsprechenden MLKey, dann kann man diesen Eintrag wieder neu im Wörterbuch anlegen. Beim anschließenden Bearbeiten des MLKeys können dann die noch existierenden History-Informationen eingesehen werden. Gefüllt wird die History mit dem Save -Button. Framework Studio sammelt alle im Wörterbuch vorgenommenen Änderungen und speichert diese mit dem Save -Button in einem Rutsch. Dadurch kann ein Text auch mehrfach hintereinander geändert werden. Erst nach dem Save steht der alte Text in der History. Note Beim Labeln der Package-Version wird die History-Information nicht in die neue Package-Version übernommen. Die History-Informationen berücksichtigen nur das aktuelle Package. Weil für Basis-Packages das Wörterbuch aus dem letzten Framework-Compiler-Stand gelesen wird, enthält es keine History-Informationen."
  },
  "doc/namespace/namespace.html": {
    "href": "doc/namespace/namespace.html",
    "title": "Namespaces",
    "keywords": "Namespaces Die Namespaces sind, wie im .NET die Klassen, systematisch zu gruppieren. In einer leeren Anwendung stehen im SystemPackage ( Packages ) bereits einige Namespaces zur Verfügung, die Framework Studio benötigt, um einige Dinge zu organisieren. Zum einen gibt es den System -Namespace. Hier sind bereits die einfachen Typen von .NET wie z.B. string, int und long als Komponenten angelegt. Darunter gibt es einen Namespace Framework Studio , in dem System-Klassen abgelegt sind, die Framework Studio anbietet. Zu diesen Klassen gehört z.B. DevFrameworkObject , welches die Basis-Klasse aller Components in Framework Studio darstellt oder die FS-Datentypen , die sich fast wie die .NET-Datentypen verhalten, aber zusätzlich NULL als Wert annehmen können. Im Unternamespace Metadatatypes sind die Basis-Metadatentypen für Datenbankspalten hinterlegt. Alle diese hier angebotenen Klassen können im Framework Studio nicht editiert werden – die Datentypen lassen sich nicht öffnen. Sie werden angezeigt, damit sie später in den Components oder Forms als Datentyp für Properties ausgewählt werden können. Ein weiterer besonderer Namespace ist der Namespace FSGeneral . Dieser Namespace wird von allen anderen Namespaces automatisch (durch eine using-Direktive) eingebunden und daher als erstes kompiliert. Neue Namespaces können nur im Unterordner Resources angelegt werden. Im Namespace FSGeneral befinden sich folgende Unter-Namespaces, die im DefaultPackage (und ggf. in weiteren Packages) diese Elemente enthalten: Controls In diesem Namespace werden alle Default Control Styles und alle Custom Controls angezeigt. DBTables In diesem Namespace werden alle Datasources und unterhalb der Datasouces die DBTables , die an dem jeweiligen Datasouce definiert wurden, angezeigt. GlobalObjects In diesem Namespace werden alle Global Objects angezeigt. Resources In diesem Namespace werden alle Resources angezeigt. Unternamespaces haben dabei die Bedeutung von Unterordnern im Brokerverzeichnis. Dieser Namespace ist der einzige in FSGeneral , in dem neue Namespaces angelegt werden dürfen! Namespace erstellen / löschen Erstellen eines Namespaces Elemente erstellen Löschen eines Namespaces Elemente löschen Warning Ein Namespace kann nur gelöscht werden, wenn er keine Elemente mehr enthält. Namespace umbenennen Um den Namespace zu einem späteren Zeitpunkt umbenennen zu können, bietet das Kontext-Menu des Namespaces den Eintrag Rename . Da sich Framework Studio für eingecheckte Elemente den generierten Quellcode merkt, kann ein Umbenennen eines Namespaces im laufenden Betrieb Probleme mit sich bringen. Der Name des Namespaces sollte deshalb schon beim Anlegen gut überlegt sein. Spätestens beim ersten CheckIn sollte der Name feststehen, damit andere Entwickler, die diesen Namespace bereits verwenden, keine Probleme bekommen. Caution Lässt es sich dennoch nicht vermeiden, einen Namespace umzubenennen, muss danach der gesamte zwischengespeicherte Code der Anwendung gelöscht und neu erzeugt werden. Nähere Informationen dazu gibt es im Abschnitt Code Builder und Kompilieren als FrameworkCompiler ."
  },
  "doc/package-manager/administrative-mode.html": {
    "href": "doc/package-manager/administrative-mode.html",
    "title": "Administrative Mode",
    "keywords": "Administrative Mode Für einige Aktionen auf dem Repository ist es notwendig, dass alle Entwickler das Repository verlassen: Labeln einer Version und öffnen einer neuen Importieren von Packages Update des Repositories Einige Daten werden im Repository mit Triggern bearbeitet. Zudem gibt es Absicherungen durch Constraints. Bei den oben aufgeführten Aktionen werden die Trigger und Constraints zum Teil deaktiviert. Das ist aus Performance-Gründen notwendig. Dieses Deaktivieren hätte ggf. zur Folge, dass im Repository falsche Daten entstehen können. Ist der Admin-Mode aktiviert, wird der Menüeintrag rot hervorgehoben. Der Modus kann nur aktiviert werden, wenn kein Entwickler am Repository angemeldet ist. Ist dies der Fall, wird ein Dialog angezeigt mit der Information, welche Benutzer derzeit noch angemeldet sind und der Option diese Sitzungen zu beenden. Falls noch Benutzer angemeldet sind, wird dieser Dialog angezeigt. Hier gibt es die folgenden Möglichkeiten: Cancel – den Vorgang abbrechen Retry – es erneut versuchen, nachdem z.B. dem Benutzer Bescheid gegeben wurde Kill User Sessions – die Sitzungen der Benutzer zu beenden. Bei dieser Aktion wird 130 Sekunden gewartet. Das ist die Zeit, die im Extremfall benötigt wird, bis ein Benutzer zum Beenden seiner Sitzung gezwungen wurde. (60 Sekunden bis zur Hinweismeldung + 60 Sekunden bis zum endgültigen Abbruch + 10 Sekunden Reserve) Während dieser Dialog angezeigt wird, können sich keine neuen Benutzer mehr anmelden. Befindet sich ein Repository im Admin-Mode, können sich keine Benutzer mehr darauf anmelden. Diese erhalten dann folgende Meldung. Sollte man vergessen, dass der Admin-Mode aktiv ist, wird man beim Schließen des Package-Managers darauf aufmerksam gemacht."
  },
  "doc/package-manager/compile-wizard.html": {
    "href": "doc/package-manager/compile-wizard.html",
    "title": "Compile Wizard",
    "keywords": "Compile Wizard Der Compile Wizard ermöglicht das automatische Kompilieren eines Labels mit den davon abhängigen Labels. Alle Einstellungen für einen solchen Vorgang können gespeichert und wieder geladen werden. Außerdem lässt sich der Compile Wizard per Kommandozeilenparameter mit einer zuvor gespeicherten Konfiguration automatisch starten. Warning Es wird immer ohne Use saved code kompiliert. Starten des Wizards Der Compile Wizard wird über den Eintrag Compile Wizard im Kontextmenü eines Labels gestartet. Im Compile Wizard werden auf der linken Seite in einem Treeview das ausgewählte Label und alle davon abhängigen Labels angezeigt. Wurzelknoten ist das ausgewählte Label. Alle davon abhängigen Labels werden auf der ersten Ebene dargestellt. Sind von diesen Labels wiederrum weitere Labels abhängig, werden diese auf einer weiteren Ebene dargestellt. Im folgenden Screenshot ist zum Beispiel das Label CustomizingTestLevel2 1.0 abhängig vom Label CustomizingTest 1.0 . Deshalb wird es (auch) als Unterknoten von CustomizingTest 1.0 angezeigt. Im Treeview kann für jedes Label über die dazugehörige Checkbox festgelegt werden, ob dieses Label kompiliert werden soll. Auf der rechten Seite werden daraus resultierend alle Labels in der Reihenfolge angezeigt, in der sie kompiliert werden. Tip Wenn man mehrere Labels (Versionen) desselben Packages hintereinander kompilieren möchte, kann man den Compile Wizard über das Kontextmenü des Labels SystemVersion vom SystemPackage öffnen. Es werden dann alle Labels angezeigt, da alle Labels von diesem Label abhängig sind. Checkbox Refresh workspace of FrameworkCompiler before each compile Wenn diese Checkbox gesetzt ist, wird der Workspace des FrameworkCompilers vor dem Kompilieren eines Labels für dieses Label aktualisiert. Button Start Compile Mit diesem Button wird der gesamte Kompiliervorgang gestartet. Tritt beim Kompilieren ein Fehler auf, wird der gesamte Kompiliervorgang unterbrochen. Button Stop after this Label Mit diesem Button kann der Kompiliervorgang zwischen den einzelnen Labels abgebrochen werden. Einstellungen exportieren Im Compile Wizard kann über den Menüpunkt File / Export Settings die aktuelle Konfiguration in eine XML-Datei exportiert werden. In dieser Datei sind die folgenden Informationen enthalten: ConnectionString für den Zugriff auf das Repository (verschlüsselt) Zu kompilierende Labels Soll der Workspace vor dem Kompilieren aktualisiert werden? Mit dieser XML-Datei ist es möglich, ein Kompiliervorgang für mehrere Packages / Labels per Kommandozeile anzustoßen Einstellungen importieren Im Compile Wizard können Sie eine gespeicherte Konfiguration über den Menüpunkt File / Import Settings importieren. Start per Kommandozeilenparameter Der folgende Aufruf startet den Package-Manager, öffnet den Compile Wizard mit den Einstellungen, die in der Datei Settings1.XML abgelegt sind und startet den Kompiliervorgang. FrameworkStudioPackageManager.exe \\compileXML \"C:\\Settings1.XML\" So ist es z.B. möglich den Package-Manager über einen geplanten Task zu starten und so das regelmäßige Kompilieren mit dem FrameworkCompiler automatisch durchzuführen. Idealerweise sollte dieser Vorgang am Abend gestartet werden, nachdem die Entwickler ihre Elemente in einem kompilierfähigen Zustand eingecheckt haben."
  },
  "doc/package-manager/export.html": {
    "href": "doc/package-manager/export.html",
    "title": "Export einer Package-Version",
    "keywords": "Export einer Package-Version Über den Button kann die im Baum ausgewählte Package-Version in eine Datei exportiert werden. Diese Datei kann anschließend in einem anderen Repository wieder importiert werden. Es wird folgender Dialog angezeigt: Package File hier wird die Datei angegeben, in welche die Package-Version exportiert werden soll. Der Datei-Name wird automatisch mit dem Format <Datum_Package_Version> vorbelegt. Dieser sollte nach Möglichkeit nicht geändert werden. Export Code Es wird standardmäßig der Code exportiert. Der Code beinhaltet dabei sämtlichen Methoden-Code und auch den vom FrameworkCompiler generierten Code. Include Base Packages Wenn diese Checkbox gesetzt wird, dann wird ein Bereich eingeblendet, in dem angegeben werden kann, welche Basis-Packages mit in die Export-Datei gepackt werden sollen. Dies funktioniert auch bei importierten Basis-Packages. Im Vergleich zum Export der einzelnen Package-Versionen hat dieses Vorgehen den Vorteil, dass auf jeden Fall der passende Compile-Stand des Basis-Packages verwendet wird – auch wenn das Basis-Package später neu kompiliert wurde und dafür ein aktuellerer FrameworkCompiler-Stand zur Verfügung steht. Wenn die Checkbox gesetzt wird, dann werden automatisch folgende Packages ausgewählt: Export unsealed Base Packages Damit werden alle Package-Versionen ausgewählt, die nicht versiegelt wurden. Diese Option ist z.B. beim Einsatz von noch offenen Vorab-Versionen sinnvoll. Export Service Releases Damit werden alle Service-Releases ausgewählt. Dies bedingt aber, dass im Ziel-Repository bereits ein aktueller Stand des Basis-Packages importiert wurde. Bei Bedarf können auch gezielt weitere Packages ausgewählt werden. Bei Package-Versionen, die sich im Service-Release-Modus befinden kann mit der Checkbox Export Full Package statt dem Service-Release-Paket die komplette Package-Version eingebunden werden. Beim Package-Import werden automatisch alle in der Export-Datei beinhalteten Packages importiert – die Auswahl kann nur beim Export getroffen werden. Bei Service-Releases erfolgt ein Import nur dann, wenn nicht bereits ein aktuellerer Service-Release-Stand vorhanden ist. Note Ein neues Repository kann mit so einer Export-Datei nicht angelegt werden. Dies ist nur mit dem Export des Default-Packages möglich."
  },
  "doc/package-manager/package.html": {
    "href": "doc/package-manager/package.html",
    "title": "Package",
    "keywords": "Package In der Baumstruktur des Package Managers werden alle Packages des Repositories in alphabetischer Reihenfolge auf der ersten Ebene dargestellt. Durch Doppelklick auf ein Package wird ein Fenster geöffnet, in dem grundlegende Eigenschaften des Packages bearbeitet werden können. Package Eigenschaften: Name Name des Packages. Manufacturer Name des Package Herstellers. Owner Ist in der Checkbox ein Haken gesetzt, wird dadurch angezeigt, dass Sie der Eigentümer des Packages sind. Wenn Sie ein neues Package erstellen, sind Sie automatisch der Eigentümer. Warning Der Eigentümer eines Packages ist der einzige, der Lizenzen für ein Package erstellen kann. Diese Eigenschaft kann nicht geändert werden! Wenn man Eigentümer eines Packages ist und dieses zunächst exportiert, um es anschließend wieder zu importieren, ist man nicht mehr Eigentümer des importierten Packages! Package prefix Hier kann ein Präfix angegeben werden, das einheitlich bei allen neu erstellten Elementen in diesem Package dem normalen Namen voran gestellt wird. Dadurch werden Namenskonflikte zwischen verschiedenen Packages vermieden. Beispiel (Package prefix = NV1 ): Neues Form wird mit dem Namen NV1 _frm initialisiert. Damit das Präfix verwendet wird, muss außerdem die im Folgenden beschriebene Checkbox gesetzt sein."
  },
  "doc/package-manager/package-lizenz.html": {
    "href": "doc/package-manager/package-lizenz.html",
    "title": "Lizenzen",
    "keywords": "Lizenzen In der Baumstruktur des Package Managers wird unterhalb eines Packages ein Ordner Licenses angezeigt. In diesem Ordner werden alle Lizenzen des Packages mit dem Symbol dargestellt. Diese Lizenzen legen fest, wie das Package zur Entwicklung verwendet werden darf. Durch einen Doppelklick auf eine Lizenz wird ein Fenster geöffnet, in dem alle Eigenschaften der Lizenz angezeigt werden. Warning Die Eigenschaften können nach dem ersten Speichern der Lizenz nicht mehr geändert werden. Eine neue Lizenz kann über den Menüpunkt New / License angelegt werden. Anschließend können die folgenden Angaben gemacht werden: Name Name der Lizenz Customer Lizenznehmer Serial Number Frei definierbare Seriennummer Generation Date Datum, an dem die Lizenz erzeugt wurde. (nicht editierbar ) Package Package, für das die Lizenz gültig ist. (nicht editierbar ) Edit Permission Recht, wie das Package bearbeitet werden darf. Zur Auswahl stehen: ReadWithoutCode: Leserechte ohne Sourcecode. Das bedeutet, dass beispielsweise nur Methodendefinitionen, nicht der Inhalt der Methoden zur Verfügung steht. ReadWithCode: Leserechte auch auf den Sourcecode. Write: Volle Lese- und Schreibrechte. Use Permission Customizing-Recht. Zur Auswahl stehen: ReadOnly: Customizing ist nicht erlaubt CustomizeFormsAndWorkflows: Customizing für Forms und Workflows CustomizeAll: Volle Customizing-Rechte Note Lizenzen können außerdem mit dem Package Manager importiert und exportiert. Siehe dazu Bedienung des Package Managers ."
  },
  "doc/package-manager/package-manager.html": {
    "href": "doc/package-manager/package-manager.html",
    "title": "Package Manager",
    "keywords": "Package Manager Der Package Manager von Framework Studio ist ein eigenständiges Programm. Mit diesem Tool lassen sich die folgenden Aufgaben rund um Packages erledigen: Anlegen, Löschen und Bearbeiten sowie Import und Export von Packages und Package Lizenzen Definition, welche Sprachen eine Anwendung grundsätzlich unterstützen soll Fixierung eines Entwicklungsstandes (Versionierung / Labeling) Verzweigung von Entwicklungspfaden (Branching) Folgende Funktionen stehen sowohl im Package Manager als auch in Framework Studio zur Verfügung: Runtime License Manager ( Laufzeitlizenzen Publish Wizard Publish2Go Wizard Start des Package Managers Starten Sie den Package Manager, indem Sie im Programmverzeichnis von Framework Studio die Datei FrameworkStudioPackageManager.exe ausführen. Es erscheint der Dialog zur Auswahl eines Repositories (analog zum Start von Framework Studio start . Nach der Repository-Auswahl werden Sie aufgefordert, sich als FrameworkAdministrator anzumelden. Bedienung des Package Managers Nach dem Start des Package Managers erscheint das Hauptfenster. Im Hauptfenster werden über die Toolbar folgende Funktionen angeboten: New Sie erkennen New an einem -Icon. Anlegen eines neuen Packages, einer neuen Lizenz oder einer neuen Sprache. Um eine neue Sprache anlegen zu können, muss in der Baumstruktur ein Default-Package (also das unterste Package in der Package-Hierarchie einer Anwendung) ausgewählt sein, da Sprachen nur am Default-Package definiert werden. Um neue Lizenzen anlegen zu können, muss man Eigentümer eines Packages sein ( Package ). Delete Sie erkennen Delete an einem -Icon. Löschen der in der Baumstruktur ausgewählten Lizenz ( Lizenzen ), Version ( Package-Versionen ) oder Sprache ( Sprachen ). Versionen dürfen nur mit dem Package Manager der aktuellsten Framework Studio Version gelöscht werden, die im Repository zum Einsatz kommt! Save Sie erkennen Save an einem -Icon. Speichern der Änderungen am ausgewählten Element. Save All Sie erkennen Save All an einem -Icon. Speichern aller Änderungen. Label Sie erkennen Label an einem -Icon. Erzeugt eine neue Package-Version auf gleicher Ebene und versiegelt dabei die Ursprungsversion (Status= sealed ). Ausgecheckte Elemente werden dabei in die neue Version übertragen. Beispiel : Label 3.0 => 3.1 Der Status der Ursprungsversion kann anschließend bei Bedarf auf Service-Release oder wieder zurück auf Open gesetzt werden. Branch Sie erkennen Branch an einem -Icon. Erzeugt eine neue Package-Version eine Ebene tiefer und verändert den Zustand der Ursprungsversion dabei nicht. Ausgecheckte Elemente verbleiben in der Ursprungsversion. Beispiel Branch 3.0 => 3.0.2 Import Package Sie erkennen Import Package an einem -Icon. Importieren einer Package-Version. Nach dem Import ist es in der Regel notwendig, abhängige Package-Versionen zu compilieren bzw. passende Stände von abhängigen Package-Versionen zu importieren. Export Package Sie erkennen Export Package an einem -Icon. Exportieren der ausgewählten Package-Version. Import License Sie erkennen Import License an einem -Icon. Importieren einer Package Lizenz (PKL) Export License Sie erkennen Export License an einem -Icon. Exportieren der ausgewählten Lizenz Export Service Release Sie erkennen Export Service Release an einem -Icon. Exportiert den Service Release Stand der ausgewählten Package-Version. Dabei werden nur die Änderungen seit dem Eröffnen des Service Release Modus übernommen. Dadurch entstehen deutlich kleinere Dateien als beim normalen Package-Export. Import Service Release Sie erkennen Import Service Release an einem -Icon. Importiert einen Service Release Stand, welcher zuvor mit Export Service Release exportiert wurde. Durch den Import ändert sich der Compile-Stamp nicht, deshalb müssen die abhängigen Package-Version nicht neu compiliert werden. Über das Menü Tools / Publish / Wizard bzw. Tools / Publish / 2Go kann der Publish- bzw. der Publish2Go-Wizard für die ausgewählte Package-Version aufgerufen werden. Über das Menü Tools / Check Using Hierarchies des Hauptmenüs können die Abhängigkeiten der Packages überprüft werden. Über das Menü Tools / Runtime Licenses Manager kann der Runtime License Manager ( Laufzeitlizenzen ) für die ausgewählte Package-Version gestartet werden. In der Baumstruktur des Package Managers werden Packages , Package-Versionen , Lizenzen und Sprachen hierarchisch dargestellt. Die einzelnen Elemente werden im Folgenden genauer beschrieben."
  },
  "doc/package-manager/packages.html": {
    "href": "doc/package-manager/packages.html",
    "title": "Packages",
    "keywords": "Packages Ein Package kapselt funktionale Erweiterungen und Veränderungen der Anwendung. Eine mit Framework Studio erstellte Anwendung setzt sich immer aus mehreren Packages zusammen. Aus welchen Packages letztendlich eine Anwendung zusammengesetzt ist, steht zur Entwicklungszeit eines Packages nicht fest. Klar definiert ist nur, welche Packages vorausgesetzt werden. Einzelne Packages einer Anwendung können von unterschiedlichen Herstellern entwickelt werden und mit Packages anderer Hersteller kombiniert werden. Hauptvorteil des Package-Konzepts von Framework Studio sind die Customizing Möglichkeiten. Kunden und Partnerunternehmen können durch das Hinzufügen eines zusätzlichen Packages die Anwendung nahezu ohne Einschränkungen funktional erweitern und verändern. Dabei sind sogar Erweiterungen an zentralen Datenstrukturen, Datenbanktabellen und Prozessabläufen möglich. SystemPackage Wenn Sie ein leeres Repository anlegen, enthält dieses Repository immer automatisch ein Package mit dem Namen SystemPackage . An diesem Package können Sie sich beim Start von Framework Studio nicht anmelden, da am SystemPackage keine Veränderungen vorgenommen werden können. Das SystemPackage enthält einige grundlegende Namespaces und Elemente, die von jeder Anwendung benötigt werden. Default Package Mit Default Package wird das Package bezeichnet, welches in der Verwendungsreihenfolge der Packages direkt oberhalb des SystemPackages angeordnet ist. Dieses Package hat einige Besonderheiten: Am Default Package werden die Sprachen definiert, die grundsätzlich von der Anwendung unterstützt werden sollen. Verschiedene Default Packages lassen sich mit der aktuellen Framework Studio Version nicht zusammen führen. Im Default Package werden alle Standard Controls ( Default Control Styles ) angezeigt. Ein Default Package muss mit dem Package Manager ( Package Manager ) angelegt werden, bevor es genutzt werden kann. Weitere Packages Mit Hilfe des Package Managers ( Package Manager ) können weitere Packages zu einem Repository hinzugefügt werden. Dort wird auch definiert, in welcher Reihenfolge die Packages benutzt werden sollen und welche anderen Packages Voraussetzung für die Verwendung eines Packages sind. Aktives Package Mit aktivem Package wird das Package bezeichnet, an dem sich der Benutzer beim Start von Framework Studio angemeldet hat. Nur an diesem Package kann der Benutzer Veränderungen durchführen. Synonym dazu wird auch der Begriff Top Package verwendet. Customizing Mit Customizing wird der Vorgang bezeichnet, bei dem man Änderungen an einem Element aus einem Package vornimmt, das nicht das aktive Package ist. Da Änderungen immer nur im aktiven Package durchgeführt werden können, wird dazu von dem gewünschten Element eine Customization im aktiven Package angelegt. An dieser Customization können die gewünschten Änderungen dann vorgenommen werden. Technisch gesehen ist eine Customization eine Ableitung vom originalen Element. Diese Ableitung wird dann in der gesamten Anwendung statt des Originalen Elements verwendet. Das Anlegen einer Customization erfolgt über den Button Customize ( Buttons ). Warning Wenn ein Element über das Kontextmenü mit der Funktion Change Namespace… in einem anderen Package in einen anderen Namespace verschoben wurde, so muss das Element, wenn eine Customization im aktiven Package existiert, über das Kontextmenü seines Namespaces mit der Funktion Adjust moved customizations … auch im aktiven Package in den neuen Namespace verschoben werden."
  },
  "doc/package-manager/package-version.html": {
    "href": "doc/package-manager/package-version.html",
    "title": "Package-Versionen",
    "keywords": "Package-Versionen In der Baumstruktur des Package Managers werden unterhalb eines Packages alle definierten Entwicklungsstände (Versionen) mit dem Symbol für Version dargestellt. Durch Doppelklick auf eine Version wird ein Fenster geöffnet, in dem alle Einstellungen zu der Version vorgenommen werden können. Package Name des Package Herstellers ( nicht editierbar ). Version Name Bezeichnung der Version. Es wird empfohlen, ausschließlich gültige Versionsnummern in dem Format \"Major.Minor.Build.Revision\" (z.B. 3.11 oder 3.11.1.5) zu verwenden. Es funktionieren auch andere Versions-Bezeichnungen, allerdings können diese dann nicht korrekt sortiert werden. Version ID Die interne ID der Package-Version ( nicht editierbar ). Product Name Der Name des Produkts. Dieser kann z.B. bei Versions-Informationen innerhalb der End-Anwendung ausgegeben werden. Assembly Prefix Kürzel, welches vor die Assemblies und den internen Elementnamen (Komponenten, Forms, Tabellen, …) gehängt werden soll. Der Assembly Prefix kann nur bearbeitet werden, wenn noch kein Compiler ausgeführt wurde bzw. es noch keinen Workspace für diese Package-Version gibt. Ist das Feld gesperrt, kann diese Sperre mit dem Button Edit aufgehoben werden. Dies hat zur Folge, dass alle Workspaces für diese Package-Version und ALLE davon abhängigen Package-Versionen gelöscht werden. Anschließend müssen alle diese Package-Versionen neu kompiliert werden. Version State: Open: Die Package-Version ist offen und befindet sich in der Entwicklung. Es gibt keinerlei Einschränkungen bei der Arbeit. Bei jedem Compile mit dem FrameworkCompiler / Compile-Wizard wird ein neuer Compile-Stempel erzeugt – das bedeutet, dass alle anhängigen Package-Version ebenfalls neu kompiliert werden müssen. Sealed: Die Package-Version ist versiegelt. Es können keine Änderungen vorgenommen werden. Es kann sich kein Entwickler mehr an dieser Package-Version anmelden. Damit eine Package-Version in den Status Sealed versetzt werden kann, darf nichts mehr ausgecheckt sein und alle Änderungen müssen mit dem FrameworkCompiler / Compile-Wizard kompiliert sein. Service Release: An der Package-Version können nur Änderungen an Methoden-Inhalten vorgenommen werden – es darf keine Schnittstellen-Änderungen mehr geben. Bei einem FrameworkCompiler / Compile-Wizard bleibt der Compile-Stempel erhalten. Dadurch brauchen abhängige Package-Versionen nicht neu kompiliert werden und es ist ein sehr schneller Update möglich. Der Version State kann jederzeit geändert werden. Dabei werden entsprechende Plausibilitäten geprüft, um eine Fehl-Bedienung zu unterbinden. Button Lock Damit kann eine Package-Version gesperrt werden, damit sich niemand mehr daran anmelden kann. Mit dem Klick erscheint ein Dialog, in dem eine Begründung eingegeben werden kann. Diese Begründung wird im Login-Dialog angezeigt. Falls noch Benutzer angemeldet sind, wird dieser Dialog angezeigt. Hier gibt es die folgenden Möglichkeiten: Cancel: den Vorgang abbrechen. Retry: es erneut versuchen, nachdem z.B. dem Benutzer Bescheid gegeben wurde. Kill User Sessions: die Sitzungen der Benutzer zu beenden. Bei dieser Aktion wird 130 Sekunden gewartet. Das ist die Zeit, die im Extremfall benötigt wird, bis ein Benutzer zum Beenden seiner Sitzung gezwungen wurde. (60 Sekunden bis zur Hinweismeldung + 60 Sekunden bis zum endgültigen Abbruch + 10 Sekunden Reserve) Während dieser Dialog angezeigt wird, können sich keine neuen Benutzer mehr anmelden. Dieser Mechanismus wird automatisch verwendet, um eine Package-Version während eines Upgrades vor einer Benutzung abzusichern. Button Status… Öffnet einen Dialog zum Festlegen einer Statusmeldung, die jedem Nutzer dieser Package Version beim Einloggen und in der Entwicklungsumgebung selbst angezeigt wird. Wird kein Informationstext angegeben, so wird der Status nicht angezeigt. Ansonsten ist er an den unten aufgeführten Positionen in der Entwicklungsumgebung sichtbar. Wird in der Combobox Name ein Status ausgewählt, dann gelten die Einstellungen, die in dem entprechenden Dialog gepflegt sind und es wird, sofern vorhanden, an allen Stellen zusätzlich der als nächstes greifende Status angezeigt. Login Dialog in der Detailbeschreibung zu einer Package Version: Status Bar im FrameworkDesigner: Im Check Out Dialog: Check In Dialog: Bei Status Rot muss im Check-In Dialog zusätzlich eine Begründung eingegeben werden, bevor der Check-In möglich ist. Diese Begründung wird mit dem Zusatz #warning State Red in den Check-In-Kommentar eingefügt. Über den Menüpunkt Tools / Package Versions States im Package Manager wird dieser Dialog geöffnet. Hier können mehrere Package Version Status gepflegt werden. Wenn mehrere Status den selben Namen haben, werden sie dem Datum entsprechend nacheinander aktiv, sofern der Name an einem Package hinterlegt ist. FS Version Framework Studio Version, mit der die Package Version bearbeitet werden kann. ( nicht editierbar ) Button Upgrade Note nur aktiv, wenn die FS Version der Package-Version kleiner ist als die Version, in der der Package Manager gestartet wurde Für die Package-Version wird ein Upgrade auf die aktuelle Framework Studio Version durchgeführt. Warning Der Upgrade-Vorgang lässt sich nicht rückgängig machen. Das heißt, dass dieses Label mit älteren Framework Studio Versionen nicht mehr verwendet werden kann. Compile Run In diesem Feld kann ein Name eingegeben werden, mit dem über die FSConsole.exe gesteuert werden kann, welche Package-Versionen kompiliert werden sollen. Button Source Ctrl. History … Öffnet die Source Control History für die aktuelle Package Version. Standardmäßig werden hierbei alle Elemente angezeigt. Sowohl eingecheckte als auch ausgecheckte Elemente. Button Compile Wizard Ruft für die Package-Version den Compile Wizard auf. Auf der Registerkarte Using Hierarchy werden die Package Versionen angezeigt, die von dieser Version verwendet werden. Die Versionen werden in der Verwendungsreihenfolge angezeigt. Die Using Hierarchy kann von den Requirements wie folgt abweichen: In der Using Hierarchy können zusätzlich Labels von weiteren Packages aufgeführt werden. Von einem Label in den Requirements kann ein anderes Label des gleichen Packages in der Using Hierarchy aufgeführt werden. Auf der Registerkarte Requirements werden tabellarisch die Abhängigkeiten der Version von anderen Packages bzw. Package Versionen dargestellt, also auf welchen Packages in welcher Version das aktuelle Package aufbaut. Diese Information wird beim Import im Repository abgelegt und ist nicht veränderbar. Die Registerkarte Info stellt interne Informationen zum Kompilierstatus dar. Auf allen Registerkarten befindet sich ein Button Refresh zum Aktualisieren der dargestellten Informationen. Warnings Es besteht die Möglichkeit Warnings, welche der Compiler ausgibt, zu ignorieren. Geben Sie hierfür die entsprechende Warning-Nummer oder Nummern in das Textfeld, getrennt mit einem Komma, ein. Zudem kann auch das Level der Warnings (Level 0 - Level 4) definiert werden. Wird kein Level angegeben, ist es standardmäßig Level 3. Die verschiedenen Warnings können Sie hier einsehen. Die Einstellung wird an die Customizing-Packages vererbt. Sie kann ausschließlich durch Nissen & Velten am eNVenta Package (bzw. einem anderen Default-Package) geändert werden. Register Languages Auf dieser Registerkarte können die Sprachen für die Package-Version definiert werden. Eine Sprache besteht aus den folgenden Informationen: Iso-Code : Der ISO 639-1 Code der Sprache. Dieser besteht aus 2 kleinen Buchstaben - z.B. de , en . Name : Der Name der Sprache. Dieser wird in der IDE angezeigt. An einer Package-Version können beliebig viele Sprachen definiert werden. Diese werden automatisch in die abhängigen Package-Versionen vererbt. Warning Auf der Application Startseite werden nur Sprachen angeboten, für die im Wörterbuch mindestens ein MLKey übersetzt ist. Languages from Base Diese Liste zeigt die Sprachen aus den Basis-Packages an. Languages from current Package In dieser Liste können die Sprachen für die Package-Version gepflegt werden. Es können zusätzliche Sprachen definiert werden Wird eine Sprache mit einem identischen Iso-Code wie im Basis-Package angelegt, dann überschreibt der Eintrag das Basis-Package. In der IDE wird dann die überschriebene Bezeichnung der Sprache angezeigt. Note Wird eine Sprache gelöscht, dann bleiben die Übersetzungen an den Records und im Wörterbuch trotzdem erhalten."
  },
  "doc/package-manager/sprachen.html": {
    "href": "doc/package-manager/sprachen.html",
    "title": "Sprachen",
    "keywords": "Sprachen In der Baumstruktur des Package Managers wird unterhalb jedes Default-Packages ein Ordner Languages angezeigt. In diesem Ordner werden alle Sprachen mit dem Symbol dargestellt, die von den Anwendungen angeboten werden können, die dieses Package als Default-Package verwenden. Durch einen Doppelklick auf eine Sprache wird ein Fenster geöffnet, in dem die beiden folgenden Eigenschaften festgelegt werden können: ISO Sprachkürzel nach ISO-Norm 639-1 Language Bezeichnung der Sprache Eine neue Sprache für ein Default-Package kann über das Kontextmenü der Baumstruktur oder das Symbol New / Language aus der Toolbar angelegt werden."
  },
  "doc/pbe/aktionen.html": {
    "href": "doc/pbe/aktionen.html",
    "title": "PBE-Aktionen",
    "keywords": "PBE-Aktionen Allgemein Aktionen Die eigentliche Arbeit wird in den Aktionen ausgeführt. Neben der FSConsole.exe können auch allgemeine Aktionen definiert werden. So können z.B. entsprechende Ordner oder Dienste vorbereitet werden. Konten <Batch> Damit kann eine beliebige Batch-Routine ausgeführt werden. Attribute: Name : optional Cmd : erforderlich - gibt den Pfad für eine Exe oder eine Batch-Datei an. Die Angabe sollte mit komplettem Pfad erfolgen. Args : optional - hier können Kommandozeilen-Argumente übergeben werden. Args können auch als XML-Knoten angegeben werden. Diese werden hinter die im Attribut definierten Args gepackt. Das ist praktisch bei komplexeren Listen von Kommandozeilen-Argumenten. PBE kümmert sich dabei um die korrekte Behandlung von Leerzeichen und Anführungszeichen. Beispiele: <Batch Name=\"IIS neu starten\" Cmd=\"iisreset\"/> <Batch Name=\"IIS beenden\" Cmd=\"NET\" Args=\"STOP W3SVC\"/> <Batch Name=\"IIS starten\" Cmd=\"NET\" Args=\"START W3SVC\"/> <!-- MyProgram.exe Param1 \"Param2 mit Leerzeichen\" C:\\temp\\export --> <Batch Name=\"Individuelle Aktion\" Cmd=\"MyProgram.exe\" Args=\"Param1\"> <Args> <Arg>Param2 mit Leerzeichen</Arg> <Arg>{ExportDir}</Arg> </Args> </Batch> Knoten <MD> Legt ein neues Verzeichnis an. Attribute: Name : optional Dir : erforderlich - Der anzulegende Ordner Beispiel <MD Dir=\"{ExportDir}\"/> Knoten <RD> Löscht ein Verzeichnis samt ihrem Inhalt. Attribute: Name : optional Dir : erforderlich - Der zu löschende Ordner Beispiel <RD Dir=\"{ExportDir}\"/> FSConsole-Aktionen Kern dieser Routine ist die Arbeit mit der FSConsole.exe . Dazu werden folgende Aktionen angeboten. Knoten <FSConsole> Startet eine FSConsole.exe Attribute Name : optional FS : erforderlich - gibt die Version von Framework-Studio an. \"3.8.0.0\", \"3.7.0.0\", ... Rep : erforderlich - gibt das Repository an, mit dem gearbeitet werden soll Args : erforderlich - gibt die weiteren Kommandozeilen-Parameter an. Wie beim Konten <Batch> können auch Args in Form eines XML-Knoten angegeben werden. Knoten <CompileRun> Führt mithilfe der FSConsole.exe einen Compile-Run durch Attribute: Name : optional FS : erforderlich (siehe oben) Rep : erforderlich (siehe oben) Run : erforderlich - Gibt den Compile-Run an. Dieser kann im Package-Manager an der Package-Version gepflegt werden. MaxParallel : optional - (ab FS 3.6) gibt an, wie viele Compiler innerhalb des CompileRuns parallel laufen dürfen. Beispiel: <!--Führt den CompileRun \"1\" für Framework-Studio 3.8 aus.--> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep1}\" Run=\"1\"/> Knoten <Export> Exportiert ein Package. Dieses wird in dem Ordner abgelegt, der im Parameter ExportDir angegeben wird. Der Name der Datei setzt sich aus dem Namen des Packages und der Version zusammen. Attribute: Name : optional FS : erforderlich (siehe oben) Rep : erforderlich (siehe oben) Package : erforderlich - gibt den Namen des zu exportierenden Packages an Version : erforderlich - gibt den Namen der zu exportierenden Package-Version an Mode : optional - wenn ein Bugfix / ServiceRelease exportiert werden soll, muss Mode=\"Bugfix\" angegeben werden Queue : optional - Der Name der Import-Queue, mit der dieser Export wieder importiert werden soll. Siehe auch Knoten <ImportQueue> Dir : optional - der Ordner, in dem die Export-Dateien abgelegt werden sollen, falls dieser vom Parameter {ExportDir} abweicht. IncludeBasePackages : optional - gibt an ob Basis-Package in den Export eingeschlossen werden sollen. Mögliche Werte: ServiceRelease - analog zum Package-Manager Unsealed - analog zum Package-Manager All - alle kompletten Base-Packages Konten <Import> Importiert ein Package. Ordner und Dateinamen werden wie beim Export verwendet. Die Attribute müssen zum Knoten <Export> passen. Bei der Verwendung der <ImportQueue> wird diese Aktion automatisch von der PBE.exe erzeugt. Attribute: Name : optional FS : erforderlich (siehe oben) Rep : erforderlich (siehe oben) Package : erforderlich - gibt den Namen des zu exportierenden Packages an Version : erforderlich - gibt den Namen der zu exportierenden Package-Version an Mode : optional - wenn ein Bugfix / ServiceRelease exportiert werden soll, muss Mode=\"Bugfix\" angegeben werden Dir : optional - der Ordner, aus dem die Export-Dateien gelesen werden sollen, falls dieser vom Parameter {ExportDir} abweicht. Knoten <ApprovedExport> Arbeitet wie der Konten <Export> mit folgenden Unterschieden: Wenn nicht über das Attribut Dir anders definiert, dann wird für den Export-Ordner der Parameter {ApprovedExportDir} verwendet. Das Attribut Queue steht nicht zur Verfügung. Konten <ApprovedImport> Importiert alle im Ordner enthaltenen Dateien in das angegebene Repository. Nach erfolgreichem Import werden die Dateien in das {HistoryDir} verschoben. Wenn dieser Ordner nicht angegeben ist – weder als Parameter noch als Attribut – dann werden die Dateien nach dem Import gelöscht, damit sie beim nächsten Lauf nicht noch einmal importiert werden. Bei der Verarbeitung wird für jeden Import ein separater Import -Vorgang protokolliert. Die FS-Version wird aus dem Dateinamen ermittelt. Dieser muss z.B. so aussehen: 2014-11-10_FSDemo_3.9 ( FS 3.9 ).db . Beim Export wird bereits ein passender Dateiname erzeugt. Dieser sollte nicht verändert werden. Attribute: Name : optional Rep : erforderlich (siehe oben) Dir : optional - der Ordner, aus dem die zu importierenden Dateien gelesen werden sollen, falls dieser vom Parameter {ApprovedImportDir} abweicht. HistoryDir : optional - der Ordner, in den die Dateien nach erfolgreichen Import verschoben werden sollen, falls dieser vom Parameter {ApprovedHistoryDir} abweicht. Knoten <Publish> Führt einen Publish-Vorgang aus. Attribute: Name : optional FS : erforderlich (siehe oben) Rep : erforderlich (siehe oben) Package : erforderlich - gibt den Namen des zu exportierenden Packages an Version : erforderlich - gibt den Namen der zu exportierenden Package-Version an Setting : erforderlich - Name des Settings. Dieses muss im Publish-Wizard vorbereitet und abgespeichert werden. Knoten <Publish2Go> Führt einen Publish2Go-Vorgang aus. Attribute: Name : optional FS : erforderlich (siehe oben) (ab FS 3.11.8) Rep : erforderlich (siehe oben) Package : erforderlich - gibt den Namen des zu exportierenden Packages an Version : erforderlich - gibt den Namen der zu exportierenden Package-Version an Setting : erforderlich - Name des Settings. Dieses muss im Publish-Wizard vorbereitet und abgespeichert werden. Im Setting muss der Folder angegeben sein Dieser darf für den Publish2Go keinen Inhalt haben. Knoten <ExportDoc> Exportiert die komplette Dokumentation der Package-Version im HTML-Format. Attribute: Name : optional FS : erforderlich (siehe oben) (ab FS 3.11.8) Rep : erforderlich (siehe oben) Package : erforderlich - gibt den Namen des zu exportierenden Packages an Version : erforderlich - gibt den Namen der zu exportierenden Package-Version an Iso : erforderlich - der Iso-Code der zu exportierenden Sprache – z.B. „de“ oder „en“ Dir : optional - der Ordner, in dem die Dokumentation abgelegt werden soll, falls dieser vom Parameter {ExportDir} abweicht. Für den Export wird ein Unter-Ordner mit dem folgenden Format erzeugt: {ExportFilePrefix}_<Package>_<Version>_Help_<Iso> Beispiel: ExportDir\\2016-09-17_eNVenta_3.7_Help_de\\... ExportDBTables : optional - sollen die Tabellen-Beschreibungen exportiert werden, dann muss ExportDBTables=\"1\" angegeben werden. UseLicense : optional - wenn dieser Parameter( UseLicense=\"1\" ) gesetzt ist, wird die Runtime-Lizenz aus dem Setting verwendet, welches via Setting=\"SETTING_NAME\" übergeben wird. In der Folge wird nur der Teil der Dokumentation exportiert, der mit der Runtime-Lizenz sichtbar ist. Setting : erforderlich, wenn UseLicense=\"1\" gesetzt ist - Name des Settings. Dieses muss im Run-Wizard vorbereitet und abgespeichert werden. Args : optional - Weitere Kommandozeilen-Argumente, die zusätzlich übergeben werden sollen. So können zukünftige Features integriert werden. Wie beim Konten <Batch> können auch Args in Form eines XML-Knoten angegeben werden."
  },
  "doc/pbe/beispiel.html": {
    "href": "doc/pbe/beispiel.html",
    "title": "Beispiel PBE.xml",
    "keywords": "Beispiel PBE.xml Die folgende Konfiguration stellt beispielhaft einen etwas komplexeren Ablauf mit mehreren FS-Versionen und Repositories dar. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <!DOCTYPE PBE SYSTEM \"PBE.dtd\"> <PBE Logfile=\"C:\\temp\\Log.html\" Logarchive=\"C:\\temp\\Archive\\Log_{DateTime}.html\"> <FSVersions> <FSVersion FS=\"3.7.0.0\" Dir=\"C:\\Programme\\Framework Systems\\FrameworkStudio 3.7.3\"/> </FSVersions> <Params> <Param Name=\"ExportDir\" Value=\"E:\\temp\\export\\\"/> <Param Name=\"rep1\" Value=\"\\ConnectionType SqlServer \\Server NV261 \\Database FSDemo37\"/> <Param Name=\"rep2\" Value=\"\\ConnectionType SqlServer \\Server NV261 \\Database FSDemo37Imp\"/> </Params> <Sequence> <RD Name=\"letztes Export-Dir löschen\" Dir=\"{ExportDir}\"/> <MD Name=\"Export-Dir neu anlegen\" Dir=\"{ExportDir}\"/> <Parallel Name=\"Compile Repository 1\"> <ImportQueue QueueName=\"ImportQueue\" Rep=\"{rep2}\"/> <Sequence Name=\"Compile-Lauf FS 3.7\"> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep1}\" Run=\"1\"/> <Export FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.2\" Queue=\"ImportQueue\"/> <Export FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.2\" Queue=\"ImportQueue\"/> </Sequence> <Sequence Name=\"Compile-Lauf FS 3.8\"> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep1}\" Run=\"1\"/> <Export FS=\"3.8.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.3\" Queue=\"ImportQueue\"/> <Export FS=\"3.8.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.3\" Queue=\"ImportQueue\"/> </Sequence> </Parallel> <Parallel Name=\"Compile Repository 2\"> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep2}\" Run=\"1\"/> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep2}\" Run=\"1\"/> <Condition Name=\"Sonntags-Compile\" Value=\"{Weekday}\" Equals=\"So\"> <Parallel> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep2}\" Run=\"Sonntag\"/> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep2}\" Run=\"Sonntag\"/> </Parallel> </Condition> </Parallel> <Sequence Name=\"Publish\"> <Batch Name=\"IIS beenden\" Cmd=\"NET\" Args=\"STOP W3SVC\"/> <Parallel Name=\"Publish\" MaxTasks=\"2\"> <Publish FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.2\" Setting=\"Cust1_Setting1\"/> <Publish FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.2\" Setting=\"Cust1_Setting2\"/> <Publish FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.2\" Setting=\"Cust2_Demo\"/> </Parallel> <Batch Name=\"IIS wieder starten\" Cmd=\"NET\" Args=\"Start W3SVC\"/> </Sequence> </Sequence> </PBE>"
  },
  "doc/pbe/config.html": {
    "href": "doc/pbe/config.html",
    "title": "Konfiguration der PBE",
    "keywords": "Konfiguration der PBE Die Konfiguration erfolgt mithilfe der Datei PBE.xml . Diese wird am besten mit Visual Studio bearbeitet, weil es dort eine IntelliSense-Unterstützung und eine Validierung der Eingaben gibt. Programm-Verzeichnisse Für die unterschiedlichen FS-Versionen werden die Programm-Verzeichnisse ermittelt. Dabei geht die Routine für jede FS-Version mit den folgenden Prioritäten vor und verwendet das Verzeichnis, welches zuerst gefunden wird: Konfiguration in der XML-Datei Beispiel: <FSVersions> <FSVersion FS=\"3.7.0.0\" Dir=\"C:\\Programme\\Framework Systems\\FrameworkStudio 3.7.3\"/> <FSVersion FS=\"3.8.0.0\" Dir=\"C:\\Programme\\Framework Systems\\FrameworkStudio 3.8\"/> </FSVersions> Order C:\\FS\\Framework Studio X.Y.0.0\\ - das ist der Standard im Haus von Nissen & Velten. Standard Installations-Verzeichnis %ProgramFiles%\\Framework Systems\\Framework Studio X.Y Dabei werden auch ServiceRelease- und Beta-Versionen erkannt. Parameter Für eine einfachere Konfiguration wird mit Parametern gearbeitet. Diese werden am Anfang der Datei angegeben. Unterhalb des XML-Knoten <Params> werden die Parameter mit <Param> -Knoten aufgelistet. Diese Parameter können bei den Aktionen verwendet werden. Dazu müssen sie in geschweiften Klammern geschrieben werden: {parameter} Beispiel: <Params> <Param Name=\"ExportDir\" Value=\"E:\\temp\\export123\\\"/> <Param Name=\"rep\" Value=\"\\ConnectionType SqlServer \\Server NV261 \\Database FSDemo37 \\DBUser sa \\DBPassword sql2005\"/> </Params> <Sequence> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep}\" Run=\"1\"/> </Sequence> Die im Folgenden aufgelisteten Parameter sind immer gefüllt: ExportDir Beinhaltet einen Ordner, in dem die Dateien der Package-Exporte abgelegt werden. Die Package-Importe werden ebenfalls in diesen Ordner gesucht. Dieser Parameter wird bei den Aktionen <Export> und <Import> automatisch verwendet. ApprovedExportDir Beinhaltet einen Ordner, in dem die Dateien der Approved Package-Exporte abgelegt werden. Dieser Parameter wird bei der Aktion <ApprovedExport> automatisch verwendet. ApprovedImportDir Beinhaltet einen Ordner, in dem die Dateien abgelegt werden, die mit der Aktion <ApprovedImport> verbarbeitet werden sollen. ApprovedHistoryDir Beinhaltet einen Ordner, in den die Dateien verschoben werden, nachdem sie mit der Aktion verbarbeitet wurden. Date Start-Datum im Format \"yyyyMMdd\" z.B. 20140526 DateTime Start-Zeit im Format \"yyyyMMdd-HHmmss\" z.B. 20140526-142457 DateTimeText Start-Zeit im Format \"yyyy-MM-dd HH:mm (dddd)\" z.B. 2014-05-26 14:24 (Montag) ExportFilePrefix Start-Datum mit dem Format \"yyyy-MM-dd_\" z.B. 2014-05-26_ Dieses Präfix wird vor den Dateinamen der Export-Dateien gestellt. So haben die Dateinamen dasselbe Format wie es auch der Package-Manager beim Export vorschlägt. z.B. 2014-05-26_eNVenta_3.4.db Weekday Aktueller Wochentag in Deutsch: Mo, Di, Mi, Do, Fr, Sa, So Kann z.B. in einer <Condition> verwendet werden um wöchentliche Aktionen zu definieren. Title Hat standardmäßig den Wert \"Nachtlauf {DateTimeText}\". Dieser Parameter kann bei Bedarf überdefiniert werden. Machine Name des Rechners (Environment.MachineName) Darüber hinaus können auch eigene Parameter definiert werden. So können z.B. die verwendeten Repository-Connections an zentraler Stelle definiert werden. Bei Parametern kann auch auf vorher definierte Parameter verwiesen werden – wie z.B. bei dem vordefinierten Parameter Title . Organisation Die Aktionen werden in der XML-Datei als Sequenzen oder Parallel-Verarbeitungen organisiert. Die unterschiedlichen Knoten können beliebig ineinander verschachtelt werden. Einzige Ausnahme ist der oberste Knoten – dieser muss immer <Sequence> sein. Jeder Knoten kann Optional ein Attribut \"Name\" erhalten. Dieser Name wird in der Protokoll-Datei ausgegeben. Konten <Sequence> Alle darunter aufgeführten Aktionen werden nacheinander verarbeitet. In der Protokoll-Datei werden die Einträge untereinander ausgegeben. Attribute: Name : optional Knoten <Parallel> Alle darunter definierten Aktionen werden parallel verarbeitet. In der Protokoll-Datei werden die Einträge nebeneinander ausgegeben. Attribute: Name : optional MaxTasks : optional - gibt die Anzahl der maximal parallel ausgeführten Aktionen an. Bei einer sehr langen Liste an Aktionen macht es Sinn, die Parallelität z.B. auf 4 zu begrenzen. Important Wenn dieses Attribut nicht angegeben ist, erfolgt die Verarbeitung komplett parallel – egal wie viele Aktionen definiert wurden. Konten <Condition> Arbeitet wie eine <Sequence> - die darunter aufgeführten Aktionen werden nacheinander ausgeführt. Die Ausführung erfolgt aber nur dann, wenn die beiden Attribute \"Value\" und \"Equals\" denselben Wert haben. Attribute: Name : optional Value : erforderlich – gibt den linken Wert für den Vergleich an. Üblicherweise wird hier ein Parameter angegeben - z.B. \"{Weekday}\" Equals : erforderlich – gibt den Wert an, mit dem verglichen werden soll – z.B. \"So\" . Im Value kann eine Funktion \"#EXISTS(<dateipfad>)\" verwendet werden. Diese liefert den Wert \"True\" oder \"False\" . Der Dateipfad kann auch Parameter beinhalten. Beispiel: <Condition Name=\"Prüfen ob Publish2Go existiert\" Value=\"#Exists({InputDir}\\sqlitedb.p2go)\" Equals=\"True\"> Knoten <ImportQueue> Damit können die Package-Importe so organisiert werden, dass diese parallel zu anderen Aktionen durchgeführt werden können. Die Export-Aktionen packen, wenn sie fertig sind, entsprechende Import-Aktionen in diese Queue. Diese wird dann sofort mit der Abarbeitung beginnen. Dabei werden aber alle Importe nacheinander verarbeitet, weil parallele Importe auf einem Repository nicht möglich sind. Attribute: Name : optional QueueName : erforderlich – gibt den Namen der Queue an. Diese kann bei einer <Export> -Aktion verwendet werden. Rep : erforderlich – gibt das Repository an, in dem die Packages importiert werden sollen. Beispiel Es laufen parallel 2 Compile-Läufe und Exporte auf Repository1. Daneben werden zeitgleich die Exporte in Repository2 importiert. Beispiel: <Parallel> <ImportQueue QueueName=\"ImportQueue\" Rep=\"{rep2}\"/> <Sequence Name=\"Compile-Lauf FS 3.7\"> <CompileRun FS=\"3.7.0.0\" Rep=\"{rep1}\" Run=\"1\"/> <Export FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.2\" Queue=\"ImportQueue\"/> <Export FS=\"3.7.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.2\" Queue=\"ImportQueue\"/> </Sequence> <Sequence Name=\"Compile-Lauf FS 3.8\"> <CompileRun FS=\"3.8.0.0\" Rep=\"{rep1}\" Run=\"1\"/> <Export FS=\"3.8.0.0\" Rep=\"{rep1}\" Package=\"Cust1\" Version=\"3.3\" Queue=\"ImportQueue\"/> <Export FS=\"3.8.0.0\" Rep=\"{rep1}\" Package=\"Cust2\" Version=\"3.3\" Queue=\"ImportQueue\"/> </Sequence> </Parallel>"
  },
  "doc/pbe/pbe.html": {
    "href": "doc/pbe/pbe.html",
    "title": "Parallel Batch Engine (PBE)",
    "keywords": "Parallel Batch Engine (PBE) Die P arallel B atch E ngine ist eine Routine, die es ermöglicht eine Batch-Verarbeitung zu automatisieren. Neben der Ausführung normaler Batch-Verarbeitung ist sie dafür optimiert, die FSConsole.exe von Framework Studio zu steuern und so Compile-Läufe, Package-Exporte, Package-Exporte und Publish-Aktionen auszuführen. Weitere Kern-Funktionen sind die parallele Verarbeitung und das erzeugen und Archivieren einer Log-Datei. Arbeitsweise Ausgeliefert wird diese Routine zusammen mit Framework Studio. Sie ist im Programm-Verzeichnis von Framework Studio im Unterordner PBE abgelegt. Das Programm besteht aus folgenden Dateien: PBE.exe - Das eigentliche Programm PBE.xml - hier wird die Konfiguration vorgenommen PBE.dtd - beinhaltet die Schema-Definition für die PBE.xml LogTemplate.htm - Vorlage für die Protokoll-Datei Wenn die Konfiguration in der Datei PBE.xml vorgenommen wurde, dann kann die Routine durch ausführen der Datei PBE.exe gestartet werden. Es wird die XML-Datei ausgewertet und die darin konfigurierten Schritte werden alle abgearbeitet. Dabei wird ein Protokoll in Form einer HTML-Datei erzeugt. Dieses beinhaltet neben den Informationen, wann welche Aktion gestartet wurde und wie lange sie gedauert hat, auch das während der jeweiligen Aktion erzeugte Protokoll. Das Protokoll wird während der Ausführung regelmäßig aktualisiert. So kann man sich auch ein Bild vom Fortschritt der Aktion machen. PBE ist dafür konzipiert in einem Lauf mit mehreren Versionen von Framework Studio parallel zu arbeiten. Unterstützt werden alle Versionen ab Framework Studio 3.2. Protokoll Die Routine erzeugt ein Protokoll. In dem Haupt-Knoten <PBE> kann eingestellt werden, wohin das Protokoll geschrieben werden soll. In jeder Protokoll-Datei wird ein Link Previous Logfile erzeugt, in dem jeweils auf das vorherige \"archivierte\" Protokoll verwiesen wird. So kann man sich einfach durch die Protokolle klicken. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <!DOCTYPE PBE SYSTEM \"PBE.dtd\"> <PBE Logfile=\"U:\\eNVenta\\Nacht\\Compile\\Log.html\" Logarchive=\"U:\\eNVenta\\Nacht\\Compile\\Archiv\\{DateTime}.html\"> <Params> <Param Name=\"ExportDir\" Value=\"C:\\PackageExport\\\"/> Logfile : gibt den Pfad der Protokoll-Datei an. In Netzwerk-Umgebungen macht es Sinn, das Protokoll auf einem Netzlaufwerk abzulegen, so kann sie z.B. einfach über eine interne Web-Seite verlinkt werden. Logarchive : gibt an, wo die Historischen Protokolle gespeichert werden sollen. Dabei ist es sinnvoll den Parameter {DateTime} in den Dateinamen einzubauen, um einen eindeutigen Namen zu erhalten."
  },
  "doc/print-server/config.html": {
    "href": "doc/print-server/config.html",
    "title": "Konfiguration Print-Server",
    "keywords": "Konfiguration Print-Server Registerkarte Printers Mit dem Link Add new Printer wird ein neuer Drucker angelegt. Es erscheint eine Drucker-Auswahl der auf dem Rechner installierten Drucker. Wählen Sie den gewünschten Drucker aus. Feld ID Hier wird die ID des Druckers angegeben. Diese wird automatisch erzeugt. Dabei handelt es sich um eine eindeutige Guid. Mit dem Link Generate ID kann eine neue ID generiert werden. Note Wird die ID nachträglich geändert, verlieren andere Programme die Zuordnung zu diesem Drucker. Feld Name Dieser Name wird in Framework-Studio-Anwendungen ausgegeben. Dieser Name ist frei wählbar und muss nicht mit dem physikalischen Namen des Druckers in Verbindung stehen. Der Name kann auch nachträglich geändert werden, weil die Zuordnung des Druckers über die ID erfolgt. Feld Path Bei Path wird der physikalische Name des Druckers angegeben. Mit dem Link Choose Printer können Sie diesen neu definieren. Mit dem Link Choose Folder kann ein Datei-Ordner ausgewählt werden. In diesen werden dann die Dokumente abgelegt. Dadurch wird der Typ des Druckers zu [Folder] geändert. Im Feld Path wird dann der Datei-Pfad angezeigt. Weitere Informationen dazu finden Sie im Feature Druck in einen Ordner . Feld Paper Source Hier können Sie den Schacht angeben, der zum Druck verwendet werden soll. Paper Source 1st Page(s) Hier können Sie bei Bedarf für die ersten Seiten eine abweichende Papier-Quelle angeben. Standardmäßig zieht diese Einstellung für die erste Seite. Wenn der Drucker z.B. für Duplex-Druck konfiguriert ist, dann kann die Anzahl der Seiten auf 2 gesetzt werden, damit das erste Blatt beidseitig bedruckt wird. Wenn hier ein Wert definiert ist, der von Paper Source abweicht, dann wird der Druck in 2 Schritten ausgeführt. Das kann die Verarbeitungsgeschwindigkeit verringern. Beim Ausdruck von mehreren Kopien wird der Druck in mehreren Schritten durchgeführt, damit die Reihenfolge der Seiten gewährleistet ist: ersten Seiten mit Schacht 1, Folgeseiten mit Schacht 2, ersten Seiten mit Schacht 1, Folgeseiten mit Schacht 2, usw. Wir dem Ausdruck als Start die Seite 2 oder höher übergeben, dann erfolgt der komplette Ausdruck auf dem Standard-Schacht. Note Der Schacht ( Paper Source und Paper Source 1st Page ) wird nur beim Ausdruck mit Crystal Reports berücksichtigt. Checkbox Use Word Mit Use Word können Sie einstellen, dass ein Crystal Report erst in ein Word-Dokument umgewandelt wird und dann auf den Drucker gesendet wird. Das kann bei der Verwendung von Fax-Druckern hilfreich sein, denn Crystal Reports schafft es meist nicht Steuertexte an den Drucker zu senden. Bei der Umwandlung in ein Word-Dokument bleiben diese erhalten und Word kann sie dann an den Drucker schicken. Note Mit Windows Server 2008 ist es nicht möglich, Word in einem Windows Dienst zu steuern. Deshalb muss in diesem Fall der Print-Service als Konsole-Anwendung gestartet werden. Registerkarte Database Connection Geben Sie hier die gewünschte Verbindung zu der Datenbank an, in der die Druckdaten abgelegt werden. Standardmäßig wird dazu das Runtime Repository Ihrer Anwendung verwendet. Bei Query Interval geben Sie den Rhythmus an, mit dem der Print-Service auf der Datenbank nach neuen Druckaufträgen schaut. Die Angabe hat das Format hh:mm:ss.millisekunden - Beispiel: 00:00:01.5000000 sind 1,5 Sekunden. Registerkarte Service Feld Name Dieser Name wird in Framework-Studio-Anwendungen ausgegeben. Feld ID Die eindeutige ID des Print-Service. Bei der Installation können Sie mit dem Link Generate ID eine neue ID erzeugen. Feld URL Die URL können Sie mit dem Link Set Default auf den eigenen Rechnernamen setzen. Dort ist auch z.B. eine IP-Adresse möglich. Es kann auch ein anderer Port als 20002 verwendet werden. Dann müssen auch die Konfigurationen der Clients, die mit dem Service kommunizieren sollen, auf den geänderten Port angepasst werden. Falls Sie auf einem Server mehrere Print-Services installieren, muss jeder Print-Service einen anderen Port erhalten. Feld Private Key , Public Key Für Private Key und Public Key müssen Sie mit dem Link Generate Keypair ein neues Schlüsselpaar generieren. Feld Culture gibt an, mit welchen Ländereinstellungen der Print-Service arbeiten soll. Diese Einstellung zieht beim Verarbeiten von Crystal Reports. Wenn hier nichts angegeben ist, dann ziehen die Standard-Einstellungen des Rechners. Beispiele: de-DE de-CH en-US Feld Log File Hier kann eine Datei angegeben werden, in der detaillierte Informationen protokolliert werden sollen. Das sind dieselben Informationen, die bei Start mit /Console in das Konsolen-Fenster ausgegeben werden. Zusätzlich werden die einzelnen Protokoll-Einträge mit einem Zeit-Stempel versehen. Der Benutzer, mit welchem der Service gestartet wird, muss Schreibrechte für diese Datei besitzen. Checkbox Delete Printjobs after Processing Wenn diese Checkbox gesetzt ist, dann löscht der Printserver die Druckjobs nach der Verarbeitung. Diese Aktion ist Bestandteil der Verarbeitung eines Jobs. Es wird also nur der aktuelle Printjob gelöscht. Der Druckjob muss die folgenden Bedingungen erfüllen: Es wurden keine PDF-Dateien für die Archivierung generiert (in diesem Fall kümmert sich eNVenta ERP im Archiv-Pool um das Löschen). Der Druckjob war erfolgreich (Status = 3). Das Löschen wird in das detaillierte Protokoll ausgegeben. Nach einem Update muss der Schalter explizit gesetzt werden. Feld Export Folder Wenn definiert, dann werden alle Druck-Jobs, die über den Print-Service verarbeitet werden, zusätzlich in diesen Ordner gespeichert. Dies kann bei der Analyse von Problemen helfen. Feld Trace Folder Wenn angegeben, dann werden in diesen Ordner Trace-Informationen des Print-Servers gespeichert. Diese Dateien können mit dem Session Trace Analyzer gelesen werden. Registerkarte Windows-Service Hier können nur Änderungen vorgenommen werden, solange der Service nicht installiert worden ist. Warning Ändern Sie diese Einstellungen auch niemals manuell in der Datei PrintService.exe.config . Ansonsten kann der Print-Service dem Windows-Dienst nicht mehr zugeordnet werden. Wenn Sie diese Einstellung nachträglich ändern möchten, dann müssen Sie: den Dienst mit dem Link stop beenden, den Dienst mit dem Link uninstall Service deinstallieren, die Änderungen vornehmen und speichern und den Dienst mit dem Link install Service wieder installieren. Dabei sollte der Benutzer-Account des Dienstes wieder der von vorher sein – ggf. vor der ganzen Aktion merken. Siehe auch Installation . Feld Service Name Unter diesem Namen wird der Service in den Windows-Diensten registriert. In dem Feld können Sie einen Namenszusatz angeben. Das ist vor allem dann notwendig, wenn Sie mehrere Print-Services auf einem Rechner installieren, da der Name in den Windows-Diensten eindeutig sein muss. Feld Description Diese wird als Description in den Windows-Diensten gespeichert. Registerkarte Print Adapter Hier können die vom Print-Service unterstützen Print-Adapter aktiviert und konfiguriert werden. Details dazu sind auf der Seite Print-Adapter ausgeführt. Registerkarte Runtime Supervisor Hier kann angegeben werden, an welchem Runtime Supervisor sich der Print-Service registrieren soll. Nähere Informationen dazu sind in der Dokumentation des Runtime Supervisor zu finden. Checkbox Enable Diese Checkbox muss gesetzt werden, damit der Runtime Supervisor aktiviert wird. Feld Runtime Supervisor Url Hier können der Server und der Port angeben werden. Die vollständige URL wird automatisch aufgebaut. Mit dem Button Test kann versucht werden, ob eine Verbindung zum Runtime Supervisor aufgebaut werden kann."
  },
  "doc/print-server/features.html": {
    "href": "doc/print-server/features.html",
    "title": "Features im Print-Server",
    "keywords": "Features im Print-Server Konsole Sie können den Print-Service auch als Konsole-Anwendung starten. Dazu kann einfach die Datei PrintService.exe gestartet werden. Ein PrintService darf generell nur einmal gestartet sein. Also entweder als Dienst oder mit der Konsole. Bevor Sie die Konsole-Anwendung starten, stellen Sie sicher, dass der Dienst gestoppt oder deaktiviert ist. Anmerkung: Es ist aber durchaus möglich VERSCHIEDENE PrintServices auf einem Rechner parallel zu betreiben. Jeder dieser Services darf aber nur einmal laufen. Beim Start mit der Konsole werden detaillierte Informationen zum Status und zu den Print-Jobs ausgegeben. Das kann sehr hilfreich sein, um z.B. das Verhalten des PrintServices oder auch Fehler zu analysieren. Die Ausgaben auf der Konsole haben denselben Inhalt wie die Protokoll-Datei. Wenn der Service als Konsole-Anwendung gestartet wird, werden die Informationen sowohl in der Konsole als auch, wenn konfiguriert, in der Protokoll-Datei ausgegeben. Prüfungen beim Start Der PrintService führt beim Start Überprüfungen durch. Sind Drucker verfügbar? Es wird geprüft, ob die angegebenen Drucker auch als Windows-Drucker verfügbar sind. Der Print-Server registriert ja alle Drucker im Repository. Diese werden dann von der Applikation (z.B. eNVenta) verwendet. Wenn ein Drucker nicht verfügbar ist, wird eine Warnung in das Ereignis-Protokoll geschrieben, Es wird eine Information in die Protokoll-Datei geschrieben und der Drucker wird mit dem Präfix ##ERROR## in das Repository geschrieben. So können Sie auch in der Anwendung sehen, wenn der Print-Service einen Drucker nicht ansprechen kann. Wenn der Drucker aufgrund technischer Probleme nicht korrekt arbeitet, kann der PrintService keinen Fehler erzeugen. Das schlägt dann ggf. erst bei der Verarbeitung des Druckjobs auf. Sind die Print-Adapter richtig konfiguriert? Crystal Adapter : Beim Start wird geprüft, ob die Crystal-Komponente angesprochen werden kann. Wenn z.B. nicht die korrekte Runtime installiert ist, dann wird eine Fehlermeldung generiert. Diese landet in der Protokoll-Datei und als Warnung im Ereignis-Protokoll. Word, Excel Adapter : Es wird geprüft, ob Word oder Excel verfügbar ist. Bei der Prüfung wird die Version in die Protokoll-Datei geschrieben. Im Fehlerfall wird in die Protokoll-Datei geschrieben und es wird eine Warnung in das Ereignis-Protokoll geschrieben. Wenn Sie kein Word oder Excel verwenden, dann können die entsprechenden Adapter auch aus der Config-Datei entfernt werden. Entsprechende Print-Jobs werden in diesem Fall ignoriert. PDF-Adapter : Es wird geprüft, ob die in der Config definierte Programm-Datei existiert. Wenn nicht, wird die Protokoll-Datei geschrieben und eine Warnung in das Ereignis-Protokoll. Wenn Sie keine PDF-Dateien verarbeiten, dann können Sie diesen Adapter auch aus der Config-Datei entfernen. Entsprechende Print-Jobs werden in diesem Fall ignoriert. Druck in einen Ordner Wenn man mit dem Link Choose Folder den Drucker in einen [Folder] geändert hat, können Sie im Anschluss den Pfad manuell bearbeiten. Tip Bei der Angabe des Ordners können auch UNC-Pfade (z.B. \\\\Server\\Freigabe\\ ) verwendet werden. Es ist zwingend darauf zu achten, dass der Dienst mit einem Benutzer läuft, der entsprechende Schreib-Rechte für diese Freigabe hat. Note Netzlaufwerke sind hingegen NICHT zu empfehlen, weil diese – wenn der Print-Service als Dienst gestartet wird – evtl. nicht zur Verfügung stehen. Durch die Verwendung von Platzhaltern kann der Pfad dynamisch aufgebaut werden. Folgende Platzhalter können verwendet werden: Platzhalter Beschreibung {date} Datum des Drucks mit dem Format yyyy-MM-dd z.B. 2012-05-30 {time} Zeit des Drucks im Format HHmmss z.B. 121037 (für 12:10:37) {owner} Benutzer, der den Druck durchgeführt hat. Der Dateiname wird folgendermaßen generiert: Crystal Report Adapter Dateiname: <ReportName>_<PrintJob-ID>.PDF Beispiel: Invoice_61b7ad1bb4304b40a7758f02f888e614.PDF Wenn nicht bereits im Ordner verwendet, werden dem Dateinamen noch die Platzhalter in der folgenden Reihenfolge vorangestellt: {date}_{time}_{owner}_<dateiname> Beispiel-Konfiguration Es soll pro Tag ein neuer Ordner angelegt werden und darunter pro Mitarbeiter ein weiterer eigener Ordner. Konfigurierter Ordner (Folder): \\\\Fileserver1\\Ausdrucke\\{date}\\Server1\\{owner}\\ Es werden z.B. folgende Ordner generiert: \\\\Fileserver1\\Ausdrucke\\2012-05-30\\Server1\\User1\\ \\\\Fileserver1\\Ausdrucke\\2012-05-30\\Server1\\User2\\ Es werden die Dateien im folgenden Format angelegt: {time}_<ReportName>_<PrintJob-ID>.PDF ( {date} und {owner} werden schon im Ordner verwendet und deshalb nicht in den Dateinamen gepackt) Beispiele für Dateien 121037_Invoice_61b7ad1bb4304b40a7758f02f888e614.PDF 182026_CallList_2a0af0b92b7f418483b5ab0801727453.PDF"
  },
  "doc/print-server/installation.html": {
    "href": "doc/print-server/installation.html",
    "title": "Installation Print-Server",
    "keywords": "Installation Print-Server Requirements Die Requirements für den Print-Server sind in der Liste der Requirements enthalten. Update Wenn ein bestehender Print-Service mit einer neuen Version aktualisiert werden soll, dann befolgen Sie bitte die folgenden Schritte. Die Installation eines neuen Print-Service ist weiter unten beschrieben. Bitte prüfen Sie vor dem Update, ob alle Requirements in der korrekten Version installiert sind. Sichern Sie das aktuelle Programm-Verzeichnis. Jetzt müssen Sie den Dienst deinstallieren. Note Sehen Sie ggf. nach, mit welchem Benutzer der Dienst im Moment läuft (unter Systemsteuerung, Verwaltung, Dienste). Dieser Benutzer muss später bei der Installation der neuen Version wieder angegeben werden. Starten sie das Programm PrintServiceConfigEditor.exe und drücken sie nacheinander die beiden Links stop und uninstall Service und beenden Sie dann den Config-Editor. Wenn noch eine ältere Version im Einsatz ist, welche keinen PrintServiceConfigEditor besitzt, dann führen Sie die Datei Service_uninstall.bat aus. Kopieren Sie den Inhalt des Ordners bin\\ in den Zielordner. Ersetzen Sie alle vorhandenen Dateien. Note Mit dieser Kopier-Aktion wird eine Datei Template_PrintService.exe.config in den Programm-Ordner kopiert. Unbedingt die Datei PrintService.exe.config aus dem alten (gesicherten) Programmverzeichnis weiterverwenden. Starten Sie das Programm PrintServiceConfigEditor.exe und prüfen Sie, ob alle Einstellungen korrekt sind. Es kann durch den Update Änderungen in der config-Datei geben, die dazu führen, dass Änderungen gespeichert werden müssen. Mit Klick auf den Link install Service wird das Programm wieder als Dienst im Betriebssystem registriert. Die darauffolgenden Schritte sind identisch mit der Installation (siehe unten). Installation Bitte prüfen Sie vor der Installation, ob alle Requirements installiert sind. Erstellen Sie den Zielordner für den Service Empfehlung: C:\\Programme\\Framework Systems\\PrintService\\ Kopieren Sie den Inhalt des Ordners bin\\ in den Zielordner. Jetzt müssen Sie die Konfiguration des Services festlegen. Führen Sie dazu im Zielordner das Programm PrintServiceConfigEditor.exe aus. Dieses Programm bearbeitet den Inhalt der Konfigurations-Datei PrintService.exe.config . Beim ersten Aufruf des Configuration-Editors wird die Datei Template_PrintService.exe.config automatisch in PrintService.exe.config umbenannt. Informationen zur Konfiguration von Datenbankverbindung und Drucker finden Sie auf der separaten Seite Konfiguration . Bitte führen sie diese wie gewünscht durch. Jetzt müssen Sie das Programm als Dienst im Betriebssystem registrieren. Klicken Sie dazu den Link install Service . Es öffnet sich ein Fenster, welches den Fortschritt der Installation anzeigt. Fehler, die bei der Installation auftreten, werden in diesem Fenster ausgegeben. Während der Installation des Services wird folgendes Fenster angezeigt: Geben Sie hier den Benutzer an, mit welchem der Dienst ausgeführt werden soll. Es wird empfohlen nach Möglichkeit einen Domain-User anzugeben, der Zugriff auf die Drucker des Rechners hat. Im Idealfall dürfte dies der angemeldete Benutzer sein. Wählen Sie dazu User aus und geben sie in User credentials die Benutzerdaten an. Der User muss im Format Domain\\User angegeben werden. Je nach Konfiguration des Systems kann ggf. auch eines der Systemkonten verwendet werden. Diese Routine erzeugt einige Protokoll-Dateien über den Installationsverlauf im Zielordner. Diese sind kein Problem. Schließen Sie das Installations-Fenster mit dem Button Close . Wenn die Installation erfolgreich verlaufen ist, dann wird im Anschluss angezeigt, dass der Dienst läuft. Im oberen Teil des Fensters sollten Sie folgendes Bild sehen: Mögliche Gründe für das Fehlschlagen der Installation: Die Konfiguration ist fehlerhaft. Starten Sie ggf. die PrintServiceConfigEditor.exe erneut und prüfen Sie die Angaben. Der angegebene Benutzer hat nicht die notwendigen Rechte. Prüfen Sie ggf. das Ereignisprotokoll. Deinstallation Starten Sie das Programm PrintServiceConfigEditor.exe Stoppen Sie den Dienst mit dem Link stop Mit dem Link uninstall Service wird der Windows Dienst deinstalliert. Nach einer Rückfrage startet die Deinstallation und es wird wie bei der Installation ein Dialog mit dem Fortschritt angezeigt. Auch hier werden bei Problemen Fehlermeldungen ausgegeben. Wenn die Deinstallation abgeschlossen ist, kann dieser Dialog mit dem Button Close beendet werden. Anschließend wird angezeigt, dass der Service nicht installiert ist. Beenden Sie den Configuration-Editor und löschen Sie den Zielordner. Warning Dabei gehen die Einstellungen aus der Konfigurations-Datei PrintService.exe.config verloren. Sichern Sie diese Datei ggf. für eine spätere Verwendung. David Fax für Faxversand Installieren Sie auf dem PrintService-Rechner ein Tobit Infocenter. Setzen Sie den neu angelegten Tobit Faxware Drucker als Standarddrucker ein. Falls noch nicht vorhanden, installieren Sie ein Microsoft Word in der Version 2003, 2007, 2010 oder 2013 auf dem PrintService-Rechner. Legen Sie im Abschnitt Printers den neuen Fax-Drucker an. a. Legen Sie mit Add new Printer einen neuen Fax-Drucker an. b. Es erscheint eine Drucker-Auswahl der auf dem Rechner installierten Drucker. Wählen Sie den Drucker Tobit Faxware aus. c. Für den Faxware Drucker wird eine Registerkarte angelegt. d. Markieren Sie die Checkbox Use Word (for Fax Printers). Bei Name geben Sie den Namen des neuen Fax-Druckers an. Dieser Name wird in Framework-Studio-Anwendungen ausgegeben. Dieser Name ist frei wählbar und muss nicht mit dem physikalischen Namen des Druckers in Verbindung stehen. Hier im Beispiel haben wir den Namen Tobit Fax gewählt. Bei Path wird der physikalische Name des Fax-Druckers angegeben, hier Tobit Faxware . Bei Paper Source können Sie den Schacht angeben, der zum Druck verwendet werden soll. Diese Einstellung ist hier erst einmal nicht von Interesse. Der Schacht wird nur beim Ausdruck mit CrystalReports berücksichtigt. Speichern Sie die neuen Einstellungen über Save Changes . Starten Sie anschließend den PrintService-Dienst einmal mit dem Link restart durch. Der Fax-Drucker steht nun in eNVenta ERP zur Verfügung und kann benutzt werden."
  },
  "doc/print-server/print-adapter.html": {
    "href": "doc/print-server/print-adapter.html",
    "title": "Print-Adapter",
    "keywords": "Print-Adapter Auf der Register-Karte Print-Adapter können diese bearbeitet und konfiguriert werden. Es folgt eine Aufstellung der standardmäßig zur Verfügung stehenden Print-Adapter. DEVEXPRESS Mit diesem Adapter können DevExpress-Reports (.repx) gedruckt werden. Assembly: DevExpressPrintAdapter Class: PrintServer.DevExpressPrintAdapter Settings: ExportFolder : Diese Einstellung kann optional zu Test- oder Debug-Zwecken angegeben werden. Es werden alle Reports nach dem Druck als PRNX-Datei (Report-Datei inkl. Daten) in diesem Ordner abgelegt. Beispiel: ExportFolder = C:\\temp\\PRNX-Files CRYSTAL Mit diesem Adapter können Reports (.rpt) mithilfe der Crystal Reports Runtime gedruckt werden. Assembly: CrystalPrintAdapter Class: PrintServer.CrystalPrintAdapter Settings: ExportFolder : Diese Einstellung kann optional zu Test- oder Debug-Zwecken angegeben werden. Es werden alle Crystal-Reports nach dem Druck als RPT-Datei inkl. Daten in diesem Ordner abgelegt. Beispiel: ExportFolder = C:\\temp\\RPT-Files IMAGE Der IMAGE-Adapter dient zum Drucken von Bildern. Assembly: ImagePrintAdapter Class: PrintServer.ImagePrintAdapter Settings: -keine- PDF Mit diesem Adapter können PDF-Dateien an den Drucker gesendet werden. Der Adapter verwendet ein externes PDF-Programm zur Verarbeitung der PDF-Dateien. In diesem Adapter kann ein beliebiges Kommandozeilen-Programm verwendet werden. Für den Einsatz von Sumatra PDF , Foxit Reader oder Acrobat Reader sollte bei Class auf entsprechend optimierten Adapter umgestellt werden (siehe unten). Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter Settings: ReaderPath : Dateipfad des PDF-Programms. Diese Einstellung muss angegeben werden. Beispiel: ReaderPath = C:\\Programme\\Adobe\\Reader 9.0\\Reader\\AcroRd32.exe ReaderArgs : Die Kommandozeilen-Argumente zur Ansteuerung des PDF-Programms. Darin können die Platzhalter {file} und {printer} benutzt werden. PDF - Sumatra PDF Dieser PDF-Adapter ist speziell für den Sumatra PDF Reader optimiert. Um diesen einzusetzen, muss beim PDF-Adapter die Class PrintServer.PdfPrintAdapter_SumatraPDF angegeben werden. Sumatra PDF ist ein einfacher, schlanker PDF-Viewer für Windows. Er kann von der Home-Page des Herstellers http://www.sumatrapdfreader.org heruntergeladen werden. Es gibt eine Installations-Routine und eine portable Version, welche lediglich aus der SumatraPDF.exe besteht. Im Normalfall kann die 32-Bit Version verwendet werden. Die 32-Bit Version hat eine etwas bessere Performance als die 64-Bit Version. Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter_SumatraPDF Settings ReaderPath : Die SumatraPDF.exe der portablen Version kann direkt in das Print-Service-Verzeichnis gepackt werden. In diesem Fall braucht kein Reader-Path angegeben werden. Wird die installierte Version von Sumatra PDF verwendet, muss der Pfad angegeben werden. Beispiel: ReaderPath = C:\\Program Files\\SumatraPDF\\SumatraPDF.exe ReaderArgs : Wenn nicht angegeben, dann wird die folgende Standard-Einstellung verwendet: ReaderArgs = -print-to \"{printer}\" \"{file}\" -exit-on-print PDF - Foxit Reader Dieser Adapter ist speziell für den Foxit Reader optimiert. Um diesen einzusetzen, muss beim PDF-Adapter die Class PrintServer.PdfPrintAdapter_FoxitReader angegeben werden. Der Foxit-Reader kann über die Homepage des Herstellers heruntergeladen werden: https://www.foxitsoftware.com/de/products/pdf-reader/ Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter_FoxitReader Settings ReaderPath : Dateipfad des Foxit Reader. Diese Einstellung muss angegeben werden. Beispiel: ReaderPath = C:\\Program Files (x86)\\Foxit Software\\Foxit Reader\\FoxitReader.exe ReaderArgs : Wenn nicht angegeben, dann wird die folgende Standard-Einstellung verwendet: ReaderArgs = /t \"{file}\" \"{printer}\" Timeout : Zeitdauer in ms, die angibt, wie lange gewartet werden soll, bis der FoxitReader-Prozess beendet wird. Der Standard-Wert ist 2000 ms. Wird der PrintService als Dienst ausgeführt, dann kann es sein, dass die FoxitReader.exe nach dem Druck nicht automatisch schließt. Nach Ablauf dieses Timeouts wird ein alternativer Versuch unternommen, den Reader zu schließen. Wenn der Timeout zu kurz bemessen ist, denn wird die FoxitReader.exe zu früh geschlossen und es wird kein Ausdruck erzeugt. Für die Ermittlung eines passenden Wertes ist es sinnvoll, sich durch mehrere Tests an einen Minimal-Wert heranzutasten. Dieser sollte dann mit genug Reserve als Einstellung verwendet werden. Z.B. minimal 300 ms – Einstellung 500 ms. Beispiel: Timeout = 2000 PDF - Acrobat Reader Dieser Adapter ist für den Adobe Acrobat Reader DC optimiert. Um diesen einzusetzen, muss beim PDF-Adapter die Class „PrintServer.PdfPrintAdapter_AcrobatReader“ angegeben werden. Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter_AcrobatReader Settings ReaderPath : Dateipfad des Acrobat Reader. Diese Einstellung muss angegeben werden. Beispiel: ReaderPath = C:\\Program Files (x86)\\Adobe\\Acrobat Reader DC\\Reader\\AcroRd32.exe ReaderArgs : Wenn nicht angegeben, dann wird die folgende Standard-Einstellung verwendet: ReaderArgs = /t /n /h \"{file}\" \"{printer}\" WORD Mit diesem Adapter können Word-Dateien (.doc / .docx) an den Drucker gesendet werden. Assembly: MsOfficePrintAdapter Class: PrintServer.WordPrintAdapter Warning Word hat die Einschränkung, dass es nicht von einem Dienst-Programm gesteuert werden kann / darf. Aus diesem Grund ist der WORD-Adapter standardmäßig deaktiviert. Wird der Word-Adapter aktiviert, dann sollte der Print-Service nur im Console-Modus ausgeführt werden. Settings StaticApp : Optional - mögliche Werte 0 oder 1 Beispiel: StaticApp = 1 Standardmäßig wird für jeden Druck eine eigene Instanz von Word geöffnet. Wenn der Wert mit 1 angegeben ist, dann wird beim ersten Druck eine Word-Instanz geöffnet, die auch für alle folgenden Drucke verwendet wird. Diese Einstellung kann die Performance verbessern, sie kann aber auch die Stabilität des Print-Service verringern. EXCEL Mit diesem Adapter können Excel-Dateien (.xls / .xlsx) an den Drucker gesendet werden. Assembly: MsOfficePrintAdapter Class: PrintServer.ExcelPrintAdapter Warning Der EXCEL-Adapter ist standardmäßig deaktiviert. Wird der EXCEL-Adapter aktiviert, dann sollte der Print-Service nur im Console-Modus ausgeführt werden. Settings -keine-"
  },
  "doc/publish-wizards/auto-publish.html": {
    "href": "doc/publish-wizards/auto-publish.html",
    "title": "AutoPublish",
    "keywords": "AutoPublish Framework Studio bietet eine Möglichkeit, Anwendungen vollständig automatisiert über die Kommandozeile zu publishen. So können Publish- / Publish2Go-Vorgänge z.B. per Batch in der Nacht angestoßen werden. Dabei gibt es die Möglichkeit, ein bestimmtes Setting direkt aus dem Repository heraus zu publishen oder einen automatisierten Publish-Vorgang von einem Publish2Go-Paket anzustoßen. Beide Möglichkeiten werden im Folgenden beschrieben. AutoPublish mit FSConsole Um mit FSConsole.exe ein Setting publishen zu können, muss dieses in Framework Studio als öffentliches Setting gespeichert werden. Auf dem Panel „End“ befindet sich der Button „Save Setting“. Im Dialog einen entsprechenden Namen eingeben und das Setting speichern. „Save as personal“ darf nicht aktiviert sein, da sonst das Setting vom FrameworkCompiler (welcher den AutoPublish durchführt) nicht gefunden wird. Ist das Setting gespeichert, kann der Konsolenbefehl für den AutoPublish vorbereitet werden. Folgende Parameter müssen übergeben werden: \\Publish Initiiert den AutoPublish-Vorgang \\ConnectionType „SqlServer“ oder „Oracle“ \\Server Name oder IP des Datenbankservers \\Database Name der Datenbank \\DBUser Datenbank-User (z.B. „sa“) \\DBPassword Passwort des Users \\Package Name des zu publishenden Packages \\Version Package Version, die gepublished werden soll \\Setting Öffentliches Setting, welches gepublished werden soll \\Logfile (optional) Pfad mit Dateiname des Logfiles Beispiel FSConsole.exe \\Publish \\ConnectionType SqlServer \\Server NVDBServer \\Database eNVenta \\DBUser dbadmin \\DBPassword dbadminpw123 \\Package Themes \\Version 1.0 \\Setting “AutoPublishSetting” \\Logfile “C:\\AutoPublish.log” Note Bei einer Oracle-Verbindung werden DBUser und DBPassword nicht benötigt (TNSNAMES). Warning Wird vom AutoPublish-Vorgang erkannt, dass das ausgewählte Setting schon gepublished ist, wird automatisch ein Revoke durchgeführt und die Installation gelöscht bevor der AutoPublish-Vorgang angestoßen wird. AutoPublish mit Publish2Go Da beim Publish2Go kein Repository verfügbar ist, sieht die Vorbereitung etwas anders aus. Hier wird ein exportiertes Setting benötigt. Ein Setting kann entweder über den Publish Wizard in Framework Studio oder direkt mit dem Publish2Go Wizard des Pakets erstellt werden. Im Panel „End“ kann über den Button „Save Setting“ das aktive Setting als *.p2gosetting Datei auf die Festplatte exportiert werden. Runtime-Lizenzen, die vom AutoPublish-Vorgang mit installiert werden sollen, müssen sich im Root-Ordner des Publish2Go-Pakets befinden (auf Höhe der Datei „sqlitedb.p2go“). Das Setting wird als Parameter an die Publish2Go.exe übergeben und muss somit nicht zwingend im Root-Ordner liegen. Folgende Parameter müssen übergeben werden: \\Publish Initiiert den AutoPublish-Vorgang \\Setting Pfad zum Setting, welches gepublished werden soll \\Logfile (optional) Pfad mit Dateiname des Logfiles Beispiel Publish2Go.exe \\Publish \\Setting “C:\\Publish2Go\\AutoPublishSetting.p2gosetting” \\Logfile “C:\\AutoPublish.log” Note Wird vom AutoPublish-Vorgang erkannt, dass das ausgewählte Setting schon gepublished ist, wird automatisch ein Revoke durchgeführt und die Installation gelöscht bevor der AutoPublish-Vorgang angestoßen wird."
  },
  "doc/publish-wizards/load-balancing.html": {
    "href": "doc/publish-wizards/load-balancing.html",
    "title": "Load Balancing",
    "keywords": "Load Balancing Framework Studio bietet die Möglichkeit, eine Lastenverteilung über mehrere Broker hinweg zu definieren. Im Beispiel werden 3 Applications veröffentlicht. In der Application „ThemesApplication“ sind die anderen zwei Broker als Load Balancing Broker hinterlegt. Diese können auf demselben oder auf einem ganz anderen Server laufen. Startet ein User die Application „ThemesApplication“ wird er von diesem Broker auf einen der anderen verwiesen und kommuniziert von nun an mit dem zugewiesenen Broker. User 1 startet die Anwendung „ThemesApplication“. Der Client sendet einen ersten Request. Der Broker (Verteiler) erkennt, dass zwei andere Broker als Load Balancing Broker hinterlegt sind und wird dem Client im ersten Response im Round Robin Verfahren eine der beiden Broker-Adressen übergeben. Ab diesem Zeitpunkt wird der Client von User 1 seine Requests nur noch an den vom Verteiler zugewiesenen Broker senden. Auf welchem Broker der jeweilige Client gerade arbeitet, ist in der Titelleiste des JavaClients ersichtlich. Note Bei einem Update der Applikationen sollte darauf geachtet werden, dass auch der Verteiler Broker aktualisiert wird, da der JavaClient einige Daten vom Broker erhält. Warning Wenn mehrere Broker auf demselben Server veröffentlicht werden, sollte darauf geachtet werden, dass diese in unterschiedlichen Application Pools laufen, da ein Pool ab ca. 4GB Speicherauslastung spürbar langsamer werden kann Load Balancing hat keinen Effekt mehr."
  },
  "doc/publish-wizards/publish2go-export-wizard.html": {
    "href": "doc/publish-wizards/publish2go-export-wizard.html",
    "title": "Publish2Go Export-Wizard",
    "keywords": "Publish2Go Export-Wizard Der Publish2Go Export-Wizard wird verwendet, wenn mit Framework Studio entwickelte Applikationen und Dienste (Service Hosts) auf einem Rechner (oder auch auf mehreren Rechnern) installiert werden sollen, auf denen kein Framework Studio installiert ist (siehe Publish2Go Prinzip ). Gestartet wird der Publish2Go Export-Wizard über den Menüeintrag Tools / Publish2Go Export . Der Publish2Go Export-Wizard arbeitet grundsätzlich wie bei Wizards üblich. Man kann sich mit den Buttons Back und Next durch die verschiedenen Einstellungen navigieren. Um gezielt eine bestimmte Einstellung zu ändern, können Sie diese auch direkt über den Baum anwählen. Button Restore Default Settings: Sämtliche Einstellungen, die im Publish2Go Export-Wizard definiert wurden, werden verworfen. Damit wird alles auf die Default-Einstellungen zurückgestellt. Die Default-Einstellungen werden aus der FSDomain gelesen. Button Back, Next: Zur vorherigen bzw. nächsten Einstellung navigieren. Button Run: Die ausgewählte Applikation und die ausgewählten Service Hosts werden gestartet. Siehe auch Registerkarte End Button Close: Schließt den Publish2Go Export-Wizard. Die geänderten Einstellungen werden in dem aktuellen User-Setting gespeichert. Start Folder Name: In diesem Eingabefeld wird der Name des zu erstellenden Publish2Go-Verzeichnisses angegeben. Das Verzeichnis muss leer sein. Button Load Setting: Hier kann ein gespeichertes Setting aus dem Repository geladen werden. Alle nicht gespeicherten Angaben gehen dabei verloren. Runtime License Beim Erstellen eines Publish2Go-Pakets ist es möglich, die zugehörigen Runtime Lizenzen gleich mit zu exportieren. Dazu steht im Publish2Go Wizard der aus dem normalen Publish Wizard bekannte Runtime License Manager zur Verfügung. Nachdem das Paket erfolgreich erstellt wurde, befinden sich die Runtime Lizenzen im angegebenen Ordner. Beim Starten des Publish2Go werden alle im Ordner befindlichen Lizenzen automatisch eingelesen. Service Proxies Hier kann die Serviceadresse von externen Diensten geändert werden. End Save Setting: Mit diesem Button öffnen Sie den Dialog zum Speichern der aktuellen Einstellungen in der Datenbank. Im Bereich Choose Applications and Service Hosts you want to publish wählen Sie alle Applikationen und Service Hosts aus, die zur Verfügung gestellt werden sollen. Benutzen Sie den Button Create um den Publish2GO-Ordner mit den ausgewählten Applikationen und Service Hosts zu erstellen."
  },
  "doc/publish-wizards/publish2go-wizard.html": {
    "href": "doc/publish-wizards/publish2go-wizard.html",
    "title": "Publish2Go-Wizard",
    "keywords": "Publish2Go-Wizard Allgemeine Informationen zum Publish2Go finden Sie unter Publish2Go Prinzip . Gestartet wird der Publish-Vorgang mit der Datei Publish2Go.exe im entsprechenden Unterordner 32bit oder 64bit des erstellten Publish2Go-Verzeichnisses. Der Publish2Go Wizard entspricht im Wesentlichen dem normalen Publish Wizard und weicht nur in den folgenden Punkten davon ab: Unter dem Navigationspunkt Start kann über den Button Load Setting ein zuvor vorbereitetes Setting aus einer Datei geladen werden. Unter dem Navigationspunkt End kann analog dazu ein Setting für die erneute Verwendung in eine Datei gespeichert werden. Unter dem Navigationspunkt Runtime License wird wie gewohnt die aktuelle Lizenzkonfiguration (Laufzeitlizenzen für alle Packages) verwaltet. Diese Lizenzen werden im Publish2Go-Verzeichnis gespeichert. Mit dem Button Select License File kann eine andere Lizenzdatei zur Verwendung ausgewählt werden. Liegt diese Datei nicht im oben genannten Verzeichnis, wird sie automatisch dorthin kopiert. Note Wenn für jedes Package genau eine Laufzeitlizenz im Publish2Go-Verzeichnis liegt werden diese Lizenzen automatisch als gültige Lizenzkonfiguration verwendet. Mit dem Button Publish wird wie gewohnt der Publish-Vorgang gestartet. Service Release Beim Export eines Service-Release-Paketes über den Package-Manager wird neben der srdb-Export-Datei auch ein Ordner erstellt. Dieser beinhaltet die im Service-Release geänderten DLLs. Im Navigationspunkt Service-Release können diese Ordner angegeben werden. Beim Publish-Vorgang ersetzen diese, in den Service-Release-Ordnern enthaltenen, Dateien die ursprünglichen Dateien. Die Service-Release-Ordner werden vom Publish2Go-Wizard automatisch erkannt, wenn sie wie in der Abbildung gezeigt, in den Publish2Go-Ordner gepackt werden. Erkannt werden sie genau dann, wenn die Namen der Ordner mit \"Package_Version\" enden. In diesem Fall werden die Ordner automatisch vorbelegt. Über diesen Mechanismus können bei Bedarf auch gezielt andere Dateien - wie z.B. Reports – ersetzen. Die Ordner-Struktur muss dabei der des Brokers entsprechen."
  },
  "doc/publish-wizards/publish-wizard.html": {
    "href": "doc/publish-wizards/publish-wizard.html",
    "title": "Publish Wizard",
    "keywords": "Publish Wizard Der Publish-Wizard wird verwendet, wenn mit Framework Studio entwickelte Applikationen und Dienste (Service Hosts) lokal veröffentlicht (installiert) werden sollen. Gestartet wird der Publish-Wizard über den Menüeintrag Tools / Publish Wizard . Der Publish-Wizard arbeitet grundsätzlich wie bei Wizards üblich. Man kann sich mit den Buttons Back und Next durch die verschiedenen Einstellungen navigieren. Um gezielt eine bestimmte Einstellung zu ändern kann man diese auch direkt über den Baum anwählen. Button Restore Default Settings: Sämtliche Einstellungen, die im Publish-Wizard definiert wurden, werden verworfen. Damit wird alles auf die Default-Einstellungen zurückgestellt. Die Default-Einstellungen werden aus der FSDomain gelesen. Button Back, Next: Zur vorherigen bzw. nächsten Einstellung navigieren. Button Publish: Installiert die Umgebung. Es werden die Applications und Services auf dem Rechner installiert. Siehe auch Registerkarte End Button Close: Schließt den Publish-Wizard. Die geänderten Einstellungen werden in dem aktuellen User-Setting gespeichert. Start Installation Name Hier muss ein eindeutiger Name für die Installation angegeben werden. Das ist vor allem dann wichtig, wenn man mehrere verschiedene Umgebungen installieren möchte. Framework Studio merkt sich unter diesen Namen alle erzeugten Verzeichnisse und Dienste. Wird eine Umgebung erneut gepublished, dann wird erst alles, was unter diesem Namen installiert wurde entfernt, bevor die neuen Dateien rausgeschrieben werden. Standardmäßig wird der Name des aktuellen Packages vorbelegt. Windows Service Prefix Wenn Services als Windows Dienst installiert werden, dann muss Framework Studio diesen Diensten einen eindeutigen Namen geben. Als Dienst-Name wird der Name des Services verwendet. Damit bei mehreren unterschiedlichen Installationen auf einem Rechner die Dienst-Namen eindeutig bleiben, kann man hier einen Prefix angeben, der dem Dienst-Namen vorangestellt werden soll. Standardmäßig wird der Name des aktuellen Packages vorbelegt. Server-Culture Hier kann eine Culture definiert werden (z.B: de-DE , de-CH oder en-US ) mit der die Anwendung ausgeführt werden soll. Dies wirkt sich auf Culture-spezifische Aktionen wie z.B. Zahlen- und Datums-Formate aus. Erfolgt keine Angabe, dann wird die Culture des Betriebssystems verwendet. Client-Timeout Der Java-Client meldet sich in der Regel alle 2 Minuten beim Server - auch wenn der Benutzer keine Aktionen ausführt. Bleiben diese Meldungen aus beendet der Broker die entsprechende Session nach dem definierten Timeout. Dadurch werden Lizenzen und Ressourcen freigegeben, wenn ein Benutzer z.B. seinen Rechner ausschaltet ohne den Client zuvor zu beenden. Der Standard-Wert ist 5 Minuten. Logging / Tracing Hier kann definiert werden, ob und in welche Ordner protokolliert werden soll. Warning Beide Protokollierung erzeugen große Daten-Mengen. Die Protokolle sollten nur gezielt in konkreten Situationen aktiviert werden. Checkbox Session Trace : Diese Checkbox aktiviert das Session Trace . Dazu muss ein entsprechender Folder angegeben werden, in dem die Daten protokolliert werden sollen. Ist die Checkbox nicht gesetzt, dann hat ein ggf. definierter Ordner keine Funktion. Checkbox Broker XML : Ist diese Checkbox gesetzt, dann werden alle Broker-Requests und Responses als XML-Datei gespeichert. Das kann hilfreich sein um ganz konkrete Probleme im Detail zu analysieren. Dazu muss ein entsprechender Folder angegeben werden, in dem die Daten protokolliert werden sollen. Ist die Checkbox nicht gesetzt, dann hat ein ggf. definierter Ordner keine Funktion. Warning In den XML-Dateien sind ALLE Daten enthalten, die ein Benutzer am Client eingibt und angezeigt bekommt. Das kann auch benutzerbezogene und sensible umfassen - insbesondere in produktiven Umgebungen. Button Revoke Release Mit diesem Button wird die komplette Umgebung deinstalliert. Dabei wird alles das deinstalliert, was unter dem angegebenen Installations-Namen installiert wurde. Button Configure Servernames Mit diesem Button wird ein Dialog geöffnet, mit dem Server, welche einen vom internen Namen abweichenden externen Namen haben, konfiguriert werden können. Mit dem Button New wird in der linken Listbox ein neuer Eintrag angelegt. Dort werden alle Server mit ihrem internen Namen aufgeführt. Mit dem Button Delete wird der Eintrag, den Sie in der linken Listbox ausgewählt haben, gelöscht. Im Eingabefeld Internal server name kann der interne Name bzw. die IP-Adresse für den Eintrag angegeben werden, den Sie in der linken Listbox ausgewählt haben. Im Eingabefeld Existing external server names werden zu einem Eintrag, den Sie in der linken Listbox ausgewählt haben, alle externen Servernamen angegeben. Gibt es mehrere externe Namen für einen Server, so müssen die Namen dort getrennt durch Zeilenumbrüche eingegeben werden. Mit dem Button OK werden alle Änderungen bestätigt und der Dialog geschlossen. Mit dem Button Cancel werden alle Änderungen verworfen. Button Session Logging Analyzer Dieser Button öffnen den Session Logging Analyzer und meldet ihn automatisch am Runtime-Repository an. Connection Groups Hier können die Verbindungseinstellungen für die verschiedenen Connection Groups definiert werden. Die RuntimeConnection ist die Verbindung zum Repository. Combobox Registerkarte Database: Hier kann eine Registerkarte Database ausgewählt werden. Die Angaben aus der Registerkarte Database werden entsprechend angezeigt. Diese Angaben werden dynamisch aus den Registered Databases gelesen. Wenn sich also dort die Angaben ändern, werden diese auch hier verwendet. Button Individual: Mit diesem Button kann man eine individuelle Verbindung definieren. Die Felder für die Verbindungsdaten werden freigeschaltet und können entsprechend definiert werden. Note Diese Daten gehen verloren, wenn aus der Combobox eine Datenbank ausgewählt wird. Wenn eine Verbindung häufiger verwendet wird, dann ist es empfehlenswert, dafür eine Registerkarte Database anzulegen und diese dann hier auszuwählen. Authentication Hier können die Grundeinstellungen für die Authentication definiert werden. Im Eingabefeld Default User wird der Name des Benutzers angegeben, der bei eingeschalteter Authentifizierung von der mit Framework Studio erstellten Applikation automatisch verwendet wird, solange noch gar kein Benutzer authentifiziert wurde. Im Eingabefeld Default Password wird das Password des Default Benutzers angegeben. Im Eingabefeld Public Key (Auth. Service) wird der öffentliche Schlüssel des Authentifizierungsdienstes angegeben, der von den Applikationen und Service Hosts verwendet werden soll. Wenn der Authentifizierungsdienst läuft, kann der öffentliche Schlüssel des Authentifizierungsdienstes mit dem Button Get key from Auth. Service vom Dienst erfragt werden und wird automatisch in das Eingabefeld übernommen. Im nicht editierbaren Eingabefeld Auth. Service Address wird die Adresse angezeigt, unter der alle Applikationen und Service Hosts, die mit Authentifizierung arbeiten, den Authentifizierungsdienst ansprechen. Diese Einstellung kann am AuthService Proxy geändert werden. Um zum AuthService Proxy zu wechseln, kann der Link Button Configure Auth. Service Proxy verwendet werden. Runtime Licenses Hier werden die zu verwendenden Laufzeitlizenzen konfiguriert. Die Lizenzkonfiguration kann mit dem Button Change configuration geändert werden. Siehe Laufzeitlizenzen Applications Hier können alle Applikationen konfiguriert werden. Application properties Title: Name der Applikation. Dieser wird später im Anwendungsfenster und in der Task Leiste des Betriebssystems als Bezeichnung der Applikation angezeigt. Service Name: Name der Applikation. Unter diesem Namen wird im IIS ein Verzeichnis für die Applikation registriert. Der Name darf nur alphanumerische Zeichen und den Unterstrich enthalten. Service Address: Ist die Checkbox nicht gesetzt, wird die Serviceadresse, unter der das Applikationsverzeichnis erreichbar ist, automatisch vorbelegt. Ist die Checkbox gesetzt, kann die Service Adresse manuell angegeben werden. Insbesondere, wenn die externe Adresse des Servers von dem eigenen Namen des Servers abweicht, muss hier eine manuelle Eingabe durchgeführt werden. Bei abweichender externer Adresse muss diese hier eingetragen werden, gefolgt von einem Schrägstrich „/“ und dem Service Name . Die interne Adresse wird dann automatisch aus den Einstellungen unter Start ermittelt. Directory: Verzeichnis, in dem die Applikationsdateien abgelegt werden sollen. Der IIS muss mindestens lesend auf dieses Verzeichnis zugreifen dürfen. Mit dem Button … wird ein Ordner-Auswahldialog geöffnet. Server Culture: Kultureinstellung, die im Server verwendet werden soll. Diese hat beispielsweise Auswirkungen auf „ToString()“ Methoden im Applikationscode. Configuration: Hier können in einer Xml Struktur Parameterwerte angegeben werden, die der Applikation beim Start mit übergegeben werden und in der Programmlogik über das GlobalObject ausgewertet werden können. Enable Java Web Start: Damit kann auf der Client Start Page die Client-Option Java Web Start ein- oder ausgeblendet werden. Note Benutzerdefiniertes XML wird weder von FS, noch während der Laufzeit geparst oder auf Validität/Wohlgeformtheit geprüft. Registerkarte Authentication Enabled: Nur dann, wenn in dieser Checkbox ein Häkchen gesetzt ist, wird die Applikation mit Authentifizierung gestartet. Nur dann sind auch die weiteren Einstellungen zur Authentifizierung zugänglich. Name: Name der Applikation, mit der sich die Applikation am Authentifizierungsdienst anmelden soll. Description: Beschreibung der Applikation. ID: Eindeutige Identifikationsnummer der Applikation. Diese wird mit dem Button Generate New Identity zufällig erzeugt. Public Key, Private Key: Öffentlicher und privater Schlüssel der Applikation. Die Schlüssel werden vom Authentifizierungsdienst verwendet, um diese Applikation zweifelsfrei zu identifizieren. Die Schlüssel werden mit dem Button Generate New Identity zufällig initialisiert. Generate New Identity: Für die Applikation wird eine neue Identität generiert. Durch diesen Vorgang werden ID , Public Key und Private Key mit zufälligen Werten gefüllt. Registerkarte Images Auf der Registerkarte Images können Hintergrundbild ( Background Image ), Startbild ( Start Image ) und das Icon der Applikation angepasst werden. Dafür stehen die Buttons und Reset zur Verfügung. Mit dem Button wird ein Dateiauswahldialog geöffnet. Mit dem Button Reset wird das jeweilige Bild auf die Standardeinstellung zurückgesetzt. Registerkarte Load Balancing Auf der Registerkarte Load Balancing können zusätzliche Broker für die Lastenverteilung definiert werden siehe Load Balancing Service Hosts Für jeden mit Framework Studio erstellten Service Host (Dienst), der publiziert werden soll, werden hier alle Einstellungen vorgenommen. Service Host - General Hier werden allgemeine Einstellungen zu einem Service Host vorgenommen. Servername: Name des Servers, auf dem der Dienst/Service Host installiert werden soll. Port: Port, unter dem der Dienst bereitgestellt werden soll. Hostname: Wenn das Häkchen gesetzt ist, kann der Name des ServiveHosts überschrieben werden. Dies hat Einfluss auf den Platzhalter %HOSTNAME% in der Base Address des Service Hosts und dessen Endpoints. CORS Origin: Wenn ein Service gehostet wird, der direkt über JavaScript aus dem Browser angesprochen wird, kann hier der CORS Origin gesetzt werden, welcher per HTTP-Header an den Client geschickt wird. Bei jedem Response des Services wird der Header „Access-Control-Allow-Origin“ mit dem angegebenen Wert mitgeschickt. Username: Gibt den Benutzer an, mit dem der Windows-Dienst für den Service Host installiert werden soll. Eine Domäne kann mit der Schreibweise „Domäne\\Username“ angegeben werden. Es stehen auch die drei Systemkonten „Local Service“, „Local System“ und „Network Service“ zur Auswahl. Ist eines dieser Konten ausgewählt, ist kein Passwort erforderlich. Password: Das Passwort zum ausgewählten Benutzer. Configuration: Hier können in einer Xml-Struktur Parameterwerte angegeben werden, die der Applikation beim Start mit übergegeben werden und in der Programmlogik über das GlobalObject ausgewertet werden können. Note Benutzerdefiniertes XML wird weder von FS, noch während der Laufzeit geparst oder auf Validität/Wohlgeformtheit geprüft. Trace: Einstellungen zur Protokollierung (Tracing) Activate: Nur wenn diese Checkbox gesetzt ist, wird Protokollierung verwendet und es können weitere Einstellungen vorgenommen werden. Output File: Datei, in die die Trace-Informationen geschrieben werden sollen. Mit dem Button wird ein Dateiauswahl-Dialog geöffnet. Trace Level: Über die Auswahlbuttons wird das Trace Level festgelegt. Activity Tracing: Activity Tracing ein- oder ausschalten Service Host - Authentication Hier werden die Authentifizierungseinstellungen zu einem Service Host vorgenommen. Enabled: Nur dann, wenn in dieser Checkbox ein Häkchen gesetzt ist, wird die Applikation mit Authentifizierung gestartet. Nur dann sind auch die weiteren Einstellungen zur Authentifizierung zugänglich. Name: Name der Applikation, mit der sich die Applikation am Authentifizierungsdienst anmelden soll. Description: Beschreibung der Applikation. ID: Eindeutige Identifikationsnummer der Applikation. Diese wird mit dem Button Generate New Identity zufällig erzeugt. Public Key, Private Key: Öffentlicher und privater Schlüssel der Applikation. Die Schlüssel werden vom Authentifizierungsdienst verwendet, um diese Applikation zweifelsfrei zu identifizieren. Die Schlüssel werden mit dem Button Generate New Identity zufällig initialisiert. Generate New Identity: Für die Applikation wird eine neue generiert. Durch diesen Vorgang werden ID , Public Key und Private Key mit zufälligen Werten gefüllt. Service Directories Für alle Server wird hier jeweils im Eingabefeld hinter dem Servernamen das Verzeichnis angegeben, in das alle Service Dateien gespeichert werden sollen. Mit dem Button wird ein Ordnerauswahl-Dialog geöffnet. Service Proxies Hier kann die Serviceadresse von externen Diensten geändert werden. End Hier werden alle Applikationen und Dienste (Service Hosts) aufgelistet, die zur Installation zur Verfügung stehen. Wenn einzelne Einträge ausgegraut dargestellt werden, sind nicht alle nötigen Konfigurationseinstellungen vorgenommen worden. In diesem Fall steht in Klammern hinter dem Namen der Applikation bzw. des Dienstes ein Hinweis, warum die Installation nicht möglich ist. Benutzen Sie den Button Publish um die Veröffentlichung zu starten. Save Setting: Mit diesem Button öffnen Sie den Dialog zum Speichern der aktuellen Einstellungen in der Datenbank. Auflistung blockierender Prozesse und Netzwerksitzungen Beim Publish sowie beim Revoke wird überprüft, ob das Zielverzeichnis von einem Prozess oder einer Netzwerksitzung blockiert wird. Im GUI Modus werden diese Blockaden aufgelistet. Über das Kontextmenü lassen sich einzelne davon abräumen. Der Button Terminate all löst alle aufgelisteten Blockaden. Über den Button Retry kann erneut das Löschen des Verzeichnisses angestoßen werden. Geschieht der Publish aus der Konsole, so wird ein Terminate all forciert. D.h. alle Prozesse und Netzwerksitzungen, die das Löschen des Zielverzeichnisses unterbinden, werden unmittelbar beendet."
  },
  "doc/publish-wizards/run-wizard.html": {
    "href": "doc/publish-wizards/run-wizard.html",
    "title": "Run Wizard",
    "keywords": "Run Wizard Der Run-Wizard wird verwendet, wenn mit Framework Studio entwickelte Applikationen und Dienste (Service Hosts) getestet werden sollen. Gestartet wird der Run-Wizard über den Menüeintrag Compile / Run… oder über die Tastenkombination Umschalt+F5 . Der Run-Wizard arbeitet grundsätzlich wie bei Wizards üblich. Man kann sich mit den Buttons Back und Next durch die verschiedenen Einstellungen navigieren. Um gezielt eine bestimmte Einstellung zu ändern kann man diese auch direkt über den Baum anwählen. Button Restore Default Settings: Sämtliche Einstellungen, die im Run-Wizard definiert wurden, werden verworfen. Damit wird alles auf die Default-Einstellungen zurückgestellt. Die Default-Einstellungen werden aus der FSDomain gelesen. Button Back, Next: Zur vorherigen bzw. nächsten Einstellung navigieren. Button Run: Die ausgewählte Applikation und ausgewählten Service Hosts werden gestartet. Siehe auch Registerkarte End Button Close: Schließt den Run-Wizard. Die geänderten Einstellungen werden in dem aktuellen User-Setting gespeichert. Start Active Languages In dieser Liste kann die Sprach-Hierarchie definiert werden. Start Mode Mit der Combobox wird der zu startende Client ausgewählt. Client Launcher: Die Anwendung wird als Java-Client über den FS Client Launcher gestartet. Java Client: Die Anwendung wird als Java-Client über Java WebStart gestartet. Das setzt die Installation einer Java Runtime voraus. Html Client: Es wird der HTML-Client im Browser geöffnet. Diese Option steht nur zur Verfügung, wenn der HTML-Client in der Application aktiviert ist. Client Start Page: Es wird die Client Start-Page im Browser angezeigt. Diese Aktion kann man auch direkt mit dem Befehl Open Client Start Page (F6) aufrufen. Server-Culture Hier kann eine Culture definiert werden (z.B: de-DE , de-CH oder en-US ) mit der die Anwendung ausgeführt werden soll. Dies wirkt sich auf Culture-spezifische Aktionen wie z.B. Zahlen- und Datums-Formate aus. Erfolgt keine Angabe, dann wird die Culture des Betriebssystems verwendet. Logging / Tracing Hier kann definiert werden, ob und in welche Ordner protokolliert werden soll. Warning Beide Protokollierung erzeugen große Daten-Mengen. Die Protokolle sollten nur gezielt in konkreten Situationen aktiviert werden. Checkbox Session Trace : Diese Checkbox aktiviert das Session Trace . Dazu muss ein entsprechender Folder angegeben werden, in dem die Daten protokolliert werden sollen. Ist die Checkbox nicht gesetzt, dann hat ein ggf. definierter Ordner keine Funktion. Checkbox Broker XML : Ist diese Checkbox gesetzt, dann werden alle Broker-Requests und Responses als XML-Datei gespeichert. Das kann hilfreich sein um ganz konkrete Probleme im Detail zu analysieren. Dazu muss ein entsprechender Folder angegeben werden, in dem die Daten protokolliert werden sollen. Ist die Checkbox nicht gesetzt, dann hat ein ggf. definierter Ordner keine Funktion. Button Session Logging Analyzer Dieser Button öffnen den Session Logging Analyzer und meldet ihn automatisch am Runtime-Repository an. Connection Groups Hier können die Verbindungseinstellungen für die verschiedenen Connection Groups definiert werden. Die RuntimeConnection ist die Verbindung zum Repository. Combobox Registerkarte Database: Hier kann eine Registerkarte Database ausgewählt werden. Die Angaben aus der Registerkarte Database werden entsprechend angezeigt. Diese Angaben werden dynamisch aus den Registerkarte Databases gelesen. Wenn sich also dort die Angaben ändern, werden diese auch hier verwendet. Button Individual: Mit diesem Button können Sie eine individuelle Verbindung definieren. Die Felder für die Verbindungsdaten werden freigeschaltet und können entsprechend definiert werden. Diese Daten gehen verloren, wenn aus der Combobox eine Datenbank ausgewählt wird. Wenn eine Verbindung häufiger verwendet wird, dann ist es empfehlenswert, dafür eine Registerkarte Database anzulegen und diese dann hier auszuwählen. Authentication Hier können die Grundeinstellungen für die Authentication definiert werden. Im Eingabefeld Default User wird der Name des Benutzers angegeben. Dieser Name wird von der mit Framework Studio erstellten Applikation automatisch verwendet, wenn die Authentifizierung eingeschaltet ist. Dies gilt nur solange noch gar kein Benutzer authentifiziert wurde. Im Eingabefeld Default Password wird das Password des Default Benutzers angegeben. Im Eingabefeld Public Key (Auth. Service) wird der öffentliche Schlüssel des Authentifizierungsdienstes angegeben, der von den Applikationen und Service Hosts verwendet werden soll. Wenn der Authentifizierungsdienst läuft, kann der öffentliche Schlüssel des Authentifizierungsdienstes mit dem Button Get key from Auth. Service vom Dienst erfragt werden und wird automatisch in das Eingabefeld übernommen. Im nicht editierbaren Eingabefeld Auth. Service Address wird die Adresse angezeigt, unter der alle Applikationen und Service Hosts, die mit Authentifizierung arbeiten, den Authentifizierungsdienst ansprechen. Diese Einstellung kann am AuthService Proxy geändert werden. Um zum AuthService Proxy zu wechseln, kann der Link Button Configure Auth. Service Proxy verwendet werden. Runtime Licenses Hier werden die zu verwendenden Laufzeitlizenzen konfiguriert. Die Lizenzkonfiguration kann mit dem Button Change configuration geändert werden. Siehe Laufzeitlizenzen Applications Hier können alle Applikationen konfiguriert werden. Mit der Combobox Choose application wird die zu startende Applikation festgelegt. Application properties Title: Name der Applikation. Dieser wird später im Anwendungsfenster und in der Task-Leiste des Betriebssystems als Bezeichnung der Applikation angezeigt. Server Culture: Kultureinstellung, die im Server verwendet werden soll. Diese hat beispielsweise Auswirkungen auf „ToString()“ Methoden im Applikationscode. Configuration: Hier können in einer Xml Struktur Parameterwerte angegeben werden, die der Applikation beim Start mit gegeben werden und in der Programmlogik ausgewertet werden können. Enable Java Web Start: Damit kann auf der Client Start Page die Client-Option Java Web Start ein- oder ausgeblendet werden. Registerkarte Authentication Enabled: Nur dann, wenn in dieser Checkbox ein Häkchen gesetzt ist, wird die Applikation mit Authentifizierung gestartet. Nur dann sind auch die weiteren Einstellungen zur Authentifizierung zugänglich. Name: Name der Applikation, mit der sich die Applikation am Authentifizierungsdienst anmelden soll. Description: Beschreibung der Applikation. ID: Eindeutige Identifikationsnummer der Applikation. Diese wird mit dem Button Generate New Identity zufällig erzeugt. Public Key, Private Key: Öffentlicher und privater Schlüssel der Applikation. Die Schlüssel werden vom Authentifizierungsdienst verwendet, um diese Applikation zweifelsfrei zu identifizieren. Die Schlüssel werden mit dem Button Generate New Identity zufällig initialisiert. Generate New Identity: Eine neue Identität für die Applikation wird generiert. Durch diesen Vorgang werden ID, Public Key und Private Key mit zufälligen Werten gefüllt. Registerkarte Images Auf der Registerkarte Images können Hintergrundbild ( Background Image ), Startbild ( Start Image ) und das Icon der Applikation angepasst werden. Dafür stehen die Buttons und Reset zur Verfügung. Mit dem Button wird ein Dateiauswahldialog geöffnet. Es dürfen nur Bilder aus dem Brokerverzeichnis angegeben werden. Mit dem Button Reset wird das jeweilige Bild auf die Standardeinstellung zurückgesetzt. Service Hosts Für jeden mit Framework Studio erstellten Service Host, der gestartet werden soll, werden hier alle Einstellungen vorgenommen. Service Host – General Hier werden allgemeine Einstellungen zu einem Service Host vorgenommen. Active (Start Development Service Host): Wenn diese Checkbox gesetzt ist, wird dieser Service Host zum Starten via F5 markiert, andernfalls nicht. Servername: Name des Servers, auf dem der Dienst/Service Host installiert werden soll. Port: Port, unter dem der Dienst bereitgestellt werden soll. CORS Origin: Wenn ein Service gehostet wird, der direkt über JavaScript aus dem Browser angesprochen wird, kann hier der CORS Origin gesetzt werden, welcher per HTTP-Header an den Client geschickt wird. Bei jedem Response des Services wird der Header „Access-Control-Allow-Origin“ mit dem angegebenen Wert mitgeschickt. Configuration: Hier können in einer Xml-Struktur Parameterwerte angegeben werden, die der Applikation beim Start mit übergeben werden und in der Programmlogik über das GlobalObject ausgewertet werden können. Note Benutzerdefiniertes XML wird weder von FS, noch während der Laufzeit geparst oder auf Validität/Wohlgeformtheit geprüft. Bereich Trace Activate: Nur wenn diese Checkbox gesetzt ist, wird Protokollierung verwendet und es können weitere Einstellungen vorgenommen werden. Output File: Datei, in die die Trace-Informationen geschrieben werden sollen. Mit dem Button wird ein Dateiauswahl-Dialog geöffnet. Trace Level: Über die Auswahlbuttons wird das Trace Level festgelegt. Activity Tracing: Activity Tracing ein- oder ausschalten. Service Host – Authentication Hier werden die Authentifizierungseinstellungen zu einem Service Host vorgenommen. Enabled: Nur dann, wenn in dieser Checkbox ein Häkchen gesetzt ist, wird die Applikation mit Authentifizierung gestartet. Nur dann sind auch die weiteren Einstellungen zur Authentifizierung zugänglich. Name: Name der Applikation, mit der sich die Applikation am Authentifizierungsdienst anmelden soll. Description: Beschreibung der Applikation. ID: Eindeutige Identifikationsnummer der Applikation. Diese wird mit dem Button Generate New Identity zufällig erzeugt. Public Key, Private Key: Öffentlicher und privater Schlüssel der Applikation. Die Schlüssel werden vom Authentifizierungsdienst verwendet, um diese Applikation zweifelsfrei zu identifizieren. Die Schlüssel werden mit dem Button Generate New Identity zufällig initialisiert. Generate New Identity: Eine neue Identität für die Applikation wird generiert. Durch diesen Vorgang werden ID , Public Key und Private Key mit zufälligen Werten gefüllt. Service Proxies Hier kann die Serviceadresse von externen Diensten geändert werden. End Save Setting: Mit diesem Button öffnen Sie den Dialog zum Speichern der aktuellen Einstellungen in der Datenbank. Benutzen Sie den Button Run um die ausgewählte Applikation und alle zum Starten markierten Service Hosts Service Host – General zu starten. Update config files on start: Das Flag bestimmt, ob bei einem Anwendungsstart über den RunWizard oder F5 die im Development Broker Verzeichnis liegenden Config-Dateien überschrieben werden oder nicht. Standardmäßig ist das Flag aktiviert. Wird das Flag deaktiviert, hat der Entwickler die Möglichkeit, sämtliche Konfigurationsdateien im Development Broker Verzeichnis abzuändern und seine Anwendung mit diesen zu testen, ohne dass bei jedem neuen Start der Anwendung die Konfigurationsdateien von Framework Studio wieder überschrieben werden. So können z.B. in der Web.config des Development Brokers für Testzwecke zusätzlich Trace Listener o.ä. konfiguriert werden oder manuell ein Control Style einer Application vorübergehend abgeändert werden. Betroffene Konfigurationsdateien *.FrameworkBroker.config von Applications *.FrameworkBroker.config von Service Hosts Web.config des Development Brokers Note Nach einem Neustart von Framework Studio ist das Flag grundsätzlich aktiviert (Konfigurationsdateien werden überschrieben)."
  },
  "doc/publish-wizards/wizards.html": {
    "href": "doc/publish-wizards/wizards.html",
    "title": "Wizards zum Starten und Konfigurieren von Anwendungen und Diensten",
    "keywords": "Wizards zum Starten und Konfigurieren von Anwendungen und Diensten Szenarien Framework Studio bietet unterschiedliche Möglichkeiten zum Starten und Installieren von Anwendungen und Diensten. Zum Testen bietet sich die Verwendung des Run-Wizards ) an. Dieser hat insbesondere den Vorteil, dass der Startvorgang sehr schnell geht (Siehe auch Anwendung Starten / Fehlersuche ] Zum Publizieren von Anwendungen und Diensten auf einem Rechner mit Framework Studio kann der Publish-Wizard verwendet werden. Sollen Anwendungen und Dienste auf einem oder mehreren Rechnern publiziert/installiert werden, auf denen kein Framework Studio zur Verfügung steht, so bietet sich die Verwendung des Publish2Go Export-Wizards an. Weitere Details zum Publish2Go Prinzip folgen im nächsten Kapitel. Publish2Go Prinzip Applikationen können grundsätzlich auch auf einem Rechner publiziert/installiert werden, ohne dass dort Framework Studio benötigt wird. Das Vorgehen ist wie folgt Mit Framework Studio wird ein Publish2 Go-Verzeichnis (Dateiordner) erstellt. Darin befindet sich in erster Linie eine SQL-Lite Datei, in der alle für den Publish-Vorgang benötigten Informationen (inkl. aller Dlls) abgelegt sind und (für 32 und 64 bit) die Datei Publish2Go.exe. Dieser Ordner wird zusammen mit geeigneten Laufzeitlizenzen zu den Rechnern übertragen, an denen Installationen durchgeführt werden sollen. Die Installation selbst wird dann mit der Datei Publish2Go.exe durchgeführt. In einem Setting werden alle Einstellungen für den Publish-Vorgang abgespeichert. Dazu zählen beispielsweise Datenbankverbindungen, Applikationsnamen, welche Applikation auf welchem Rechner publiziert werden soll, Installationsverzeichnisse, Laufzeitlizenzen und so weiter. Diese Settings können in eine Datei gespeichert werden und für weitere Publish-Vorgänge (z.B. Updates) wiederverwendet werden. Das Erstellen des Publish2Go-Verzeichnisses wird mit dem Publish2Go Export-Wizard durchgeführt; die Installation vor Ort durch starten der Datei Publish2Go.exe mit dem Publish2Go-Wizard ."
  },
  "doc/report-document-type/convert-crystal-to-devexpress.html": {
    "href": "doc/report-document-type/convert-crystal-to-devexpress.html",
    "title": "Konvertierungsleitfaden Crystal -> DevExpress XtraReports",
    "keywords": "Konvertierungsleitfaden Crystal -> DevExpress XtraReports Auto-converter laufen lassen (technische Subreports wie der GlobalPageBackground müssen nicht konvertiert werden) Unnötige Sections löschen Data Member des Gesamt-Reports setzen / Ein Grouping oder eine Detail-Section mit einem entsprechenden Data Member versehen Zwischen den Sections „verrutschte“ Subreports korrigieren (mit Crystal Report vergleichen) Expressions für unterdrückte Elemente aus dem CR kopieren (lässt sich nicht automatisieren, da Crystal Reports diese nicht erreichbar macht) Ggfs. Formeln neu schreiben, die auf ihrer Ebene keinen Zugriff auf die benötigten Daten haben, oder diese direkt ins Feld kopieren Footer anpassen – PageInfo-Felder konfigurieren und formatieren, überflüssige Labels / PageInfos löschen Bei Bedarf FoldMarks-Control hinzufügen und richtig einstellen (Zum bedingten Anzeigen Expression an Visible property binden) Ungültige Feldreferenzen korrigieren Größen- und Positionsfeintuning der Controls (touchup) Übermäßig komplexe Reports wie z.B. eine Rechnung sollten vermutlich von Grund auf neu gebaut werden. Hierbei wurde stark Crystal-spezifische Logik genutzt, die automatisiert nicht zu greifen ist und manuell ein großer Konvertierungsaufwand wäre."
  },
  "doc/report-document-type/report-document-type.html": {
    "href": "doc/report-document-type/report-document-type.html",
    "title": "Report Document Type",
    "keywords": "Report Document Type Report Document Types stellen die Verbindung zwischen den Components und den Reports dar. Sie definieren, was für Daten in welchem Report ausgegeben werden. Ein Report Document Type enthält eine Angabe, welche Components ausgedruckt werden sollen und welche Reports dafür zur Verfügung stehen. Diese Report Document Types können später in Forms verwendet werden. Report-Document Types sind an dem – Icon zu erkennen. Erstellen, bearbeiten und löschen von Report Document Types Sie erstellen einen neuen Report Document Type, indem Sie in der Registerkarte Namespaces den Namespace auswählen, in dem der Report Document Type abgelegt werden soll. Mit dem Button ( New ) und dem Eintrag ReportDocumentType aus dem Menü wird im markierten Namespace ein neuer Report Document Type angelegt. Dieser wird auch gleich geöffnet. Direkt nach dem Anlegen des Report Document Types steht der Cursor in dem sich öffnenden Designer auf dem Feld Name , wo Sie gleich den Namen eingeben können. Es wird empfohlen, den Namen mit rpt zu beginnen. Löschen können Sie einen Report Document Type mit dem Button ( Delete ). Sie müssen dazu den gewünschten Report Document Type im Namespace-Baum markiert haben. Es gibt auch im Kontext-Menü den Eintrag Delete . Der Löschvorgang wird erst im Repository wirksam, wenn Sie den Button ( Save All ) drücken. DataSource Unter Datasource werden die Components angegeben, die in einem Report ausgegeben werden sollen. Es ist möglich, mehrere Components (Collections) aus unterschiedlichen Namespaces einzubinden. Jede Component wiederum kann für mehrere Reports als Datasource angegeben werden. Mit dem Button Add wird ein neuer Eintrag in der Liste erstellt. In der Combobox Datatype können Sie angeben, welche Component / Collection verwendet werden soll. Im Feld Name können Sie dem Eintrag einen Namen geben. Dieser wird anhand des ausgewählten Datentyps mit einem Standard-Namen vorbelegt. Diese Einträge sind sozusagen die Properties des Reports. Diese Properties müssen später beim Druck mit Werten gefüllt werden. Wenn Sie Components oder Collections eingebunden haben, können Sie diese aufklappen und die Properties der Component / Collection werden angeboten. Sind diese Properties ebenfalls Components, können diese erneut aufgeklappt werden, etc. XSD-Datei Warning Dieses Kapitel ist nur für Crystal Reports relevant. DevExpress XtraReports bindet direkt an die Objekte der Datenquelle, weshalb keine Umwege über die XSD gefahren werden. Am nun aufgeklappten Baum können sie angeben, welche Properties und Komponenten in die XSD-Datei aufgenommen werden sollen. Dazu müssen Sie die Checkbox an dem entsprechenden Eintrag setzen. Note Ein DevExpress Report hat immer Zugriff auf alle Komponenten am Report Document Type und dessen Properties, ob die Checkbox im Einzelfall aktiviert ist oder nicht. Hierzu wird in jede verwendete Component ein ' KomponentenName _Rptx'-Interface generiert. Aus diesen Daten wird eine XSD-Datei (XML-Definition) erstellt. Diese XSD-Datei kann einem Crystal-Report zugewiesen werden. So versteht der Report die Daten, die ihm übergeben werden. Mit jedem Klick im Baum wird die XSD-Datei neu erzeugt. Sie wird im Report-Pfad der aktuellen Applikation abgelegt. Der Name setzt sich folgendermaßen zusammen: Namespaces.rptXXX.xsd. Zum Einstellen des Pfades siehe Kapitel Code-Builder / Applications ( Application ). Beim Druck werden die kompletten Components / Collections an den Report Document Type übergeben. Es werden aber nur die ausgewählten Daten in die XSD weitergegeben. Umso größer die Listen, desto wichtiger für die performance ist es, dass nur die Daten übergeben werden, die wirklich benötigt werden. Crystal Reports nutzt die übergebene XSD-Datei eigenständig, um den Report mit Daten zu füllen. Report Files Auf der Registerkarte Report Files können dem Report Document Type mehrere Reports zugewiesen werden. Diese beinhalten die tatsächlichen Dokumente (jeweils 0 bis 1 Crystal und 0 bis 1 DevExpress). Einen neuen Report fügen Sie beispielsweise über das Kontextmenü der Tabelle hinzu, in der die Reports angezeigt werden. Mit der Checkbox Include Base Reports legen Sie fest, ob vererbte, nicht geänderte Basisreports später in der Applikation zur Auswahl stehen sollen. Sie hat Einfluss darauf, was die Methode ReportDocument. GetReportEnums() zurückgibt. Die folgenden Einstellungen beziehen sich auf den in der Tabelle ausgewählten Report: Im Feld Name kann dem Report ein Name gegeben werden. Warning Dieser Name darf keine Leer- und Sonderzeichen enthalten, weil dieser später im Code zum Einsatz kommt. Mit dem Button Edit Report wird der Report über ein externes Tool bearbeitet. Warning Zum Erstellen und Editieren von Crystal Reports benötigen Sie einen Crystal Reports Designer oder Visual Studio. Der Button Choose File öffnet einen Dateiauswahl-Dialog, in dem Sie eine bestehende Report-Datei zuweisen können. Mit dem Button New Report wird ein neuer, leerer Report erstellt und zugewiesen. Mit dem Button Reset File wird eine einzelne Report-Datei aus einem Report gelöscht. Der Eintrag im Report Document Type und die etwaige andere Report-Datei im selben Eintrag bleiben hierbei unverändert bestehen. Mit dem Button Convert to DevExpress wird die Konvertierungsroutine gestartet. Caption Im Report Document Type können Sie für Crystal Reports lokalisierte Bezeichnungen (Captions) hinterlegen, also die Bezeichnung mehrsprachig pflegen. Diese Captions können zur Laufzeit ausgewertet werden, um z.B. im Druck-Dialog bei der Auswahl der unterschiedlichen Report-Varianten einen sprechenden Text auszugeben. Report-Verzeichnis Auf dem Dateisystem werden die Crystal Report-Dateien mit ihren .xsd-Dateien zusammen vom Compile-Verzeichnis ausgehend im Ordner /Report/ gespeichert. DevExpress Reports erhalten einen weiteren Unterordner, nach dem übergeordneten Report Document Type benannt. Der Report CustomerList aus rptCustomerList wäre also unter /Report/NV.ERP.Base.Customer.rptCustomerList/CustomerList.repx zu finden. Da DevExpress Reports keine .xsd-Dateien benötigen, befinden sich in den Unterordnern ausschließlich die .repx-Dateien. Bei jedem Compile-Vorgang werden Crystal und DevExpress Report-Dateien aus dem Repository in das Dateisystem herausgeschrieben, nach folgenden Regeln: Crystal Alle Crystal Reports aller Report Document Types werden in den /Report/-Ordner geschrieben, inklusive Basis-Reports. DevExpress Alle DevExpress Reports eines Report Document Types im aktuellen Package werden in den entsprechenden Unterordner unter /Report/ herausgeschrieben. Basis-Reports werden nur aus der Basis gesucht und ins Verzeichnis geschrieben, solange am Report Document Type die Checkbox \"Include Base Reports\" gesetzt ist. Crystal Report mit Visual Studio erstellen Öffnen Sie Visual Studio. Legen Sie jetzt ein neues Projekt an (Visual C# Project / leeres Projekt oder empty Project) oder öffnen Sie ein bereits vorhandenes Projekt. Es empfiehlt sich, ein Projekt zur Erstellung und Pflege von Reports anzulegen und dieses immer wieder zu verwenden. Crystal Report auswählen und Open drücken. Es öffnet sich ein Wizard zum Erstellen eines Crystal Reports . Crystal Report Gallery: Auf OK drücken. Standard Report Expert Registerkarte Data: In diesem Fenster wählen Sie den Eintrag Database Files aus. Es öffnet sich ein Datei-Auswahl-Dialog. Hier wählen Sie die von Framework Studio generierte XSD-Datei aus. Diese Datei befindet sich in dem Report Directory, der in Applications angegeben wurde. Unter Database Files wird die XSD-Datei und darunter die darin enthaltenen Tabellen angezeigt. Jede im Report Document Type eingebundene Component wird als eine Tabelle angeboten und bekommt den Namen, den Sie angegeben haben. Ist in einer Component eine andere Component enthalten und wurde diese ebenfalls ausgewählt, wird diese als eigenständige Tabelle angeboten. Sie können nun die gewünschten Tabellen mit einem Doppelklick auswählen. Sie werden dann in die rechte Listbox eingetragen. Mit Next öffnet sich die Registerkarte, in dem Sie die Felder auswählen können, die der Report anzeigen soll. Wählen Sie die gewünschten Felder mit Doppelklick oder Add aus. Mit den Pfeilen über der Liste, mit den ausgewählten Feldern, können Sie noch die Reihenfolge der Felder ändern. Mit Next öffnen sich weitere Fenster, in denen Sie Gruppierungen, Summen, Layouts und weitere Einstellungen vornehmen können. Mit Finish wird der Report erzeugt. Crystal Report mit Visual Studio aktualisieren Wenn Sie in DataSource Components oder Properties hinzufügen oder entfernen, ändert sich die Schnittstelle zum Report und somit auch die XSD-Datei. Dann ist es notwendig, dass diese Änderung dem Report mitgeteilt wird. Dazu öffnen Sie wieder Visual Studio, legen ein leeres Projekt an oder öffnen Ihr Crystal-Reports-Projekt. Am besten fügen Sie zum Projekt den Report aus dem Report-Verzeichnis von Framework Studio hinzu. (Menu Project / Add Existing Item) Warning Achtung: als Dateityp geben Sie Crystal Reports an. Rufen Sie im Field-Explorer bei Database Fields Verify Database auf. Project2 – Microsoft Visual C#.NET [design] – Customer1.rpt Wenn die XSD-Dateien nicht gefunden werden, fragt Visual Studio nach, wo diese zu finden sind. Es werden jetzt die neuen Felder hinzugefügt und die entfernten Felder gelöscht. Das Löschen kann ggf. zu Fehlermeldungen führen. Wenn Sie neue Components eingebunden haben, können diese mit dem Befehl Add/Remove Database manuell hinzugefügt werden. Für den Druck relevante Klassen ReportDocument ReportEnum PrintServer PrintQueue Browserbasierter Report-Designer zur Laufzeit Zur Laufzeit steht ein Report Designer dem Benutzer zur Verfügung. Dieser muss vorher in das System integriert und aufgerufen werden. Im folgenden Beispiel wird ein Report Designer geöffnet, auf eine Bestätigung des Benutzers gewartet und anschließend der geänderte Report ausgedruckt. Warning Diese Funktionalität steht noch nicht vollständig zur Verfügung. // Eigenschaft, um sich die Design Session zu merken private FrameworkSystems.FrameworkBase.Reporting.ReportDesignSession oDesignSession { get; set; } // Einstiegspunkt; hier bspw. über einen Button Click protected virtual void btnGrdReportDesigner_OnClick(FrameworkButtonClickEventArgs e) { rptArticles report = new rptArticles(this.Global, rptArticles.Reports.XArticleReport, ExportFormat.PDF); this.oDesignSession = report.CreateDesigner(); this.oDesignSession.ShowDesigner(); // Öffnet den Report Designer in einem Browser-Fenster MsgBox.Show(FSGeneral.ctMessagesFactory.GetText(this.Global, 10), \"\", MsgBoxButtons.OK, MsgBoxIcons.None, new MsgBoxEventHandler(OnMsgBoxReportDesignSessionClick)); } // Ein Klick auf den MessageBox-Button signalisiert, dass die Bearbeitung abgeschlossen ist protected virtual void OnMsgBoxReportDesignSessionClick(object sender, MsgBoxEventArgs e) { byte[] reportDesign = null; if (this.oDesignSession != null && this.oDesignSession.IsModified()) { // Veränderten Report aus der Session herunterladen reportDesign = this.oDesignSession.GetBytes(); } this.oDesignSession.Dispose(); // Verwerfen der Design Session nicht vergessen this.oDesignSession = null; if (reportDesign == null) { throw new Exception(\"Kein neuer Report vorhanden.\"); } // Drucken des geänderten Reports rptArticles report = new rptArticles(this.Global, rptArticles.Reports.XArticleReport, ExportFormat.PDF); report.SelectedReport.ReportBytes = reportDesign; report.oArticle = oArticleColl; // Beim Drucken wird die Datenquelle benötigt report.Print(); } Weitere Information zum Web-Designer finden Sie unter ReportDesignSession ."
  },
  "doc/resources/resources.html": {
    "href": "doc/resources/resources.html",
    "title": "Resources",
    "keywords": "Resources Allgemeines Ressourcen ermöglichen dem Entwickler, der Anwendung beliebige Dateien zur Verfügung zu stellen. Typische Beispiele für Ressourcen sind: von der Anwendung benötigte Bilder Custom Control Erweiterungen auf der Seite der Clients externe Bibliotheken (dlls), die von der Anwendung benutzt werden Bedeutung von Namespaces für Ressourcen Ressourcen können im Objekt-Baum ( Registerkarte Namespaces ) im Namespace FSGeneral / Resources angelegt werden. Beim Kompilieren von Ressourcen werden diese dann direkt ins Brokerverzeichnis kopiert. Außerdem können im Namespace FSGeneral / Resources weitere Namespaces angelegt werden. Diese Namespaces werden beim Kompilieren von Ressourcen automatisch als Unterverzeichnisse im Brokerverzeichnis angelegt, sobald sie eine Ressource enthalten. Die Ressourcen eines Unter-Namespaces werden dann ins entsprechende Unterverzeichnis des Brokers kopiert. Erstellen und Löschen von Ressourcen Für das Erstellen und Löschen ist zu beachten, in welchem Namespace die Ressource angelegt werden muss ( Bedeutung von Namespaces für Ressourcen ). Ansonsten werden Ressourcen wie alle anderen Elemente angelegt. Erstellen einer Ressource Löschen einer Ressource Bearbeiten von Ressourcen Durch einen Doppelklick auf eine Ressource im Objekt-Baum wird das Designer-Fenster geöffnet. Resource Dort können Sie mit dem Button Import File einen Dateiauswahldialog öffnen. Dort wählen Sie die Datei aus, die ins Brokerverzeichnis kopiert werden soll. Nach dem Import wird der Name der Ressource mit dem Namen der ausgewählten Datei initialisiert. Sie können diesen Namen im Textfeld Name ändern. Im nicht editierbaren Textfeld Relative Path wird der Pfad relativ zum Brokerverzeichnis angezeigt, unter dem die Datei letztendlich angelegt wird. Der Pfad ergibt sich aus dem Namespace, in dem die Ressource angelegt wurde ( Bedeutung von Namespaces für Ressourcen ) und dem Namen der Ressource. Erläuterungen zu den Standardfunktionen, die im Designer-Fenster für Ressourcen angeboten werden, finden Sie unter Allgemeine Funktionalitäten ."
  },
  "doc/session-logging/logging.html": {
    "href": "doc/session-logging/logging.html",
    "title": "Application Logging",
    "keywords": "Application Logging Framework Studio stellt mehrere Möglichkeiten bereit, Applications zu protokollieren. Session-Logging Jede Application speichert automatisch Informationen in der Tabelle tblRep_SessionLogging im Runtime-Repository. Es werden pro Session aggregierte Daten über die Anzahl und Dauer der ausgeführten Broker-Anfragen und die Datenbank-Befehle gespeichert. Diese Daten können mit dem Session Logging Analyzer ausgewertet werden. Session-Trace Das Session Trace protokolliert einzelne Requests und Datenbank-Befehle in Protokoll-Dateien auf dem Broker-Server. Das Session-Trace muss bei Bedarf explizit im Publish-Wizard bzw. Publish2Go-Wizard aktiviert werden. Diese Daten können mit dem Session Trace Analyzer ausgewertet werden."
  },
  "doc/session-logging/manuelle-requests-im-sessionanalyzer.html": {
    "href": "doc/session-logging/manuelle-requests-im-sessionanalyzer.html",
    "title": "Manuelle Requests im Session Analyzer",
    "keywords": "Manuelle Requests im Session Analyzer Der Broker protokolliert automatisch jeden Request im SessionLogging. Bei Services gibt es keine Requests, die generell von einer FS-Logik überwacht und sicher einer \"Session\" zugeordnet werden können. Um jedoch auch Services in die Protokollierung einfließen zu lassen, kann man gezielt eigene Requests protokollieren. Die eigentliche Session hängt am Global. Jede Instanz eines GlobalObject ist gleichzeitig auch eine eigene Session und erzeugt somit auch einen eigenen Datensatz in der SessionLogging-Tabelle . Bei Services kann das verschiedene Auswirkungen haben: Wenn in einer Service-Methode ein neues Global erzeugt wird (Property GenerateGlobalObjects an der Service-Methode), dann bedeutet das JEDES mal eine neue Session. In Umgebungen mit mehreren Globals (z.B. Job-Server) baut auch dort jedes Global eine eigene Session auf. Somit erzeugt ein laufender Service mehrere Einträge im SessionLogging. Die Session \"läuft\", solange das Global existiert. Dadurch können sich Sessions über einen sehr langen Zeitraum - ggf. mehrere Tage oder Wochen - erstrecken. Zeitliche Zusammenhänge lassen sich dadurch sehr bedingt erfassen. Die DB-Commands werden über die Connection automatisch am Global gesammelt - und zwar über die komplette Session und nicht nur während der protokollieren Requests. Nur dann, wenn mindestens 1 Request protokolliert wurde, landet die Session im Runtime-Repository . Requests protokollieren Das Session-Logging ist ursprünglich für Broker-Requests ausgelegt und betrachtet deshalb die Folgenden Informationen: FormName (der FullName des Forms) ControlName EventName Es wird die Anzahl und die Gesamt-Zeit der Requests gespeichert. Dabei wird nach allen 3 Informationen gruppiert. Auch die manuellen Requests müssen aus diesen Informationen bestehen. Es muss selbst entschieden werden, wie man diese 3 Felder mit eigenen Informationen bestückt. Beispiel Job-Server: FormName = \"JobServer\" ControlName = FullName der Component (also Art des Jobs) EventName = ID des Jobs (so lassen sich verschiedene Job-Konfigurationen unterscheiden) Über this.Global.SessionLogging werden verschiedene Varianten für die Protokollierung angeboten: Variante 1 RequestDisposable(string formName, string controlName, string eventName) Es wird ein Disposable zurückgegeben. Ein using-Block übernimmt automatisch die Zeit-Messung. Beispiel: using(this.Global.SessionLogging.RequestDisposable(\"MyForm\", \"MyControl\", \"MyEvent\")) { // Code ... } Variante 2 RequestDisposable() Es wird ein Objekt mit dem Typ SessionRequestDisposable zurückgegeben. Wenn die Request-Informationen erst im Laufe der Verarbeitung bekannt sind, können sie an diesem Objekt gesetzt werden. Der Request wird am Ende nur protokolliert, wenn am SessionRequestDisposable-Objekt mindestens 1 Information gesetzt ist. Der Using-Block übernimmt automatisch die Zeit-Messung. using(SessionRequestDisposable request = this.Global.SessionLogging.RequestDisposable()) { // Code ... request.FormName = \"MyForm\"; request.ControlName = \"MyControl\"; request.EventName = \"MyEvent\"; // Code ... } Variante 3 AddRequest(string formName, string controlName, string eventName, TimeSpan duration) Die Zeit-Messung erfolgt manuell - z.B. über eine Stopwatch. System.Diagnostics.Stopwatch stopwatch = System.Diagnostics.Stopwatch.StartNew(); try { // Code ... } finally { this.Global.SessionLogging.AddRequest(\"MyForm\", \"MyControl\", \"MyEvent\", stopwatch.Elapsed); }"
  },
  "doc/session-logging/session-logging-analyzer.html": {
    "href": "doc/session-logging/session-logging-analyzer.html",
    "title": "Session Logging Analyzer",
    "keywords": "Session Logging Analyzer Jede Application speichert automatisch Informationen in der Tabelle tblRep_SessionLogging im Runtime-Repository. Es werden pro Session aggregierte Daten über die Anzahl und Dauer der ausgeführten Broker-Anfragen und die Datenbank-Befehle gespeichert. Mit dem Session Logging Analyzer können diese Daten ausgewertet werden. Im Session-Logging werden die Daten aggregiert. So lassen sich sehr gut statistische Aussagen auch über viele Sessions und lange Zeiträume treffen. Die Aussagen können maximal auf Session-Ebene heruntergebrochen werden. Einzelne Requests und auch exakte Zeitpunkte (z.B. von auftretenden Blockaden) sind nicht zu greifen. Dafür muss das deutlich detailliertere Session Trace verwendet werden. Einlesen der Daten Mit dem Button Login kann man sich an einem Runtime-Repository anmelden. Wird der Session Logging Analyzer über den Run Wizard , Publish Wizard oder Publish2Go-Wizard gestartet, dann wird die Verbindung zum im Setting definierten Runtime-Repository automatisch hergestellt. Anschließend kann man mit dem Button Load from DB die Daten einlesen. Über die Datums-Felder kann vor dem Einlesen der Zeitraum eingeschränkt werden. Standardmäßig sind die letzten 30 Tage voreingestellt. Mit dem Button Load from Files können exportierte Daten eingelesen werden. Dabei können aus einem Ordner auch mehrere Dateien gleichzeitig ausgewählt werden. Dafür ist kein Login notwendig. Mit jedem Einlese-Vorgang werden die aktuellen Daten verworfen. Export der Daten Mit dem Button Export to File können die Daten aus dem Repository in eine Datei exportiert werden. Es ist sinnvoll, die Daten auf diese weise zu archivieren, bevor sie dauerhaft aus der Tabelle tblRep_SessionLogging gelöscht werden. Auf diese Weise lassen sich die Daten auch ganz einfach transportieren. Über die Datums-Felder muss vor dem Export der Zeitraum eingeschränkt werden. Standardmäßig sind die letzten 30 Tage voreingestellt. Der Export erfolgt immer direkt aus der Datenbank in die Datei. Die aktuell eingelesenen Daten landen nicht im Export. Tip Es ist sinnvoll, monatsweise Exports zu erstellen und diese z.B. im Format yyyy-mm-KundenName.sessionlogging zu speichern. Die Export-Dateien lassen sich sehr gut zippen. Um den Datenschutz zu gewährleisten ist die Checkbox Anonymous Export standardmäßig gesetzt. Sie bewirkt, dass alle Daten, die auf den Benutzer schließen können anonymisiert werden. In der Export-Datei werden nur noch Hash-Codes angezeigt. Das betrifft z.B. Name des Benutzers (UserName, ClientUser) Name und IP des Client-Rechners (ClientMachine) Löschen der Daten Im Laufe der Zeit sammeln sich in der Tabelle tblRep_SessionLogging sehr viele Datensätze an. Tip Grundsätzlich können auch ältere Daten interessante Informationen enthalten, wenn z.B. beurteilt werden soll, wie sich die Performance des Systems im Laufe der Zeit entwickelt hat. Vor dem endgültigen Löschen aus der Datenbank sollte daher ein Export vorgenommen werden (siehe oben). Alte Datensätze müssen direkt per SQL auf der Datenbank gelöscht werden. Das folgende SQL-Statement löscht Sätze, die älter sind als 6 Monate. Es werden auf einen Schlag nur 1.000 Zeilen gelöscht, weil ansonsten die Transaktion zu groß und die Tabelle zu lange für laufende Sessions blockiert werden könnte. Das Statement muss so oft ausgeführt werden, bis keine Sätze mehr gelöscht wurden. Die Anzahl der Monate und die Anzahl der zu löschenden Zeilen kann bei Bedarf angepasst werden. -- SQL-Server: DELETE TOP (1000) FROM tblRep_SessionLogging WHERE SL_SessionStart < DATEADD(month, DATEDIFF(month, 0, getdate()) - 6, 0); -- Oracle: DELETE FROM tblRep_SessionLogging WHERE SL_SessionStart < ADD_MONTHS(TRUNC(SYSDATE,'MM'), -6) AND ROWNUM <= 1000;"
  },
  "doc/session-logging/session-trace-analyzer.html": {
    "href": "doc/session-logging/session-trace-analyzer.html",
    "title": "Session Trace Analyzer",
    "keywords": "Session Trace Analyzer Das Session-Trace protokolliert detailliert Sessions, einzelne Requests und lang dauernde Sql-Statements in Form von SessionTrace-Dateien. Aktiviert werden kann der Session-Trace im Run Wizard , Publish Wizard oder Publish2Go-Wizard . Mit dem Session Trace Analyzer können diese Daten visualisiert und ausgewertet werden. Im Gegensatz zum Session Logging , welches die Daten aggregiert, speichert das Session-Trace exakte Start- und Ende-Zeiten für jede einzelne Aktion. Darüber hinaus werden CPU-Auslastung und RAM-Verbrauch protokolliert. Mit dieser Aufbereitung ist es möglich potentielle Probleme wie z.B. Transaktions-Blockaden oder hohen Ressource-Verbrauch auf einzelne Sessions und sogar Requests einzuschränken."
  },
  "doc/sql/aggr-funktionen.html": {
    "href": "doc/sql/aggr-funktionen.html",
    "title": "Aggregat-Funktionen",
    "keywords": "Aggregat-Funktionen COUNT COUNT ( <Expression> ) Liefert die Anzahl. MIN MIN ( <Expression> ) Liefert das Minimum. MAX MAX ( <Expression> ) Liefert das Maximum. SUM SUM ( <Number Expression> ) Liefert den Summe. AVG AVG ( <Number Expression> ) Liefert den Durchschnitt. VAR VAR ( <Number Expression> ) Liefert die Varianz. STDEV STDEV ( <Number Expression> ) Liefert die Standardabweichung."
  },
  "doc/sql/alpha-funktionen.html": {
    "href": "doc/sql/alpha-funktionen.html",
    "title": "Alphanumerische Funktionen",
    "keywords": "Alphanumerische Funktionen LENGTH LENGTH ( <text> ) Liefert die Länge des Ausdrucks LOWER LOWER ( <text> ) Text in Kleinbuchstaben. UPPER UPPER ( <text> ) Text in Großbuchstaben. LTRIM LTRIM ( <text> ) Schneidet die linken Leerzeichen der Zeichenkette ab. RTRIM RTRIM ( <text> ) Schneidet die rechten Leerzeichen der Zeichenkette ab. REPLACE REPLACE ( <text>, <search text>, <replace text> ) Ersetzt im übergebenen Text den Search-Text durch Replace-Text. SUBSTRING SUBSTRING ( <text>, <number start>, <number length> ) Gibt den Teil einer Zeichenkette zurück."
  },
  "doc/sql/cast-funktionen.html": {
    "href": "doc/sql/cast-funktionen.html",
    "title": "Umwandlungsfunktionen",
    "keywords": "Umwandlungsfunktionen CHAR_TO_DATE CHAR_TO_DATE ( <Expression>, <format-Number>) Wandelt eine Zeichen-Kette in ein Datum um. Dabei wird das angegebene Format verwendet. Die Format-Nummer muss als konstante Zahl übergeben werden. Sie kann folgende Werte haben: Number Format YY Format YYYY 1 / 101 MM/DD/YY MM/DD/YYYY 2 / 102 YY/MM/DD YYYY/MM/DD 3 / 103 DD/MM/YY DD/MM/YYYY 4 / 104 DD.MM.YY DD.MM.YYYY 5 / 105 DD-MM-YY DD-MM-YYYY 6 / 106 DD MM YYY DD MM YYYY 7 / 107 Mon DD, YY Mon DD, YYYY 8 / 108 hh:mm:ss (24h) 10 / 110 MM-DD-YY MM-DD-YYYY 11 / 111 YY/MM/DD YYYY/MM/DD 12 / 112 YYMMDD YYYYMMDD 20 / 120 YYYY-MM-DD hh:mm:ss (24h) DATE_TO_CHAR DATE_TO_CHAR ( <date Expression>, <format-Number> ) Wandelt ein Datum in eine Zeichenkette um. Die Format-Nummer arbeitet wie bei der Funktion CHAR_TO_DATE. NUMBER_TO_CHAR NUMBER_TO_CHAR ( <Number Expression>, <Decimals>) Wandelt eine Dezimal-Zahl in einen Text um. Dabei wird die Zahl auf die übergebene Anzahl von Dezimal-Stellen gerundet bzw. abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, <Decimals> ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999.9999' ) ) Die Anzahl der Nachkommastellen ist gleich <Decimals> INT_TO_CHAR INT_TO_CHAR ( <Number Expression>) Wandelt eine Ganzzahl in einen Text um. Bei einer Dezimal-Zahl wird gerundet bzw. es werden die Dezimal-Stellen abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, 0 ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999' ) ) CHAR_TO_DECIMAL CHAR_TO_DECIMAL ( <Expression> ) Wandelt eine Zeichenkette in eine Dezimal-Zahl um. LOB_COMPARABLE LOB_COMPARABLE ( <Expression> ) Wandelt eine Langtext-Spalte so um, dass sie in einer Where-Condition bzw. in einem Order By verwendet werden kann. Das ist notwendig unter Oracle bei Spalten mit dem Typ CLOB und unter SQL-Server bei Spalten mit dem Typ text . Beispiel: SELECT memo FROM Tabelle WHERE LOB_COMPARABLE(memo) != 'text' ORDER BY LOB_COMPARABLE(memo) Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CONVERT ( VARCHAR(max), <Expression> ) Oracle CAST ( SUBSTR ( <Expression>, 1, 4000) AS VARCHAR2(4000) ) NLOB_COMPARABLE NLOB_COMPARABLE ( <Expression> ) Wandelt eine Unicode Langtext-Spalte so um, dass sie in einer Where-Condition bzw. in einem Order By verwendet werden kann. Das ist notwendig unter Oracle bei Spalten mit dem Typ NCLOB und unter SQL-Server bei Spalten mit dem Typ ntext . Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CONVERT ( NVARCHAR(max), <Expression> ) Oracle CAST ( SUBSTR ( <Expression>, 1, 2000 ) AS NVARCHAR2(2000) )"
  },
  "doc/sql/datum-funktionen.html": {
    "href": "doc/sql/datum-funktionen.html",
    "title": "Datums-Funktionen",
    "keywords": "Datums-Funktionen GETDATE GETDATE ( ) Liefert das aktuelle Datum auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETDATE ( ) Oracle SYSDATE GETUTCDATE GETUTCDATE ( ) Liefert die aktuelle Weltzeit (UTC) auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETUTCDATE ( ) Oracle CAST(sys_extract_utc(systimestamp) AS TIMESTAMP) ADD_DAYS ADD_DAYS ( <Date Expression>, <Days> ) Addiert die übergebenen Tage zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( DAY, <Days>, <Date Expression> ) Oracle <Date Expression> + <Days> ADD_MINUTES ADD_MINUTES ( <Date Expression>, <Minutes> ) Addiert die übergebenen Minuten zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MINUTE, <Minutes>, <Date Expression> ) Oracle <Date Expression> + ( <Minutes> / 1440 ) ADD_MONTHS ADD_MONTHS ( <Date Expression>, <Months> ) Addiert die übergebenen Monate zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MONTH, <Months>, <Date Expression> ) Oracle ADD_MONTHS ( <Date Expression>, <Months> ) DAYS_BETWEEN DAYS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Tage zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF ( DAY, <Start-Date>, <End-Date> ) Oracle TRUNC ( <End-Date> - <Start-Date> ) MONTHS_BETWEEN MONTHS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Monate zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF (MONTH, <Start-Date>, <End-Date>) Oracle MONTHS_BETWEEN (<End-Date>, <Start-Date>) YEAR YEAR ( <Date Expression> ) Liefert eine 4-stellige Zahl, die dem Jahr des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server YEAR ( <Date Expression> ) Oracle EXTRACT ( YEAR FROM <Date Expression> ) MONTH MONTH ( <Date Expression> ) Liefert eine Zahl, die dem Monat des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server MONTH ( <Date Expression> ) Oracle EXTRACT ( MONTH FROM <Date Expression> ) DAY DAY ( <Date Expression> ) Liefert eine Zahl, die dem Tag (Tag des Monats) des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DAY ( <Date Expression> ) Oracle EXTRACT ( DAY FROM <Date Expression> ) HOUR HOUR ( <Date Expression> ) Liefert eine Zahl, die der Stunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( HOUR, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'HH24' ) ) MINUTE MINUTE ( <Date Expression> ) Liefert eine Zahl, die der Minute des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( MINUTE, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>,'MI' ) ) SECOND SECOND ( <Date Expression> ) Liefert eine Zahl, die der Sekunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( SECOND, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'SS' ) )"
  },
  "doc/sql/funktionen.html": {
    "href": "doc/sql/funktionen.html",
    "title": "SQL-Funktionen",
    "keywords": "SQL-Funktionen GETGUID GETGUID ( ) Liefert eine neue Guid mit folgendem Format: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server LOWER( REPLACE ( NEWID ( ), '-', '' ) ) Oracle LOWER( SYS_GUID ( ) )"
  },
  "doc/sql/grammatik.html": {
    "href": "doc/sql/grammatik.html",
    "title": "SQL-Grammatik",
    "keywords": "SQL-Grammatik Im Folgenden ist die Grammatik beschrieben, die vom Framework Studio SQL-Parser verstanden wird. Alle an die Datenbank geschickten Befehle müssen dieser Grammatik genügen, ansonsten kommt es zu SqlParser-Exceptions. Grammatik für SQL-Kommandos <select> SELECT [DISTINCT] { * | <resultColumn>[,…n] } FROM { <singleSource> | <joinSource> } [ WHERE <condition> ] [ GROUP BY <value>[,…n] [HAVING <condition>]] [ {UNION [ALL] | INTERSECT | EXCEPT} <select(ohne orderby)> ] [ ORDER BY <orderColumn>[,…n] ] <insert> INSERT INTO <identifierChain> ( <identifier>[,…n] ) { VALUES ( <value>[,…n] ) | <select> } <update> UPDATE <identifierChain> SET {<identifierChain> = <value> } [,…n] [ WHERE <condition> ] <delete> DELETE [FROM] <identifierChain> [ WHERE <condition> ] Grammatik für die Bestandteile der Kommandos <resultColumn> <identifierChain>.* | <value> [AS <identifier>] <singleSource> ( <singleSource> ) | <identifierChain> [ [AS] <identifier> ] <joinSource> ( <joinSource> ) | { <singleSource> | <joinSource> } { INNER | {LEFT | RIGHT | FULL} [OUTER] } JOIN { <singleSource> | <joinSource> } ON <condition> <condition> ( <condition> ) | NOT <condition> | <condition> {{ AND | OR } <condition>}[,…n] | <value> <predicate2> | EXISTS ( <select> ) <predicate2> { = | != | < | <= | > | >= } <value> | IS [NOT] NULL | BETWEEN <value> AND <value> | IN ( <select> | <value> [,…n] ) | LIKE <value> | LIKEESCAPE <value> <value> NULL | ( <value> ) | { - | + } <value> | <value> { + | - | * | / | “||” } <value> | <identifierChain> | [<identifierChain>.] <FunktionsName> ( [ <value> [,…n] ] ) | <searchedCaseWhen> | <simpleCaseWhen> | \"[[\" <natives sql fragment> \"]]\" | <stringLiteral> | <integerValue> | <decimalValue> <searchedCaseWhen> CASE {WHEN <condition> THEN <value>}[,…n] [ ELSE <value> ] END <simpleCaseWhen> CASE <value> {WHEN {<predicate2> | <value>} THEN <value>}[,…n] [ ELSE <value> ] END <orderColumn> <value> [ASC | DESC] <identifierChain> <identifier>[.<identifier>][,…n] <identifier> \"[\" <beliebige Zeichenfolge> \"]\" | <Wort, mit einem Buchstaben beginnend>"
  },
  "doc/sql/num-funktionen.html": {
    "href": "doc/sql/num-funktionen.html",
    "title": "Numerische Funktionen",
    "keywords": "Numerische Funktionen ABS ABS ( <Numeric Expression> ) Liefert den absoluten Betrag einer Zahl TRUNC TRUNC ( <Numeric Expression>, <Decimals> ) Schneidet eine Dezimal-Zahl auf die angegebene Anzahl Stellen ab. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server ROUND ( <Numeric Expression>, <Decimals>, 1 ) Oracle TRUNC ( <Numeric Expression>, <Decimals> ) ROUND ROUND ( <Numeric Expression>, <Decimals> ) Rundet eine Dezimal-Zahl auf die angegebene Anzahl Stellen. POWER POWER ( <Numeric Expression>, <y> ) Potenziert eine Zahl mit y SQUARE SQUARE ( <Numeric Expression> ) Quadrat eine Zahl. SQRT SQRT ( <Numeric Expression> ) Quadratwurzel einer Zahl CEILING CEILING ( <Numeric Expression> ) Rundet eine Zahl auf. FLOOR FLOOR ( <Numeric Expression> ) Rundet eine Zahl ab. LOG LOG (<Float Expression> ) Natürlicher Logarithmus einer Fließkommazahl. LOG10 LOG10 ( <Float Expression> ) Logarithmus mit der Basis 10. EXP EXP ( <float Expression> ) Gibt den exponentiellen Wert des angegebenen float-Ausdrucks zurück. (e x ) SIN SIN ( <float Expression> ) Sinus einer Fließkommazahl. TAN TAN (<Float Expression> ) Tangens einer Fließkommazahl. SIGN SIGN ( <Number> ) Gibt das Vorzeichen der Zahl zurück. Negativ -> -1, 0 -> 0, positiv -> +1."
  },
  "doc/sql/operatoren.html": {
    "href": "doc/sql/operatoren.html",
    "title": "Operatoren",
    "keywords": "Operatoren || Verbindet 2 Zeichenketten. Beispiel: SELECT column1 || ' - ' || colum2 FROM tabelle Bei Zeichen-Ketten muss dieser Operator verwendet werden. Der + - Operator ist nicht zulässig. Wenn dennoch der + - Operator verwendet wird, versucht der Parser dies zu korrigieren. Das ist möglich, wenn bei der Operation Zeichen-Ketten oder bestimmte Zeichenketten-Funktionen beteiligt sind. Nicht erkannt wird z.B. das Verbinden von 2 Spalten. In diesem Fall kann es zu Fehlern auf der Ziel-Datenbank kommen. + - * / Addiert, subtrahiert, multipliziert bzw. dividiert 2 Zahlenwerte. Der Framework Studio SQL-Parser versteht die im Folgenden beschriebenen Operatoren und Funktionen. Diese werden Datenbank-spezifisch umgesetzt und können bedenkenlos in selbst formuliertem Sql verwendet werden. Funktionen, die der Parser nicht kennt, werden direkt ohne Konvertierung an die Datenbank weitergegeben. Das bedingt, dass diese Funktionen von der Datenbank verstanden werden. Ggf. Ist es in solchen Fällen nötig, selbst dafür zu sorgen, dass das Sql datenbankspezifisch formuliert wird."
  },
  "doc/sql/syntax.html": {
    "href": "doc/sql/syntax.html",
    "title": "SQL-Syntax",
    "keywords": "SQL-Syntax Framework Studio übersetzt alle SQL-Statements in die Syntax der verwendeten Ziel-Datenbank. Dazu werden alle Statements geparsed und für die Ziel-Datenbank wieder neu zusammengesetzt."
  },
  "doc/tables/dbrun_config.html": {
    "href": "doc/tables/dbrun_config.html",
    "title": "dbRun_Config (Business-Datenbank)",
    "keywords": "dbRun_Config (Business-Datenbank) Diese Tabelle beinhaltet die Konfigurationen für den automatischen Datenbank-Update und die MLColumn-Logik. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Die Einstellungen müssen manuell per SQL vorgenommen werden. Wenn keine Einstellung existiert, dann zieht automatisch die Default-Einstellung. Spalte Beschreibung ConfigKey Schlüssel (siehe unten) ConfigValue Wert (siehe unten) ConnectionGroup Der Name der Connection-Group. Bei <NULL> zieht die Einstellung für alle Connection-Groups. Wenn für eine Connection-Group eine Konfiguration angegeben ist, dann hat diese Priorität. ConfigKey UNICODE Dieser ConfigKey stellt das Unicode-Verhalten des Update-Assinstenten ein. In ConfigValue sind folgende Werte zulässig: Disabled (Default) Neue Spalten werden ASCII (VARCHAR/ CLOB) angelegt. Enabled Neue Spalten werden Unicode (NVARCHAR/ NCLOB) angelegt. Adjust Bestehende Spalten werden auf Unicode umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. Important Diese Einstellung hat zur Folge, dass die GESAMTE Datenbank angefasst wird. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. ConfigKey LOB Dieser ConfigKey steuert, wie der Update-Assistent mit Langtext-Spalten umgehen soll. In ConfigValue sind folgende Werte zulässig Normal (Default) Neue Spalten werden mit LOB-Typen angelegt. Adjust Bestehende Spalten werden auf LOB-Typen umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. SQL-Server: text => varchar(max) / image => varbinary(max) Oracle: varchar2(2000) => CLOB Important ACHTUNG! Diese Einstellung hat zur Folge, dass große Teile der Datenbank angefasst werden. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. Bei Oracle kann sein ggf. sein, dass einige ältere Programme (wie z.B. SQL-Business) nicht mit dem Datentyp CLOB umgehen können. In diesem Fall muss der Schalter auf Normal gesetzt werden. ConfigKey ML_SEARCH_ENABLED Dieser ConfigKey aktiviert die Such-Funktion für die ML-Columns . 0 (Default) Das Feature ist deaktiviert. 1 Das Feature ist aktiv. Die Einstellung zieht für die komplette Datenbank. Die ConnectionGroup muss null sein. Caution Wird dieser Schalter nachträglich aktiviert, dann muss einmalig für bereits existierende Einträge in der Tabelle dbRun_MLStrings die indizierte Spalte ML_SearchText gefüllt werden. -- Sql-Server: UPDATE dbRun_MLStrings SET ML_SearchText = LEFT(ML_Text, 200); -- Oracle: UPDATE dbRun_MLStrings SET ML_SearchText = SUBSTR(ML_Text, 1, 200); ConfigKey ML_DEFAULT_LANGUAGE Dieser ConfigKey legt die Default-Sprache für die ML-Columns fest. Es muss der 2-stellige Iso-Code der Sprache angegeben werden (z.B. en , fr , it ). Default-Wert: de Die Einstellung zieht für die komplette Datenbank. Die ConnectionGroup muss null sein. Caution Wird die Default-Sprache geändert, dann müssen die Anwendungs-Broker und FS-Services neu gestartet werden, weil diese Informationen aus Performance-Gründen zwischengespeichert werden. Wird die Default-Sprache nachträglich geändert, dann müssen in der Tabelle dbRun_MLStrings eventuell existierende Texte für die neue Default-Sprache entfernt werden."
  },
  "doc/tables/dbrun_mlstrings.html": {
    "href": "doc/tables/dbrun_mlstrings.html",
    "title": "dbRun_MLStrings (Business-Datenbank)",
    "keywords": "dbRun_MLStrings (Business-Datenbank) In dieser Tabelle werden die Fremdsprachen-Texte für die ML-Columns abgelegt. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Spalte Beschreibung ML_TableName Der Name der Datenbank-Tabelle (Uppercase) ML_ColumnName Der Name der MLColumn-Tabellen-Spalte (Uppercase) ML_FSRowID Die FSRowID des referenzierten Datensatzes. Diese kann für SQL-Abfragen verwendet werden. ML_Iso Der 2-stellige Iso-Code der Fremdsprache (Lowercase) ML_Text Der fremdsprachige Text (Langtext) ML_SearchText Indizierte Spalte mit den ersten 200 Zeichen des fremdsprachigen Textes. Sie wird für SQL-Abfragen verwendet."
  },
  "doc/tables/dbrun_runtimeconfigtext.html": {
    "href": "doc/tables/dbrun_runtimeconfigtext.html",
    "title": "dbRun_RuntimeConfigText (Runtime-Config Datenbank)",
    "keywords": "dbRun_RuntimeConfigText (Runtime-Config Datenbank) Spalte Beschreibung RCT_Tenant Identifier des Tenants. RCT_Key Konfigurations-Schlüssel. (siehe unten) RCT_Value Wert als Langtext oder XML. Tenant-Namen Der Tenant wird in der Spalte RCT_Tenant angegeben. Der Name des Tenants kann frei vergeben werden. Er darf Buchstaben, Zahlen und Unterstriche beinhalten - z.B. MyTenant_7 . Es gibt reservierte Namen für Tenants: * (Stern): Konfigurationen für diesen \"generellen\" Tenant werden von allen anderen Tenants verwendet Das gilt auch für die anderen reservierten Tenants, sofern sie den Konfigurations-Schlüssel unterstützen. Wird in anderen Tenants ebenfalls ein Eintrag für einen Konfigurations-Schlüssel definiert, dann hat dieser höhere Priorität und überschreibt so die Konfiguration des \"generellen\" Tenants. #Proxy# : In diesen speziellen \"Tenant\" werden Konfigurationen für den FrameworkBrokerHostProxy hinterlegt. #AuthService# : In diesen speziellen \"Tenant\" werden Konfigurationen für den Authentication-Service hinterlegt. Arbeitet der Auth-Service im Tenant-Betrieb, dann wird der normale Tenant verwendet. Gültigkeit Expiration Date Datum, an dem der Tenant ausläuft. Important Dieser Wert muss angegeben sein, ansonsten kann ein Tenant nicht gestartet werden. Für den generellen Tenant \"*\" darf dieser Wert nicht angegeben werden. RCT_Key: ExpirationDate RCT_Value: Datum im Format \"yyyy-MM-dd HH:mm:ss\" UTC. Gibt es kein Ablauf-Datum, dann wird * angegeben. Activation Date Ab diesem Datum darf ein Tenant benutzt werden. Diese Angabe ist optional. Important Für den generellen Tenannt \"*\" darf dieser Wert nicht angegeben werden. RCT_Key: ActivationDate RCT_Value: Datum im Format \"yyyy-MM-dd HH:mm:ss\" UTC. Lizenzen Die Lizenzen werden pro Package gespeichert. RCT_Key: License|{Package-Name} RCT_Value: Der <License> Knoten aus der Lizenz-XML-Datei inklusive der Singnatur. Beispiel: RCT_Key = 'License|FSDemo' RCT_Value = <License> <Data> <LicenseID>836ff6388f4f41be88a130e328facb90</LicenseID> <PackageID>fde6193cb96842aaaf0d5e005b1a0c8d</PackageID> <PackageName>FSDemo</PackageName><LabelName>4.3</LabelName> [...] <AccessUnits> <AU ID=\"AccessUnitRoot\" ACC=\"0\" ACD=\"0\" UPD=\"0\" INS=\"0\" DEL=\"0\" /> <AU ID=\"c8954266da5e4f0dbd0e2177393ee60c\" ACC=\"0\" ACD=\"0\" UPD=\"0\" INS=\"0\" DEL=\"0\" /> [...] </AccessUnits> </Data> <Signature>14C129D7BC2962A0C20732F2FD1484C430[...]</Signature> </License> Connections Authentication AuthService|DefaultUserName AuthService|DefaultUserPassword AuthService|PublicKey ApplicationService AppService|Id AppService|Title - Überschreibt den Titel der über den Publish in der IDE definiert wurde. AppService|Name AppService|Description AppService|PrivateKey AppService|IsAuthenticationEnabled true oder false Service-Proxies RCT_Key: ServiceProxy|<ProxyType-FullName>|Address RCT_Value: Adresse des Proxy Proxy-Settings Settings für den FrameworkBrokerHostProxy. (Tenant = #Proxy# ) Use Http Startet den FrameworkBrokerHostProxy mit HTTP statt HTTPS. Diese Einstellung sollte in Produktiv-Umgebungen nicht verwendet werden. RCT_Key: Proxy|UseHttp RCT_Value: true oder false . Password Hash Password-Hash für die API des FrameworkBrokerHostProxy. RCT_Key: Proxy|PasswordHash RCT_Value: SAH512 Hashwert des API-Passworts. Z.B. auf der Seite https://passwordsgenerator.net/sha512-hash-generator/ (Benutzung auf eigene Gefahr!) kann man einen Passwort-Hash generieren. AuthService-Settings Settings für den Authentication-Service. Wird der Auth-Service pro Tenant betrieben, wird mit dem normalen Tenant mit Fallback auf den generellen Tenant \"*\" gearbeitet. Arbeitet der Auth-Service ohne Tenants, dann wird der reservierte Tenant #AuthService# mit Fallback auf den generellen Tenant \"*\" verwendet. Multi-Tenant Gibt an, ob der Auth-Service als Multi-Tenant betrieben werden soll. In diesem Fall werden Tenant-Spezifische Instanzen des Auth-Service, die ihre Einstellungen über den normalen Tenant beziehen. Für diese Einstellung muss der reservierte \"Tenant\" #AuthService# verwendet werden. RCT_Tenant: #AuthService# RCT_Key: AuthService|MultiTenant RCT_Value: false (default) | true Enabled Gibt an, ob für den Tenant der Auth-Service gestartet werden soll. Diese Einstellung zieht nur im Tenant-Betrieb. RCT_Key: AuthService|Enabled RCT_Value: false (default) | true Connection Im Tenant-Betrieb greift ein Fallback auf Connection|RuntimeConnection , falls dieser Key nicht gefüllt ist. RCT_Key: AuthService|Connection RCT_Value: Connection-String Service-ID Eindeutige ID des Service. RCT_Key: AuthService|Id RCT_Value: guid-String Service-Uri Url des Auth-Service RCT_Key: AuthService|Uri RCT_Value: Url des Auth-Service Service-Name RCT_Key: AuthService|Name RCT_Value: Name des Service. Wenn nicht angegeben, dann ist der Default-Wert \"AuthenticationService\" Service-Description RCT_Key: AuthService|Description RCT_Value: Beschreibung des Service Public Key Öffentlicher Schlüssel des Authentication-Service. Dieser kann auch im generellen Tenant \"*\" definiert und so automatisch von allen Tenants verwendet werden. RCT_Key: AuthService|PublicKey RCT_Value: Public Key in Hex-Schreibweise Private Key RCT_Key: AuthService|PrivateKey RCT_Value: Private Key in Hex-Schreibweise Runtime Supervisor Gibt an, ob der Runtime-Supervisor aktiviert ist: RCT_Key: RuntimeSupervisorEnabled RCT_Value: true oder false Gibt die URL des Runtime-Supervisor an: RCT_Key: RuntimeSupervisorUri RCT_Value: Url des Runtime-Supervisor"
  },
  "doc/tables/ml_config.html": {
    "href": "doc/tables/ml_config.html",
    "title": "ML_Config (Business-Datenbank)",
    "keywords": "ML_Config (Business-Datenbank) Caution Diese Tabelle ist veraltet. Die Default-Sprache kann seit Framework Studio 4.2.1 in der Datenbank-Tabelle dbRun_Config mit dem ConfigKey ML_DEFAULT_LANGUAGE definiert werden. Existiert der neue ConfigKey nicht, dann erfolgt weiterhin ein Fallback auf diese Tabelle. Es wird empfohlen die Konfiguration in die neue Tabelle zu übertragen und diese Tabelle zu löschen. Die ML-Columns arbeiten standardmäßig mit der Default-Sprache de Deutsch. Ist die \"führende\" Sprache nicht de , dann kann über diese Tabelle die korrekte Default-Sprache eingestellt werden. Das geschieht in der Business-Datenbank, wo auch die Übersetzungs-Tabelle dbRun_MLStrings abgelegt ist, welche die anderssprachigen Werte speichert. Die Einstellung muss in dieser Datenbank stehen, damit sichergestellt ist, dass die Übersetzungs-Tabelle immer mit derselben Konfiguration angesprochen wird - unabhängig davon, wie die Anwendung FS-seitig konfiguriert ist. Die Tabelle muss bei Bedarf manuell per SQL angelegt werden. Dazu können die folgenden Scripte verwendet werden. Das Iso-Sprach-Kürzel de muss entsprechend durch das gewünschte Iso-Sprach-Kürzel ersetzt werden. -- SQL-Server CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR(2), CONSTRAINT PK_ML_CONFIG PRIMARY KEY CLUSTERED (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); -- Oracle CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR2(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR2(2) NULL, CONSTRAINT PK_ML_CONFIG PRIMARY KEY (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); Caution Wenn die Konfiguration geändert wurde, dann müssen die Anwendungs-Broker und FS-Services neu gestartet werden, weil diese Informationen aus Performance-Gründen zwischengespeichert werden. Die Konfiguration darf nicht nachträglich geändert werden, weil ansonsten die in der Übersetzungs-Tabelle abgelegten Texte nicht mehr stimmen. Wenn die Konfiguration zu Beginn bei Einrichtung der Business-Datenbank vorgenommen wird, dann muss im Anschluss sichergestellt werden, dass die Tabelle dbRun_MLStrings leer ist. Wenn bei einer Änderung der Konfiguration doch dbRun_MLStrings -Inhalte erhalten bleiben sollen, müssen alle Einträge, für die neue Default-Sprache gelöscht werden."
  },
  "doc/tables/tblrep_reportinstance.html": {
    "href": "doc/tables/tblrep_reportinstance.html",
    "title": "tblRep_ReportInstance (Runtime-Repository)",
    "keywords": "tblRep_ReportInstance (Runtime-Repository) Diese Tabelle beinhaltet die Druck-Jobs die per Anzeige / Vorschau direkt am Client angezeigt werden. Spalte Beschreibung RPTI_ID Eindeutige ID des Print-Jobs (Guid) RPTI_Reportname Der Name der Report-Datei RPTI_XML XML-Serialisierte Form der Datei RPTI_RPTExpF_ID Das Format in dem der Druck ausgegeben werden soll. 1 = CrystalReport 2 = RichText 3 = Word 4 = Excel 5 = PDF 6/7 = HTML RPTI_CreateDateTime Zeitpunkt, an dem der Print-Job erzeugt wurde RPTI_XSDFileName Der Name der XSD-Schemadatei, welche den Aufbau der Datenquelle beschreibt. RPTI_Orientation Die Orientierung (Portrait/Hochkant), in welcher gedruckt werden soll RPTI_ReportFile Der Inhalt der Datei im Binär-Format. Normalerweise werden die Datensätze in dieser Tabelle nach 10 Minuten automatisch gelöscht. Sollten dennoch Einträge stehen bleiben, dann können veraltete Einträge auch manuell gelöscht werden. -- SQL-Server: DELETE FROM [tblRep_ReportInstance] WHERE DATEADD(minute, 10, [RPTI_CreateDateTime]) < GetDate (); -- Oracle: DELETE FROM tblRep_ReportInstance WHERE (RPTI_CreateDateTime + (10 / 1440)) < sysdate;"
  },
  "doc/tables/tblrep_sessionlogging.html": {
    "href": "doc/tables/tblrep_sessionlogging.html",
    "title": "tblRep_SessionLogging (Runtime-Repository)",
    "keywords": "tblRep_SessionLogging (Runtime-Repository) Diese Tabelle speichert die von jeder Application automatisch erzeugten Session-Logging Informationen. Ausgewertet werden können die Daten mit dem Session Logging Analyzer . Spalte Beschreibung SL_ID Eindeutige ID der Session (Guid) SL_SessionStart Zeitpunkt, an dem die Session gestartet wurde SL_LastUpdate Zeitpunkt, an dem der Datensatz zuletzt aktualisiert wurde SL_State Status der Session SL_RequestsCount Anzahl der Broker-Requests SL_TopRequests Informationen über alle Requests, aggregiert pro Event (XML) SL_CommandsCount Anzahl der Datenbank-Befehle SL_TopCommands Informationen über die langsamsten Datenbank-Befehle (XML) SL_ObjectsCount Aktuelle Anzahl von Framework-Studio Objekten SL_CreatedObjectsCount Gesamt-Anzahl der während der Session erzeugten Framework-Studio Objekte SL_UserName Name des Benutzers SL_MachineName Name des Broker-Servers SL_DBDuration Gesamte Dauer aller Datenbank-Befehle in Millisekunden SL_RequestDuration Gesamte Dauer aller Broker-Requests in Millisekunden (am Broker gemessen) SL_ClientRequestDuration Gesamte Dauer aller Broker-Requests in Millisekunden (am Client gemessen) SL_ClientDuration Gesamte Dauer der Client-Zeit in Millisekunden SL_RequestSize Summe der Größe aller Requests in Bytes (vom Client zum Broker gesendeten Daten) SL_ResponseSize Summe der Größe aller Responses in Bytes (vom Broker zum Client gesendeten Daten) SL_ClientInfo Textuelle Liste mit Informationen zum Client und Package-Versionen"
  },
  "doc/textcoll/textcollection.html": {
    "href": "doc/textcoll/textcollection.html",
    "title": "Textcollections",
    "keywords": "Textcollections Textcollections beinhalten mehrere Einträge mit Zeichenketten. Die Zeichenketten können in den verschiedenen Sprachen angegeben werden. Ein Eintrag beinhaltet immer eine in der Collection eindeutige ID und für jede Sprache eine Zeichenkette. Je nachdem, mit welcher Sprache die Anwendung gestartet wird, geben die Einträge mit dem Property value die Zeichenkette für die entsprechende Sprache zurück. Die Textcollections können im Form-Designer z.B. für Comboboxen, für Messageboxen oder auch frei im Code verwendet werden, um sprachabhängig Texte zusammenzubauen. Erstellt werden kann eine Textcollection über das Kontext-Menü des jeweiligen Namespaces. Dort steht der Befehl New / Textcollection (Menü File >> New >> Textcollection) zur Verfügung. Customizing von Textcollections ist möglich, um neue Einträge hinzuzufügen und bestehende Einträge abzuändern. Wenn ein neuer Eintrag mit einer ID hinzugefügt wurde, die in einem der Basis Packages verwendet wird, wird eine Warnung ( FSWarn[2017] ) generiert. Warning Das Customizing von Textcollections, um neue Einträge hinzuzufügen ist nur dann sinnvoll, wenn zwingend eine bestehende Textcollection erweitert werden muss. In so einem Fall sollte der neue Eintrag einen Wert erhalten, bei dem die Gefahr von nachträglicher Überschneidung möglichst gering ist. Registerkarte General Description Beschreibung für die Component. Control Types Hier können analog zu den Components Controls hinterlegt werden. Registerkarte Data Auf dieser Registerkarte werden die Einträge der Textcollection verwaltet. Die Tabelle zeigt alle vorhandenen Einträge an. Es werden die ID und die Zeichenkette in der in Framework Studio eingestellten Sprache angezeigt. Markieren Sie den Eintrag, den Sie bearbeiten möchten. Rechts neben der Tabelle werden dann die Daten zu diesem Eintrag angezeigt. Diese können auch bearbeitet werden. Button New Erstellt einen neuen Eintrag. Button Delete Löscht den markierten Eintrag. Methoden der Textcollection string GetTextOnID(Int32 id, string defaultText) Liefert den Text zur übergebenen ID in der aktuellen Sprache. Wird die ID in der TextCollection nicht gefunden, wird der im Parameter defaultText übergebene Wert zurückgegeben. IDevFrameworkObjectMLString GetOnID(Int32 id) Liefert das Element der angegebenen Position zurück. Wird die Position in der Collection nicht gefunden, wird null zurückgegeben. Um Ressourcen zu schonen, kann man die Methoden an der Factory-Klasse verwenden. Dadurch braucht für den Zugriff keine Instanz der TextCollection zu existieren. string GetText(GlobalObject, Int32 id, string defaultText) Statische Methode an der Factory-Klasse der Text-Collection. Sie liefert den Text zur übergebenen ID in der aktuellen Sprache. Wird die ID in der TextCollection nicht gefunden, wird der im Parameter defaultText übergebene Wert zurückgegeben. Beispiel: string sText = ctTextCollFactory.GetText(this.Global, id, \"invalid id\"); IDevFrameworkObjectMLString Get(GlobalObject, Int32 id) Liefert das Element der angegebenen Position zurück. Wird die Position in der Collection nicht gefunden, wird null zurückgegeben. Beispiel: IDevFrameworkObjectMLString mlText = ctTextCollFactory.Get(this.Global, id); string sText; if (mlText != null) { sText = mlText.Text; } else { sText = “invalid id”; } Konstanten Wird an einem Texteintrag ein Konstantenname vergeben, so wird in der Textcollection-Factory eine Konstante erzeugt. Wenn in einer Textcollection nur eine Teilmenge der Einträge mit einem Konstantennamen versehen sind, erzeugt der Compiler für die übrigen jeweils eine Warnung. Es sollten also entweder keine oder alle Einträge einen Konstantennamen besitzen. Beispiel für die Konstantennamen: Code-Beispiel: public virtual void btnBuyArticle_OnClick() { switch(PurchaseArticle()) { case ctArticleTextFactory.Purchased: // Artikel versenden break; case ctArticleTextFactory.NotInStock: // Nachbestellen break; case ctArticleTextFactory.NotExisting: // ... break; } } ctSystemMessages Im Namespace FSGeneral existiert bereits im SystemPackage eine Textcollection mit dem Namen ctSystemMessages . Diese Textcollection enthält Systemmeldungen, die von den Clients benutzt werden (z.B. \"Soll die Anwendung geschlossen werden?\" oder \"Abbrechen\"). Auf diese Weise wird dem Client ermöglicht, auch Systemmeldungen in der Sprache anzeigen zu können, in der die Anwendung gestartet wurde. Diese Textcollection kann in jedem Package customized werden, so dass zum Beispiel in einem landesspezifischen Package die Systemmeldungen in der entsprechenden Sprache nachgepflegt werden können."
  },
  "doc/themes/aufraeum-routine.html": {
    "href": "doc/themes/aufraeum-routine.html",
    "title": "Aufräum-Routine",
    "keywords": "Aufräum-Routine Diese Routine ist verantwortlich dafür, Themes korrekt aus einem Package zu entfernen. Da nicht nur die Themes alleine von Framework Studio gespeichert werden, sondern auch Referenzen von den Applications, Default Control Styles und Ressourcen auf die Themes verweisen, müssen vor dem endgültigen Löschen der Themes erst alle Referenzen in diesen Elementen eliminiert werden. Gelöscht werden grundsätzlich alle Themes im aktuellen Package, die im Theme Manager auf „Deprecated“ gesetzt wurden. Es werden erst alle Applications, Default Control Styles und Ressourcen durchlaufen und jegliche Referenzen auf nicht vorhandene oder auf Deprecated gesetzte Themes eliminiert und danach die Themes an sich gelöscht. Mit dem Button im Theme Manager kann die Routine gestartet werden. Es erfolgt zur Sicherheit noch eine Abfrage, ob fortgefahren werden soll: Sicherheitsabfrage der Aufräum-Routine Bevor die Routine startet, wird von Framework Studio auf das Default-Theme gewechselt. Um Änderungen an den Applications, Default Control Styles und Ressourcen vornehmen zu können, müssen diese Elemente ausgecheckt sein. Dies wird von der Routine selbst übernommen. Ist ein zu bearbeitendes Element nicht ausgecheckt, wird es automatisch ausgecheckt und nach erfolgreichem Ablauf der Routine wieder eingecheckt. Sollte ein zu änderndes Element schon vom Benutzer ausgecheckt worden sein, wird die Routine die Änderungen am Element durchführen, es aber nach erfolgreichem Ablauf NICHT einchecken (Der Benutzer könnte schon andere Änderungen am Element vorgenommen haben, die er vielleicht noch gar nicht einchecken will). Der Ablauf der Routine selbst ist im Output-Fenster von Framework Studio einsehbar: Ablauf der Routine im Output-Fenster: Nun muss noch folgender Fall betrachtet werden: Was ist, wenn ein Package Theme-Informationen beinhaltet, die auf Themes verweisen, die im Basis-Package definiert wurden und dort gelöscht werden? Dafür wird noch einmal die Konstellation von 3 Packages und 2 Themes betrachtet: Theme-Definition für die FocusHighlightColor: Beide Themes sind im Package „BasePackage“ über den Theme-Manager angelegt worden. Nun gibt es 2 Szenarien, in denen „unnötige Theme-Daten“ in den aufgesetzten Packages (CustomPackage und AdditionalPackage) entstehen. Szenario 1 Im BasePackage werden z.B. beide Themes auf Deprecated gesetzt und die Aufräum-Routine ausgeführt. Danach ist im BasePackage nur noch das Default-Theme vorhanden und jegliche Informationen zu den Themes in den Applications, Default Control Styles und Ressourcen gelöscht. Da die Themes im BasePackage gelöscht wurden, sind diese nun auch nicht mehr in den aufsetzenden Packages auswählbar. Die Property-Informationen zu den Themes in den aufsetzenden Packages sind jedoch noch im Repository gespeichert. So ist die Information Yellow für die FHC für Theme1 im AdditionalPackage immer noch im Repository vorhanden, obwohl das Theme längst aus dem BasePackage gelöscht wurde. Dies hat zur Folge, dass bei jedem CheckIn/CheckOut der Application diese nunmehr sinnlose Information mitgeschleift wird. Es empfiehlt sich also, die Aufräum-Routine auch in den aufsetzenden Packages durchzuführen. Die Routine erkennt nicht nur auf Deprecated gesetzte Themes, sondern eliminiert auch jegliche Informationen zu Themes, die in der Package-Hierarchie nicht mehr auffindbar sind. Im konkreten Fall würde die Routine im AdditionalPackage die Application durchgehen, in der für Theme1 für die FHC Yellow definiert wurde. Sie erkennt dann, dass die das Theme Theme1 gar nicht mehr in der Package-Hierarchie auffinden kann (da es ja im BasePackage gelöscht wurde). Somit wird diese Property-Information aus dem AdditionalPackage gelöscht und die Application hat, bezogen auf die Themes, wieder einen sauberen Stand. Szenario 2 Da Framework Studio die Möglichkeit bietet, Packages beliebig in der Hierarchie anzuordnen, kann folgender Fall eintreten: Das BasePackage mit den 2 definierten Themes wird aus der Hierarchie entfernt und ein neues BasePackage wird an dessen Stelle gesetzt. In diesem neuen BasePackage sind jedoch die Themes überhaupt nicht definiert. Ab diesem Zeitpunkt ist die Situation wieder wie in Szenario 1. Die aufsetzenden Packages CustomPackage und AdditionalPackage haben in ihren Elementen Theme-Informationen für Themes, die gar nicht mehr in der Package-Hierarchie existieren. Das Starten der Aufräum-Routine in den Packages CustomPackage und AdditionalPackage würde diese Unsauberkeiten bereinigen. Note Wenn Themes gelöscht werden und die Aufräum-Routine in aufsetzenden Packages NICHT ausgeführt wird, hat dies funktional KEINEN Einfluss auf die Anwendungen. Es werden lediglich unnütze Daten im Repository von Version zu Version mitgeschleift ."
  },
  "doc/themes/einfuehrung.html": {
    "href": "doc/themes/einfuehrung.html",
    "title": "Einführung",
    "keywords": "Einführung Durch Themes wird die Möglichkeit gegeben, einer FS-Anwendung ein anderes Aussehen zu geben, ohne dabei auf die Geschäftslogik und damit den Sourcecode Einfluss zu nehmen. Beispiel FS-Demo mit Standard-Theme: Das Bild zeigt die FS-Demo-Anwendung, wie sie standardmäßig von Framework Studio erstellt wird. Im folgenden Bild wurde das Aussehen der Anwendung durch Hinzufügen eines Themes grundlegend verändert: In diesem neuen Theme wurden folgende Änderungen durchgeführt: Hintergrundbild geändert. Transparenz des Grids deaktiviert. Button-Images durch blaue Bilder ersetzt. Schriftfarbe der Labels auf blau gesetzt. FocusHighlightColor auf hellgelb gesetzt."
  },
  "doc/themes/hierarchie-bei-mehreren-package-und-themes.html": {
    "href": "doc/themes/hierarchie-bei-mehreren-package-und-themes.html",
    "title": "Hierarchie bei mehreren Packages und Themes",
    "keywords": "Hierarchie bei mehreren Packages und Themes Wenn mehrere Packages übereinander liegen und mehrere Themes verfügbar sind, folgt Framework Studio einem gewissen Schema, woher die einzelnen Property-Werte bezogen werden. Dieses Schema ist für Properties der Applications, der Default Control Styles, sowie der Bilder der Ressourcen exakt gleich. Im folgenden Beispiel wird angenommen, dass 3 Packages übereinander liegen und im untersten Package (BasePackage) 2 Themes definiert wurden, die somit auch den anderen Packages zur Verfügung stehen. Das Property, welches hier betrachtet werden soll, ist die FocusHighlightColor (im Folgenden FHC) einer Application. Die FHC soll in der Package-Hierarchie wie folgt definiert sein: Theme-Definition für die FocusHighlightColor: Ist die FHC im aktuellen Package für das gewählte Theme nicht definiert (wie z.B. bei CustomPackage/Theme2), werden erst alle Basis-Packages durchsucht, ob dort das Property für das gewählte Theme gesetzt ist. Ist dies nicht der Fall, wird die gleiche Suche für das Property im Default-Theme angestoßen (siehe Pfeile). Anhand der folgenden Grafik soll nun erläutert werden, welche Werte die FHC je Package und Theme annehmen würde: Lookup-Pfad des Themeable Properties: Beispiel BasePackage/Theme1 Da im BasePackage für das Theme Theme1 die FHC explizit auf Purple gesetzt wurde, wird keine Hierarchiesuche angestoßen und die FHC ist somit Purple . Beispiel BasePackage/Theme2 Im BasePackage ist die FHC für das Theme Theme2 nicht definiert. Da das BasePackage kein weiteres Basis-Package hat, wird der Wert des Default-Theme zurückgegeben. In diesem Fall ist im Default-Theme auch nicht explizit ein Wert gesetzt, also wird die Standardfarbe für die FHC (Black) zurückgegeben. Beispiel CustomPackage/Theme1 Für Theme1 ist im CustomPackage keine FHC definiert, also wird im Basis-Package von CustomPackage (BasePackage) für das Theme1 nach der FHC gesucht. Dort ist Purple definiert und wird somit zurückgegeben. Beispiel CustomPackage /Theme2 Im CustomPackage ist die FHC für Theme2 nicht definiert. Es wird somit in BasePackage für Theme2 nach einem Wert gesucht. Dort ist ebenso kein Wert definiert. Es verbleiben keine weiteren Basis-Packages, also wird wieder vom CustomPackage aus durch die Hierarchie gesucht, diesmal jedoch mit dem Default-Theme (da für Theme1 in keinem Package ein Wert für FHC definiert wurde). Für das Default-Theme ist im CustomPackage der Wert Red für die FHC definiert und wird somit zurückgegeben. Beispiel AdditionalPackage/Theme1 In diesem Beispiel ist im AdditionalPackage für das Theme1 gleich ein Wert für die FHC definiert. Yellow wird sofort zurückgegeben. Beispiel AdditionalPackage /Theme2 Für Theme2 ist in keinem der Packages ein Wert für die FHC definiert. Somit wird die Package-Hierarchie für das Default-Theme nach einem Wert für die FHC durchsucht. Im AdditionalPackage wird für das Default-Theme gleich ein Wert Blue gefunden und zurückgegeben."
  },
  "doc/themes/properties-theme-abhaengig-aendern.html": {
    "href": "doc/themes/properties-theme-abhaengig-aendern.html",
    "title": "Properties Theme-abhängig ändern",
    "keywords": "Properties Theme-abhängig ändern Um in Applications oder Default Control Styles Properties Theme-abhängig ändern zu können, muss nur das entsprechende Theme ausgewählt werden. Wird nun ein Property modifiziert, wird die Information automatisch dem aktuell aktiven Theme zugeordnet. Properties ändern bei Applications Beispiel Wurde vom Benutzer kein Theme ausgewählt (d.h. das Default-Theme ist aktiv), sieht die FSDemoApplication im Design-Panel wie folgt aus: Application PropertyGrid im Default-Theme: Ein BackImage wurde definiert, IsTransparent aktiviert, SplitterBackColor und die Farben für Menüs wurden modifiziert. Wird nun ein anderes Theme (über Tools > Choose Theme ) ausgewählt, werden die Properties, bezogen auf das nun ausgewählte Theme, angezeigt und können geändert werden: Application PropertyGrid im angepassten Theme: Im Gegensatz zum Default-Theme wurde hier ein anderes BackImage definiert. Das Property „FocusHighlightColor“ ist auf einen Gelbton abgeändert worden (im Default-Theme war hier nichts definiert). Auch die SplitterBackColor wurde neu zugewiesen. Properties ändern bei Default Control Styles Das Theme-abhängige Modifizieren von Properties eines Default Control Styles gestaltet sich analog zu den Applications: Beispiel Im Folgenden wird der Default Control Style des Button-Controls angezeigt, während der Benutzer das Default-Theme ausgewählt hat: DefaultControlStyle PropertyGrid im Default-Theme: Die BackColor wurde auf ButtonFace , die Font auf Arial; 12pt und die ForeColor auf Red gesetzt. Wird nun wiederrum ein Theme ausgewählt, könnten die Properties z.B. wie folgt umdefiniert werden: DefaultControlStyle PropertyGrid im angepassten Theme: Bild ändern bei Ressourcen Ist das Default-Theme aktiv, kann ein Bild über den Button Import File an die Resource gebunden werden. Der Name der Resource wird dabei standardmäßig auf den Namen der importierten Datei angepasst: Bild-Resource im Default-Theme: Wird nun ein Theme vom Benutzer ausgewählt, hat der Benutzer die Möglichkeit über den Button Import File erneut eine Bilddatei zu importieren. Diese wird dann jedoch dem Theme zugeordnet und das Bild des Default-Themes (der graue Buttonhintergrund) bleibt erhalten. Resource mit angepasstem Bild: In dieser Grafik wurde für die Resource NVButton1.gif ein neues Bild für das ausgewählte Theme importiert. Dass das Bild im aktiven Theme überschrieben ist, zeigt sich an der fetten Schrift des Relative Path und daran, dass der Reset-Button aktiv ist. In der Resource wurde der graue Button-Hintergrund durch einen bläulichen ausgetauscht. Wird wieder zum Default-Theme gewechselt, würde die Resource wieder den grauen Button-Hintergrund anzeigen. Bild zurücksetzen Ist einer Resource für ein Theme ein abweichendes Bild zugeordnet, kann dies durch den Reset-Button wieder auf das Default-Bild zurückgesetzt werden. Beispiel Der Resource ist im Default-Theme, wie in den obigen Grafiken zu sehen, der graue Button-Hintergrund zugewiesen und im Theme der bläuliche. Befindet sich der Benutzer nun im Theme und klickt den Reset-Button, wird der bläuliche Buttonhintergrund aus der Resource für das Theme entfernt und der graue Button-Hintergrund würde auch für das Theme verwendet werden (siehe Hierarchie bei mehreren Packages und Themes ). Important Wird einer Resource bei aktiviertem Theme ein Bild zugewiesen und ist das Bild für das Default-Theme noch nicht gesetzt, wird das im Theme importierte Bild auch als Bild für das Default-Theme hinzugefügt."
  },
  "doc/themes/themeable-properties.html": {
    "href": "doc/themes/themeable-properties.html",
    "title": "Themeable Properties",
    "keywords": "Themeable Properties Um der Anwendung ein anderes Aussehen zu geben, können folgende Elemente auf Theme-Ebene angepasst werden: Applications Default Control Styles Resources (nur Bilder) Im Folgenden werden die verschiedenen Properties dieser Elemente aufgelistet, die im Rahmen eines Themes verändert werden können: Themeable Application Properties BackImage FocusHighlightColor Icon IsTransparent MenuBackColor MenuBackColorAlpha MenuItemBackColor MenuItemBackColorAlpha SplitterBackColor SplitterBackColorAlpha StartImage Themeable Default Control Styles Für jeden Default Control Style BackColor ForeColor Font IsEditable IsVisible IsTransparent EditField DisableBackColor TextAlign ImageButton CaptionAlign ScaleMode Picture ContentAlignment PictureScaleMode TabbedWindow TabAlignment TabLayout TreeView IsBorderVisible IsFirstExpandIconVisible IsHeaderVisible Themeable Resource Property Da Bilder die einzigen Ressourcen sind, die durch Themes angepasst werden können, ist auch das einzige Property, welches anpassbar ist, das Bild, welches die Resource definiert."
  },
  "doc/themes/verwalten.html": {
    "href": "doc/themes/verwalten.html",
    "title": "Verwalten",
    "keywords": "Verwalten Die Themes werden über den Theme Manager verwaltet. Dieser kann über das Menü Tools > Manage Themes aufgerufen werden. In der Liste werden alle verfügbaren Themes angezeigt. Sind Themes in einem oder mehreren Basis-Packages des aktuellen Packages definiert, werden diese mit dem jeweiligen Packagenamen in Klammern angezeigt, können aber nicht geändert werden. Menü: Über den Button wird ein neues Theme angelegt werden. Neue Themes erhalten ein (+) -Zeichen. Nur neu angelegte Themes können ohne die Aufräum-Routine gelöscht werden. Mit werden alle Änderungen gespeichert. Neue Themes mit (+) werden dann persistent gespeichert und können dann nur noch über die Aufräum-Routine gelöscht werden. Mit können noch nicht persistent gespeicherte Themes (mit (+) ) wieder gelöscht werden. Mit kann die Aufräum-Routine angestoßen werden. Properties: ID: Die ID wird beim Anlegen eines Themes generiert und ist eindeutig. Name: Name des Themes. Kann auch im Nachhinein noch geändert werden, da die Themes über die ID identifiziert werden. Der Name darf maximal 20 Zeichen lang sein. Deprecated: Wird ein Theme auf „Deprecated“ gesetzt, steht es in der Theme-Auswahl nicht mehr zur Verfügung. Es wird zudem auch bei Publish-Vorgängen nicht mehr beachtet. Deprecated gilt somit als Vorstufe zum Löschen des Themes mittels der Aufräum-Routine (siehe Aufräum-Routine ). Caution Sind in einem Package Themes auf Deprecated gesetzt, werden diese von der Aufräum-Routine endgültig aus dem Package gelöscht. Für Packages, die auf dem Package aufsetzen, in dem das Theme definiert war, ist das Theme dann auch nicht mehr verfügbar."
  },
  "doc/themes/zwischen-themes-wechseln.html": {
    "href": "doc/themes/zwischen-themes-wechseln.html",
    "title": "Zwischen Themes wechseln",
    "keywords": "Zwischen Themes wechseln Sind im aktuellen Package oder in dessen Basis-Packages Themes definiert (und nicht auf Deprecated gesetzt) kann das aktive Theme über das Menü Tools > Choose Theme ausgewählt werden. Note Wird Framework Studio neu gestartet, wird IMMER das Default-Theme geladen. Menü zur Auswahl des aktiven Themes: Wenn das aktive Package über ein oder mehrere Basis-Packages verfügt, in denen auch Themes definiert sind, werden diese mit dem jeweiligen Package Namen angezeigt. Themes aus Basis-Packages: Das aktuell aktive Theme wird auch rechts in der Framework Studio Statusleiste angezeigt. Anzeige des aktiven Themes:"
  },
  "doc/transformationen/transformationen.html": {
    "href": "doc/transformationen/transformationen.html",
    "title": "Transformationen",
    "keywords": "Transformationen Mit Hilfe von Transformationen können ein oder mehrere Eingabeparameter in einen Ausgabeparameter umgewandelt werden. Dies ist vor allem in Bezug auf Webservices hilfreich, bei dem z.B. eine Component, die nur im Webservice, jedoch nicht am Client bekannt ist, in einen Data Contract überführt werden soll. Es gibt zwei Arten von Transformationen: Eine graphische Transformation, bei der Properties der Eingabeparameter mit den Properties des Ausgabeparameters visuell verknüpft werden können und eine Code-Transformation, in der per C# die Eingabeparameter programmatisch in einen Ausgabeparameter konvertiert werden. Anlegen von Transformationen: Transformationen werden in einem Namespace über das Erstellmenü oder über Rechtsklick auf den Namespace in der unteren Treeview > New > FSTransformation erstellt. Code-Transformation Mit Hilfe der Code-Transformation können beliebig viele Eingabeparameter in einen Ausgabeparameter umgewandelt werden. Der Vorteil gegenüber graphischen Transformationen ist, dass der Komplexität der Transformation keine Grenze gesetzt ist. Beispiel 1: Die wohl kürzeste Code-Transformation ist die Umwandlung eines Typs in einen anderen. Hier dient als Beispiel die Umwandlung eines objects in einen string . Diese Operation kann z.B. von C# nicht implizit ausgeführt werden. Natürlich würde diese Umwandlung normalerweise vom Programmierer mit dem Aufruf der ToString() -Methode auf dem object realisiert werden. Wir wollen dies aber zu Anschauungszwecken in einer Code-Transformation abbilden: Beispiel 2: Als etwas komplexeres Beispiel wird eine Liste von Integern in einen String umgewandelt, in dem alle in der Liste enthaltenen Zahlen per Komma getrennt hintereinander stehen. Der Eingabeparameter ist also eine List<int> mit den Werten [2, 4, 6, 8] und als Ausgabe soll der String in Form von 2, 4, 6, 8 zurückgegeben werden. Die folgende Code-Transformation setzt dies um: Komplexere Code-Transformation: Eine Code-Transformation besteht immer aus einer einzigen Methode. Dabei sind Ref- und Out-Parameter nicht zulässig. Graphische Transformation Graphische Transformationen eignen sich besonders dafür, aus einer Component einen Data Contract und umgekehrt zu transformieren. Beispiel: Es existieren die Components cdArtikel und cdHersteller . Der Artikel implementiert eine Relation zu einem Hersteller. Es soll auf Basis dieser Components ein Data Contract erstellt werden, der allerdings nicht alle Properties bei der Component beinhaltet. Dieser wird wie folgt erstellt: Nun existieren die beiden Components und der Data Contract. Die Components und der Data Contract haben im FS jedoch keinerlei Verknüpfung. Um diese Verknüpfung herzustellen, d.h. festzulegen, wie aus den beiden Components ein Data Contract erstellt werden soll, bedarf es einer graphischen Transformation. Diese sieht wie folgt aus: Name Definiert den Namen der Transformation. Auf der linken Seite wird der Datentyp des Eingabeparameters ausgewählt (im Beispiel cdArtikel). Über den Button Add Argument können zusätzliche Eingabeparameter in die Transformation eingebunden werden. Alle Relationen in der jeweiligen Component (hier die Relation auf cdHersteller) werden in der Baumstruktur angezeigt. Auf der rechten Seite wird der Typ des Ausgabeparameters definiert (in diesem Beispiel dcArtikel). Anschließend können auf der linken Seite Properties markiert und per Drag&Drop auf ein Property des Ausgabeparameters gezogen werden. Verknüpfte Properties werden gelb markiert. Wird ein gelbes Property mit der Maus angeklickt, wird sein verknüpftes Property auf der anderen Seite grün markiert. So kann schnell eingesehen werden, welches Property der linken mit welchem Property der rechten Seite verknüpft ist. Transformationen der Properties Es kann vorkommen, dass die Properties, die verbunden werden sollen, vom Typ her nicht zusammenpassen. Im Beispiel befindet sich in cdArtikel ein Property namens oEinObjekt vom Typ object . Dieses ist jedoch in dcArtikel mit dem Property SEinStringVomObjekt verknüpft, welches vom Typ string ist. In diesen Fällen können pro Property wiederum Transformationen definiert werden, mit denen die Properties selbst transformiert werden sollen. Im Beispiel wird cdArtikel.oEinObjekt mit Hilfe der trObject2String -Transformation nach dcArtikel.SEinStringVomObjekt transformiert. Dabei ist trObject2String äquivalent zur FSTransformation1 aus Beispiel 1 im Kapitel Code-Transformation : Transformation von Object nach String Ableiten und Customizen von Transformationen Transformationen können gecustomized werden. Ableitungen sind nur für Code-Transformationen zulässig. In Code-Transformationen können die Methoden normal überschrieben werden. In graphischen Transformationen können neue Property-Verbindungen hergestellt oder Property-Transformationen ausgetauscht werden. Das Hinzufügen neuer Argumente ist nicht zulässig. Generierung des Data Contracts und der Transformationen aus Components Um die Erstellung von graphischen Transformationen erheblich zu vereinfachen, kann FS aus Components heraus eigenständig Data Contracts und die zugehörigen Transformationen zwischen der Component und des Data Contracts generieren. Hierzu muss in einer Component im Menü Edit > Autogenerate Data Contract gewählt werden. Data Contract Wizard: In diesem Formular können die Properties selektiert werden, die der Data Contract beinhalten soll. Mit dem Häkchen Inverse transformation kann gewählt werden, ob auch eine Transformation vom Data Contract zurück zur Component erstellt werden soll. Mit Klick auf den Button OK werden im Namespace der Data Contract und die zugehörigen Transformationen erzeugt."
  },
  "doc/webservices/data-contract.html": {
    "href": "doc/webservices/data-contract.html",
    "title": "Data Contract",
    "keywords": "Data Contract Es kann sein, dass Webservices komplexere Datenstrukturen empfangen oder versenden müssen als die normalen Datentypen wie Integer, String, Boolean usw. Beispiel: Ein Webservice erhält eine ID eines Herstellers in Form eines Integer. Er sucht dann in einer Datenbank nach allen PC’s, die von diesem Hersteller am Lager sind. Der Webservice wird also als Rückgabewert eine Liste von PC’s generieren. Intern im Webservice kann mit Klassen des PC’s oder auch des Herstellers operiert werden. Der Client, der den Webservice aufruft, kennt diese Klassendefinitionen jedoch nicht. Es wird also eine Datenbasis benötigt, die sowohl der Client als auch der Server kennt. Diese muss sich somit in die WSDL-Definition des Webservices integrieren und vom Client abrufbar sein. Name Definiert den Namen des Data Contracts. Type Wie Service Contracts können auch Data Contracts generiert werden. Dies geschieht bei Data Contracts mit Hilfe des ServiceProxies (siehe Generieren eines Data Contracts aus einem Service Proxy ). Dieser liest die WSDL-Definition des Webservice aus. In dieser sind alle Data Contracts als XSD-Definition hinterlegt. Sind in einem Webservice mehrere Data Contracts definiert, wird der Service Proxy auch mehrere Data Contract-Elemente erstellen. Somit existieren Data Contracts des Typs Userdefined Contract und External Contract , wenn dieser über einen Service Proxy generiert wurde. Registerkarte General Contract Type Hier kann definiert werden, von welchem Typ der Data Contract sein soll. Wird als Typ ein Collection-Type ausgewählt, muss der Datentyp der Collection-Elemente in der Combobox Element datatype definiert werden. Dies kann z.B. ein weiterer Data Contract sein. Interfaces Hier können per Komma getrennt Interfaces angegeben werden, die die Data Contract-Klasse implementieren soll. Binden eines externen Data Contracts Es besteht die Möglichkeit, in externen Assemblies untergebrachte WCF Data Contracts direkt in Framework Studio einzubinden. Hierzu kann über den Button Bind Contract eine .NET-Dll importiert werden. Importieren eines Data Contracts aus einer Assembly: Mit dem Button Add Assembly kann nach einer gewünschten Assembly auf dem System gesucht werden. Nach dem Import wird die Assembly automatisch nach Klassen mit dem Attribut [Data Contract] durchsucht und diese in der Combobox Choose Contract angezeigt. Die importierte Assembly wird als Ressource in Framework Studio eingebunden und bei einem Anwendungsstart oder Publish in das /bin-Verzeichnis des Brokers herausgeschrieben. Registerkarte Properties Hier werden die Properties des Data Contracts definiert. Mit Rechtsklick auf die Liste > New > Property wird ein neues Property angelegt. Name Definiert den Namen des Properties. Der erste Buchstabe des Namens wird immer in einen Großbuchstaben umgewandelt. Datatype Definiert den Datentyp des Properties. (Siehe Datentyp bearbeiten ). Property Type Definiert die Art des Properties (siehe Membervariablen ). Attributes Das Häkchen [DataMember] definiert, dass das Property des Data Contracts Bestandteil der XSD-Definition sein wird, welche in die WSDL-Definition eingebunden wird. Es müssen also nicht zwingend alle Properties des Data Contracts über den Webservice abrufbar gemacht werden. In der Textbox können zusätzliche Attribute zum Property definiert werden. Muss z.B. auf jeden Fall ein Wert in einem Property an den Webservice übergeben werden, kann dieses Property mit [DataMember(IsRequired=true)] erweitert werden. Ableiten und Customizen von Data Contracts Data Contracts können gecustomized werden. Dabei können neue Properties hinzugefügt werden oder Get-/Set-Methoden von Individual Properties überschrieben werden. Ableitungen von Data Contracts sind nicht möglich. Service Contract automatisch generieren In WCF ist für jeden Webservice zwingend ein Service Contract nötig. Der Service Contract wird dem Konsumenten über die WSDL zur Verfügung gestellt. Zur Vereinfachung der Implementierung eines Services in Framework Studio bietet dieses an, den Service Contract aus den Informationen des Servives automatisch zu generieren. Es wird also kein Service Contract-Element benötigt, um den Service zu betreiben. Um die automatische Generierung des Service Contracts am Service zu aktivieren, muss die Combobox Implement auf Yes gestellt werden (siehe Registerkarte Contracts ). Dies ist gleichzeitig der Standardwert für neu erstellte Service-Elemente. Auch wenn an einem Service der letzte zugeordnete Service Contract gelöscht wird, wird die automatische Generierung des Contracts aktiviert. Um aus einem Service den Contract automatisch zu generieren, wird der Service von Framework Studio nach allen Methoden mit Access Level public durchsucht. Öffentliche Methoden am Service: Der Name des automatisch generierten Contracts wird wie folgt abgeleitet: I + [Servicename] + Contract Für den Service AtricleInfoService aus dem Beispiel heißt der zugehörige, automatisch generierte Contract somit IArticleInfoService Contract . In der folgenden Abbildung wird verdeutlicht, wie der Code für den autogenerierten Contract erzeugt wird. Automatisch generierter Service Contract in der Use-Schicht: Es ist zu erkennen, dass die beiden öffentlichen Methoden aus dem Service in das Contract-Interface aufgenommen wurden und dass der Service den automatisch generierten Contract implementiert. Zusätzlich hat die Methode GetArticleByID(string id) ein FaultContract-Attribut erhalten, da an der Service-Methode der Data Contract „dcArticleError“ entsprechend als Fault Contract hinterlegt wurde (siehe Registerkarte Methods )."
  },
  "doc/webservices/fault-contracts.html": {
    "href": "doc/webservices/fault-contracts.html",
    "title": "Fault Contracts",
    "keywords": "Fault Contracts Wird eine Webservicemethode von einem Client (z.B. ein C#-Programm) aufgerufen, kann es auf dem Server zu Exceptions kommen. Im Normalfall können auf Client-Seite diese Exceptions abgefangen und ausgewertet werden. Es stehen aber nur limitierte Informationen bereit (Message/StackTrace). Im folgenden Beispiel wird an einem Webservice, der mit Framework Studio erstellt wurde, die Methode string GetArticleByID(string id) aufgerufen. Wird während der Abarbeitung der Methode auf dem Server eine Exception geworfen, kann diese auf Clientseite mittels try/catch abgefangen und behandelt werden. Es gibt jedoch auch den Anwendungsfall, dass die Servicemethode ganz bewusst ein Scheitern der Abarbeitung an den Client zurückgeben soll und dies mit möglichst ausführlichen Daten, wieso es zu dem Fehler gekommen ist. Eine normale Exception mit Message und StackTrace ist dann nicht mehr ausreichend. Beispiel: Die Servicemethode string „GetArticleByID(string id)“ gibt normalerweise den Namen des Artikels zurück, welcher für die angegebene ID in der Datenbank gefunden wurde. Wenn die ID allerdings nicht gefunden wurde, soll nicht nur ein Leerstring oder Null an den Client zurückgegeben werden, sondern ein definierter Statuscode und zusätzlich eine adequate Fehlermeldung. Da dies schon zwei Properties sind, die an den Client übertragen werden müssen, wird ein Objekt benötigt, welches alle gewünschten Informationen enthält – der Fault Contract. Fault Contract = Data Contract In der Praxis ist ein Fault Contract ein Data Contract, d.h. ein komplexes Objekt mit Properties, die wiederum vom Typ eines Data Contracts sein können. Um das obige Beispiel in die Tat umsetzen zu können, wird also ein Data Contract benötigt, der einen Statuscode und die dazugehörige Fehlermeldung aufnehmen kann. Hierzu wird in Framework Studio ein neuer Data Contract erstellt, der folgendermaßen aussieht: Fault Contracts zuweisen Die Verbindung zwischen Service-Methode und Fault Contract kommt im Service Contract zustande. Dieses Interface legt fest, welche Methoden vom Service implementiert werden müssen und zusätzlich, welche Fault Contracts von welcher Methode genutzt werden dürfen. Der für das Beispiel nötige Service Contract sieht folgendermaßen aus: Es soll also später vom Service die Methode string GetArticleByID(string id) implementiert werden. Zusätzlich wurde für diese Methode in der Liste der Fault Contracts der zuvor angelegte Data Contract dcArticleFault als Fault Contract hinterlegt. Das bedeutet, die Methode GetArticleByID kann im Fehlerfall ein Objekt vom Typ „dcArticleFault“ instantiieren und dieses an den aufrufenden Client zurückgeben. Um die Funktionsweise noch weiter zu verdeutlichen, folgt nun ein kleiner Ausschnitt aus dem generierten Code von Framework Studio. Zu sehen ist der Code des Service Contracts ArticleService Contract : Zu sehen ist, dass über der Methode string GetArticleByID(string id) ein Attribut [Fault Contract(typeof(dcArticleFault))] hinzugefügt wurde. Dies bedeutet, dass ein Service, der diesen Service Contract implementiert, in der Methode GetArticleByID den Data Contract dcArticleFault als Fault Contract verwenden kann. Dabei können einer Methode beliebig viele Fault Contracts zugewiesen werden. Zurückgeben eines Fault Contracts Als erstes muss nun ein neuer Service in Framework Studio angelegt werden, der den Service Contract „ArticleService Contract“ implementiert: Zu beachten ist, dass die Option Autogenerate Contract auf No gestellt ist, da wir uns ja selbst um einen Service Contract gekümmert haben. Der Service ist nun erstellt und der Contract korrekt zugewiesen. Nun muss die Methode string GetArticleByID(string id) am Service ArticleService ausprogrammiert werden. Im Beispiel wurde die übliche Businesslogik außer Acht gelassen. Wir gehen einfach davon aus, dass für die übergebene ID kein zugehöriger Artikel in der Datenbank gefunden wurde. Diese Information soll dem Client nun adequat mitgeteilt werden. Es kann nun, nachdem der Artikel nicht in der Datenbank gefunden wurde, eine neue Instanz des Data-/Fault Contracts dcArticleFault erstellt werden. Dieser kann mit den gewünschten Werten gefüllt werden, die zum Client übertragen werden sollen. In unserem Fall ist es der Statuscode 1 als Integer und die Information, dass der Artikel nicht gefunden wurde in Form eines Strings. Alles was nun noch getan werden muss, ist das Werfen einer FaultException vom Typ des Fault Contracts. In unserem Fall also FaultException<dcArticleFault> . Dieser generischen FaultException wird die gerade eben erstellte Faultinstanz übergeben. Um den Service ansprechen zu können, bedarf es nur noch einem Service Host, der für den Service einen entsprechenden Endpoint bereitstellt. Abfangen einer FaultException am Client Das folgende Beispiel des Clients wurde in Visual Studio 2012 entwickelt. Hierzu wurde der Service Host in Framework Studio gestartet und in Visual Studio eine neue Service Referenz angelegt. Das zuvor angesprochene Attribut [Fault Contract(typeof(dcArticleFault))] über der Methode im Service Contract sorgt dafür, dass die Beschreibung des Typs dcArticleFault in das WSDL des Webservices generiert wird. Dies hat zur Folge, dass jegliche Clients, die mit dem Service arbeiten, von diesem Typ wissen und ihn somit ohne Weiteres in ihrem eigenen Code verwenden können. Es folgt der neue Clientcode: Der Client weiß also mit Hilfe des WSDL, dass die Servicemethode string GetArticleByID(string id) potenziell eine Exception vom Typ FaultException<dcArticleFault> werfen kann. Es kann immer noch eine unhandled Exception auftreten. Der Code wird also um einen neuen Catch-Block erweitert, der nur auf die FaultException hört. Würden der Servicemethode mehrere Fault Contracts zugewiesen, könnten die unterschiedlichen FaultExceptions in weiteren Catch-Blöcken abgefangen werden. Die generische FaultException<T> bietet den jeweiligen Fault Contract über das Property Detail schon korrekt typisiert an. Es muss nichts gecastet werdeb. Danach kann auf die zur Verfügung stehenden Properties des Fault Contracts zugegriffen und vom Client verarbeitet werden."
  },
  "doc/webservices/rest-endpoint.html": {
    "href": "doc/webservices/rest-endpoint.html",
    "title": "REST Endpoint für Service-Methoden",
    "keywords": "REST Endpoint für Service-Methoden Standardmäßig bietet ein Service Host den ausgewählten Service bzw. dessen Service Contract nach außen hin über WCF und damit das SOAP-Protokoll an. Moderne Applikationen und allen voran Webapplikationen in Borwsern oder auf mobilen Endgeräten unterstützen mittlerweile jedoch oft kein SOAP mehr und bevorzugen deshalb die Kommunikation über JSON. Framework Studio bietet die Möglichkeit, den Service Host so zu konfigurieren, dass vollständig automatisch ein zusätzlicher Endpoint generiert wird, mit dem die im Service Contract propagierten Methoden auch über JSON und damit über einen normalen HTTP-Request angesprochen werden können. Um die vollständige Automatisierung dieser Funktionalität gewährleisten zu können, bedarf es einiger Regeln, die beachtet werden müssen. Diese betreffen vor allem die Kommunikation zwischen dem Client und dem generierten REST Endpoint des Service Hosts. Aktivieren des REST-Endpoints Der Service Host generiert den REST Endpoint, wenn die Checkbox Generate REST Endpoint aktiviert wird. In der Konfigurationsdatei des Servic Hosts wird dadurch ein neuer Endpoint mit dem ausgewählten Contract registriert: <endpoint name=\"rest\" address=\"api\" binding=\"webHttpBinding\" contract=\"App.IHelloServiceContract\" /> Warning Der REST Endpoint basiert auf der in WCF integrierten webHttpBinding . In einem WCF-Service darf für einen Service Contract nur ein Binding eines bestimmten Typs registriert werden. Sollte am Service Host schon ein Endpoint mit einem webHttpBinding für den ausgewählten Contract existieren, so kann das automatische Generieren des REST Endpoints nicht verwendet werden bzw. wird beim Start des Service Host zu Fehlern führen. Der Endpoint hat fest den Namen api und wird immer auf der im Service Host angegebenen Base Address registiert. Ist die Base Address z.B. http://localhost:1234/HelloServiceHost dann wird der REST Endpoint unter http://localhost:1234/HelloServiceHost/api zu finden sein. Im Development Service ist der neue Endpoint auch in der Auflistung im System Tray zu sehen: Aufrufen von Service-Methoden am REST Endpoint Das Aufrufen einer durch den REST Endpoint bereitgestellten Service Methode erfolgt über einen normalen HTTP-Request. Dabei gibt es einige Regeln, die beachtet werden müssen. Nachfolgend werden alle Spezialitäten der Kommunikation detailliert beschrieben und mit mehreren Beispielen transparent dargestellt. In den Beispielen wird ein Service namens \"HelloService\" verwendet. Dieser besteht aus 4 Methoden, die den Benutzer auf unterschiedliche Weise grüßen. Separate Urls für Service-Methoden Um die Methoden am REST Endpoint voneinander unterscheiden zu können, besitzt jede Methode eine eigene Url. Ist der REST Endpoint beispielsweise unter http://localhost:1234/HelloServiceHost/api registriert, so werden die einzelnen Methoden wie folgt angesprochen: Methodenname Url SayHello http://localhost:1234/HelloServiceHost/api/sayhello SayHelloComplex http://localhost:1234/HelloServiceHost/api/sayhellocomplex SayHelloFault http://localhost:1234/HelloServiceHost/api/sayhellofault SayHelloName http://localhost:1234/HelloServiceHost/api/sayhelloname Der Methodenname wird also als Url-Erweiterung am REST Endpoint genutzt. Auf Groß- und Kleinschreibung muss an dieser Stelle nicht geachtet werden. Um testweise HTTP-Requests auf den Service Host absetzen zu können, wird in den nachfolgenden Beispielen die App Postman genutzt. Sie ist kostenlos unter https://www.postman.com erhältlich. Beispiel 1: Parameterlose Methoden public virtual string SayHello() { return \"Hello!\"; } Am REST Endpoint ist diese Methode unter http://localhost:1234/HelloServiceHost/api/sayhello aufrufbar. Parameterlose Methoden können ausschließlich mit HTTP GET aufgerufen werden. Die Header Content-Type und Content-Encoding müssen nicht zwingend gesetzt sein, da bei parameterlosen Methoden im Request kein HTTP-Content übertragen wird. Der Header Accept muss auf application/json gesetzt sein oder diesen MIME-Type beinhalten (wird im Beispiel durch */* abgedeckt), ansonsten führt der Response am Client zu einem Fehler. Der Response hat ausschließlich den Content-Type application/json und das Content-Encoding utf-8 . Somit kann der Response ohne Umwege z.B. vom im JavaScript integrierten JSON-Parser eingelesen werden. Beispiel 2: Methoden mit Parametern (einfache Datentypen) public virtual string SayHelloName(string name) { return \"Hello \" + name + \"!\"; } Am REST Endpoint ist diese Methode unter http://localhost:1234/HelloServiceHost/api/sayhelloname aufrufbar. Methoden mit Parametern müssen zwinged mit HTTP POST aufgerufen werden. Der Header Content-Type muss zwingend auf application/json gesetzt sein, da der Service Host eine JSON-Kommunikation erwartet. Um Encoding-Fehlern vorzubeugen, wird empfohlen, den Header Content-Encoding entsprechend des übertragenen Contents zu setzen (vorzugsweise utf-8 ). Der Header Accept muss auf application/json gesetzt sein oder diesen MIME-Type beinhalten (wird im Beispiel durch */* abgedeckt), ansonsten führt der Response am Client zu einem Fehler. Methodenparameter müssen im HTTP-Content in einem JSON-Objekt übertragen werden. Url-Parameter werden nicht unterstützt. Jeder Methodenparameter wird als JSON-Property mit dem exakten Namen (Groß- und Kleinschreibung beatchen) übergeben. Im Beispiel wäre das der Parameter string name . Der Parameter wird im JSON wie folgt übertragen: { \"name\": \"Max Mustermann\" } Der Response hat ausschließlich den Content-Type application/json und das Content-Encoding utf-8 . Somit kann der Response ohne Umwege z.B. vom im JavaScript integrierten JSON-Parser eingelesen werden. Hat eine Methode mehrere Parameter, so werden diese im JSON-Objekt ebenfalls als Properties hinzugefügt. Die Reihenfolge ist dabei nicht relevant. public virtual string SayHelloMultiple(string name, int age, string city) Diese Methode würde folgendes JSON-Objekt wie gewünscht verarbeiten, obwohl die Parameter vertauscht sind: { \"name\": \"Max Mustermann\", \"city\": \"Stockach\", \"age\": 36 } Beispiel 3: Methoden mit Parametern (komplexe Datentypen) public virtual dcHelloResult SayHelloComplex(dcHelloInput input) { dcHelloResult result = new dcHelloResult() { sGreeting = \"Welcome!\", sFirstName = input.sFirstName, sLastName = input.sLastName }; return result; } Für einen Methodenaufruf mit komplexen Datentypen wie z.B. DataContracts oder Arrays gelten dieselben Regeln wie für einen Methodenaufruf mit einfachen Datentypen. Der einzige Unterschied ist, dass der jeweilige Parameter als JSON-Objekt übertragen wird. Im Beispiel hat die Methode einen Parameter vom Typ dcHelloInput mit zwei Properties. Dieser DataContract sieht im Framework Studio folgendermaßen aus: Als Rückgabetyp dient der DataContract dcHelloResult mit drei Properties, welcher so definiert ist: Der Aufruf der Service-Methode gestaltet sich intuitiv wie folgt: Hat eine Methode mehrere komplexe Parameter, so gilt dieselbe Nomenklatur wie in Beispiel 2. public virtual dcHelloResult SayHelloMultiple(dcHellopInput input, dcHelloInput inputOther, string greeting) Diese Methode würde folgendes JSON-Objekt wie gewünscht verarbeiten: { \"input\": { \"sFirstName\": \"Max\", \"sLastName\": \"Mustermann\" }, \"inputOther\": { \"sFirstName\": \"Peter\", \"sLastName\": \"Pan\" }, \"greeting\": \"Hi\" } Beispiel 4: Exceptions und FaultContracts public virtual void SayHelloFault() { dcFault fault = new dcFault() { sProp1 = \"Fault Property 1\", sProp2 = \"Fault Property 2\" }; throw new FaultException<dcFault>(fault, \"OH NO!\", new FaultCode(\"Custom Fault Code\"), \"Custom Fault Action\"); } Tritt währende der Verarbeitung im Service eine Exception auf oder wird aus der Logik heraus eine FaultException geworfen, so werden auch diese im JSON an den Client übertragen. Die FaulException aus obigem Code stellt sich im JSON folgendermaßen dar: { \"Action\": \"Custom Fault Action\", \"Code\": { \"IsPredefinedFault\": true, \"IsSenderFault\": false, \"IsReceiverFault\": false, \"Namespace\": \"\", \"Name\": \"Custom Fault Code\", \"SubCode\": null }, \"Reason\": { \"Translations\": [ { \"XmlLang\": \"en-US\", \"Text\": \"OH NO!\" } ] }, \"Detail\": { \"sProp2\": \"Fault Property 2\", \"sProp1\": \"Fault Property 1\" }, \"Exception\": { \"ClassName\": \"System.ServiceModel.FaultException`1[App.dcFault]\", \"Message\": \"OH NO!\", \"Data\": {}, \"InnerException\": null, \"HelpURL\": null, \"StackTraceString\": \" at App.REST_HelloService.SayHelloFault()\\r\\n at SyncInvokeSayHelloFault(Object , Object[] , Object[] )\\r\\n at System.ServiceModel.Dispatcher.SyncMethodInvoker.Invoke(Object instance, Object[] inputs, Object[]& outputs)\\r\\n at System.ServiceModel.Dispatcher.DispatchOperationRuntime.InvokeBegin(MessageRpc& rpc)\\r\\n at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage5(MessageRpc& rpc)\\r\\n at System.ServiceModel.Dispatcher.MessageRpc.Process(Boolean isOperationContextSet)\", \"RemoteStackTraceString\": null, \"RemoteStackIndex\": 0, \"ExceptionMethod\": \"8\\nSayHelloFault\\nApp_Svc, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\\nApp.REST_HelloService\\nVoid SayHelloFault()\", \"HResult\": -2146233087, \"Source\": \"App_Svc\", \"WatsonBuckets\": null, \"code\": [ {} ], \"reason\": [ {} ], \"messageFault\": null, \"action\": \"Custom Fault Action\", \"detail\": { \"sProp2\": \"Fault Property 2\", \"sProp1\": \"Fault Property 1\" } }, \"Message\": \"OH NO!\", \"StackTrace\": \" at App.REST_HelloService.SayHelloFault()\\r\\n at SyncInvokeSayHelloFault(Object , Object[] , Object[] )\\r\\n at System.ServiceModel.Dispatcher.SyncMethodInvoker.Invoke(Object instance, Object[] inputs, Object[]& outputs)\\r\\n at System.ServiceModel.Dispatcher.DispatchOperationRuntime.InvokeBegin(MessageRpc& rpc)\\r\\n at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage5(MessageRpc& rpc)\\r\\n at System.ServiceModel.Dispatcher.MessageRpc.Process(Boolean isOperationContextSet)\" } Folgende Properties stehen zur Verfügung, um am Client ggf. eine adequate Fehlermeldung anzeigen zu können: Property Typ Beschreibung Action String Beinhaltet die angegebene FaulAction Code Object Beinhaltet den angegebenen FaulCode inkl. aller SubCodes Reason Object Beinhaltet den angegebenen FaulReason , ggf. mit allen übergebenen Übersetzungen Detail User Defined Beinhaltet das Objekt, welches vom Entwickler als Fault in die FaultException gegeben wurde. Im Beispiel die Variable fault vom Typ dcFault Exception Object Beinhaltet die in Gänze serialisierte Exception mit allen Properties Message String Beinhaltet das Message -Property der Exception StackTrace String Beinhaltet das StackTraceString -Property der Exception JSON Format JSON kann verschiedene Datentypen in unterschiedlichsten Formaten übertragen. Für eine Datums- und Zeitangabe gibt es im JSON z.B. keinerlei Spezifikation, wie diese Information dargestellt werden soll. Da es im JSON keinen dedizierten DateTime-Typ gibt, wird ein Datum meist als String repräsentiert. Wie genau dieser String letztenendes aussieht, hängt vom JSON-Serializer ab. Der in WCF integrierte DataContractJsonSerializer von Microsoft überträgt den .NET-Typ DateTime z.B. so: { \"datetime\": \"/Date(1335205592410-0500)/\" } JavaScript serialisiert ein Datum aber so: { \"datetime\": \"2012-04-23T18:25:43.511Z\" } Der Effekt ist, dass sich ggf. Server und Client nicht verstehen und letztenendes auf Fehler laufen, da sie einen unterschiedlichen \"JSON-Dialekt\" sprechen. Aus diesem Grund arbeitet der REST Endpoint in einem Framework Studio Service Host mit dem bekannten JSON.NET Serializer , der weltweit in millionen von Anwendungen zum Einsatz kommt. Das von diesem Serializer ausgegebene JSON ist kompatibel mit JavaScript und versteht im Umkehrschluss auch die meisten Dialekte, ohne dass der Entwickler selbst in den Serialisierungsprozess eingreifen muss. ref- und out-Parameter WCF unterstützt generell ref- und out-Parameter in Service Methoden. Dies mündet in der SOAP-Kommunikation letztenendes in mehreren Rückabewerten einer Methode. Der REST Endpoint unterstützt ref- und out-Parameter NICHT . Wenn mehr als ein Rückgabeparameter in einer Service-Methode nötig sind, wird empfohlen, einen DataContract für diesen Zweck zu erstellen und diesen als Rückgabetypen für die Methode zu verwenden (siehe Beispiel 3)."
  },
  "doc/webservices/service.html": {
    "href": "doc/webservices/service.html",
    "title": "Service",
    "keywords": "Service Ein Service ist das Element, das die Methoden, welche in einem Service Contract definiert sind, implementiert. Jeder Service muss dabei mindestens einen Service Contract implementieren. Es besteht allerdings auch die Möglichkeit, den Service Contract automatisch aus den Metadaten des Service generieren zu lassen (siehe Service Contract automatisch generieren ). Name Name des Service-Elements. Dies ist gleichzeitig der Name der Klasse im IntelliSense. Registerkarte General In der Textbox Service Class Attributes können zusätzliche Attribute für die Service-Klasse definiert werden (z.B. [System.Serializable]). Registerkarte Methods Hier werden die Methoden des Services implementiert. In der Liste können mit Rechtsklick -> New -> Method/Method Override neue Methoden angelegt und im Codefenster ausprogrammiert werden. Das Property Misc -> GenerateGlobalObject kann für jede Methode unabhängig auf true oder false gesetzt werden. Ist es auf True gesetzt, wird im Hintergrund ein GlobalObject (siehe Global Objects ) generiert, welches im Code mit Global angesprochen und übergeben werden kann. Der Zugriff auf Global ist nötig, wenn eine Servicemethode Elemente aus Framework Studio instantiiert, bei deren Instantiierung ein GlobalObject nötig ist. Im Beispiel wird eine cdArticleColl über ihre Factory-Klasse mit cdArticleCollFactory.Create(Global) erstellt. Groupbox Properties for autogenerated Service Contract Method : Alle hier definierten Eigenschaften für die ausgewählte Service-Methode werden nur verwendet, wenn für den Service ein automatisch generierter Service Contract verwendet wird (siehe Service Contract automatisch generieren ). In der Textbox Attributes können Attribute für die automatisch generierte Interface-Methode im Service Contract definiert werden. Das für den Service Contract benötigte Attribut [OperationContract] wird automatisch hinzugefügt und muss nicht manuell eingetragen werden. In der Liste Fault Contracts können zur derzeit ausgewählten Service-Methode Fault Contracts hinzugefügt werden, die später im Code als Typ für eine FaultException verwendet werden können. Mehr Information hierzu im Kapitel Fault Contracts . Registerkarte Contracts Groupbox Autogenerated Service Contract : Die Combobox Implement gibt an, ob für den Service ein Service Contract automatisch generiert und implementiert werden soll (siehe Service Contract automatisch generieren ). In der Textbox Attributes können Attribute für das automatisch generierte Service Contract Interface definiert werden. Das für den Service Contract benötigte Attribut [OperationContract] wird automatisch hinzugefügt und muss nicht manuell eingetragen werden. Groupbox Implemented Service Contracts : In dieser Liste werden alle Service Contracts aufgelistet, die der Service implementiert. Die Spalte Type zeigt an, ob es sich bei einem Service Contract um einen benutzerdefinierten oder externen Service Contract handelt. Generieren eines Service Hosts aus einem Service Im Menü Edit befindet sich der Eintrag New service host for this service . Damit wird auf Basis des ausgewählten Services ein Service Host-Element im gleichen Namespace erstellt (siehe Fehler! Verweisquelle konnte nicht gefunden werden. ). Ableiten und Customizen von Services Services sind vollständig ableit- und customizbar. Es können neue Methoden hinzugefügt oder Basismethoden überschrieben werden. Implementierte Service Contracts aus der Basis können nicht gelöscht werden."
  },
  "doc/webservices/service-contract.html": {
    "href": "doc/webservices/service-contract.html",
    "title": "Service Contract",
    "keywords": "Service Contract Der Service Contract stellt eine funktionelle Beschreibung des zu implementierenden Webservices in Form eines Interfaces dar. Der Contract enthält die Deklarationen der Methoden, die der Webservice implementieren soll. Name Name des Service Contracts, standardmäßig beginnend mit einem großen I ( Interface ). Auch im IntelliSense ist der Service Contract unter diesem Namen zu finden. Type Es gibt zwei Arten von Service Contracts: Userdefined Contract Ein vom Programmierer erstellter Service Contract. Dieser Service Contract enthält ausschließlich diejenigen Methoden, die auf der Registerkarte Operations angelegt wurden. External Contract Wenn ein Service Contract aus einer externen Assembly implementiert wird, der an den Framework Studio Service Contract gebunden wird, ist dieser als External Contract gekennzeichnet. Registerkarte General Service Contract Attributes In dieser Textbox können zusätzliche Attribute für den WCF Service Contract definiert werden. Das Attribut [Service Contract] wird automatisch hinzugefügt und muss nicht manuell angegeben werden. Binden eines externen Service Contracts Es besteht die Möglichkeit, in externen Assemblies untergebrachte WCF Service Contracts direkt in Framework Studio einzubinden. Hierzu kann über den Button Bind Contract eine .NET-Dll importiert werden. Importieren eines Service Contracts aus einer Assembly: Mit dem Button Add Assembly kann nach einer gewünschten Assembly auf dem System gesucht werden. Nach dem Import wird die Assembly automatisch nach Interfaces mit dem Attribut [Service Contract] durchsucht und diese in der Combobox Choose Contract angezeigt. Die importierte Assembly wird als Ressource in Framework Studio eingebunden und bei einem Anwendungsstart oder Publish in das /bin-Verzeichnis des Brokers herausgeschrieben. Die Verbindung zum WCF Service Contract kann über einen Klick auf den Button Unbind Contract wieder gelöscht warden. Dann fungiert der Service Contract wieder als Userdefined Contract und es können manuell Methoden deklariert werden. Im Textfeld External Contract Information werden alle verfügbaren Methoden des WCF Service Contracts aus der externen Assembly angezeigt. Solange ein externer WCF Service Contract gebunden ist, steht die Registerkarte Operations nicht zur Verfügung. Registerkarte Operations Hier werden die Methoden deklariert, welche der Webservice später implementieren soll. Mit Rechtsklick in das Grid -> New -> Operation wird eine neue Methode angelegt. Anschließend werden in der Textbox Declaration Rückgabewert, Methodenname und optional Übergabeparameter definiert. Der Access Level der Methode wird automatisch auf public gesetzt. In der Textbox Attributes können zusätzliche Attribute für die Operation definiert werden. Das Attribut [OperationContract] wird automatisch hinzugefügt und muss nicht manuell angegeben werden. In der Liste Fault Contracts können zur derzeit ausgewählten Operation Fault Contracts hinzugefügt werden, die später im Service als Type für eine FaultException<T> verwendet werden können. Mehr Information hierzu im Kapitel Fault Contracts . Generieren eines Services aus einem Service Contract Im Menüpunkt Edit befindet sich der Eintrag New service implementing this contract . Damit wird auf Basis des ausgewählten Service Contracts ein Service-Element ( Service ) im selben Namespace generiert, welches den Service Contract implementiert. Dies erspart dem Programmierer das Anlegen eines Service-Elements und das manuelle Einbinden des zugehörigen Service Contracts zum Service-Element. Customizen von Service Contracts Service Contracts können in Framework Studio nur gecustomized werden. Es besteht die Möglichkeit, den Service Contract um Methoden zu erweitern. Das Ableiten von Service Contracts ist nicht möglich. Methoden aus der Basis werden ausgegraut dargestellt. Werden in der Ableitung oder Customization Attribute am Service Contract oder an dessen Methoden definiert, werden diese als zusätzliche Attribute in den Code generiert. Attribute aus der Basis werden demnach NICHT überschrieben."
  },
  "doc/webservices/service-host.html": {
    "href": "doc/webservices/service-host.html",
    "title": "Service Host",
    "keywords": "Service Host Ein Service Host legt die Richtlinien fest, wie ein Service veröffentlicht wird. Dabei bezieht er sich immer auf einen Service und einen dem Service zugeordneten Service Contract. Service Host Properties Name Name des Service Host. Dies ist gleichzeitig der Name der Klasse im IntelliSense. Service Über den Button Select Service wird der Service ausgewählt, den der Service Host nach außen hin anbieten soll. Service Contract Wenn am zugeordneten Service die Option Autogenerate Contract aktiviert ist, besteht hier am Service Host die Möglichkeit den vom Service generierten Service Contract zu verwenden, indem die Checkbox Use Autogenerated aktiviert wird. Soll ein benutzerdefinierter Service Contract des Services genutzt werden, kann dieser mittels der Combobox ausgewählt werden. Wenn in einer Customization eines Service Hosts zeitweise ein anderer Service Contract ausgewählt war, kann mit dem Button Inherit Contract wieder die Einstellung des Basis-Service Hosts übernommen werden. Host Type Hier wird ausgewählt, wie der Service Host den Service anbietet. Derzeit ist nur die Veröffentlichung als Windows Service möglich. Generate REST Endpoint Diese Option bestimmt, ob am Service Host automatisch ein zusätzlkicher Endpoint generiert wird, welcher alle Service-Methoden als JSON-API nach außen hin anbietet. Eine detaillierte Beschreibung dieser Funktionalität befindet sich im Kapitel REST Endpoint für Service-Methoden . Use WebServiceHost instead of ServiceHost Wählt die .NET Service Host-Klasse aus, von der der Service Host abgeleitet wird. Standard ist ServiceHost . Launch Debugger on Startup Wenn der Service über Framework Studio gestartet wird (siehe Start/Stop current development FSDomain ), wird er im Development Service Host bereitgestellt. Ist Launch Debugger on StartUp aktiviert, erscheint beim Starten der FSDomain ein Fenster, in dem eine neue Instanz des VisualStudio Debugger erstellt werden kann. Just-In-Time-Debugger: Wird mit Ja bestätigt, wird der Code des Service im Visual Studio angezeigt, der Prozess des Development Service Hosts unterbrochen und es kann mit dem Debugging begonnen werden. Registerkarte Service Behaviors Base Address Definiert die Adresse, an der der Webservice verfügbar gemacht werden soll. Aus der Combobox können von FS vorgegebene Adressen ausgewählt werden. Ist die Checkbox aktiviert, kann die Adresse überschrieben und manuell konfiguriert werden. Es stehen folgende Platzhalter zur Verfügung: %SERVER% %PORT% %REPOSITORY% %VERSION% %USER% %HOSTNAME% %HOSTFULLNAME% Wird der Port mit 0 angegeben, wird zur Laufzeit ein freier Port vom System zugewiesen. HttpGetEnabled Diese Checkbox definiert, ob die Dienstmetadaten in Form von WSDL über HTTP/GET bereitgestellt werden. Ein Client kann also über die Adresse des Webservice inklusive eines angehängten ?wsdl die Definition des Webservice z.B. in einem Browser auslesen. Beispiel: Existiert ein Webservice auf dem lokalen System an der Adresse http://localhost:8082/FSDemo/ArticleInfoService Host kann die Definition dieses Service mit dem Aufruf http://localhost:8082/FSDemo/ArticleInfoService Host?wsdl eingesehen werden. Über diese Definition können Clients für diesen Webservice automatisch erstellt werden, z.B. in einem Visual Studio-Projekt oder einem anderen Framework Studio Package. Warning Wird keines der Häkchen gesetzt, kann ein Client, der die Implementierung des Webservice nicht kennt, die Definition für die Benutzung des Webservice via WSDL nicht auslesen. Der Client muss also wissen, welche Methoden mit welchen Parametern und Rückgabewerten an diesem Webservice veröffentlicht werden, um Aufrufe zu tätigen. IncludeExceptionDetailInFaults Sollte nach einem Request eines Clients an einen Webservice zur Laufzeit eine Exception auftreten, kann mit diesem Flag bestimmt werden, ob der Webservice die Details der geworfenen Exception mit in den SOAP-Envelope mit einbezieht, der als Response an den Client zurück geschickt wird. Beispiel: <s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\"> <s:Body> <s:Fault> <faultcode mlns:a=\"http://schemas.microsoft.com/net/2005/12/wcf/dispatcher\"> a:InternalServiceFault </faultcode> <faultstring xml:lang=\"en-US\"> Exception in FindEmployeeByLastName </faultstring> <detail> <ExceptionDetail xmlns=\"http:// org/2004/07/System.ServiceModel\" xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\"> <HelpLink i:nil=\"true\"/> <InnerException i:nil=\"true\"/> <Message>Exception in FindEmployeeByLastName</Message> <StackTrace> at EmployeeService.ServiceImplementation.EmployeeManager. FindEmployeeByLastName( String request) in C:\\Dev\\EmployeeSvcManual\\Source\\Service\\EmployeeService.ServiceImplementation\\EmployeeManager.cs:line 25&#xD; at SyncInvokeFindEmployeeByLastName(Object , Object[] , Object[] )&#xD; at System.ServiceModel.Dispatcher.InvokeDelegate.Invoke(Object target, Object[] inputs, Object[] outputs)&#xD; at System.ServiceModel.Dispatcher.SyncMethodInvoker.Invoke(Object instance, Object[] inputs, Object[]&amp; outputs)&#xD; at System.ServiceModel.Dispatcher.DispatchOperationRuntime.InvokeBegin( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage5( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage4( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage3( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage2( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.ImmutableDispatchRuntime.ProcessMessage1( MessageRpc&amp; rpc)&#xD; at System.ServiceModel.Dispatcher.MessageRpc.Process(Boolean isOperationContextSet) </StackTrace> <Type>System.ApplicationException</Type> </ExceptionDetail> </detail> </s:Fault> </s:Body> </s:Envelope> Der Client kann demnach den <detail> -Block auswerten und in ein mögliches Error-Handling mit einbeziehen. Hier sind auch die Details der Exception, die zur Laufzeit der Webservice-Methode aufgetreten sind, zu sehen. Zusätzlich wird auch der gesamte Stack-Trace mit übergeben. Die Implementierung des Exceptionhandlings wird durch die meisten generierten Clients automatisch mit abgedeckt. Caution Diese Einstellung ist bei der Entwicklung von Webservices sehr hilfreich, sollte jedoch in produktivem Betrieb deaktiviert werden. Da der Stack-Trace dem Client einige Informationen über die internen Abläufe des Webservice offenbart, könnte der Webservice ggf. leicht angreifbar werden. Textbox <ServiceBehavior> Zusätzlich zu den per Checkbox auswählbaren Parametern können hier noch manuell Behavior-Attribute in Form von XML gesetzt werden. Diese werden beim Start des Service Hosts in die Web.config geschrieben. Registerkarte EndPoints EndPoint Konfiguration: Hier können verschiedene Arten von EndPoints für den Webservice definiert werden. Beim Aufruf eines WCF-Services durchläuft der Request in der WCF-Runtime den sogenannten Stack-Channel. Dieser beschreibt, wie die Kommunikation zwischen Client und Server stattfindet. Er enthält Informationen zu Interoperabilität, Sicherheit, Protokollen, Encodierungen, Transaktionsfluss und vieles mehr (siehe auch http://msdn.microsoft.com/en-us/library/ms730879.aspx ). Die EndPoints eines Webservice kapseln genau diese Informationen. Soll ein Webservice über unterschiedliche Kommunikationsarten aufrufbar sein, können mehrere EndPoints zu einem Webservice definiert werden (z.B. einer für HTTP und einer für die Kommunikation via NamedPipes). Default Properties Name Name des EndPoints. Dieser ist auch in der WSDL-Definition des Webservice zu sehen. Address Adresse des EndPoints für den Webservice. In der Combobox werden seitens FS lokale Adressen zur Auswahl angeboten. Diese können mittels der Checkbox überschrieben werden. Folgende Platzhalter stehen zur Verfügung: %SERVER% %PORT% %REPOSITORY% %HOSTNAME% %ENDPOINT% %VERSION% %USER% %HOSTNAME% %HOSTFULLNAME% Wird der Port mit 0 angegeben, wird zur Laufzeit ein freier Port vom System zugewiesen. Binding Hier wird die Binding des Services ausgewählt. In der Combobox stehen alle von WCF vordefinierten Bindings. Jede dieser Bindings generiert einen unterschiedlichen WCF-Stack-Channel und wirkt sich somit direkt auf die Kommunikation und Erreichbarkeit des Webservices aus. Eine genaue Beschreibung der unterschiedlichen Bindings befindet sich unter http://msdn.microsoft.com/en-us/library/ms730879.aspx oder http://msdn.microsoft.com/en-us/magazine/cc163394.aspx Binding Configuration Sind auf der Registerkarte EndPoint Bindings Einträge vorhanden, können diese dem EndPoint zugewiesen werden. Binding Name Name der Binding in der WSDL-Definition. Behavior Sind auf der Registerkarte EndPoint Behaviors Einträge vorhanden, können diese dem EndPoint zugewiesen werden. Additional Properties Hier kann die EndPoint-Konfiguration mittels XML manuell erweitert werden. Beim Start des Service Hosts werden alle Eingaben in die Web.config übernommen. Registerkarte EndPoint Bindings EndPoint Binding Konfiguration: Mit EndPoint Bindings lässt sich die Kommunikation - wenn erwünscht - zwischen Client und Webservice genauer spezifizieren. Wird in einen Service keine EndPoint Binding eingebunden, gelten die Default-Werte seitens der WCF-Spezifikation in Abhängigkeit des im EndPoint angegebenen Binding Types. Name Definiert den Namen der EndPoint Binding. Binding Type Definiert den Binding Type der EndPoint Binding. Warning Es können nur EndPoint Bindings zu EndPoints zugeordnet werden, die den gleichen Binding Type haben. Default Properties Die Werte werden je nach ausgewähltem Binding Type aktiviert oder deaktiviert. Als Standardwerte dienen die Standardwerte der WCF-Spezifikation. AllowCookies Kann nur bei HTTP-Bindings aktiviert werden. Wenn das Häkchen gesetzt ist, wird dem Webservice der Umgang mit Cookies erlaubt. Eine dem Webservice entsprechende Client-Implementierung beinhaltet dann das WCF-Managementsystem für den Umgang mit Cookies. BypassProxyOnLocal Wenn gesetzt, wird der Proxy vom System für alle Aufrufe ins Internet umgangen. Wenn nicht gesetzt, werden alle Aufrufe ins Internet durch den Proxy geleitet. CloseTimeout Definiert die Zeitspanne, die dem Webservice eingeräumt wird, um eine Close-Operation auszuführen. OpenTimeout Definiert die Zeitspanne, die dem Webservice eingeräumt wird, um eine Open-Operation auszuführen. ReceiveTimeout Definiert die Zeitspanne, die dem Webservice eingeräumt wird, um eine Empfangs-Operation auszuführen. SendTimeout Definiert die Zeitspanne, die dem Webservice eingeräumt wird, um eine Sende-Operation auszuführen. HostNameComparisonMode Mit diesem Wert werden die URI-Übereinstimmungsregeln angegeben, die vom Dispatcher eines Transportprotokolls wie HTTP, TCP oder NamedPipes beim Verteilen von eingehenden Nachrichten an die im Webservice verfügbaren EndPoints verwendet werden. Jeder Wert von HostNameComparisonMode entspricht einer bestimmten Übereinstimmungsregel. Die Priorisierung der Übereinstimmungsregeln gestaltet sich wie folgt: StrongWildcard Exact WeakWildcard StrongWildcard ignoriert den Hostnamen bei der Übereinstimmungsprüfung. Er hat die höchste Priorität der drei verschiedenen Übereinstimmungsmodi. Dies ist der Standardwert für eine von WCF bereitgestellte Binding. Dadurch wird angegeben, dass ein EndPoint eines Webservices mit jedem gültigen Hostnamen erreicht werden kann. Beispiel: Wenn MyService beispielsweise auf http://localhost/MyService gehostet wird, ist er immer noch über http://www.anotherhost.com/MyService erreichbar, da der Hostname anotherhost.com ignoriert wird. Exact erfordert, dass mithilfe der angegebenen Url eine exakte Übereinstimmung, einschließlich des Host-Namens, gefunden werden muss, wenn sonst keine hinreichende Übereinstimmung erzielt werden kann mit der die Url genau einem EndPoint zugeordnet werden kann. Dieser Modus prüft z.B. nicht die Übereinstimmung von kurzen Hostnamen mit vollqualifizierten Domänennamen. Auf diese Weise können Hostnamen als Suchkriterien in solchen Szenarien verwendet werden, in denen mehreren Hosts die gleiche IP-Adresse zugewiesen wird. WeakWildcard ignoriert den Hostnamen, wenn sonst keine hinreichende oder exakte Übereinstimmung erzielt werden kann. MaxBufferPoolSize Definiert die Größe des Hauptspeichers, welcher vom WCF-Message-Buffer-Manager für eingehende Nachrichten verwendet werden darf. MaxBufferSize Ein Wert in Bytes, welcher die maximale Größe des Puffers angibt, der die zu bearbeitenden Nachrichten für den EndPoint beinhaltet, zu dem diese Binding zugeordnet ist. Der Wert kann nicht kleiner als „MaxReceivedMessageSize“ sein. MaxReceivedMessageSize Ein Wert in Bytes, der die maximale Größe einer Nachricht zum verknüpften EndPoint angibt. Der Versender der Nachricht erhält als Antwort bei Überschreitung des Wertes einen SOAP-Fault. Der Webservice verwirft die eingehende Nachricht und schreibt das Ereignis in das Trace-Log. TextEncoding Definiert, wie der in der Nachricht enthaltene Text codiert ist. Beispiele: UFT-8, ISO-8559-1. MessageEncoding Je nach Binding Type stehen Text, Binary oder MTOM (Message Transmission Optimization Mechanism) zur Verfügung. TransferMode Definiert, wie die Nachrichten über den Stack-Channel versendet und gepuffert werden. Es stehen folgende Transfermodes zur Auswahl: Buffered: Die Anforderungs- und Antwort-Nachrichten werden gepuffert. Streamed: Die Anforderungs- und Antwort-Nachrichten werden per Stream übertragen. StreamedRequest: Die Anforderungsnachricht wird per Stream übertragen, und die Antwortnachricht wird gepuffert. StreamedResponse: Die Anforderungsnachricht wird gepuffert, und die Antwort-Nachricht wird per Stream übertragen. UseDefaultWebProxy Wenn im System ein Proxy hinterlegt ist, wird dieser vom Webservice mit der vom System veröffentlichten Konfiguration verwendet. Reader Quotas Properties maxArrayLength Definiert die maximale Größe von Arrays, die in einer Nachricht übertragen werden dürfen. maxBytesPerRead Definiert die maximale Anzahl an Bytes die pro Lesevorgang zurückgegeben werden darf. maxDepth Definiert die maximale Knotentiefe, die pro Lesevorgang erreicht werden darf. maxNameTableCharCount Definiert die maximale Anzahl an Buchstaben, die ein Tabellenname beinhalten darf. maxStringContentLength Definiert die maximale Anzahl an Buchstaben im Inhalt von übertragenen XML-Elementen. Additional Properties Hier kann die EndPoint-Binding-Konfiguration mittels XML manuell erweitert werden. Beim Start des Service Hosts werden alle Eingaben in die Web.config übernommen. Registerkarte EndPoint Behaviors Ein EndPoint Behavior definiert ein Verhalten eines zugehörigen EndPoints. Wird in einem EndPoint kein explizites Verhalten angegeben, gelten die Standardwerte seitens der WCF-Spezifikation. Name Definiert den Namen der EndPoint Behavior. Properties enableWebScript Aktiviert das Endpunktverhalten, durch das der Dienst über ASP.NET AJAX-Webseiten genutzt werden kann. Das Verhalten sollte nur in Verbindung mit entweder dem <webHttpBinding> - oder dem <webMessageEncoding> -Binding Type verwendet werden. synchronousReceive Gibt das Laufzeitverhalten für das Empfangen von Nachrichten in einem Dienst oder einer Clientanwendung an. Es enthält keine Attribute oder untergeordnete Elemente. transactedBatching Gibt an, ob Transaktionsbatching für Empfangsvorgänge unterstützt wird. MaxBatchSize Eine ganze Zahl, die die maximale Anzahl an Empfangsvorgängen angibt, die in einer Transaktion zusammengefasst werden können. webhttp Gibt WebHttpBehavior an, anhand der Konfiguration in einem Endpunkt. Wenn dieses Verhalten zusammen mit der -Binding verwendet wird, wird das Webprogrammiermodell für einen WCF-Dienst aktiviert. Registerkarte Methods Hier können beliebig Methoden implementiert werden, die die Service Host-Klasse anbieten soll. Registerkarte Variables Hier können beliebig Variablen für die Service Host-Klasse deklariert werden. Es können auch statische Variablen verwendet werden. Generieren eines ServicesProxy aus einem Service Host Im Menüpunkt Edit befindet sich der Eintrag New proxy for this service host . Damit wird auf Basis des ausgewählten Service Hosts ein Service Proxy-Element (siehe Fehler! Verweisquelle konnte nicht gefunden werden.) im selben Namespace generiert, welches sich automatisch für den Zugriff auf einen EndPoint des Webservices konfiguriert. Dies erspart dem Programmierer das Anlegen eines Service Proxy-Elements und das manuelle Einbinden des zugehörigen Service Hosts und EndPoints. Ableiten und Customizen von Service Hosts Service Hosts können abgeleitet und gecustomized werden. Alle Properties, Endpoints, Behaviors, Methoden usw. sind überschreib- oder änderbar."
  },
  "doc/webservices/service-proxy.html": {
    "href": "doc/webservices/service-proxy.html",
    "title": "Service Proxy",
    "keywords": "Service Proxy Ein Service Proxy verschafft einem Client Zugang zu einem Webservice. Dieser kann ein Webservice (also ein Service Host, der auf einen Service inklusive Service Contract zeigt) sein, der lokal im FS definiert wurde oder ein externer Webservice im Internet. Der Service Proxy übernimmt an dieser Stelle die Generierung des Codes, der nötig ist, um auf die Operationen, die der Webservice bereitstellt, zuzugreifen. Er kapselt somit auch die gesamte EndPoint- und somit WCF-Stack-Channel-Definition des Webservice. Dies wird vor allem dann hilfreich, wenn aus der WSDL-Definition eines Webservices im Internet ein passender Client erstellt werden soll, der sich genau an die Richtlinien des Webservice hält. Service Proxy für Service Hosts aus dem Repository Name Definiert den Namen des Service Proxy. Registerkarte General Um Service Hosts aus dem Repository in den Service Proxy einzubinden wird der Radiobutton Service from this repository gewählt. Danach kann über den Button Choose Host aus dem Namespace-Tree ein beliebiges Service Host-Element ausgewählt werden. Die Combobox EndPoint zeigt nun alle im Webservice verfügbaren EndPoints, die angesprochen werden können. Mit der Checkbox Generate wrapper for all proxy methods kann im generierten Code des Service Proxy für jede Methode eine Wrapper-Methode angelegt werden. Beispiel: Ist das Häkchen gesetzt, kann später im Code (z.B. in einer Component) wie folgt auf die Methoden zugegriffen werden: dcPC[] pcs; using (PcListSvcProxy proxy = new PcListSvcProxy(this.Global)) { pcs = proxy.GetPcList(ID); } Ist das Häkchen nicht gesetzt, sieht der Aufruf wie folgt aus: dcPC[] pcs; using (PcListSvcProxy proxy = new PcListSvcProxy(this.Global)) { pcs = proxy.Proxy.GetPcList(ID); } Der Aufruf findet also über die Interne Proxy-Klasse des Service Proxy-Elements statt. Registerkarte Methods Hier können beliebig Methoden implementiert werden, die die Service Proxy-Klasse anbieten soll. Registerkarte Service Operations Liste der Methoden am Service Proxy: Hier werden alle Methoden des Webservice aufgelistet, die der Webservice anbietet bzw. auf die der Service Proxy zugreifen kann. Registerkarte EndPoint Hier wird die EndPoint-Definition in Form von XML angezeigt. Diese kann mit dem Häkchen Overwrite EndPoint manuell überschrieben werden. Registerkarte Binding Hier wird die Binding-Definition in Form von XML angezeigt. Diese kann mit dem Häkchen Overwrite Binding manuell überschrieben werden. Registerkarte EndPoint Behavior Hier wird die EndPoint Behavior-Definition in Form von XML angezeigt. Diese kann mit dem Häkchen Overwrite EndPoint Behavior manuell überschrieben werden. Service Proxy für einen externen Webservice im Internet Um externe Webservices im Internet in die Anwendung einzubinden, wird der Radiobutton External service im Service Proxy gewählt. Im Feld Service Address wird die Adresse des Webservices im Internet angegeben. Mit der Combobox Contract kann optional aus dem Namespace-Tree ein Service Contract ausgewählt werden, den der Proxy mit implementieren soll. Die Combobox EndPoint wird automatisch gefüllt, wenn die Proxy-Klasse mit dem Button Generate Proxy (siehe Registerkarte SvcUtil Options ) aus der WSDL-Definition des Webservice generiert wird. Danach stehen alle EndPoints, die der Webservice anbietet, zur Auswahl. Mit dem Button Test Service wird der mit Visual Studio ausgelieferte WCF-Testclient gestartet und versucht, den angegebenen Webservice zu laden. Die verschiedenen EndPoints (im Beispiel „CurrencyCenvertorSoap“ und „CurrencyConvertorSoap12“) und die erreichbaren Methoden werden angezeigt. Mit einem Doppelklick auf eine der Methoden kann diese im rechten Fenster getestet und die SOAP-Envelopes des Request und Response in XML-Format eingesehen werden. Registerkarte SvcUtil Options Mit dem Häkchen bei \\Async wird bei der Generierung des Proxy-Codes je Methode eine Signatur für den synchronen und eine für den asynchronen Aufruf erstellt. Somit ist es möglich, später in der Anwendung zu entscheiden, ob der Webservice synchron oder asynchron (z.B. wie bei AJAX) aufgerufen werden soll. Mit \\Collection Type wird angegeben, welche Art von Collection-Typ die Proxy-Klasse für Collection-Parameter im Webservice verwenden soll. Mit dem Button Generate Proxy wird im Hintergrund der tatsächliche Programmcode des Proxy und die dazugehörige App.Config-Datei generiert. Dies geschieht über das Tool SvcUtil.exe , welches mit dem Windows SDK ausgeliefert wird. Wo die EXE auf dem System liegt, kann unter Tools > Options > Utilities > SvcUtil angegeben werden. Der Standardpfad ist C:\\Programme\\Microsoft SDKs\\Windows\\v6.0A\\bin\\SvcUtil.exe . Die Metadaten des Webservice werden in Form der WSDL-Definition heruntergeladen und auf Basis dieser der Proxy erstellt. Dabei werden auch die Informationen über die verfügbaren EndPoints eingelesen und in der Combobox EndPoint zur Auswahl bereitgestellt. Registerkarte Generated Code Hier kann der von SvcUtil.exe generierte Proxy-Code eingesehen werden. Registerkarte Generated App.Config Hier kann die von SvcUtil.exe generierte App.Config-Datei eingesehen werden. Generieren eines Data Contracts aus einem Service Proxy Im Menüpunkt Edit befindet sich der Eintrag Generate Data Contracts . Damit wird auf Basis des ausgewählten Service Proxy ein (oder mehrere) Data Contract-Element(e) (siehe Fehler! Verweisquelle konnte nicht gefunden werden. ) im selben Namespace generiert. Dies ist nur für externe Webservices möglich. Ableiten und Customizen von ServiceProxies ServiceProxies können abgeleitet und gecustomized werden. Lediglich EndPoints, Bindings und Behaviors können bearbeitet werden. Eine Änderung des Service Host ist nicht möglich und auch ein Aufruf von SvcUtil.exe wird nicht angeboten."
  },
  "doc/webservices/webservices.html": {
    "href": "doc/webservices/webservices.html",
    "title": "Webservices",
    "keywords": "Webservices Framework Studio bietet die Möglichkeit, mit einfachen Mitteln Webservices auf Basis der Microsoft Windows Communication Foundation (WCF) zu erstellen und zu konsumieren. Hierzu wird die Komplexität von WCF mittels einiger Service-Elemente seitens Framework Studio abstrahiert und vereinfacht. Service-Elemente anlegen Es wird der Namespace ausgewählt, in dem das neue Element angelegt werden soll. Danach wird über den Button New des Registerkartes Service und anschließend das gewünschte Service-Element ausgewählt."
  },
  "doc/weitere-themen/clientoptions-xml.html": {
    "href": "doc/weitere-themen/clientoptions-xml.html",
    "title": "ClientOptions.xml",
    "keywords": "ClientOptions.xml In dieser Datei können Einstellungen für den Java-Client vorgenommen werden. Die Datei muss manuell angelegt und bearbeitet werden. Die Datei ClientOptions.xml wird auf dem Client-Rechner im Ordner %userprofile%\\FSClientLauncher\\ abgelegt. Die darin vorgenommenen Einstellungen ziehen für alle Java-Clients die auf diesem Rechner gestartet werden, sofern sie die entsprechende Einstellung unterstützen. Das gilt sowohl für Clients, die über den Client-Launcher als auch für Clients, die über Java Web Start gestartet werden. Beispiel-Datei: <ClientOptions> <add key=\"NoTooltip\" value=\"1\"/> <add key=\"NoProgressWindow\" value=\"1\"/> <add key=\"NoFrameAnimation\" value=\"1\"/> </ClientOptions> Es werden folgende Einstellungen unterstützt: NoTooltip : Es werden in der Anwendung keine Tooltips angezeigt. NoProgressWindow : Es wird in der Anwendung kein Progress-Fenster angezeigt. NoFrameAnimation : Das Ein- und Ausblenden von Frames im Frameset wird nicht animiert."
  },
  "doc/weitere-themen/clone_und_adoptvalues.html": {
    "href": "doc/weitere-themen/clone_und_adoptvalues.html",
    "title": "Clone() und AdoptValues()",
    "keywords": "Clone() und AdoptValues() Framework Studio bietet einen Mechanismus, mit dem es möglich ist, eine Component inkl. aller Unter-Objekte zu kopieren. Dafür werden an der Component und der Collection die Methoden Clone() und AdoptValues() angeboten. Clone vs. AdoptValues Beim Clone wird von einer Component eine Kopie erzeugt. Dabei bleibt die Eigenschaft ObjectRowID erhalten. Aber intern wird eine neue RuntimeID vergeben. IcdComponent oCompCloned = (IcdComponent)oComp.Clone(); Bei AdoptValues werden die Daten der übergebenen Component übernommen. Die ObjectRowID wird allerdings nicht übernommen, sie behält ihren Wert wie vor dem Aufruf von AdoptValues. IcdComponent oCompAdopted = cdComponentFactory.Create(this.Global); oCompAdopted.AdoptValues(oComp); BEIDE Routinen arbeiten standardmäßig alle Unter-Properties rekursiv durch (Tiefen-Kopie). Dabei wird intern die Methode Clone() verwendet. Das bedeutet, dass auch bei der Verwendung von AdoptValues() die ObjectRowIDs der UNTER-Objekte erhalten bleiben. AdoptMode Der Adopt-Mode beschreibt die Art und Weise, wie die Methode AdoptValues() bzw. Clone() arbeiten soll. Es gibt folgende Möglichkeiten: AdoptMode.Deep Das ist das Standard-Verhalten, wenn der Parameter nicht angegeben ist. Es wird eine Tiefen-Kopie erstellt. Das bedeutet, dass alle Unter-Objekte mit Clone() kopiert werden. AdoptMode.Flat Es wird eine flache Kopie erstellt. Dabei werden nur die direkt in der Component vorhandenen Properties übernommen. Die Unter-Objekte werden nicht kopiert, sondern als Referenz übernommen. Beispiel: // führt die Tiefen-Kopie durch. oCompAdopted.AdoptValues(oComp, AdoptMode.Deep); // analog zu: oCompAdopted.AdoptValues(oComp); // führt eine flache Kopie durch. oCompAdopted.AdoptValues(oComp, AdoptMode.Flat); Dasselbe funktioniert auch für den Clone() : // führt die Tiefen-Kopie durch. oCompCloned = oComp.Clone(AdoptMode.Flat) AdoptDictionary Clone bzw. AdoptValues erkennen bei der rekursiven Verarbeitung der Unter-Objekte identische Instanzen. Die Kopien der Components beinhalten an diesen Stellen wieder identische Instanzen. Das löst auch Probleme, wenn Objekte Zirkelbezüge haben. Dafür wird bei der Routine ein Dictionary verwendet, in dem gespeichert wird, welches Ursprungs-Objekt zu welcher Kopie zegordnet ist. Genau genommen wird die RuntimeID des Ursprungs-Objektes gespeichert. Deklaration der Klasse AdoptDictionary: public class AdoptDictionary : Dictionary<long, IDevFrameworkBaseObject> Dieser Mechanismus kann auch ganz geziehlt eingesetzt werden, um schon vor dem Aufruf der Methode AdoptValues festzulegen, welche Objekte als Kopien - oder besser noch anstatt von neuen Kopien - verwendet werden sollen. Für die Methode AdoptValues gibt es eine Überladung, in der auch ein bereits gefülltes AdoptDictionary übergeben werden kann: public void AdoptValues(IDevFrameworkBaseObject, AdoptDictionary) Um das Arbeiten mit diesem Dictionary zu erleichern, gibt es zusätzlich zu den Dictionary-Membern weitere Methoden: public void AdoptInstance(IDevFrameworkBaseObject comp) Es wird das Objekt übergeben, welches nicht kopiert, sondern direkt übernommen werden soll. adoptDict.AdoptInstance(oComp.oUnterObjekt); public void UseInstance(IDevFrameworkBaseObject comp, IDevFrameworkBaseObject sourceComp) Das im Parameter comp übergebene Objekt soll verwendet werden. Der Parameter sourceComp gibt das Objekt in der Quell-Struktur an. Anders formuliert: wenn das in sourceComp übergebene Objekt kopiert werden soll, wird stattdessen das in comp übergebene Objekt verwendet. adoptDict.UseInstance(oCompNew.oUnterObjekt, oComp.oUnterObjekt); Ein Beispiel: Beim Adopten soll die Instanz eines Unter-Objektes direkt übernommen werden. IcdComponent oCompAdopted = cdComponentFactory.Create(this.Global); AdoptDictionary adoptDict = new AdoptDictionary(); adoptDict.AdoptInstance(oComp.oUnterObjekt); // identisch mit: // adoptDict[oComp.oUnterObjekt.RuntimeID] = oComp.oUnterObjekt; oCompAdopted.AdoptValues(oComp, adoptDict); In einem weiteren Beispiel soll das Unter-Objekt am Ziel erhalten bleiben: IcdComponent oCompAdopted = cdComponentFactory.Create(this.Global); AdoptDictionary adoptDict = new AdoptDictionary(); adoptDict.UseInstance(oCompAdopted.oUnterObjekt, oComp.oUnterObjekt); // identisch mit: // adoptDict[oComp.oUnterObjekt.RuntimeID] = oCompAdopted.oUnterObjekt; oCompAdopted.AdoptValues(oComp, adoptDict); Das Unter-Objekt wird jeweils mit all seinen Unter-Objekten übernommen. ABER: wenn es sich dabei um ein Objekt handelt, welches ebenfalls vom Haupt-Objekt referenziert wird, dann wird dieses trotzdem kopiert. Beispiel: oComp (RuntimeID 1) oUnterObjekt (RuntimeID 2) oArtikel (RuntimeID 3) oKunde (RuntimeID 4) oArtikel (RuntimeID 3 - dieselbe wie oben) Das führt dann dazu, dass sich in der neuen Objekt-Struktur 2 verschiedene Instanzen des ursprünglich gleichen Objektes wiederfinden. oCompAdopted (RuntimeID 11) oUnterObjekt (RuntimeID 2 - aus Quelle übernommen) oArtikel (RuntimeID 3 - auch die Unter-Objekte) oKunde (RuntimeID 4) oArtikel (RuntimeID 12 - Kopie von Objekt 3) Wenn dieses Verhalten unterbunden werden soll, dann muss im Vorfeld auch das oArtikel in das Dictionary gepackt werden: adoptDict.AdoptInstance(oComp.oUnterObjekt); adoptDict.AdoptInstance(oComp.oArtikel); AdoptValues überschreiben In speziellen Fällen kann es Sinn machen, die Methode AdoptValues zu überschreiben, um gezielt eigene Aktionen durchzuführen oder sogar die von FrameworkStudio generierte Logik zu ersetzen. Warning Diese Methode sollte nur durch fortgeschrittene Entwickler in Ausnahmefällen überschrieben werden. Deklaration der Methode: public override void AdoptValues(DevFrameworkBaseObject fromComponent, AdoptDictionary dict, AdoptMode mode) Parameter: fromComponent: Die Component, deren Werte übernommen werden sollen. dict: Das Adopt-Dictionary, welches zur Erkennung identischer Instanzen währen dem AdoptValues-Vorgang dient. mode: AdoptMode.Flat oder AdoptMode.Deep. Alle Aufrufe von AdoptValues und Clone landen in dieser zentralen Methode. Hier können Sie abhängig von den Parametern eigene Aktionen durchführen. In der Praxis könnten Sie z.B. dafür sorgen, dass beim Aufruf einer flachen Kopie, ein besimmtes Unter-Objekt, welches immer zusammen mit dem Haupt-Objekt gespeichert wird, trotzdem kopiert wird. public override void AdoptValues(DevFrameworkBaseObject fromComponent, AdoptDictionary dict, AdoptMode mode) { base.AdoptValues(fromComponent, dict, mode) if (mode == AdoptMode.Flat) { this.oUnterObjekt = (cdObjekt)this.oUnterObjekt.Clone(dict); } }"
  },
  "doc/weitere-themen/connection-einstellungen.html": {
    "href": "doc/weitere-themen/connection-einstellungen.html",
    "title": "Connection Einstellungen",
    "keywords": "Connection Einstellungen Connection-Type Gibt an, mit was für einer Datendank (SQL-Server oder Oracle) gearbeitet werden soll. SQL-Server Oracle Managed Oracle ODP Server / Database Entsprechen bei Sql-Server dem Servername und dem Initial Catalog. Für den Connect auf eine Oracle Datenbank baut Framework Studio aus Server und Database einen TNS-String auf. Bei Server wird der Name des Servers angegeben. Mit einem Komma getrennt kann der Port angegeben werden, z.B. „192.168.0.120,1520“. Wenn kein Port angegeben wird, dann wird der Standard-Port 1521 verwendet. Bei Database wird der Name der Instanz (SID) angeben. Der TNS-String hat das folgende Format: (DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP) (HOST=<Server>)(PORT=<Server-Port>)))(CONNECT_DATA=(SID=<Database>) (SERVER=DEDICATED))) Wird kein Server angegeben, dann erzeugt Framework Studio keinen TNS-String sonder verwendet Database direkt als DataSource . So kann man einen in der tnsnames.ora konfigurierten TNS-Alias bei Database angeben. Es ist auch möglich, bei Database einen kompletten TNS-String anzugeben – das sollte aber möglichst vermieden werden. DB Username / DB Password Wird bei SQL-Server kein Username angegeben, erfolgt die Anmeldung per Windows Authentication. Die folgenden Einstellungen stehen nicht überall zur Verfügung. Use AnsiString Gibt an, ob die Datenbank im Ansi-Modus angesprochen werden soll. Das wirkt sich auf die Abfrage-Parameter aus. Warning Ist diese Haken gesetzt, werden in Abfrage-Parametern keine Unicode-Daten unterstützt. FSPooling – Activate Aktiviert ein von Framework Studio gesteuertes Connection-Pooling. Eine mit Framework Studio entwickelte Anwendung benötigt eine Datenbankverbindung, um mit dem zugehörigen Broker zu kommunizieren. Bei jedem Request wird eine Verbindung aufgebaut und danach wieder geschlossen. Da dieses Verhalten vor allem auf Oracle-Datenbankservern sehr viel Zeit in Anspruch nimmt, kann vom Broker eine bestimmte Anzahl an offenen Datenbankverbindungen vorgehalten werden, auf die die Anwendung zurückgreifen kann. Sollten vorgehaltene Verbindungen unterbrochen werden, werden diese automatisch wieder aufgebaut FSPooling – Min Minimale Anzahl an Connections, die dauerhaft aufrecht erhalten werden. FSPooling – Max: Maximale Anzahl an Connections im Pool. Wenn diese Anzahl erreicht ist, werden weitere Connections nach der Verwendung wieder sofort geschlossen. FSPooling – Timeout Zeit (in Sekunden), nach der eine Connection geschlossen werden soll, wenn sie nicht benutzt wurde Intern arbeitet Framework Studio mit einem Connection String . Dieser wird auch in einigen Konfigurations-Dateien gespeichert. Im Folgenden sind die verfügbaren Parameter beschrieben. FSProviderType Folgende Werte sind möglich: SqlServer OracleManaged Oracle (entpsricht dem Connection-Type Oracle ODP) Server (siehe oben) Database (siehe oben) UserID Entspricht dem Username (siehe oben) Password (siehe oben) PasswordEncrypted Das verschlüsselte Passwort. Speichert Framework Studio einen Connection-String – z.B. in Konfigurations-Dateien – dann wird das Passwort in diesem Parameter verschlüsselt gespeichert. FSUseAnsiString (siehe oben) FSPoolingMin (siehe oben) – ist dieser Parameter angegeben, dann wird das Connection-Pooling aktiviert. FSPoolingMax (siehe oben) FSPoolingTimeout (siehe oben) FSPoolingDebugOutput (siehe Kapitel Connection Pooling Protokoll ) Weitere Parameter Die von Framework Studio nicht erkannt werden, werden direkt in den nativen Connection-String übernommen. So können auch native Features der jeweiligen Datenbank genutzt werden."
  },
  "doc/weitere-themen/connection-pooling-protokoll.html": {
    "href": "doc/weitere-themen/connection-pooling-protokoll.html",
    "title": "Connection Pooling Protokoll",
    "keywords": "Connection Pooling Protokoll Das Connection-Pooling bietet die Möglichkeit, die Aktionen in einer Datei zu protokollieren. Damit können Probleme besser analysiert werden. Diese Protokollierung sollte nur vorrübergend eingesetzt werden, weil dadurch sehr große Datenmengen produziert werden - vor allem auf Broker mit hoher Last. Um die Protokollierung für das Connection-Pooling zu aktivieren, muss im ConnectionString die Eigenschaft FSPoolingDebugOutput ergänzt werden. Dies muss manuell nach dem Publish der Applikation erfolgen, weil diese Eigenschaft nicht im Publish-Dialog konfiguriert werden kann. Diese Angabe kann sowohl für die Runtime-Connection als auch für die Business -Connections gemacht werden. Beispiel für die Runtime-Connection: <RuntimeDB ConnectionType=\"Oracle\" ConnectionString=\"Data Source=ORCLNV270;User ID=FSD35; Password=FSD35;Persist Security Info=False; Pooling=False; FSPoolingMin=5; FSPoolingMax=15; FSPoolingTimeout=60; FSPoolingDebugOutput=C:\\temp\\FSPool.txt; FSUseAnsiString=False\" /> Informationen zur Protokollierung 2012-05-18 20:37:01.449 PID=9976 1;DB=DEV01.sysadm Used 0 Free 0 #025EE953 CREATE Connection 1 2012-05-18 20:37:01.454 PID=9976 1;DB=DEV01.sysadm Used 1 Free 0 #025EE953 GET Connection 1 2012-05-18 20:37:17.991 PID=9976 1;DB=DEV01.sysadm Used 0 Free 1 #025EE953 FREE Connection 1 Eine Protokoll-Zeile beinhaltet die folgenden Felder: Datum/Uhrzeit PID - Prozess-ID. Wichtig, wenn auf einem Rechner mehrere Anwendungen laufen, die in dieselbe Datei protokollieren Pool-Information: eindeutige Nummer des Pools im Prozess; Datenbank Used: Anzahl der gerade verwendeten Connections Free: Anzahl der freien Connections im Pool #xxxxxxxx: Eindeutige ID der Connection. Dabei handelt es sich um den HashCode des Connection-Objektes. Dieser kann dazu verwendet werden, die Aktionen einer Connection sauber zuzuordnen. Aktion mit Connection-Nummer. Diese Nummer ist innerhalb des Pools eindeutig. Über diese Nummer können die Aktionen einander sauber zugeorndet werden und so z.B. analysiert werden, ob es zu einem \"GET Connection\" auch ein passendes \"FREE Connection\" oder \"DESTROY Connection\" gibt. CREATE Connection 1: Eine Connection wird erzeugt. Die Information \"Free\" hängt hinterher, weil die Connection erst nach dieser Aktion in den Pool gepackt wird. GET Connection 1: Eine Connection wird verwendet. Wenn im Pool keine Connection zur Verfügung steht, dann wird direkt im Vorfeld eine neue Connection geöffnet (CREATE Connection) FREE Connection 1: Die Connection wird wieder freigegeben und steht dem Pool wieder zur Verfügung. Wenn DESTROY Connection 1: Die Connection wird beendet. Das passiert, wenn bei der Aktion FREE Connection die Anzahl der offenen Connection FSPoolingMax übersteigt, oder wenn bei einer Aktion (GET Connection oder FREE Connection) der Timeout einer freien Connection erreicht ist. DISPOSE POOL: Der Pool wird geleert. Das passiert, wenn der Broker beendet wird, oder wenn die letzte Broker-Sitzung beendet wird. Wenn bei dieser Aktion noch Connections in Verwendung sind (Used), dann wird für diese Connections der Callstack ausgegeben, mit dem sie verwendet wurden. So kann analysiert werden, wer eine Connection öffnet, sie aber nicht freigibt. Diese Connections werden nicht vom Pool geschlossen. Mit dieser Aktion wird der komplette Pool zurückgesetzt. Die Informationen \"Used\" und \"Free\" beginnen wieder bei 0. Das ist auch der Fall, wenn zuvor noch Connections geöffnet waren. ESCALATION OF USED CONNECTIONS: Wenn die Anzahl der benutzten Connctions im Pool 30 übersteigt, dann werden einmalig pro Pool die momentan benutzten Connections mit den Callstacks, durch die sie geöffnet wurden, ausgegeben. Die einzelnen Felder sind mit Tabulator getrennt. So können Sie diese Daten sehr gut z.B. in Excel kopieren und weiter analysieren. Auf einem Rechner können mehrere Prozesse in dasselbe Protokoll schreiben, die Routine ist entsprechend abgesichert. Die Absicherung funktioniert NICHT auf Netzlaufwerken für mehrere Rechner!"
  },
  "doc/weitere-themen/fehlercodes-warnungen.html": {
    "href": "doc/weitere-themen/fehlercodes-warnungen.html",
    "title": "Fehlercodes Warnungen",
    "keywords": "Fehlercodes Warnungen Bei der Erzeugung des Quellcodes prüft FrameworkStudio viele Sachverhalte. Nicht alle Konflikte haben so gravierende Auswirkungen dass der Vorgang komplett abgebrochen werden muss. Diese Konflikte werden als Warnungen in den Quellcode generiert und beim Kompilieren ausgegeben. Warnings Die von Framework Studio erzeugten Warnungen sind mit Codes versehen. Diese Codes können Sie in den folgenden Abschnitten nachlesen. FSWarn[2001] FSWarn[2003] The identifier '{0}' is too long for Oralce Database (maximum 30 characters) Es wurde ein Bezeichner verwendet, der zu lang für Oracle ist. In Oracle dürfen Bezeichner nicht länger als 30 Zeichen sein. Die folgenden Bezeichner werden überprüft: Tabellen-Namen Index-Namen Spalten-Namen Spalten-Aliase in Component-Queries Tabellen-Aliase in Component-Queries FS prüft bei der Code-Generierung ob es Bezeichner gibt, die länger als 30 Zeichen sind und produziert entsprechende Warnungen. Es sind keine Errors, denn es kann durchaus mal vorkommen, dass z.B. bestehende Datenstrukturen einer SQL-Datenbank verwendet werden, die längere Namen enthält. FSWarn[2002] FSWarn[2002] The identitifier '{0}' is an keyword in Oracle Database Es wurde ein Bezeichner verwendet, der ein Schlüsselwort in Oracle ist. Die folgenden Bezeichner werden überprüft: Tabellen-Namen Index-Namen Spalten-Namen Spalten-Aliase in Component-Queries Tabellen-Aliase in Component-Queries Es ist bewusst nicht als #error gelöst, da es in SQL-Server umgeben durchaus existierende Datenstrukturen geben kann, bei denen so ein Oracle-Keyword verwendet wird. Die folgenden Schlüsselworte werden geprüft: ACCESS, ADD, ALL, ALTER, AND, ANY, AS, ASC, AUDIT, BETWEEN, BY, CHAR, CHECK, CLUSTER, COLUMN, COMMENT, COMPRESS, CONNECT, CREATE, CURRENT, DATE, DECIMAL, DEFAULT, DELETE, DESC, DISTINCT, DROP, ELSE, EXCLUSIVE, EXISTS, FILE, FLOAT, FOR, FROM, GRANT, GROUP, HAVING, IDENTIFIED, IMMEDIATE, IN, INCREMENT, INDEX, INITIAL, INSERT, INTEGER, INTERSECT, INTO, IS, LEVEL, LIKE, LOCK, LONG, MAXEXTENTS, MINUS, MLSLABEL, MODE, MODIFY, NOAUDIT, NOCOMPRESS, NOT, NOWAIT, NULL, NUMBER, OF, OFFLINE, ON, ONLINE, OPTION, OR, ORDER, PCTFREE, PRIOR, PRIVILEGES, PUBLIC, RAW, RENAME, RESOURCE, REVOKE, ROW, ROWID, ROWNUM, ROWS, SELECT, SESSION, SET, SHARE, SIZE, SMALLINT, START, SUCCESSFUL, SYNONYM, SYSDATE, TABLE, THEN, TO, TRIGGER, UID, UNION, UNIQUE, UPDATE, USER, VALIDATE, VALUES, VARCHAR, VARCHAR2, VIEW, WHENEVER, WHERE, WITH FSWarn[2006] FSWarn[2006] the databinding '{0}' mustn't be changed in a customisation or derivative (Form:{1} Control:{2}). Please reset the property. {Form:{3};CTRLT:{4}} Wenn man ein Form customized oder ableitet, dann dürfen an Controls die Datasources nicht verändert werden. Es gibt einige Ausnahmen An Comboboxen kann eine andere Liste definiert werden. An Grids kann nachträglich eine Collection zugeordnet werden, wenn in der Basis-Klasse noch keine Zuordnung existiert FSWarn[2007] FSWarn[2007] Form '{1}' Control '{0}' is marked as search field and is mapped with an IsMLColumn property. The autogenerated load command will only find strings in default language! {Form:{2};CTRLT:{3}} Man kann Datenbank-Spalten als Multilanguage definieren. Wenn in einem Form ein Control als Suchfeld definiert wird, das so eine Spalte anzeigt, dann wird diese Warnung generiert. Die fremdsprachigen Texte werden in einer zentralen Tabelle abgelegt, deren Inhalt ausschließlich über den Primär-Schlüssel eines Datensatzes angesprochen wird. Somit kann in diesen Texten nicht nach Inhalten recherchiert werden. Wenn mehrere Packages nachträglich übereinandergelegt werden, kann es passieren, dass diese Warnung erst beim Kompilieren des eingeschobenen Packages ausgegeben wird. Das ist dann der Fall, wenn in dem eingeschobenen Package die Datenbank-Spalte customized und als „IsMLColumn“ definiert wird. FSWarn[2008] FSWarn[2008] ReportDocumentType '{0}': The field '{1}.{2}' expects type '{3}' ('{4}'). The report uses type '{5}'. Please correct report '{6}' or the report datasource! Beim Kompilieren der Reports überprüft Framework Studio ob die definierte Schnittstelle mit der in der Crystal-Reports-Datei bekannten Schnittstelle übereinstimmt. In diesem Fall hat ein Property einen anderen Datentyp als in der Schnittstelle in der Report-Datei. Dass kann dazu führen, dass Daten im Report nicht korrekt verarbeitet werden. Um das zu beheben muss die Schnittstelle in der Report-Datei aktualisiert werden. FSWarn[2009] FSWarn[2009] ReportDocumentType '{0}' doesn't contain the field '{1}.{2}'. Please correct report '{4}' or the report datasource! Beim Kompilieren der Reports überprüft Framework Studio ob die definierte Schnittstelle mit der in der Crystal-Reports-Datei bekannten Schnittstelle übereinstimmt. In diesem Fall ist ein der Schnittstelle ein Feld definiert, dass in der Report-Datei nicht bekannt ist. Um das zu beheben muss die Schnittstelle in der Report-Datei aktualisiert werden. FSWarn[2010] FSWarn[2010] ReportDocumentType '{0}' doesn't contain table '{1}'. Please correct report '{2}' or the report datasource! Beim Kompilieren der Reports überprüft Framework Studio ob die definierte Schnittstelle mit der in der Crystal-Reports-Datei bekannten Schnittstelle übereinstimmt. In diesem Fall ist in der Schnittstelle eine Tabelle definiert, die in der Report-Datei nicht bekannt ist. Um das zu beheben muss die Schnittstelle in der Report-Datei aktualisiert werden. FSWarn[2011] FSWarn[2011] ReportDocumentType '{0}': Error occured during report validation: {1} Beim Kompilieren der Reports überprüft Framework Studio ob die definierte Schnittstelle mit der in der Crystal-Reports-Datei bekannten Schnittstelle übereinstimmt. In diesem Fall ist bei der Überprüfung ein Fehler aufgetreten. Mögliche Gründe: Die Report-Datei ist ungültig Die CrytsalReports-Runtime ist nicht oder nicht richtig installiert. FSWarn[2012] FSWarn[2012] ReportDocumentType '{0}': Report '{1}' uses a filepath. Please correct the report (Start CrystalReports and open the dialog Database|'Set Datasource Location' and choose the file again. Clear the file path before finish.). Im Report ist die XSD-Datei, welche die Schnittstelle beschreibt mit einem ungültigen Pfad angegeben. Wenn man im Report eine XSD-Datei anspricht, dann muss darauf geachtet werden, dass diese Datei ohne Pfadangeben – also nur mit dem Dateinamen angesprochen wird. Andernfalls kann es dazu kommen, dass der Report in einer anderen Umgebung mit einer anderen Ordner-Struktur nicht funktioniert. FSWarn[2013] FSWarn[2013] The checked property '{0}.{1}' of report '{2}' was ignored because of its PropertyType(Membervariable) Properties mit dem Typ Membervariable können nicht in Report-Schnittstellen verwendet werden. FrameworkStudio ignoriert solche Angaben. Bei der Definition von Datasources sind Properties mit dem Typ Membervariable nicht sichtbar. Es kann aber vorkommen, dass durch eine nachträgliche Änderung des Typs so eine Situation entsteht, wenn dieses Property zuvor schon in einem Report verwendet wurde. Um diese Warnung zu beheben gehen Sie folgendermaßen vor: In der Component das Property vorübergehend auf „Generated“ stellen. Jetzt ist dieses Property im Datasource der Report-Schnittstelle sichtbar. Ggf. muss im ReportDocumentType noch der Refresh-Button gedrückt werden. Den Haken entfernen In der Component das Property wieder auf „Membervariable“ stellen. Es kann aber auch sein, dass ein Property irrtümlich auf Membervariable gesetzt wurde. In diesem Fall muss nur das Property korrigiert werden und der Report wird es nach einem erneuten Compile verwenden. Der Report muss dazu ausgecheckt werden oder ohne SavedCode kompiliert werden. FSWarn[2014] FSWarn[2014] Please add a service contract to service {0}. Existiert für einen Service kein Service Contract oder ist dem Service kein Service Contract zugeordnet, wird diese Warning generiert, da ein Service ohne Contract keinen Sinn macht. FSWarn[2015] FSWarn[2015] A service proxy only can use a service host of the same package. If you want to use the customized service host '{0}' in the service proxy '{1}' from an other package, please customize this service. Ein Service Proxy muss aus dem gleichen Package stammen wie der zugehörige Service Host. Wenn der Service Host gecustomized ist, muss auch der zugehörige Service Proxy gecustomized werden. FSWarn[2016] FSWarn[2016] The Order IDs are not unique. Please check the tab pages of control '{0}'. {Form:{1};CTRLT:{2}} Wenn in einem TabbedWindow Control mehrere Seiten die gleiche OrderID festgelegt haben, wird die Reihenfolge zufällig erstellt. FSWarn[2017] FSWarn[2017] The index '{1}' in textcollection '{0}' is used more than once. Indices in TextCollections werden als Schlüssel verwendet und sollten deshalb einzigartig sein. FSWarn[2018] FSWarn[2018] Template '{0}' used in form '{1}'. Templates are obsolete and will not be supported in future releases. Templates werden in FS nicht mehr unterstützt und sollten deshalb entfernt werden. FSWarn[2019] FSWarn[2019] The grid column '{0}' in grid '{1}' has a list set but doesn't use the combobox editor. Wenn in einer Grid-Spalte eine Liste als Datenquelle angegeben ist, sollte der EditorStyle auf ComboBox gesetzt werden, um die definierte Liste auch anzeigen zu können. FSWarn[2020] FSWarn[2020] A column with type boolean doesn't send an OnCellValidate event, but the column '{0}' at grid '{1}' on form '{2}' has defined a handler. Wenn an einer Grid-Spalte ein OnCellValidate-EventHandler hängt und der Datentyp der Spalte anschließend auf boolean umgestellt wird, wird das OnCellValidate-Event nicht mehr gefeuert und der Handler ist somit hinfällig. FSWarn[2021] FSWarn[2021] The property '{0}' is no longer accessible. Please change the properties access level to public or call 'Edit / Clean Up Datasources' in ReportDocumentType '{1}' ReportDocumentTypes greifen auf Properties von Components zu. Wird dort ein Property z.B. von public auf private gesetzt, kann der ReportDocumentType nicht mehr auf diese Eigenschaft zugreifen und sollte über die Funktion ‚'Edit / Clean Up Datasources ‘ aktualisiert werden. FSWarn[2022] FSWarn[2022] Some parameters of Link '{0}' in Workflow '{1}' have to be corrected. Please call 'Correct workflow link parameters' in Maintenance Mode. Die Identifizierung der Link-Parameter wurde geändert und es sollte auf jedem Link die 'Correct workflow link parameters‘-Funktion ausgeführt werden. Sollte dies nicht der Fall sein, wird diese Warnung generiert. FSWarn[2023] FSWarn[2023] The column '{0}' is used more than one time in the query of component '{1}'. Es führt zu Problemen, wenn auf Components ein Insert ausgeführt wird, welche eine Spalte mehrmals in der Abfrage ausgewählt haben. FSWarn[2024] FSWarn[2024] The event '{0}' of workflow '{1}' will never be fired, but it is used by link '{2}' in workflow '{3}'! Make sure that this event is fired by a form or global event inside workflow '{1}'. Wenn innerhalb eines Workflows von einer Forminstanz ein Link auf eine Workflowinstanz zeigt und ein Event der Forminstanz als Quelle nutzt, dieses seitens des Forms oder eines Global Events aber nie gefeuert wird, wird diese Warnung generiert. FSWarn[2025] FSWarn[2025] Shortcut '{0}' is assigned to more than one control of this form ({1}). Wenn in einem Form der gleiche Shortcut an mehreren Controls hinterlegt ist, wird diese Warnung generiert. FS würde ein Control zufällig wählen (unvorhersehbar) und die anderen Shourtcuts nicht ausführen. FSWarn[2026] FSWarn[2026] The settings 'IsDragAllowed = false' and 'DropAllowedFrom = {0}' at tree '{1}' on form '{2}' are competing. Wenn z.B. ‘DropAllowedFrom’ auf ‘ThisTreeView’ gesetzt ist, macht dies nur Sinn wenn dann auch ‘IsDragAllowed’ auf ‚true‘ gesetzt wird, da sonst Drag&Drop nicht in diesem TreeView funktionieren kann. FSWarn[2027] FSWarn[2027] Avoid to use default shortcuts CtrlA, CtrlC, CtrlX, CtrlV ({0} used in {1}). Wenn Sie einem Control einen der Standard Shortcuts Strg-A, Strg-C, Strg-X oder Strg-V zuordnen, wird diese Warnung generiert. Diese Shortcuts sollten nicht verwendet werden, da sie von Windows aus schon mit Funktionen wie z.B. Kopieren und Einfügen belegt sind. FSWarn[2029] FSWarn[2029] Method Observer: One or more base methods of '{0}' have been changed. Wenn eine Methode durch den Methoden-Wächter überwacht wird und sich eine oder mehrere Basismethoden dieser Methode geändert haben, wird diese Warnung generiert. FSWarn[2036] FSWarn[2036] Aliases of query columns have to be unique. Duplicate alias:'{0}' Wenn bei den Spalten in einer Component-Query mehrdeutige Aliase vergeben werden, dann können die Spalten nicht mehr eindeutig angesprochen werden. Dies führt zu Fehlern beim Einlesen von Daten aus der Datenbank. In der Regel wird von Framework Studio automatisch ein korrekter Alias vergeben, der sich am Namen der Datenbank-Spalte orientiert. Bei manuell erstellten Queries, insbesondere bei Joins, kann es passieren, dass derselbe Spalten-Name mehrfach vorkommt. In diesem Fall muss manuell ein eindeutiger Name vergeben werden. FSWarn[2038] FSWarn[2038] SortOrder of query columns have to be unique. Duplicate SortOrder: '{0}'. Wenn bei den Spalten in einer Component-Query mehrdeutige SortOrders vergeben werden, dann können die Spalten nicht mehr eindeutig angesprochen werden. Dies führt zu Fehlern beim Einlesen von Daten aus der Datenbank. FSWarn[2039] FSWarn[2039] DeprecatedLayout. Please convert the layout. Das aktuelle Form arbeitet mit dem ‚alten‘ Layout und wurde mit dem Migrationsassistent noch nicht in das dynamische Layout konvertiert. FSWarn[2040] FSWarn[2040] Form '{0}' uses more than one container control as its root control ({1}). FSWarn[2041] FSWarn[2041] RadioButton '{2}' requires a ButtonGroupDataSource at {0} '{1}'. Wenn an dem Container eines RadioButtons kein ButtonGroupDataSOurce hinterlegt ist, kann nicht entschieden werden, wann der Radiobutton aktiv ist. Errors Im Gegensatz zu Warnings sind seitens FS generierte Errors beim Kompilieren so schwerwiegend, dass der Vorgang abgebrochen werden muss. Auch Errors sind durchnummeriert und können im Folgenden nachgelesen werden. FSErr[1000] FSErr[1000] Service property must be set. FSErr[1001] FSErr[1001] 'internal virtual' and 'protected internal virtual' is not allowed in Framework Studio: {0} FSErr[1002] FSErr[1002] Property {0} has as mapping a database column without output! FSErr[1003] FSErr[1003] None DBConnection defined! FSErr[1004] FSErr[1004] dbcolumn name '{0}' of property '{1}' is to long. Only 28 characters are allowed for pk columns. FSErr[1005] FSErr[1005] Datatype of DBColumn {0}.{1}.{2} (property '{3}') is not valid. FSErr[1006] FSErr[1006] Update/Delete could not be generated because not all primary keys of table '{0}' are known as properties of this component! FSErr[1008] FSErr[1008] Update/Delete could not be generated because the rowid column of table '{0}' is not known as property of this component! FSErr[1010] FSErr[1010] RowID or RowVersion is for oracle oledb connection not allowed. Please change the datasource to oracle connection! FSErr[1011] FSErr[1011] Update/Delete could not be generated because the rowversion column of table '{0}' is not known as property of this component! FSErr[1013] FSErr[1013] Update/Delete not possible because no primary keys are published for the main table. FSErr[1015] FSErr[1015] Property '{0}' has a invalid name. {0} is a reserved keyword in c#! {Component:{1} ;Property:{2}} FSErr[1016] FSErr[1016] Property {0} is mapped with a deleted dbcolumn! FSErr[1017] FSErr[1017] PropertyTypeRecord.Relation could only be defined for components and collections. FSErr[1018] FSErr[1018] Relations: Compareoperator {0} is not supported yet! FSErr[1019] FSErr[1019] Invalid character '{0}' in identifier '{1}'. FSErr[1020] FSErr[1020] You have to use a metadatatype as datatype of property '{0}'. FSErr[1021] FSErr[1021] Multi-Language properties can be defined only with existing database columns. Please correct {0} FSErr[1022] FSErr[1022] FatalError: CustomizationBase is null in customization! FSErr[1023] FSErr[1023] FatalError: Base is null in derivative! FSErr[1024] FSErr[1024] Property '{0}' has no database mapping. Load Condition can't be generated! FSErr[1025] FSErr[1025] {0} (Individual Consistency Message). FSErr[1026] FSErr[1026] Invalid type '{0}' at '{1}' FSErr[1027] FSErr[1027] Please assign a connection group for connection '{0}'. FSErr[1028] FSErr[1028] Columns can be defined as multi-language only if the primary keys of the table are set! FSErr[1029] FSErr[1029] Mapped Property of column '{0}'.'{1}' is not available. Probably it has been deleted! FSErr[1030] FSErr[1030] EditStyle '{0}' requires string as datatype of the value property! FSErr[1031] FSErr[1031] {0}: Choosen Format {1} mustn't be used with datatype '{2}' FSErr[1032] FSErr[1032] Private or internal membervariables or properties mustn’t be mapped to a list as datasource. Control:{0}; Datasource:{1}; {Form:{2}; CTRLT:{3}} FSErr[1033] FSErr[1033] The control {0} has been moved in customization base. Please call check out at the form {1} to adjust. FSErr[1034] FSErr[1034] Private member variables mustn’t be used as datasource of control {0}.{1}; Datasource: {2} FSErr[1035] FSErr[1035] ActionWrapperClassName not found! FSErr[1036] FSErr[1036] Datatype of property '{0}' could not be loaded!. Possibly a used component or metadatatype is recreated by another user and not checked in. FSErr[1037] FSErr[1037] format at column \"{0}\" doesn't matches to the datatype \"{1}\" FSErr[1038] FSErr[1038] The tranformation must have at least one input parameter and the output parameter cannot be void. FSErr[1039] FSErr[1039] FormatPattern should not be 'c' FSErr[1040] FSErr[1040] Please define a datasource for the report! FSErr[1041] FSErr[1041] Autogenerated service contracts mustn't be derived! FSErr[1042] FSErr[1042] Incorrect format of {0} in {1}. The format have to be like '{2}' FSErr[1043] FSErr[1043] Service Contract '{0}' have to be a derivative of '{1}' FSErr[1044] FSErr[1044] Service Proxy '{0}' hasn't an Endpoint. Please execute 'Generate Proxy' FSErr[1045] FSErr[1045] A valid external or internal service must be defined for the Service Proxy '{0}' FSErr[1046] FSErr[1046] Could not determine SourceEvent! FSErr[1047] FSErr[1047] Please customize the workflow '{0}', because the base workflow '{1}' is customized in this package! FSErr[1049] FSErr[1049] Some parameters of Link '{0}' in Workflow '{1}' have to be corrected. Please call 'Correct workflow link parameters' in Maintenance Mode FSErr[1050] FSErr[1050] The interface '{0}' and the component '{1}' are not in the same namespace. Please check out the component to correct the namespace. FSErr[1051] FSErr[1051] The HasChild binding at node '{0}' must use a bool property. FSErr[1052] FSErr[1052] The datatype of the used property for the display member '{0}' at treenode '{1}' from tree '{2}' on form '{3}' is invalid FSErr[1053] FSErr[1053] The value member of the list datasource '{2}' in grid '{0}' at column '{1}' is not set. FSErr[1054] FSErr[1054] The display member of the list datasource '{2}' in grid '{0}' at column '{1}' is not set. FSErr[1055] FSErr[1055] Index names mustn't be empty. FSErr[1056] FSErr[1056] Multiple indices with the same name '{0}'. FSErr[1057] FSErr[1057] The index has the same columns like index '{0}'. FSErr[1058] FSErr[1058] The index contains no columns. FSErr[1059] FSErr[1059] Index names must start with a letter or an underscore and must continue with letters, underscores or numbers. FSErr[1060] FSErr[1060] Method has to be virtual. FSErr[1061] FSErr[1061] Since the transformation is a customization, this method has to be overridden. FSErr[1062] FSErr[1062] Property '{0}' is readonly and cannot be marked as [DataMember]. FSErr[1063] FSErr[1063] No parent access unit has been assigned to access unit '{0}'. Please check out form '{1}' to reassign a parent access unit. FSErr[1064] FSErr[1064] No view definition has been specified. FSErr[1065] FSErr[1065] Error in view select statement (details see following comment) / 0 / FSErr[1066] FSErr[1066] No valid select statement has been specified. FSErr[1067] FSErr[1067] Some DBTable Columns are missing in view select statement: {0}. FSErr[1068] FSErr[1068] It is required to define an alias for column {0} in view select. FSErr[1069] FSErr[1069] Asterisk Expression (*) is not allowed in view select. FSErr[1070] FSErr[1070] Ivalid object reference: {0} FSErr[1071] FSErr[1071] Table names must be unique ignoring case. Table '{0}' found more than once. FSErr[1072] FSErr[1072] Property '{0}' does not exist on component '{1}'. Wenn an einem Global Objects die Checkbox Redirect to ocGlobal gesetzt ist, dann erwartet Framework Studio in der Component FSGeneral.cGlobal ein gleichnamiges Property. Dieser Fehler wird ausgegeben, wenn so ein Property nicht gefunden wurde. FSErr[1073] FSErr[1073] Property '{0}' type mismatch detected! Expected {1}, given {2}! Wenn an einem Global Objects die Checkbox Redirect to ocGlobal gesetzt ist, dann muss in der Component FSGeneral.ocGlobal das entsprechende Property denselben Typ haben wie das Global Object. Dieser Fehler wird ausgegeben, wenn die Typen abweichen. FSErr[1074] FSErr[1074] Cannot bind property '{0}' to control '{1}' because property type '{2}' is not supported. Der Fehler wird ausgegeben, wenn einem DataSource eines Controls im Form ein Property zugewiesen wurde, dessen Typ nicht geeignet ist. Beispiel: Einem Editfield wurde ein Property vom Typ System.Object zugewiesen. FSErr[1075] FSErr[1075] The customization base of {objectType} '{name}' has been moved from namespace '{source}' to '{target}'. Please call menu Tools / Adjust moved customizations. Im Basis-Package wurde ein Element in einen anderen Namespace verschoben. Im Customizing-Package muss dies über die Routine “Adjust moved customizations” nachgezogen werden. Siehe auch Kapitel Adjust moved customizations . FSErr[176] FSErr[1076] In '{GridName}' the column for property '{PropertyName}' was added twice, in Form '{CurrentForm}' and in Form '{CustomizationBaseOrBaseForm}'. Please remove the column in one of the forms."
  },
  "doc/weitere-themen/framework-studio-exe-config.html": {
    "href": "doc/weitere-themen/framework-studio-exe-config.html",
    "title": "FrameworkStudio.exe.config",
    "keywords": "FrameworkStudio.exe.config Die Datei FrameworkStudio.exe.config liegt im Programmverzeichnis von Framework Studio . In ihr werden Einstellungen für die Anwendung vorgenommen. Bevor Sie mit Framework Studio arbeiten, müssen Sie ggf. die Pfade in dieser Datei an Ihre Installation anpassen. Es folgt eine Beschreibung der Parameter, die Sie in dieser Datei einstellen können. Wie das Ganze in der Datei aussieht, ist im Anschluss dargestellt. DotNet Path Gibt den Pfad an, in dem die .Net-Runtime-Dateien liegen. In der Regel \"C:\\windows\\Microsoft.NET\\Framework\\ v2.0.50727\\\" . ApplicationsDirectory Gibt an, in welchen Ordner die Konfigurationsdateien für die Web-Anwendung abgelegt werden sollen. In der Regel C:\\inetpub\\wwwroot\\Applications . NdocPath Gibt an, in welchem Ordner das Programm NDoc installiert ist. Z.B. C:\\Programme\\NDoc\\bin\\.net-1.1. NdocOutputPath . Gibt den Pfad an, in den die Hilfe-Dateien mit NDoc generiert werden sollen. Z.B. C:\\temp\\NdocOutput . SoundShouldBeep (true, false) Gibt an, ob nach dem Kompilieren ein Signalton ausgegeben werden soll. SoundBeepFrequenze Gibt die Frequenz des Signaltons in Hz an. Z.B. 600. DLLReference Gibt den Ordner mit den Dlls an, die der Compiler benötigt. Nach der Installation ist es hier ggf. notwendig den Pfad anzupassen. CorrectMLStrings Wenn true, dann wird eine Funktion zum Korrigieren der Default-Labels aktiviert. Im Kontext-Menu des Namespaces wird ein weiterer Eintrag \"Correct MLStrings in Components …\" angeboten. Dieses Tool sucht nach Properties von Components, bei denen das Default Label mit demselben Wert überschrieben wurde, wie er im Metadatentypen oder in der DB-Column angegeben ist. Diese Labels werden auf den Standard der Basis gesetzt. Dabei werden die Components ausgecheckt. Components, die nicht ausgecheckt werden können, werden unter \"Errors\" aufgelistet. CompileBaseDirectory Gibt den Pfad an, in dem Compile-Verzeichnisse angelegt werden sollen. Diese Einstellung muss von Hand vorgenommen werden. In den Optionen wird diese Einstellung zwar angezeigt, sie kann dort aber nicht verändert werden, weil diese Einstellung schon beim Start vom Framework Studio verwendet wird. Beispiel: <add key=\"CompileBaseDirectory\" value=\"C:\\FS30\"/> Wenn diese Einstellung nicht angegeben ist, dann werden die Verzeichnisse in das Verzeichnis des Benutzer-Profils erzeugt. DevelopementBrokerBaseDirectory Gibt den Pfad an, in dem die Verzeichnisse für die Development-Broker angelegt werden sollen. Dieser Pfad muss vom CompileBaseDirectory abweichen. Diese Einstellung muss von Hand vorgenommen werden. Beispiel: <add key=\"DevelopementBrokerBaseDirectory\" value=\"C:\\FS30_Broker\"/> Wenn diese Einstellung nicht angegeben ist, dann werden die Broker-Verzeichnisse in das Stamm-Verzeichnis des IIS generiert. z.B. C:\\inetpub\\wwwroot\\FS30\\... Es folgt ein Auszug aus einer Config-Datei: <?xml version=\"1.0\" encoding=\"Windows-1252\"?> <configuration> <appSettings> <add key=\"TempDirectory\" value=\"c:\\Temp\" /> <add key=\"DotNet Path\" value=\"C:\\windows\\Microsoft.NET\\Framework\\v1.1.4322\\\" /> <add key=\"DLLReference\" value=\"C:\\Inetpub\\wwwroot\\BusinessRep\\bin\" /> <add key=\"ApplicationsDirectory\" value=\"C:\\inetpub\\wwwroot\\Applications\" /> <add key=\"NDocPath\" value=\"C:\\Programme\\NDoc\\bin\\.net-1.1\" /> <add key=\"NDocOutputPath\" value=\"C:\\NdocOutput\" /> <add key=\"SoundShouldBeep\" value=\"true\" /> <add key=\"SoundBeepFrequenze\" value=\"600\" /> … </appSettings> … </configuration>"
  },
  "doc/weitere-themen/fsrowid_fsrowversion.html": {
    "href": "doc/weitere-themen/fsrowid_fsrowversion.html",
    "title": "FSROWID / FSROWVERSION",
    "keywords": "FSROWID / FSROWVERSION Mit der RowID-RowVersion-Logik werden Objekte gegen konkurrierende Transaktionen abgesichert. Dafür können in jeder DBTable 2 Datenbank-Spalten mit dem Namen FSROWID bzw. FSROWVERSION angegeben werden. Diese müssen mit der Einstellung IsRowID bzw. IsRowVersion gekennzeichnet werden. Siehe auch Kapitel DBTable . In der Datenbank-Tabelle haben diese Spalten folgende Bedeutung: FSROWID Eine Guid-Spalte. Diese Spalte wird von Framework Studio beim Insert eines neuen Datensatzes generiert. Die Datenbank-Spalten werden mit einem Default-Constraint angelegt. Dadurch werden sie automatisch befüllt, wenn Datensätze durch ein anderes Programm angelegt und kein Wert für diese Spalte angegeben wurde. SQLServer Datatyp: uniqueidentifier Oracle Datatyp: RAW(16) Diese Spalte wird von Framework Studio als PrimaryKey-Spalte verwendet und dient beim Update und beim Nachlesen der eindeutigen Identifikation von Datensätzen. Darüber hinaus in der DBTable definierte PK-Spalten sind dafür unerheblich. Diese haben lediglich den Effekt, dass Framework Studio ein Update auf diese Spalten unterbindet. FSROWVERSION Ein numerischer Zähler, der von Framework Studio bei jedem Update des Datensatzes hochgezählt wird. Dadurch werden konkurrierende Updates erkannt und verhindert. Beim Anlegen der Tabelle muss diese Spalte erzeugt werden. Die Mechanismen von RowID und RowVersion sind unabhängig voneinander. So kann die RowVersion sowohl mit einer RowID als auch mit einem individuellen Primär-Schlüssel (PK) verwendet werden. Beim Anlegen neuer Tabellen müssen die Spalten wie folgt angelegt werden: SQL-Server: CREATE TABLE <table> ( FSROWID uniqueidentifier NOT NULL DEFAULT (NEWSEQUENTIALID()) PRIMARY KEY CLUSTERED, FSROWVERSION bigint, <columns> ); Oracle: CREATE TABLE <table> ( FSROWID RAW(16) DEFAULT SYS_GUID() NOT NULL, FSROWVERSION INTEGER, <columns> ); CREATE UNIQUE INDEX IXROWID_<table> ON <table> (FSROWID) TABLESPACE INDEX1; Für die Spalten FSROWID und FSROWVERSION generiert FrameworkStudio in den Components entsprechende Properties. Diese sehen wie folgt aus: FSSystemGuid ROWID FSlong ROWVERSION Das Property ROWID erhält seinen Wert unmittelbar beim Insert in die Datenbank. Der Wert steht also erst nach dem Insert zur Verfügung. Im OnBeforeSave() hat somit das Property ROWID bei einem neuen Datensatz noch den Wert FSSystemGuid.Null. Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine RowVersionInvalidException geworfen. An der Component gibt es folgende Methoden, mit denen dieser Exception vorgebeugt werden kann: HasDbChanged() ReloadData()"
  },
  "doc/weitere-themen/service-release-modus.html": {
    "href": "doc/weitere-themen/service-release-modus.html",
    "title": "Service-Release-Modus",
    "keywords": "Service-Release-Modus Nachdem eine Package-Version versiegelt wurde und dadurch die weitere Bearbeitung von Inhalten unterbunden wurde. kann sie wieder für eine eingeschränkte Bearbeitung im Service-Release Modus geöffnet werden. Bei jedem Kompilieren einer Package-Version wird diese mit einem neuen Stempel (Compile-Stamp) versehen. Dieser hat zur Folge, dass alle darauf aufsetzenden Package-Versionen ebenfalls neu kompiliert werden müssen. Dadurch wird sichergestellt, dass alle Schnittstellen-Änderungen auch in den abhängigen Package-Version korrekt berücksichtigt werden. Eine Fehlerkorrektur in einer Package-Version, auf der viele andere Package-Versionen aufsetzen, führt so zu einem aufwändigen Update-Szenario, da alle abhängigen Package-Versionen ebenfalls neu kompiliert werden müssten. Der Service-Release-Modus löst genau diese Problematik: Er ermöglicht eine eingeschränkte Bearbeitung mit Framework-Studio und lässt dabei aber keine Änderung von Schnittstellen zu. Bei einem anschließenden Kompilieren bleibt der zuletzt vor der Versiegelung erzeugte Compile-Stamp erhalten. Er bietet einen speziellen Export, der nur die seit der Versiegelung bearbeiteten Elemente berücksichtigt. Die relativ kleine Export-Datei kann schnell in einem Ziel-Repository importiert werden. Dabei werden die geänderten Daten einfach ersetzt und stehen sofort auch ohne zusätzliches Kompilieren in den abhängigen Package-Versionen zur Verfügung. Wenn sich eine Package-Version im Service-Release-Modus befindet, dann sind in Framework Studio grundsätzlich alle Eingaben gesperrt und es können weder neue Elemente (z.B. Components oder Forms) angelegt, noch bestehende Elemente gelöscht werden. Ausschließlich die folgenden Änderungen sind möglich: Es können alle Methoden-Inhalte bearbeitet werden. Bei Individual Component-Properties können die Get- und die Set-Methode bearbeitet werden. An Custom Control Data Sources können die Methoden GetXML und SetXml bearbeitet werden. In Text-Collections können neue Einträge angelegt werden. So können in Methoden neue Meldungen mit dem Exception- oder MessageBox-Wizard erzeugt werden. In ReportDocumentTypes können vorhandene Crsytal-Reports bearbeitet werden. Eine Änderung der Schnittstelle (XSD-Datei) ist nicht möglich. Methoden im Service-Release-Modus Von Methoden kann nur der Inhalt bearbeitet werden. Die Deklaration der Methode wird nicht im Code-Editor angezeigt, damit keine versehentlichen Änderungen durchgeführt werden können. Überschreibungen von Methoden (override) können im Service Release Modus nicht neu angelegt werden. Existierende Überschreibungen können aber inhaltlich geändert werden."
  },
  "doc/weitere-themen/timeout-inaktive-broker-session.html": {
    "href": "doc/weitere-themen/timeout-inaktive-broker-session.html",
    "title": "Timeout für inaktive Broker-Sessions",
    "keywords": "Timeout für inaktive Broker-Sessions Wenn der Java-Client unerwartet beendet wird, existieren die Sessions auf dem Broker weiter. Das kann z.B. dann passieren, wenn der Computer ausgeschaltet wird, eine Remote-Desktop-Sitzung beendet wird oder der Client-Prozess direkt über den Task-Manager abgebrochen wird. Mit den hängengebliebenen Sessions werden nicht nur wertvolle Ressourcen im Broker, sondern ggf. auch Lizenzen blockiert. Die Sessions werden nur dann abgeräumt, wenn sich auch der Java-Client regulär beendet. Die Lizenz-Prüfung orieniert sich an den real vor dem PC sitzenden Personen. Dazu wird auf dem Terminal-Server die ID der Sitzung ermittelt. Genau das kann zu einem Problem werden, wenn die Terminal-Server-Sitzung beendet wird und dieselbe Person später eine neue Sitzung startet und dadurch eine neue Sitzungs-ID erhält. Wenn der Java-Client nicht regulär beendet wurde, blockiert die noch laufende Broker-Sitzung eine Lizenz und in der neuen Terminal-Server-Sitzung wird aufgrund der abweichenden Sitzungs-ID eine weitere Lizenz verbraucht. Aus diesem Grund gibt es einen Mechanismus, der solche Sitzungen im Broker abräumt: Der Client sendet dazu mind. alle 2 Minuten ein Lebenszeichen an den Broker – auch dann, wenn der Benutzer keine Aktionen ausführt – also der Java-Client unbenutzt am Bildschirm steht. Der Broker prüft regelmäßig ob sich der Client gemeldet hat. Sitzungen, die mehr als 5 Minuten kein Lebenszeichen gemeldet haben, werden beendet. Dadurch werden sowohl die Ressourcen als auch die Lizenzen wieder freigegeben. Der Broker prüft dies auch dann, wenn im Moment kein Benutzer aktiv ist. Mit diesem Mechanismus werden auch Sitzungen abgeräumt, bei denen der Benutzer durch eine Aktion einen sehr langen Request angestoßen UND den Client anschließend hart beendet hat. In diesem Fall wird der noch laufende Request durch Thread.Abort() abgebrochen. Es wird dadurch in diesem Request eine ThreadAbortException ausgelöst. Warning Wenn der Client-Arbeitsplatz in den Standby- bzw. Energiesparmodus schaltet, dann sendet der Java-Client kein Lebenszeichen mehr an den Broker. In diesem Fall wird die Sitzung vom Broker beendet. Der Benutzer erhält bei Wiederaufnahme der Arbeit die Meldung Session has been terminated ."
  },
  "doc/weitere-themen/transaktionen.html": {
    "href": "doc/weitere-themen/transaktionen.html",
    "title": "Transaktionen",
    "keywords": "Transaktionen Framework Studio besitzt ein eigenes Transaktionsmanagement. In den meisten Fällen müssen Sie sich nicht um Transaktionen kümmern, da jeder Save auf einer Component mit einem Datasource automatisch in einer Transaktion verpackt wird. Jede Transaktion wird in Form eines FrameworkDataTransaction-Objekts repräsentiert. Dieses implementiert die Schnittstelle IDisposable, weshalb sich ein using-Block für Aktivitäten innerhalb der Transaktion empfiehlt. // FrameworkDataConnection ermitteln FrameworkDataConnection connection = ...; // Transaktion starten using(FrameworkDataTransaction transaction = connection.BeginTransaction()) { // Nun kann mit dieser Transaktion gearbeitet werden [...] transaction.Commit(); } Werden FrameworkDataTransaction-Objekte verschachtelt erzeugt, so muss sichergestellt sein, dass innere Transaktionen vor den äußeren abgeräumt werden. Andernfalls wird eine Exception geworfen: Innere Transaktionen müssen vor äußeren beendet werden: Beim Aufruf der Methode Commit an einer inneren Transaktion wird sie lediglich als geschlossen markiert und es erfolgt kein echter Commit. Dennoch wird aus Sauberkeitsgründen ggf. eine FrameworkDataTransactionException geworfen, falls die Aktion in dem aktuellen Transaktionsstapel ungültig sein sollte. Bis zum Dispose-Aufruf dieser inneren Transaktion darf dann keine weitere Transaktion geöffnet werden. Aus diesem Grund sollte der Dispose-Aufruf zeitnah auf das Commit folgen. Die Methode Rollback hingegen führt wirklich zu einem Rollback bis zum Erstellungszeitpunkt der äußersten (physischen) Transaktion. Daher darf, bis die äußerste Transaktion geschlossen wurde, keine weitere Transaktion geöffnet werden: Nach einem Rollback müssen alle Transaktionen der Verbindung freigegeben werden, bevor die nächste geöffnet wird. Zur Fehlerprotokollierung nach einem Rollback wurde ein Modus geschaffen, mit dem Transaktionen auch dann gestartet werden können, wenn noch nicht alle Transaktionen abgeräumt wurden. Das erfolgt durch den Aufruf von Begin-/CreateTransaction (TransactionBeginMode.Rollback) . Dadurch wird jedoch eine innere Transaktion zur physischen Transaktion und es können weitere, innere Transaktionen auf Basis dieser erstellt werden. Die folgende Tabelle zeigt die Eigenschaften und Methoden der Klasse FrameworkDataTransaction. Eigenschaft ActiveTransaction Die innerste Transaktion der Verbindung. Connection Die FrameworkDataConnection, mit der das Transaktionsobjekt erzeugt wurde. InnerTransaction Die innere Transaktion oder null , falls diese nicht existiert. IsActive Genau dann true , wenn die Transaktion die innerste ist. IsDisposed Genau dann true , wenn bereits ein Dispose aufgerufen wurde. Dies geschieht auch an allen inneren Transaktionen der Wurzeltransaktion nachdem ein Rollback ausgeführt wurde. IsolationLevel Die Isolationsstufe. IsOpen Genau dann true , wenn die Transaktion noch nicht Comitted, Rollbacked oder Disposed wurde. IsPhysical Genau dann true , wenn die Transaktion die physische ist. IsRoot Genau dann true , wenn die Transaktion die äußerste ist. OuterTransaction Die äußere Transaktion oder null , falls diese nicht existiert. PhysicalTransaction Die physische Transaktion, auf die diese Transaktion verweist. RootTransaction Die äußerste Transaktion der Verbindung. TransactionProvider Die native Transaktionsinstanz der Root-Transaction (innere Transaktionen besitzen keinen eigenen TransactionProvider und zeigen nur auf den der RootTransaction). Methode Commit() Schreibt die Änderungen in die Datenbank. Danach darf bis zum Dispose-Aufruf keine weitere Transaktion an der Verbindung geöffnet werden. Dispose() Wird üblicherweise vom using-Block automatisiert am Ende aufgerufen. Sollte bis dahin kein Commit-Aufruf erfolgt sein, so wird Rollback aufgerufen. Rollback() Verwirft alle Änderungen, die seit dem Öffnen der äußersten Transaktion gemacht wurden. Danach müssen alle Transaktionen geschlossen werden, bevor eine neue erzeugt wird. RegisterkarteSource(FrameworkDataTransaction.ISource) Registriert ein FrameworkDataTransaction.ISource Objekt an der Transaktion. Components und Collections implementieren dieses Interface, um nach einem Commit/Dispose die Methoden OnRollback() bzw. OnAfterCommit() aufzurufen. In OnRollback() würden die Originalwerte wiederhergestellt werden. Parallel zu OnAfterCommit() wird ApplyChanges() ausgeführt. Wird darin ein Save einer anderen Component aufgerufen, nimmt dieser quasi an der bereits geöffneten Transaktion teil. Transaktionen manuell verwalten Für komplexere Operationen kann es notwendig sein, dass eine Transaktion manuell gesteuert werden muss. Das kann zum einen in einer Komponente notwendig sein, wenn Sie in einer Methode hintereinander an anderen Components einen Save ausführen möchten, und das alles aber eine Transaktion ergeben soll. Eine Component besitzt eine CreateTransaction -Methode zur Erzeugung einer Transaktion ( Methoden in jeder Component / Collection ). Das folgende Beispiel zeigt, wie eine eigene Transaktion damit aufgebaut sein sollte. using(FrameworkDataTransaction transaction = this.CreateTransaction()) { this.oComponent1.Save(); this.oComponent2.Save(); transaction.Commit(); } Unabhängig von Komponenten kann auch an FrameworkDataConnection-Instanzen mittels BeginTransaction() eine Transaktion geöffnet werden. Jede Komponente, der ein DataSource zugewiesen ist, besitzt eine FrameworkDataConnection. Es sollte bevorzugt die Komponente gewählt werden, an der ggf. ein Save-Aufruf erfolgt. Das folgende Beispiel zeigt, wie eine Transaktion aufgebaut wird: FrameworkDataConnection connection = this.oComponent1.Connection; using(FrameworkDataTransaction transaction = connection.BeginTransaction()) { this.oComponent1.Save(); this.oComponent2.Save(); transaction.Commit(); } Der Unterschied zwischen dieser und der CreateTransaction-Vorgehensweise besteht darin, dass die Component/Collection sich in CreateTransaction zusätzlich an der äußersten Transaktion als FrameworkDataTransaction.ISource-Objekt registriert. Sobald die Transaktion endgültig geschlossen wird, teilt die Transaktion es den daran registrierten ISource-Objekten mit. Die Components und Collections benötigen diese Information, da sie ihre internen Originalwerte (die im Falle eines RollbackChanges-Aufrufs herangezogen werden) wiederherstellen oder die Änderungen akzeptieren müssen. Die folgenden zwei Beispiele zeigen, wie das zu verstehen ist. Ihre Wirkung ist identisch, sofern es sich bei der Transaktion um die einzige Transaktion der Verbindung handelt: using(FrameworkDataTransaction transaction = this.CreateTransaction()) { this.Save(); ... transaction.Commit(); bool committed = false; // bezieht sich auf die äußerste Transaktion using(FrameworkDataTransaction transaction = this.Connection.BeginTransaction()) { this.Save(); ... transaction.Commit(); committed = true; // sofern transaction die äußerste Transaktion ist } // Nachdem selbst auf der äußersten Transaktion ein Dispose aufgerufen wurde: if(committed) { this.ApplyChanges(); // Änderungen akzeptieren this.OnAfterCommit(); } else { this.OnRollback(); // Eine interne Routine => DB Originalwerte wiederherstellen } } Handelt es sich um eine innere Transaktion, so müsste im zweiten Beispiel der if-Block hinter der Freigabe der äußersten Transaktion erfolgen. Genauso muss sich die Variable comitted auf die äußerste Transaktion beziehen, da nur auf der äußersten Transaktion ein Commit erfolgen kann. Transaktionen Fehlerbehandlung Wenn bei einem Save eine Exception auftritt, darf diese nicht unterdrückt werden. Dadurch würde die Transaktion nicht mehr korrekt arbeiten und ggf. falsche Daten in die Datenbank gelangen. Wenn während dem Save in einer Component ein Fehler auftritt, dann wird die Transaktion mit einem Rollback() zurückgesetzt. Der Rollback() wird – im Gegensatz zum Commit() – sofort ausgeführt. Wenn durch das Unterdrücken der Exception nachfolgende Speicher-Vorgänge normal aufgerufen werden, hat das zur Folge, dass beim nächsten Save eine neue Transaktion gestartet wird. Diese würde dann außerhalb der ursprünglich geöffneten Transaktion laufen. Deshalb muss im Fehlerfall immer eine weitere Exception geworfen werden. try { this.oComponent1.Save( ); this.oComponent2.Save( ); } catch (Exception e) { throw new Exception(`Error”, e); } Wenn im Falle einer Exception innerhalb einer Transaktion eine eigene Protokollierung oder ein kontrolliertes Zurücksetzten von Daten in der Datenbank realisiert werden soll, dann muss dafür eine spezielle Transaktion geöffnet werden. Zuvor muss ein Rollback auf der aktuellen Transaktion ausgeführt werden. ... } // eine Fehlerbehandlung mit try-catch catch { ... // oder eine andere Fehler-Situation: if( bError ) { IcdLogEntry oLogEntry = cdLogEntryFactory.Create(this.Global); // Fehler, also Rollback – wenn eine Transaktion offen ist if (oLogEntry.Connection.ActiveTransaction != null) { oLogEntry.Connection.ActiveTransaction.Rollback(); } // Wenn die Transaktion bekannt ist, geht auch oTrans.Rollback(); // nun wird eine eigene spezielle Hilfs-Transaktion aufgemacht.. // Diese sollte immer oTransError heißen. using (FrameworkDataTransaction oTransError = oLogEntry.CreateTransaction(TransactionBeginMode.Rollback)) { ... oLogEntry.Save(); ... // Daten zurücksetzen uns speichern... ... oTransError.Commit(); } // In einer Exceptiopn den Fehler weiterwerfen oder anders behandeln throw; // Ansonsten eine Excetpion bzw. FrameworkApplicationException auslösen, damit evtl. // außerhalb organisierte Transaktion richtig reagieren können. throw new FrameworkApplicationException (\"error..\"); } Dieser Mechanismus funktioniert nur nach einem Rollback. Ansonsten wird eine ganz normale Transaktion geöffnet, die sich unter die bereits geöffnete Transaktion eingliedert. Diese würde entweder erst ganz am Ende commitet oder im Fehlerfall auch wieder rollbacked werden. Beispiel einer Transaktion // Transaktion starten using (FrameworkDataTransaction oTrans = oObjectXY.CreateTransaction()) { // Nun kann mit dieser Transaktion gearbeitet werden ... // z.B. auch ein Save am oObjectXY: oObjectXY.Save(); oObjectOtherColl.Save(); ... // wird hier kein Commit() ausgeführt, so wird am Ende des using-Blocks // automatisch ein Rollback() ausgelöst oTrans.Commit(); } Anstatt mit oObjectXY kann innerhalb einer Component-Methode auch direkt mit this.CreateTransaction() gearbeitet werden, sofern das this-Objekt einen Data-Source besitzt und dieser den o.g. Anforderungen an die Connection-Einheitlichkeit erfüllt. Weitere wichtige Fakten Der Commit-Aufruf sollte möglichst immer der letzte Code im using-Block sein. Aktionen nach dem Commit – insbesondere Save-Aktionen – könnten zu Exceptions führen. Wenn, dann müssen diese Aktionen hinter den using-Block gepackt werden. Besonders zu beachten sind vorzeitige Ausstiege aus der Funktion (return…) oder verschluckte Exceptions (catch). Beim Code-Review oder einem Umbau können Sie diese Stellen ganz einfach mit einer Suche nach return bzw. catch finden. Siehe auch Abschnitt Using-Block vorzeitig verlassen . Die alte Transaktions-Logik muss durch die neue ersetzt werden. Die alten Methoden sind als [Obsolete] gekennzeichnet und deren Verwendung führt beim Compile zu Warnungen. Es dürfen keine eigenen Transaktionen an der physischen Connection (ConnectionProvider) geöffnet werden. Diese würden die FS-Logik durcheinander bringen. Die Arbeit mit den Provider-Objekten ist prinzipiell Tabu!!! Exception-Handling Wenn beim Einsatz einer Transaktion eine Exception behandelt werden soll, dann ist es empfehlenswert, dies außerhalb des using-Blocks zu machen. Beispiel: try { using (FrameworkDataTransaction oTrans = this.CreateTransaction()) { ... oTrans.Commit(); } } catch (Exception ex) { // Ausnahme hier behandeln } Using-Block vorzeitig verlassen Manchmal kann es nötig sein, eine Funktion und damit den using-Block vorzeitig zu verlassen. Sollen die Daten gespeichert bleiben, muss frühzeitig ein Commit() stattfinden. Findet dieser nicht statt, wird der using-Block ohne Commit() verlassen und es gibt automatisch einen Rollback. using (FrameworkDataTransaction oTrans = this.CreateTransaction()) { ... if (bAllCompleted_Vorzeitig) { oTrans.Commit(); return; } if (bXyz) { return; // würde automatisch einen Rollback() erzeugen. } ... oTrans.Commit(); } Spezialfall: Transaktionen bei mehreren Connections Wenn mehrere Connections bei einer Logik betroffen, sind und auf beiden übergreifend eine Transaktion organisiert werden soll, dann müssen jeweils Transaktionen geöffnet und diese verschachtelt werden. Auch hier sollten beide Commit()-Aufrufe ganz am Ende der using-Blöcke stehen. using(FrameworkDataTransaction oTrans1 = oObject1.CreateTransaction()) { using(FrameworkDataTransaction oTrans2 = oObject2.CreateTransaction()) { // Aktionen auf beiden Connections... ... oTrans2.Commit(); } oTrans1.Commit(); } Oder direkt mit den Connections, wenn diese verfügbar sind. Es könnte auch Connection und Object gemischt werden. using(FrameworkDataTransaction oTrans1 = oConnection1.BeginTransaction()) { using(FrameworkDataTransaction oTrans2 = oConnection2.BeginTransaction()) { // Aktionen auf beiden Connections... ... oTrans2.Commit(); } oTrans1.Commit(); }"
  },
  "doc/weitere-themen/webconfig.html": {
    "href": "doc/weitere-themen/webconfig.html",
    "title": "web.config",
    "keywords": "web.config Die Datei web.config ist die Konfigurations-Datei der ASP.net-Seite, welche die Anfragen des Brokers verarbeitet. Sie liegt im Ordner der Web-Application. Im Abschnitt <appSettings> müssen einige Einstellungen vorgenommen werden, damit der Broker seine Arbeit verrichten kann: ApplicationsDirectory Gibt an, in welchem Ordner die Anwendungs-Dateien abgelegt sind. Hier muss der gleiche Ordner wie in der FrameworkStudio.exe.config angegeben werden. Application Gibt an, welche Applikation gestartet werden soll. Hier muss der Name der Applikation angegeben werden, mit der im Code-Builder kompiliert wurde. LogRequestXmlPath Gibt an, in welche Datei das XML geschrieben werden soll, das bei jeder Anfrage an den Broker geschickt wird. Diese Einstellung braucht nicht angegeben zu werden. Wenn dieser Eintrag nicht vorhanden ist, wird die Datei einfach nicht geschrieben. Wenn dieser Eintrag angegeben ist, wird dafür gesorgt, dass der Windows-Benutzer ASP.net Schreibzugriff auf diese Datei hat. LogResponseXmlPath Gibt an, in welche Datei das XML geschrieben werden soll, das der Broker an den Client zurückschickt. Es gilt hier das gleiche wie bei LogRequestXmlPath. Als Beispiel folgt ein Auszug aus einer Web.config: <configuration> <appSettings> <add key=\" RepSerConStr\" value=\"data source=NVDEV;initial catalog=BusinessRep;integrated security=false;persist security info=False;user id=FrameworkBroker;password=nv;packet size=4096\" /> <add key=\"ApplicationsDirectory\" value=\"C:\\\\inetpub\\\\wwwroot\\\\Applications\"/> <add key=\"Application\" value=\"BusinessRep.Start\" /> <add key=\"LogRequestXmlPath\" value=\"C:\\\\Inetpub\\\\wwwroot\\\\businessrep\\\\FrameworkRequest.xml\"/> <add key=\"LogResponseXmlPath\" value=\"C:\\\\Inetpub\\\\wwwroot\\\\businessrep\\\\FrameworkResponse.xml\"/> </appSettings> …"
  },
  "doc/workflow-designer/bearbeiten.html": {
    "href": "doc/workflow-designer/bearbeiten.html",
    "title": "Erstellen, Öffnen und Löschen eines Workflows",
    "keywords": "Erstellen, Öffnen und Löschen eines Workflows Erstellen Wenn Sie einen Workflow erstellen wollen, der ausschließlich eine Instanz eines bereits erstellten Forms enthält, dann wählen Sie im Form Designer des gewünschten Forms den Menüpunkt Edit / New Workflow for WorkflowForm aus. Ihnen wird dann vollautomatisch ein Workflow mit geeignetem Namen und der gewünschten Form Instanz im Namespace des Forms erzeugt. In allen anderen Fällen gehen Sie wie folgt vor: Markieren Sie den Namespace, in dem der Workflow erstellt werden soll. Um jetzt einen Workflow zu erstellen, gibt es zwei Möglichkeiten: Mit dem Button ( New ) oder über das Context-Menu des Namespaces ( New / Workflow ). Direkt nachdem der Workflow erzeugt wurde, können Sie den Namen des Workflows überschreiben. Es empfiehlt sich, den Namen mit wfl zu beginnen. Der Name des Workflows kann auch nachträglich noch geändert werden. Das geht mit dem Befehl Rename im Context-Menu des Workflows. Öffnen Durch einen Doppelklick auf einen Workflow auf der Registerkarte Overview wird dieser geöffnet. Für diesen Workflow wird auf der rechten Seite des Fensters eine Registerkarte mit dem Namen des Workflows erstellt. Auf dieser Registerkarte wird der Workflow angezeigt. Es können mehrere Workflows gleichzeitig geöffnet sein. Löschen Löschen können Sie einen Workflow mit dem Button ( Delete ). Sie müssen dazu den gewünschten Workflow im Namespace-Baum markiert haben. Es gibt auch im Context-Menu einen Eintrag Delete. Der Löschvorgang wird erst wirksam, wenn Sie den Button ( Save All ) drücken."
  },
  "doc/workflow-designer/design.html": {
    "href": "doc/workflow-designer/design.html",
    "title": "Design des Workflows",
    "keywords": "Design des Workflows Nachdem der Workflow geöffnet wurde, wird dieser auf der Registerkarte Designer grafisch dargestellt und bearbeitet. Um den Workflow und dessen Elemente zu bearbeiten, müssen Sie das entsprechende Element markieren; anschließend können Sie im Property-Grid oder über das Context-Menu Einstellungen ändern. Es gibt zum einen den Workflow selber, der markiert wird, in dem Sie auf den Hintergrund klicken und die Workflow-Elemente; das können Forms oder andere Workflows sein. Weiterhin gibt es noch Links, welche die einzelnen Workflow-Elemente verbinden und Branches und Switches, mit denen es möglich ist, Links zu verzweigen und mit Bedingungen zu versehen. Um neue Workflow-Elemente in einem Workflow zu erstellen, müssen Sie ein Form oder einen Workflow per Drag & Drop auf die Design-Fläche ziehen. Wie was auf den Workflow gezogen wird, ist in den folgenden Abschnitten beschrieben. Workflow-Properties DesignSize Größe des Design-Bereiches. Dieser Wert kann in den Properties nicht geändert werden. Um die Größe zu ändern, kann der Design-Bereich markiert und mit der Maus vergrößert oder verkleinert werden. Name Bezeichnung des ausgewählten Workflows. StartInstance (Workflow-Form) Gibt an, welches Form beim Start des Workflows angezeigt werden soll. Alternativ können Sie in den Properties des Workflow-Forms IsStartinstance auf True setzen. StartMethod Gibt an, welche Form-Methode aufgerufen werden soll, wenn beim Start des Workflows ein Form angezeigt werden soll. Es werden die Methoden des unter StartInstance eingestellten Forms angeboten. Wird der Workflow so aufgerufen, dass gezielt ein Form mit einer Methode gestartet werden soll, ist diese Angabe hier hinfällig. IsStartable (True, False) Wollen Sie den ausgewählten Workflow zu einer Startinstanz für Ihre Applikation machen, müssen Sie hier True auswählen. Default: False. SafeInitialize (True, False) Gibt an, ob beim Start der Anwendung der Safe-Initialize-Modus aktiviert werden soll. Diese Einstellung kann nur an einem Start-Workflow vorgenommen werden. Der Safe-Initialize-Modus dient dazu, z.B. in einer Update-Situation Fehlermeldungen zu unterbinden. Über this.Global.SafeInitializing kann der Status dieses Modus abgefragt werden. Der Modus muss mithilfe der Funktion this.Global.EndSafeInitialize() nach dem Start der Anwendung zurückgesetzt werden. BaseFullName Dieses Property ist für spätere Erweiterungen vorgesehen und zurzeit ohne Funktion. CheckedOutDateString (Schreibgeschützt) Datum des letzten Checkouts. CheckedOutUserName (Schreibgeschützt) Benutzer, der den Workflow zuletzt bearbeitet und eingecheckt hat. Wenn Sie den Workflow gerade ausgecheckt haben, steht Ihr Benutzername in diesem Feld. Workflow-Form Die Forms werden in der Registerkarte Design auf der linken Seite des Fensters angeboten und können von dort aus in den Workflow gezogen werden. Ein Form kann als Start-Instance und/oder Entrance-Instance definiert werden. Wenn ein Workflow gestartet wird, gibt es zwei Möglichkeiten, wie entschieden wird, welches Form aufgerufen werden soll: Beim Aufruf wird nichts angegeben, d.h. es wird nur der Workflow gestartet, ohne dass ihm gesagt wird, was er machen soll. Dann wird das Form gestartet, das als Start-Instance definiert ist. Beim Aufruf des Workflows wird gesagt, welches Form gestartet werden soll. Das lässt sich aber nur mit Forms machen, die als Entrance-Instance definiert sind. (Weitere Einzelheiten dazu sind im Workflow-Link erklärt.) Wenn Sie das erste Form in den Workflow ziehen, wird es automatisch als Start-Instance definiert. Workflow-Form Properties Die Eigenschaften des Workflow-Elements werden im Property-Grid definiert. Frame Gibt an, in welchem Frame das Fenster angezeigt werden soll. Es werden hier alle Frames angezeigt, die im Frameset in der Configuration definiert sind. Wird das Form als modaler Dialog angezeigt, hat diese Einstellung keine Auswirkung. (siehe Property IsModal) IsEntranceInstance (True, False) Gibt an, ob es sich bei diesem Form um eine Entrance-Instance handelt. Forms, die als Entrance-Instance definiert sind, können beim Aufruf des Workflows direkt angesprochen werden. Andere Forms können nur innerhalb des Workflows, indem sie sich befinden, angesprochen werden. IsModal (true, false) Gibt an, ob das Form als modaler Dialog geöffnet werden soll. Wird ein Form von einem anderen modalen Dialog geöffnet, wird dieses immer modal angezeigt – egal was bei IsModal angegeben ist. IsStartInstance (True, False) Gibt an, ob das Form eine Start-Instance sein soll. Wird der Workflow geöffnet und kein Form direkt angesprochen, wird das Form geöffnet, das als Start-Instance definiert ist. Warning Es kann maximal ein Form als Start-Instance gekennzeichnet sein. Location (schreibgeschützt) Position des Forms innerhalb des Workflows. In den Properties kann dieser Wert nicht verändert werden. Um die Position zu verändern, muss das Form im Design-Panel mit der Maus verschoben werden. Name Name des Workflow-Elements. Wenn das Form in den Workflow gezogen wird, wird der Name des Forms vorbelegt. Size (schreibgeschützt) Größe des Forms im Workflow. In den Properties kann der Wert nicht verändert werden. Um die Größe des Forms zu ändern, muss diese im Designer mit der Maus geändert werden. BaseFullName Dieses Property ist für spätere Erweiterungen vorgesehen und zurzeit ohne Funktion. Workflow-Forms Events Im Event-Teil des Property-Grids können die Workflow-Events des Forms mit den Workflow-Events des Workflows, in dem sich das Form befindet, verbunden werden. Das ist aus folgendem Grund notwendig: Wenn dieser Workflow in einen anderen Workflow eingebunden wird und dort wollen Sie auf ein Workflow-Event aus dem Form reagieren, dann ist es notwendig dieses Form-Event nach außen weiter zu reichen. Das passiert hier in dieser Zuordnung. In dieser Liste werden alle Workflow-Events des Forms aufgelistet. FiredEvent Soll das Workflow-Event eines Forms im Workflow selber nach außen angeboten werden, muss das Event des Forms mit einem Event aus dem Workflow verbunden werden. Diese Zuordnung kann in FiredEvent vorgenommen werden. Workflow im Workflow Die Workflows werden in der Registerkarte Namespaces angeboten (dort wo sie auch verwaltet werden). Von dort aus können sie per Drag & Drop in die Design-Fläche gezogen werden. Workflow im Workflow Properties Die Eigenschaften des Workflow-Elements werden auf der Registerkarte Property definiert. IsEntranceInstance (true, false) Gibt an, ob das Workflow-Element als Entrance-Instance fungieren soll. Wenn ja, dann ist es möglich diesen Workflow (das Element) von außen direkt anzusprechen (analog zu den Forms). Location (schreibgeschützt) Position des Workflows innerhalb des Workflows. In den Properties kann dieser Wert nicht verändert werden. Um die Position zu verändern, ist es erforderlich diesen Workflow im Design-Panel mit der Maus zu verschieben. Name Name des Workflow-Elements. Dieser Wert wird automatisch mit dem Namen des Workflows, der hineingezogen wird, vorbelegt. Size (schreibgeschützt) Größe des Workflows im Workflow. In den Properties kann der Wert nicht verändert werden. Um die Größe des Workflows zu ändern, wird diese im Designer mit der Maus geändert. BaseFullName Dieses Property ist für spätere Erweiterungen vorgesehen und zurzeit ohne Funktion. Workflow im Workflow Events Auch Workflows können wie die Forms Workflow-Events besitzen. Wenn diese nach außen weitergereicht werden sollen, funktioniert das genau wie bei den Forms. ( Workflow-Forms Events ) Link Ein Link dient zum Verbinden zweier Workflow-Elemente. Er hat als Ausgangspunkt ein Workflow-Event von einem Workflow-Element. Als Ziel hat er ein anderes Workflow-Element. Auf der Registerkarte Design wird der Link angeboten. Ziehen Sie ihn per Drag & Drop auf das Ausgangs-Element. Anschließend ziehen Sie das Ende des Pfeils auf das Ziel-Element. Es öffnet sich ein Dialog, in dem Sie genau einstellen können, wie sich der Link verhalten soll. Sie können diesen Dialog auch später wieder öffnen, um Änderungen am Link durchzuführen. Im Context-Menu des Links wird dazu der Befehl Properties angeboten. Link-Properties Name Name des Links. Dieser wird immer mit Link1 vorbelegt. Source (schreibgeschützt) Name des Ausgangs-Elements. SourceEvent In dieser Combobox werden alle Workflow-Events des Ausgangs-Elements angeboten. Sie müssen hier auswählen, auf welches der Link reagieren soll. Container In dieser Combobox werden alle FormContainer- und DashboardContainer-Steuerelemente des Quellformulars angezeigt. Wird ein Wert ungleich null eingestellt, so wird das Zielformular in diesem Container erstellt und angezeigt. In diesem Fall ist jedoch keine automatische Fokussierung möglich. Target Gibt das Ziel-Element an. Das kann hier nachträglich noch geändert oder auch genauer angegeben werden. Die Combobox zeigt alle Workflow-Elemente des Workflows an. Zusätzlich werden für jeden Workflow die als Entrance-Instance definierten Elemente angezeigt. Sie können z.B. gezielt ein Form ansprechen. Wenn Sie das machen, gibt es auch die Möglichkeit an dem Form eine Methode anzustoßen. Target Method Ist in Target ein Form angegeben, werden in der Combobox alle public-Methoden des Forms angeboten und Sie können eine Methode auswählen, die angestoßen werden soll. Hat die Methode Parameter, werden diese in der Tabelle unter der Methode aufgelistet. Es wird der Name das Parameters und der Typ des Parameters angezeigt. In der dritten Spalte geben Sie an, welcher Wert übergeben werden soll. In der Combobox werden alle public Membervariablen des Forms mit deren Properties angegeben. Sie können einen Wert aus der Liste angeben. Wenn es sich bei dem Parameter um eine Zahl oder einen String handelt, können Sie auch bestimmte Werte angeben. Z.B. Löschen können Sie einen Link über das Context-Menu des Links mit dem Befehl Delete . InstanceID Um mehrere Instanzen eines Formulars anlegen zu können, muss am Quellformular ein Property vom Datentyp string oder FSstring angelegt werden. Dieses Property enthält die Instanz ID des nächsten Formulars, welches mittels Workflow-Event erstellt wird. Genau dann, wenn diese Instanz ID beim Aufruf des Workflow Events mit keiner bereits existierenden übereinstimmt, wird eine neue Instanz erzeugt. Das Property, welches die neue ID darstellt, wird in diesem Feld innerhalb der Workflow-Link Eigenschaften angegeben. Wird das Feld leer gelassen, so gilt die Instanz-ID des Workflows. Create Target Nur wenn dieser Wert auf „true“ steht wird für den Fall, dass das Formular (unter Berücksichtigung der InstanceID) noch nicht instanziiert wurde, ein neues Formular erzeugt. AutoFocus Steht dieser Wert auf true , so wird der Fokus nach Aufruf des Workflow-Events in das Zielformular gesetzt. Branch Mit einem Branch können Sie einen Link mit einer Bedingung versehen oder verzweigen. Ein Branch hat immer einen Link als Eingang und einen oder zwei Links als Ausgang. Welcher der Ausgänge aufgerufen wird, wird mit der Bedingung im Branch ermittelt. Die Bedingung ist ein boolscher Ausdruck. Je nachdem, wie das Ergebnis dieses boolschen Ausdrucks ist, wird der True-Zweig oder der False-Zweig aufgerufen. Indem nur einer dieser beiden Zweige verwendet wird, können Sie einen Link mit einer Bedingung erstellen. Einen Branch binden Sie ein, indem Sie ihn per Drag & Drop in den Workflow ziehen. Das Symbol befindet sich im unteren Teil der Registerkarte Design . Anschließend erstellen Sie einen Link von der Quelle zum Branch. Über das Context-Menu des Branchs können Sie den Property-Dialog öffnen. In ihm wird die Bedingung festgelegt. Im linken Teil des Fensters befinden sich alle Properties, die das Quellobjekt anbietet. Aus diesen Properties kann die Bedingung zusammengesetzt werden. Darunter befindet sich eine Liste der Operatoren. Mit einem Doppelklick in eine der beiden Listen wird der entsprechende Text in die Bedingung eingefügt. Der Text wird dabei an die Stelle des Cursors gesetzt. Es muss eine Bedingung herauskommen, die von .NET verarbeitet werden kann. Es wird später daraus folgender Code erstellt: if (Bedingung) { True-Link } else { False-Link } Wenn die Bedingung fertiggestellt ist, können die Links vom Branch zum Ziel (zu den Zielen) definiert werden. Dazu ziehen Sie einen neuen Link auf den Branch und den Pfeil des Links auf das Ziel. Es öffnet sich wie bereits beschrieben der Property-Dialog des Links. Als Source-Event kann jetzt true oder false ausgewählt werden. Es können jetzt noch weitere Links mit true oder false definiert werden. Beim Ausführen werden dann, wenn die Bedingung wahr ist, alle Links aufgerufen, die als Source-Event true besitzen und wenn die Bedingung falsch ist, alle Links, die als Source-Event false haben. Wird am Ziel eine Target-Method mit Parameter aufgerufen, können dieser Methode Werte aus der Quelle vor dem Branch mitgegeben werden. Switch Mit einem Switch kann ein Link mehrfach verzweigt werden. Ein Switch hat einen Link als Eingang und kann mehrere Links als Ausgang besitzen. Im Switch wird ein Property des Quell-Elements ausgewertet. Je nachdem, welchen Wert dieses Property besitzt, wird einer der Ausgänge angesprochen. Einen Switch binden Sie ein, indem Sie Ihn per Drag & Drop in den Workflow ziehen. Das Symbol befindet sich im unteren Teil der Registerkarte Design . Anschließend müssen Sie einen Link vom Quell-Element in den Switch ziehen. Über das Context-Menu des Switches gelangen Sie in einen Dialog, in dem Sie die Einstellungen des Switches festlegen können. Unter Object können Sie ein Property aus dem Quell-Element angeben. Für dieses Property wird anschließend unter Events festgelegt, welche Werte ausgewertet werden sollen. Jeder dieser Werte stellt einen Ausgang aus dem Switch dar. Es können Zahlen und Zeichenketten eingegeben werden. Jetzt müssen noch die Links vom Switch zu den Zielen definiert werden. Ziehen Sie dazu einen Link auf den Switch und verbinden Sie das Ende des Links mit dem Ziel. Als Source-Event werden jetzt die unter Event hinterlegten Einträge angeboten. Der Quellcode, der aus diesen Angaben generiert wird, sieht in etwa so aus: switch Form.Property { case Event1: { Link 1 } case Event2: { Link 2 } default: { Link 3 } } Global Events Mit Global Events können Events an alle geöffneten Workflows gesendet werden. Global Events werden auf der Registerkarte Namespaces abgelegt und mit Drag & Drop in den Designer gezogen werden. Auf der Registerkarte Namespaces werden direkt unter dem Event zwei Einträge angeboten: Das Event, das aufgerufen werden kann und der Event Handler, mit dem Sie auf das Event reagieren können. Global Events aufrufen Um ein Global Event aufzurufen, ist es nötig den ersten Eintrag per Drag & Drop in den Workflow zu ziehen. Anschließend wird ein Link vom aufrufenden Element in das Global Event gezogen. In den Link-Properties kann dann am Global Event eine Methode Init angegeben werden. Diese Methode enthält alle im Global Event definierten Parameter. So können Sie dem Global Event alle am aufrufenden Element zur Verfügung stehenden Properties übergeben. ( Link-Properties ) Auf Global Events reagieren Um auf ein Global Event zu reagieren, ist es erforderlich aus der Registerkarte Namespaces den zweiten Eintrag unter dem Global Event per Drag & Drop in den Workflow zu ziehen (gevXxxHandler). Den Event Handler erkennen Sie an dem Strich links am Oval und der Inschrift gevXxxHandler. Anschließend wird ein Link vom Global Event Handler in des Ziel-Element gezogen. In den Link-Properties können Sie bei einem Methoden-Aufruf am Ziel-Element als Parameter alle Parameter aus dem Global Event übergeben. In der Combobox für die Parameter werden die Parameter unter dem Eintrag „e“ angezeigt. ( Link-Properties )"
  },
  "doc/workflow-designer/ueberblick.html": {
    "href": "doc/workflow-designer/ueberblick.html",
    "title": "Workflow Designer",
    "keywords": "Workflow Designer Der Workflow-Designer wird im Hauptfenster über das Menü Workflow >> Workflow Designer aufgerufen. Er dient – wie es der Name schon sagt – zum Gestalten von Workflows. In den Workflows wird festgelegt, wie die einzelnen Forms miteinander kommunizieren, bzw. wann welches Form angezeigt wird. Workflows können nicht nur Forms, sondern auch wiederum andere Workflows enthalten. Somit ist es möglich, Workflows modular aufzubauen und an jeder beliebigen Stelle wiederzuverwenden. Zur Orientierung folgt zunächst ein Überblick über den Workflow-Designer . Überblick Workflow Designer Registerkarte Namespaces Aus der Namespaces-Registerkarte können Forms, Global Events oder andere Workflows per Drag & Drop in den Workflow gezogen werden. Class Registerkarte Auf der Registerkarte Class werden die Workflow-Events des Workflows aufgelistet. Toolbox-Registerkarte Auf der Registerkarte Toolbox werden folgende Elemente angeboten: Link Switch Branch Sie können per Drag & Drop in den Workflow gezogen werden. Diese Elemente werden weiter unten genauer beschrieben. Registerkarte Designer Auf dieser Registerkarte wird der Workflow grafisch dargestellt. Auf diese Fläche müssen auch die Elemente gezogen werden, wenn sie dem Workflow hinzugefügt werden sollen."
  },
  "index.html": {
    "href": "index.html",
    "title": "Framework Studio 4.4",
    "keywords": "Framework Studio 4.4 Andere Versionen können hier aufgerufen werden. Note Diese Dokumentation befindet sich noch im Aufbau. Diese Seite gliedert sich in folgende Teile, die über die Navigation im oberen Bereich aufgerufen werden können: 1.) Framework Studio 4.4 Hier finden sie Neuheiten , Release-Listen , aktuelle Informationen und Systemvorrausetzungen 2.) Technische Dokumentation Alle Dokumentationen und Anleitungen für die Framework Studio IDE, Programmier-Themen und andere Programme. 3.) Api-Dokumentation Umfasst eine generierte Dokumentation der von Framework Studio bereitgestellten Klassen und Schnittstellen."
  }
}