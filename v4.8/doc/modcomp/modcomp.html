<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Modular Components </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Modular Components ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/FrameworkSystemsGmbH/fs/blob/4.8/release/0-alpha4/docs/doc/modcomp/modcomp.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="modular-components">Modular Components</h1>

<p>Mit den Modularen Components wollen wir einen Baukasten schaffen, mit dessen Hilfe wir Objekte ausschließlich mit dem benötigten Funktionsaufwand erstellen können.</p>
<h4 id="unsere-motivation">Unsere Motivation</h4>
<p>Aktuell gibt es für BusinessLogik und Datenobjekte nur die Möglichkeit eine Component als Objekttyp anzulegen.
Dieser Objekttyp bringt viele Funktionen (New, Load, Save, NotifyChanged-Logik, etc.) mit sich, welche nicht für jeden Verwendungszweck des Objekts benötigt werden.
Zum Beispiel sollte eine Component, die ausschließlich Businesslogik enthält, nicht <em>automatisch</em> in eine Form eingebunden werden können. Diese Funktionalität sollte bei Bedarf, wie bei einem Baukasten, ausgewählt werden können.</p>
<h3 id="derzeitiger-entwicklungsstand">Derzeitiger Entwicklungsstand</h3>
<p>Der Komponentenbaukasten wird iterativ erweitert. Derzeit umfasst er die folgenden Features:</p>
<ul>
<li><p>Modular Components Arten</p>
<p><img src="media/modcompTypen.png" alt="Verschiedene Modular Component Typen"></p>
<p>Die Auswahl der Modular Component-Art bestimmt Voreinstellungen der Modular Component.
Bei <em>Modular Component (Interface)</em> kann der Type Interface nicht mehr verändert werden.
Bei <em>Modular Component (UnitTest)</em> wird der Compile Step mit &quot;UnitTest&quot;, das Attribute mit &quot;[TestClass]&quot; und die Base Class mit &quot;FSTestBase&quot; vorbelegt. Außerdem wird eine Methode <code>MyTestMethod()</code> mit dem Attribute &quot;[TestMethod]&quot; hinzugefügt.</p>
</li>
<li><p>Type Auswahl: <strong>Class, Class with Interface oder Interface</strong>
Die Auswahl des Types entscheidet, ob eine Klasse und oder ein Interface generiert wird.
Die beiden Optionen <strong>Class</strong> und <strong>Interface</strong> sind selbsterklärend. Bei der Option <strong>ClassWithInterface</strong> wird sowohl eine Klasse als auch ein Interface generiert. Bei diesem Type muss zudem der Compile Step beachtet werden! Die unterschiedliche Code-Generierung kann im Kapitel <a href="#code">Code</a> eingesehen werden.</p>
</li>
<li><p>Es kann der <strong>Compile Step</strong>, wie bei CodeFiles, definiert werden. Dies entscheidet in welche DLL die Modular Component kompiliert wird.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Beim Typ <strong>ClassWithInterface</strong> gibt es die Besonderheit, dass bei Auswahl des Compile-Schritts <strong>Component</strong> das Interface in die Interface-Schicht, die Klasse jedoch in die Component-Schicht generiert wird.</p>
</div>
</li>
<li><p>An der Klasse oder dem Interface, an Properties, und Methoden können <strong>Attribute</strong> definiert werden. Eine ausführliche Erklärung der Attribute und Verhalten im Customizing erfolgt im Kapitel <a href="#class-mit-attributen-und-customizing">Attribute</a>.</p>
</li>
<li><p>Protected Setter bei Properties</p>
</li>
<li><p>Copy &amp; Paste der Methoden und Properties über verschiedene Objekttypen hinweg ist möglich. Zwischen Forms, Components und Modular Components kann kopiert werden. Da keine 1:1 Übersetzung möglich ist, muss vor allem bei der Kopie von Modular Component Properties in Components das Ergebnis ggf. überprüft werden.</p>
</li>
</ul>
<h4 id="baseclass">BaseClass</h4>
<p>Im Feld <strong>BaseClass</strong> sind nur Klassen erlaubt, welche mit Fullname angegeben werden müssen.
Dies kann für externe Klassen oder nicht Modular Component-Klassen händisch eingetragen werden.
Oder es wird eine derived Modular Component über das Derive-Command im Namespace-Baum einer Basis Modular Component erstellt - ähnlich zur Form-Vererbung.</p>
<p>Modular Components vom Typ <em>Interface</em> können keine BaseClass besitzen, das Feld wird deshalb nicht angezeigt.
Stattdessen können im Feld <strong>Interfaces</strong> mehrere Basis-Interfaces definiert werden.</p>
<p>Im Customizing kann die BaseClass nicht geändert werden.
Das Feld <strong>BaseClass</strong> zeigt den Wert aus dem Basis-Package an.</p>
<p>Im Property-Kontextmenü gibt es ebenfalls die neue Funktion: <strong>Property (Override)</strong>.
Mit welcher Properties aus der Basisklasse überschrieben werden können.
Properties haben eine Checkbox <strong>Override</strong> erhalten, welche beim Überschreiben eines Properties automatisch angehakt wird.</p>
<p><img src="media/propertyoverride.png" alt="Property override Kontextmenü"></p>
<p>Auch bei &quot;Method (override)&quot; werden Methoden aus der Basis aufgeführt.</p>
<p>Auf dem folgenden Screenshot wird der General Tab einer Class-Modular Component abgebildet.
<img src="media/%C3%BCbersichtModCompsGeneralTab.png" alt="UI der Modular Component Typen"></p>
<h4 id="interfaces">Interfaces</h4>
<p>Im Feld <strong>Interfaces</strong> können durch ein Komma getrennt mehrere Interfaces angegeben werden, welche die Modular Component implementieren soll.
Es müssen FullNames (inkl. Namespaces) verwendet werden.</p>
<p><img src="media/modcomp-interfaces.png" alt="interfaces"></p>
<p>Diese Interfaces werden 1:1 in den generierten Code der Klasse des entsprechenden Packages übernommen.
Für eine Implementierung muss manuell gesorgt werden.
Für bekannte Interfaces gibt es aber eine Unterstützung zum Erzeugen der entsprechenden Properties und Methoden.</p>
<p>&quot;Bekannte&quot; Interfaces sind derzeit andere Modular Components.</p>
<p>Im Customizing kann eine Modular Component weitere Interfaces implementieren - die im Basis-Package definierten Interfaces können hingegen nicht entfernt werden.
Aus diesem Grund stellt das Feld <strong>Interfaces</strong> nicht den Wert aus dem Basis-Package dar.</p>
<p>Über den Button neben dem Feld öffnet sich ein Context-Menü mit Aktionen für bekannte Interfaces.</p>
<ul>
<li><p><strong>Open</strong>: öffnet die entsprechende Modular Component.</p>
</li>
<li><p><strong>Implement</strong>: sofern die angegebene Modular Component vom Typ <em>Interface</em> ist, werden die fehlenden Properties und Methoden automatisch erzeugt.
Dabei wird nur das jeweilige Interface und nicht dessen Basis-Interface(s) betrachtet.</p>
</li>
</ul>
<h3 id="funktionale-einschränkungen">Funktionale Einschränkungen</h3>
<p>Funktionen, welche aus Components bekannt sind, jedoch nicht für Modular Components umgesetzt wurden:</p>
<ol>
<li>Verwendung der Modular Components in DataBindings ist nicht möglich. Auch bei Textboxen mit Autovervollständigungen werden Modular Components nicht angezeit. Es muss der FullName der Modular Component angegeben werden.</li>
<li>Properties haben derzeit nur einen External DataType. Es muss der FullName bspw. einer Component angegeben werden. MDTs stehen ebenfalls nicht zur Auswahl.</li>
</ol>
<h2 id="bestandteile-der-modular-component">Bestandteile der Modular Component</h2>
<ul>
<li>Type (nicht änderbar im Customizing)
<ul>
<li>Class, ClassWithInterface, Interface</li>
</ul>
</li>
<li>Compile Step (nicht änderbar im Customizing)
<ul>
<li>Interface, Component, UnitTest</li>
</ul>
</li>
<li>Base Class (nicht änderbar im Customizing)</li>
<li>Description (²)</li>
<li>Attributes (²)<br>
Attribute werden im Customizing über die Packages hinweg summiert und im UseCode an das Interface beziehungsweise an die Klasse generiert. Beim Typ <em>Class With Interface</em> erhält das Interface keine Attribute.</li>
</ul>
<p>(²) wird an die Klasse (bei Type <em>Class</em> und <em>ClassWithInterface</em>) oder an das Interface (bei Type <em>Interface</em>) im UseCode generiert.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Bei Type <em>ClassWithInterface</em> und Compile Step <em>Component</em> wird das Interface in die Interface-Schicht generiert. Die zugehörige Klasse kommt in die Component-Schicht.
Bei Type <em>Class</em> und <em>Interface</em> wird es in den ausgewählten Compile Step generiert.</p>
</div>
<h3 id="properties">Properties</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">Properties</th>
<th style="text-align: center;">Class</th>
<th style="text-align: center;">Class With Interface</th>
<th style="text-align: center;">Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">AccessLevel</td>
<td style="text-align: center;">public | internal | protected | private</td>
<td style="text-align: center;">public | internal | protected | private</td>
<td style="text-align: center;">public</td>
</tr>
<tr>
<td style="text-align: left;">AutoProp</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x (nur public)</td>
</tr>
<tr>
<td style="text-align: left;">* Setter Type AutoProp</td>
<td style="text-align: center;">get | get set | protected set</td>
<td style="text-align: center;">get | get set | protected set</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Field</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">* Setter Type Field</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">IndivProp</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">* Setter Type IndivProp</td>
<td style="text-align: center;">get | get set | protected set</td>
<td style="text-align: center;">get | get set | protected set</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Attributes</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x³</td>
</tr>
</tbody>
</table>
<p><strong>Code Generierung:</strong> AutoProperties und IndivProperties werden immer mit <strong>virtual</strong> bzw. im Customizing mit <strong>override</strong> generiert.</p>
<p>So sieht die UI im Bereich General der Properties aus:</p>
<p><img src="media/propertyUI.png" alt="Property UI"></p>
<p>Für die Anzeige des Codes gibt es hier eine gemeinsame Ansicht des Getter und Setter-Codes. Mit gedrückter Shift-Taste und Doppelklick auf den Splitter kann die Ansicht von Vertical zu Horizontal (Get/Set Code wird dann untereinander angezeigt) und andersherum gewechselt werden.</p>
<p><img src="media/indivPropCode.png" alt="Indiv Code"></p>
<p><code>Public</code> Properties werden automatisch <code>virtual</code>.</p>
<h4 id="autoproperty">AutoProperty</h4>
<p>Bei AutoProperties kann kein Get- oder Set-Code geschrieben werden.</p>
<pre><code class="lang-csharp">public virtual FSstring Stuff { get; set; }
</code></pre>
<h4 id="individual-property">Individual Property</h4>
<pre><code class="lang-csharp">public virtual FSstring Stuff { 
    get{ 
        // individuell definierter Code
    }
    set {
        // individuell definierter Code
    }
 }
</code></pre>
<h4 id="fields">Fields</h4>
<p>Fields können nicht gecustomized werden.
Attribute werden somit immer im Code des jeweiligen Packages definiert.</p>
<h3 id="methods">Methods</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">Methoden</th>
<th style="text-align: center;">Class</th>
<th style="text-align: center;">Class With Interface</th>
<th style="text-align: center;">Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Constructor</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">* Constructor - Attributes</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">protected Method</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">* protected Method Attributes</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">internal Method</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
</tr>
<tr>
<td style="text-align: left;">* internal Method Attributes</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
</tr>
<tr>
<td style="text-align: left;">Attributes</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x<sup>(1)</sup></td>
</tr>
</tbody>
</table>
<p>(1) Attribute werden bei Properties und Methods beim Typ Interface an den CodeCode des jeweiligen Packages, wo sie definiert wurden, im Code geschrieben. Dies verhält sich anders bei Class und ClassWithInterface. Hier werden die Attribute im UseCode an Properties und Methods gesammelt generiert.</p>
<h4 id="testmethod">TestMethod</h4>
<p>Beim Typen UnitTest gibt es im Bereich der Methods das spezielle TestMethod-Command.
Dieses Command fügt automatisch das Attribute &quot;[TestMethod]&quot; hinzu. TestMethods sind nicht virtual.</p>
<p><img src="media/testMethodAuswahl.png" alt="UnitTest Method"></p>
<h2 id="code">Code</h2>
<h3 id="class-mit-attributen-und-customizing">Class mit Attributen und Customizing</h3>
<pre><code class="lang-csharp">
[FSDemoAttribute]
[FSDemoCustomizeAttribute]
public class Stuff : FSDemoCustomize_Stuff
{ 
    [FSDemoMethodAttribute]
    [FSDemoCustomizeMethodAttribute]
    public override void SetStuff(string stuff) =&gt; base.SetStuff(stuff);

    [FSDemoPropertyAttribute]
    [FSDemoCustomizePropertyAttribute]
    public override string Stuff {
        get =&gt; base.Stuff;
        set =&gt; base.Stuff = value;
    }
}

public class FSDemoCustomize_Stuff : FSDemo_Stuff 
{
    public override string Stuff { 
        get =&gt; base.Stuff;
        set =&gt; base.Stuff = value;
    }

    public override void SetStuff(string stuff){
        base.SetStuff(stuff + &quot; customizing&quot;);
    }
}

public class FSDemo_Stuff 
{
    public virtual string Stuff { get; set; }
    public virtual void SetStuff(string stuff){
        Stuff = stuff;
    }
}
</code></pre>
<h3 id="generierter-code-bei-classwithinterface-mit-customizing-und-baseclass">Generierter Code bei &quot;ClassWithInterface&quot; mit Customizing und BaseClass</h3>
<pre><code class="lang-csharp">
// UseCode
public class Stuff : FSDemoCustomize_Stuff, IStuff { }
public interface IStuff : FSDemoCustomize_IStuff { }

// Customizing Package
public class FSDemoCustomize_Stuff : FSDemo_Stuff, FSDemoCustomize_IStuff { }
public interface FSDemoCustomize_IStuff: FSDemo_IStuff { }

// Basis Package
public class FSDemo_Stuff : BaseClass, FSDemo_IStuff { }
public interface FSDemo_IStuff { }

</code></pre>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span><a href="https://www.enventa-group.com/" target="_blank" rel="noopener noreferrer nofollow"><img class="dark" src="../../media/enventa-group-logo-dark.svg" alt="enventa-group" style="height: 1.5rem"><img class="light" src="../../media/enventa-group-logo.svg" alt="enventa-group" style="height: 1.5rem"></a></span> <span style="float:right">Made with <a href="https://dotnet.github.io/docfx" target="_blank" rel="noopener noreferrer nofollow" class="external">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
