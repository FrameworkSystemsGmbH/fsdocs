<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Registerkarte Properties </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Registerkarte Properties ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/FrameworkSystemsGmbH/fs/blob/4.7/release/3/docs/doc/comp/tab_properties.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="registerkarte-properties">Registerkarte Properties</h1>

<p><img src="media/registerkarte-properties.png" alt="Component Registerkarte Property"></p>
<h2 id="neue-properties-anlegen">Neue Properties anlegen</h2>
<p>Die Properties werden in der ClassView-Registerkarte angezeigt.
Hier können neue Properties angelegt werden.
Das können Sie über den Button (<strong>New</strong>) mit dem Eintrag <strong>Property</strong> bzw. <strong>Membervariable</strong> oder über das Kontext-Menü der Component (<strong>New / Property</strong> bzw. <strong>New / Membervariable</strong>) machen.
Eine dritte Möglichkeit besteht darin, eine Component direkt per Drag &amp; Drop aus dem <strong>Namespace Treeview</strong> auf die Property Tabelle zu ziehen.</p>
<h3 id="dragdrop-von-components">Drag&amp;Drop von Components</h3>
<p>Ziehen Sie ein Element aus dem Namespace-TreeView auf die Property-Registerkarte. So wird ein Property angelegt und zugleich im Component-Fenster angezeigt.</p>
<p><img src="media/registerkarte-properties-dragondrop.png" alt="Component Registerkarte Property"></p>
<h2 id="properties-löschen">Properties löschen</h2>
<p>Properties werden ebenfalls über die Registerkarte <strong>ClassView</strong> gelöscht. Wählen Sie zunächst das zu löschende Property und anschließend aus dem Kontext-Menü den Eintrag <strong>Delete</strong> aus.</p>
<h2 id="properties-kopieren">Properties kopieren</h2>
<p>Sie können ein Property in eine andere Komponente, in ein anderes Form kopieren oder innerhalb der Komponente duplizieren. Dazu wählen Sie das gewünschte Property in der Property-Liste aus. Anschließend verwenden Sie entweder die Standardtastenkürzel Strg+C, Strg+V und Strg+X oder das Kontextmenü, um den gewünschten Kopiervorgang durchzuführen.</p>
<h2 id="properties-bearbeiten">Properties bearbeiten</h2>
<p>Sie können ein Property öffnen, indem Sie einen Doppelklick auf den Eintrag in der ClassView-Registerkarte machen. Alternativ können Sie auch im Component-Fenster auf der Registerkarte Property in der Tabelle das gewünschte <strong>Property</strong> auswählen.</p>
<p>Die Properties werden in der Tabelle sortiert, wenn Sie auf die Spaltenüberschrift des gewünschten Sortierkriteriums anklicken.</p>
<h2 id="allgemeine-properties-am-property">Allgemeine Properties am Property</h2>
<p>Im Folgenden werden die allgemeinen Schaltflächen für ein Property, welche sich oberhalb der Property-Registerkarten befinden, erläutert.</p>
<h3 id="name">Name</h3>
<p>Bezeichnung des Properties. Über diesen Namen wird das Property im Code angesprochen.</p>
<h3 id="access-level">Access Level</h3>
<p>Legen Sie hier das Access-Level des Properties fest. Die Angabe ist analog zum .NET-Standard.</p>
<h3 id="datatype">Datatype</h3>
<p>Siehe <a href="#datentyp-bearbeiten">Datentyp bearbeiten</a></p>
<h3 id="useinterface">UseInterface</h3>
<p>Es besteht die Möglichkeit, ein Property, welches als Datatype eine Component eingestellt hat, als Interface einzubinden, um zirkulare Referenzen zu umgehen.</p>
<p>Wenn man an einer Component ein Property anlegt und dabei als Typ eine Component aus einem anderen Namespace verwendet, dann wird bei diesem Property automatisch die Eigenschaft <strong>UseInterface</strong> gesetzt.</p>
<h3 id="property-type">Property Type</h3>
<p>Folgende Typen stehen zur Auswahl:</p>
<p>• Membervariable
• Generated
• Generated (readonly)
• Individual
• Individual (readonly)
• und Relation.</p>
<p>Diese Typen werden weiter <a href="#arten-von-properties">unten</a> genauer beschrieben.</p>
<h3 id="datentyp-bearbeiten">Datentyp bearbeiten</h3>
<p>Die Eingabe des Datentyps erfolgt über ein Textfeld mit Auto-Vervollständigung. Beim Anlegen neuer Properties wird der zuletzt ausgewählte Datentyp vorbelegt.</p>
<p>Diese Angabe kann nicht geändert werden, wenn dieses Property ein Mapping hat. Dann wird der Metadatentyp aus der entsprechenden Database-Column gezogen.</p>
<p><img src="media/registerkarte-properties-datentyp.png" alt="Datentyp Registerkarte"></p>
<p>Tippen Sie einfach den Namen des gewünschten Datentyps ein. Elemente, die mit dem eingegebenen Text beginnen, werden in der Auto-Vervollständigungsliste angezeigt und können über die Pfeiltasten oder per Maus ausgewählt werden.</p>
<p>Wenn Sie den Namen eines Namespaces angeben und anschließend einen Punkt eingeben, wird die Auswahl der Vorschläge auf diesen Namespace eingeschränkt. Beispiel: „Sales.cd“ liefert alle Elemente aus dem Sales Namespace, die mit cd beginnen.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Durch Verwendung des Platzhalters „%“ können Sie angeben, dass die Ergebnisse nicht mit dem danach folgenden Text anfangen müssen, sondern der Text lediglich enthalten sein muss. Beispiel: „sales.%ordertype“ liefert alle Elemente aus dem Sales Namespace, deren Name ordertype enthält, also z.B. cdOrderType.</p>
</div>
<p>Wird die TextBox verlassen, wird der Name des ausgewählten Elements durch den vollständig referenzierenden Namen ersetzt.</p>
<div class="WARNING">
<h5>Warning</h5>
<ul>
<li>Beim ersten Verwenden der Textbox kann es einige Sekunden dauern, bis der interne Speicher mit allen Elementen gefüllt ist.</li>
<li>Es werden maximal 100 Vorschläge angeboten.</li>
</ul>
</div>
<h3 id="externe-typen">Externe Typen</h3>
<p><img src="media/registerkarte-properties-externtyp.png" alt="registerkarte-properties-externtyp"></p>
<p>Properties von Components und Data Contracts sowie Membervariablen von Forms können externe Datentypen zugewiesen werden. Wird die CheckBox „External Type“ gesetzt, wird die Autovervollständigung des Datatype-Textfeldes deaktiviert und ein beliebiger Typ kann angegeben werden (im Beispiel <code>List&lt;List&lt;int&gt;&gt;</code> ).</p>
<p>Dies bietet sich z.B. an, wenn in einem Namespace mit externen Assemblies gearbeitet wird, deren Klassen als Datentypen von Properties verwendet werden sollen.</p>
<p>Im IntelliSense wird beim Aufruf eines solchen Properties „object“ angezeigt, da im Hintergrund mit „object“ gearbeitet wird. Das Property „lstTest“ aus dem Beispiel kann aber z.B. trotzdem so verwendet werden:</p>
<pre><code class="lang-csharp">int i = this.lstTest[0][1]; // Der Wert von i ist danach 2
</code></pre>
<h2 id="registerkarte-general">Registerkarte General</h2>
<p>In der Registerkarte <strong>General</strong> können Sie die Checkbox <strong>Autogenerate Membervariable</strong> bei Individual/Individual (readonly) Properties setzen.
Wird die Checkbox aktiviert, wird automatisch eine Membervariable generiert und das entsprechende <strong>Depends on Property</strong> gesetzt.</p>
<p>Die Textfelder <strong>Display MinLength</strong>, <strong>Display MaxLength</strong>, <strong>Display MinLines</strong> und <strong>Display MaxLines</strong> und die Comboboxen <strong>Mapping</strong> und <strong>Drag Source</strong> befinden sich ebenfalls hier.
Des Weiteren können Sie im Textfeld <strong>Description</strong> eine Beschreibung hinzufügen.</p>
<p>Das Control <strong>Mapping</strong> gibt das Mapping (die Verbindung) des Properties zur Query an. In der Combobox stehen hier alle Spalten (Alias) der Query zur Auswahl.</p>
<h2 id="registerkarten-get-method--set-method">Registerkarten Get Method / Set Method</h2>
<p>Für die Properties mit dem Type <em>Generated</em>, <em>Generated (readonly)</em>, <em>Individual</em>, <em>Individual (readonly)</em> kann bei Bedarf individueller Code, der beim Setzen und Auslesen des Properties durchlaufen werden soll, programmiert werden.</p>
<p>Siehe hierzu <a href="#individual--individual-readonly-properties">Individual / Individual (readonly) Properties</a> und <a href="#generated--generated-readonly-properties">Generated / Generated (readonly) Properties</a></p>
<h2 id="registerkarte-depends-on">Registerkarte Depends On</h2>
<p>Auf dieser Registerkarte können Sie angeben, welches Property bspw. aus dem Auftrag mit welchem Property aus dem Kunden verbunden werden soll.
Sie geben also eine <strong>Schlüsselbeziehung</strong> an, ähnlich wie Sie das auf einer relationalen Datenbank tun würden.
Sie können auch mehrere Properties miteinander verknüpfen, wenn sich der Schlüssel aus mehreren Properties zusammensetzt.</p>
<p><strong>Button Add:</strong>
Fügt ein weiteres Property in die Relation ein. In der Tabelle wird eine neue Zeile angelegt und Sie definieren, welches Property mit welchem wie verknüpft werden soll.</p>
<p><strong>Button Remove:</strong>
Löscht die markierte Zeile aus der Relation.</p>
<p>Spalte <strong>Depends on Property:</strong>
Hier wird das Property auf der Seite Component, in der Sie sich gerade befinden, angegeben. Im Beispiel wäre das ein Property des Auftrags, z.B. die „Kundennnr“.</p>
<p>Spalte <strong>Compare Operator:</strong>
Gibt an, mit welchem Operator die Properties verknüpft werden sollen.</p>
<p>Spalte <strong>oXXX.Property:</strong>
Gibt an, mit welchem Property der eingebundenen Component das eigene Property verknüpft werden soll. Im Beispiel wäre das evtl. „Kunde.Kundennr“.</p>
<p>Spalte <strong>Generated Load Condition:</strong>
Zeigt die aus den anderen Spalten entstandene Suchbedingung an.</p>
<h3 id="dependson-und-individual-properties">DependsOn und Individual Properties</h3>
<p>Individual Properties hängen (meist) von anderen Properties ab und besitzen selber keinen eigenen Wert, der getracked werden kann.
Dennoch müssen Individual Properties dem Form-DataBinding Bescheid geben, dass sie sich geändert haben.
Hierfür gibt es zwei Möglichkeiten:</p>
<ol>
<li>Das Propertiy wir permanent als geändert betrachtet - das passiert, wenn keinerlei DependsOn definiert ist. Die Folge ist, dass dieses Property bei JEDEM Broker Request geprüft und das Property abgefragt wird.</li>
<li>Man pflegt die DependsOn-Informationen. Damit führen Änderungen an einem der &quot;DependsOn&quot;-Properties dazu, dass auch das Individual Property geprüft wird - aber eben nur dann und nicht mehr bei jedem Request.</li>
</ol>
<p>Wir empfehlen dringend das DependsOn zu pflegen, wann immer dies möglich ist.
Je nach Art und Weise des Individual Properties kann das <strong>erhebliche Performance-Vorteile</strong> bringen.</p>
<p>Im einfachsten Fall ist es nur eine einfache Berechnung.
Sollte es sich jedoch um ein Objekt handelt, welches aus der Datenbank gelesen werden muss. Und es wurde zusätzlich auch kein Caching implementiert, dann ist die Bremse perfekt.</p>
<p>Da das DependsOn immer wieder vergessen wird - vor allem bei einem einfachen Individual Property mit Membervariable - gibt es folgenden Mechanismus:</p>
<div class="NOTE">
<h5>Note</h5>
<p>In der Registerkarte General können Sie die Checkbox Autogenerate Membervariable bei Individual/Individual (readonly) Properties setzen.
Wird die Checkbox aktiviert, wird automatisch eine Membervariable generiert und das entsprechende DependsOn-Property gesetzt.</p>
</div>
<h2 id="registerkarte-load-command">Registerkarte Load Command</h2>
<p><img src="media/registerkarte-loadCommand.png" alt="registerkarte-loadCommand"></p>
<p>Das Load Command ist nur in Verbindung mit einem Property mit dem Type <a href="#relation-properties">Relation Properties</a> aktiv.</p>
<p>Mit den Angaben auf der Registerkarte <strong>Depends On</strong> wird Code generiert, der für das Nachlesen der Daten zuständig ist. Diesen Code können Sie überschreiben, wenn Sie eine eigene Logik wünschen.</p>
<p>Sind alle Angaben gemacht, wird die Relation erst beim ersten Zugriff nachgelesen. Dabei werden die gemachten Angaben berücksichtigt. Ändern sich die Inhalte der verbundenen Properties, wird erneut ein Load ausgeführt.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>Derzeit können nur 1:1 Relationen abgebildet werden. D.h. es ist nicht möglich eine Collection als Relation einzubinden.</p>
</div>
<h2 id="registerkarte-control-types">Registerkarte Control Types</h2>
<p>Sie haben die Möglichkeit ein Standard-Control zu definieren bzw. ein zusätzliches Control hinzuzufügen.</p>
<h2 id="registerkarte-texts">Registerkarte Texts</h2>
<p>Hier suchen Sie die Bezeichnung des Felds im Form aus. Sie können wählen, ob Sie die Bezeichnung aus der Database-Table bzw. dem Metadatentypen oder eine eigene Bezeichnung nehmen möchten. Die Bezeichnungen sind hierarchisch aufgebaut und können in den aufeinander aufbauenden Ebenen überschrieben werden.</p>
<p>Metadatatype-Labels können durch die Database-Labels überschrieben werden, Database-Labels durch die Component-Labels, Component-Labels durch die Form-Labels. Ist in einer tieferen Ebene ein Label vergeben worden, wird dieses angezeigt.</p>
<h2 id="arten-von-properties">Arten von Properties</h2>
<h3 id="membervariablen">Membervariablen</h3>
<p>Bei diesem Typ wird kein Property, sondern eine Membervariable erzeugt. Membervariablen haben keine get- und keine set-Methode.</p>
<p>Sie sollten nur mit dem Access-Level <strong>private</strong> versehen werden, um eine externe Manipulation zu unterbinden, da keinerlei Sicherungsmöglichkeiten nach außen definiert werden können.</p>
<p>Eine Membervariable wird nicht im <strong>Form-Designer</strong> angeboten. Sie sollte nur zum Merken von Informationen innerhalb der Komponente verwendet werden.</p>
<h3 id="generated--generated-readonly-properties">Generated / Generated (readonly) Properties</h3>
<p>Die get- und set-Methode für das Property wird automatisch generiert, kann aber auch überdefiniert werden. Dazu muss die Checkbox <strong>Write Individual</strong> auf der Registerkarte <strong>Get Method</strong> bzw. <strong>Set Method</strong> gesetzt werden. In Getter und Setter kann mit der Hintergrundvariable this.PropertyNameValue gearbeitet werden. In Customizations sollte mit base.PropertyName gearbeitet werden, damit Getter und Setter aus dem Basis-Package nicht ausgehebelt werden.</p>
<p>In der Component wird auch der Original-Wert des Properties gespeichert. Wird dem Property ein Wert zugewiesen, der vom Original-Wert abweicht, wird der Status der Component auf <strong>Changed</strong> gesetzt.</p>
<p>Der Original-Wert kann mit <strong>PropertynameOrgValue</strong> abgefragt werden.</p>
<pre><code class="lang-csharp">this.prop = „abc“;
if (this.prop != this.propOrgValue )
{ /*Wert hat sich geändert*/ }
</code></pre>
<p>Ist <strong>Generated (readonly)</strong> ausgewählt, steht für das Property nur die get-Methode zur Verfügung. Auf das Property kann somit nur lesend zugegriffen werden. Bei einer Wertzuweisung an das Property liefert der Compiler eine Fehlermeldung.</p>
<p>Hat das Property ein Mapping, verwalten die generierten get- und set-Methoden das Resultset der Query.</p>
<p>Ohne Mapping wird eine versteckte private Variable verwaltet.</p>
<p>Properties mit einem Mapping können nur auf <strong>Generated</strong> oder <strong>Generated (readonly)</strong> stehen. Ist in der Query die Spalte ’Readonly’ gecheckt, ist sogar nur <strong>Generated (readonly)</strong> möglich.</p>
<h3 id="individual--individual-readonly-properties">Individual / Individual (readonly) Properties</h3>
<p>Bei diesen Typen können/müssen Sie die get- und die set-Methode manuell ausprogrammieren. Es werden in den Registerkarten <strong>Get Property</strong> und <strong>Set Property</strong> die entsprechenden Code-Felder aktiv. Der Aufruf des Setters führt nicht dazu, dass der Status der Component geändert wird.</p>
<p>In der Registerkarte <strong>Set Method</strong> kann bei Properties vom Typ <strong>Individual</strong> die von Framework Studio generierte Prüfung auf den Getter mit der Checkbox <strong>Check before set</strong> unterbunden werden.
Eine Prüfung findet standardmäßig statt, weshalb die Checkbox per default gesetzt ist.</p>
<p>Bei <strong>Individual (readonly)</strong> wird nur das Code-Feld für die get-Methode aktiv.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>Achten Sie darauf, dass eine Get-Methode immer einen Rückgabewert vom Typ des Properties besitzen muss.</p>
</div>
<p>Folgende 3 Anwendungsfälle sind denkbar (Beispiel):</p>
<p><strong>1.Fall:</strong></p>
<p>Sie haben z.B. einen Generated Property Status, und wollen in einem weiteren Property den Text zum Status ausgeben. Dann empfiehlt sich ein Individual (readonly) Property.</p>
<p>Die get-Methode könnte folgendermaßen aussehen:</p>
<pre><code class="lang-csharp">if (this.Status == 1) return „offen“;
else if (this.Status == 2) return “erledigt”;
else return “”;
</code></pre>
<p><strong>2. Fall:</strong></p>
<p>Sie haben ein <strong>Generated Property</strong> vom Typ string, wollen aber ein int Property haben, mit dem Sie im Code arbeiten. Mit einem Individual Property können Sie dieses entsprechend verpacken:</p>
<p>Generated Property sType vom Typ string (z.B. mit einer Column aus der Query verbunden).</p>
<p>Individual Property intType vom Typ int:</p>
<p>get-Methode:</p>
<pre><code class="lang-csharp">return Convert.ToInt32(this.sType);
</code></pre>
<p>set-Methode:</p>
<pre><code class="lang-csharp">this.sType = Convert.ToString(value);
</code></pre>
<p><strong>3. Fall:</strong></p>
<p>Sie wollen ein Property anbieten, das nur bei Bedarf instanziiert und gefüllt wird. Dazu müssen Sie zum einen ein <strong>Individual (readonly)</strong> Property (z.B. oComp) anlegen und zum zweiten eine private <strong>Membervariable</strong> (z.B. oCompMember), die den nachgelesen Wert merkt, damit das Einlesen nur einmal erfolgt (Property und Membervariable müssen denselben Typ haben).</p>
<p>get-Methode:</p>
<pre><code class="lang-csharp">if (this.oCompMember == null)
{
    this.oCompMember = new cComp();
    oCompMember.Load();
}
return oCompMember
</code></pre>
<p>Die Individual Properties müssen dem Form-DataBinding ja irgendwann mal Bescheid geben, dass sie sich geändert haben. Da sie (meist) von anderen Properties abhängen und seilber keinen eigenen Wert besitzen, der getracked werden kann, gibt es 2 Möglichkeiten:
1.) Es wir permanent als geändert betrachtet - das passiert, wenn keinerlei DependsOn definiert ist. Die Folge ist, dass dieses Property bei JEDEM Broker Request geprüft und das Property abgefragt wird.
2.) Man pflegt die DependsOn-Informationen. Damit führen dann Änderungen an einem der &quot;DependsOn&quot;-Properties dazu, dass auch das Individual Property grprüft wird - aber ebend nur dann und nicht mehr bei jedem Request.</p>
<p>Intern halten wir unsere Programmierer immer dazu an, DependsOn zu pflegen, wann immer das möglich ist.
Ja nach Art und Weise des Individual Properties kann das erhebliche Performance-Vorteile bringen. Im einfachsten Fall ist es nur eine einfache Berechnung - da ist das nicht so tragisch. Wenn es sich aber um ein Objekt handelt, was aus der Datenbank gelesen werden muss und dann vielleicht auch noch kein Caching implementiert ist, dann ist die Bremse perfekt.</p>
<p>Gerade weil die DependsOn immer wieder vergessen werden - vor allem wenn Programmierer ein einfaches Individual Property mit Membervariable anlegen, haben wir in FS 4.3 folgende Erweiterung vorgenommen:</p>
<p>Registerkarte General
In der Registerkarte General können Sie die Checkbox Autogenerate Membervariable bei Individual/Individual (readonly) Properties setzen. Wird die Checkbox aktiviert, wird automatisch eine Membervariable generiert und das entsprechende Depends on Property gesetzt.</p>
<h3 id="relation-properties">Relation Properties</h3>
<p>Die Relations dienen dazu, Ihre Komponenten miteinander zu verbinden. (Wenn Sie z.B. einen Auftrag und einen Kunden haben, ist es in der Regel so, dass der Auftrag eine Kundennummer hat, die angibt, welcher Kunde den Auftrag erteilt hat.)</p>
<p>Relations stellen eine Möglichkeit dar, diese beiden Komponenten miteinander zu verbinden. Dazu wird im Auftrag beispielsweise ein Property Kunde angelegt. Dieses Property muss dem Typ Relation entsprechen. Anschließend müssen noch Angaben darüber gemacht werden, wie die beiden Komponenten miteinander verbunden sind.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>Achten Sie darauf, dass als Datatype eine Component ausgewählt ist, da Sie andernfalls Relation nicht als Property Type auswählen können.</p>
</div>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span><a href="https://www.enventa-group.com/" target="_blank" rel="noopener noreferrer nofollow"><img class="dark" src="../../media/enventa-group-logo-dark.svg" alt="enventa-group" style="height: 1.5rem"><img class="light" src="../../media/enventa-group-logo.svg" alt="enventa-group" style="height: 1.5rem"></a></span> <span style="float:right">Made with <a href="https://dotnet.github.io/docfx" target="_blank" rel="noopener noreferrer nofollow" class="external">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
