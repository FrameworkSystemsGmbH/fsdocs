<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Registerkarte Methods </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Registerkarte Methods ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/FrameworkSystemsGmbH/fs/blob/4.8/release/0-alpha4/docs/doc/comp/tab_method.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="registerkarte-methods">Registerkarte Methods</h1>

<p><img src="media/registerkarte-methods.png" alt="RegisterkarteMethods"></p>
<p>Bei den Methoden handelt es sich um Methoden im Sinne von .NET. Innerhalb der Methoden können Sie frei nach den Regeln von C# Code schreiben und mit den Properties der Component arbeiten. Die Methoden werden im ClassView-Registerkarte aufgelistet und sind an dem <img src="../media/icon-method.png" alt="IconMethods">-Icon zu erkennen.</p>
<h2 id="neue-methoden-anlegen--löschen">Neue Methoden anlegen / löschen</h2>
<p>Mit dem Button (<strong>New</strong>) und dem Eintrag <strong>Public Method</strong>, <strong>Protected Method</strong> oder <strong>Method(override)</strong> aus dem sich öffnenden Kontextmenü können Sie eine neue Methode erzeugen. Mit <strong>Public Method</strong> und <strong>Protected Method</strong> wird eine leere Methode angelegt.</p>
<p>Mit <strong>Method(override)</strong> haben Sie die Möglichkeit, eine in einer Basis-Klasse definierte virtuelle Methode zu überschreiben. Es erscheint ein Auswahl-Dialog, der die verfügbaren Methoden anbietet. Wenn Sie einen Eintrag auswählen und mit <strong>OK</strong> bestätigen, wird eine neue Methode angelegt, deren Deklaration entsprechend vorbelegt ist.</p>
<p>In der ClassView-Registerkarte hat das Kontext-Menü der Methoden einen Eintrag <strong>Delete</strong>. Mit diesem Eintrag können Sie die Methode löschen.</p>
<h2 id="methoden-bearbeiten">Methoden bearbeiten</h2>
<p>Um eine Methode zu öffnen, gibt es zwei Möglichkeiten:</p>
<ul>
<li>Auf der Registerkarte <strong>ClassView</strong> einen Doppelklick auf die gewünschte Methode.</li>
<li>Auf der Registerkarte <strong>Method</strong> die gewünschte Methode in der Tabelle auswählen.</li>
</ul>
<p>Auf der Registerkarte <strong>Method</strong> wird in dem großen Edit-Feld der Quellcode der Methode angezeigt, den Sie dort auch bearbeiten können.</p>
<h2 id="methoden-in-jeder-component--collection">Methoden in jeder Component / Collection</h2>
<p>Im folgenden Abschnitt werden die Methoden beschrieben, die jede Component / Collection bereits als Voraussetzung mitbringt, da sie in der Component-Basisklasse DevFrameworkObjekt bzw. DevFrameworkObjektColl implementiert sind.</p>
<h2 id="acceptchanges-">AcceptChanges( )</h2>
<p>Verfügbar für Component / Collection.</p>
<pre><code class="lang-csharp">public void AcceptChanges( )
</code></pre>
<p>Übernimmt alle Änderungen, indem es die OrgValues auf die PropertyValues und den Status auf Unchanged setzt. Es wird keine Datenbanktransaktion ausgeführt. Bei Collections führt diese Methode dazu, dass Objekte, deren Status Deleted ist, aus der Collection unwiderruflich entfernt werden.</p>
<h2 id="adoptvalues">AdoptValues()</h2>
<p>Verfügbar für Component / Collection</p>
<p>Übernimmt alle Properties der übergebenen Component / Collection in die eigenen Properties. Von Unterobjekten wird eine Tiefen-Kopie (Clone) erzeugt.</p>
<pre><code class="lang-csharp">void AdoptValues(IDevFrameworkBaseObject fromComponent)
void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptMode mode)
void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptDictionary dict)
void AdoptValues(IDevFrameworkBaseObject fromComponent, AdoptDictionary dict, AdoptMode mode)
</code></pre>
<p>Im Parameter <strong>fromComponent</strong> wird die Component übergeben, deren Properties übernommen werden sollen.</p>
<p>Über die Parameter dict und mode kann optional das Verhalten der Methode gesteuert werden. Siehe auch Kapitel <a href="#clone">Clone()</a> und <a href="#adoptvalues">AdoptValues()</a></p>
<h2 id="clear">Clear()</h2>
<p>Verfügbar für Collection.</p>
<pre><code class="lang-csharp">public void Clear()
</code></pre>
<p>Reinitialisiert die Collection als leere Collection.</p>
<h2 id="clone">Clone()</h2>
<p>Verfügbar für Component / Collection</p>
<p>Erzeugt eine Tiefen-Kopie der Component oder Collection und gibt diese zurück.</p>
<pre><code class="lang-csharp">public IDevFrameworkBaseObject Clone()
public IDevFrameworkBaseObject Clone(AdoptMode mode)
public IDevFrameworkBaseObject Clone(AdoptDictionary dict)
public IDevFrameworkBaseObject Clone(AdoptDictionary dict, AdoptMode mode)
</code></pre>
<p>Über die Parameter dict und mode kann optional das Verhalten der Methode gesteuert werden. Siehe auch Kapitel <a href="#clone">Clone()</a> und <a href="#adoptvalues">AdoptValues()</a>.</p>
<h2 id="delete-">Delete( )</h2>
<p>Verfügbar für Component / Collection.</p>
<p>Diese Methode setzt den Komponentenstatus auf Deleted. Die Komponente wird dabei aus der Collection entfernt. Damit auf dem Datasource ein physikalischer Delete ausgeführt wird, muss noch ein Save aufgerufen werden.</p>
<p>Diese Methode ist funktional identisch mit der Methode <a href="#remove-">Remove()</a>.</p>
<pre><code class="lang-csharp">public void Component.Delete()
Setzt den Komponentenstatus auf Deleted.
public void Collection.Delete()
Setzt den Komponentenstatus aller Components der Collection auf Deleted.
public void Collection.Delete(DevFrameworkObject obj)
Setzt den Komponentenstatus der übergebenen Component auf Deleted.
public void Collection.Delete(SelectedRowsCollection selectedRows)
</code></pre>
<p>Setzt den Komponentenstatus aller Komponenten, deren IDs in der SelectedRowsCollection enthalten sind, auf Deleted.</p>
<h2 id="load-">Load( )</h2>
<p>Verfügbar für Component / Collection.</p>
<pre><code class="lang-csharp">public int Load()
</code></pre>
<p>Lädt alle Datensätze aus der verknüpften Query.</p>
<pre><code class="lang-csharp">public int Load(string loadCondition)
</code></pre>
<p>Lädt Datensätze entsprechend der Bedingung aus der Datenbank und liefert die Anzahl der gefundenen Datensätze zurück.</p>
<pre><code class="lang-csharp">public int Load(string loadCondition, string OrderByClause)
public int Load(string loadCondition, string HavingClause, string OrderByClause)
</code></pre>
<p>Für das Anpassen der Load-Kriterien werden verschiedene Methoden zum Überschreiben angeboten:</p>
<ul>
<li><code>OnBeforeLoad( )</code> auf der Ebene der Component bzw. Collection.</li>
<li><code>GlobalOnBeforeLoad( )</code> auf globaler Ebene.</li>
</ul>
<h2 id="loadcount-">LoadCount( )</h2>
<p>Verfügbar an Component / Collection</p>
<pre><code class="lang-csharp">public int LoadCount(string loadCondition)
</code></pre>
<p>Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert.</p>
<h2 id="save-">Save( )</h2>
<p>Verfügbar für Component / Collection.</p>
<pre><code class="lang-csharp">public void Save( )
</code></pre>
<p>Save speichert die Änderungen in die Daten-Datenbank.</p>
<pre><code class="lang-csharp">Component.Save( )
</code></pre>
<p>Der Befehl läuft in folgenden Schritten ab:</p>
<pre><code class="lang-csharp">CreateTransaction( )
OnBeforeSaveCustom( ) (Entrypoint)
OnBeforeSave() (Entrypoint)
GlobalOnBeforeSaveAction( ) (Entrypoint)
DeleteMarkedObjects()
Aktion auf der Datenbank.
AcceptChanges( )
OnAfterSave() (Entrypoint)
OnAfterSaveCustom( ) (Entrypoint)
Commit( )
</code></pre>
<p>Läuft etwas in einem der Entrypoints schief und es wird eine Exception geworfen, wird die gesamte Transaktion abgebrochen und <strong>Rollback( )</strong> ausgeführt.</p>
<p>Es folgt eine Aufstellung, wie sich der Befehl bei den einzelnen Status verhält.</p>
<p>FrameworkComponentState.Unchanged
Es wird keine Aktion auf der Datenbank ausgeführt.
Die Entrypoints werden nur angestoßen, wenn EntryPoints.CallAllways übergeben wurde.</p>
<p><strong>FrameworkComponentState.New</strong>
Es wird ein Insert in die Daten-Datenbank gemacht.
Es werden alle Daten in die OrgValue-Properties übertragen.</p>
<p><strong>FrameworkComponentState.Changed</strong>
Es wird ein Update auf die Daten-Datenbank gemacht.
Es werden alle Daten in die OrgValue-Properties übertragen.</p>
<p><strong>FrameworkComponentState.Deleted</strong>
Es wird ein Delete auf die Daten-Datenbank gemacht.
Ist die Component ein Eintrag in der Collection, wird sie aus dieser entfernt.</p>
<p><strong>Collection.Save( )</strong>
Der Befehl läuft in folgenden Schritten ab:</p>
<pre><code class="lang-csharp">CreateTransaction( )
OnBeforeSaveCustom( ) (Entrypoint)
OnBeforeSave( ) (Entrypoint)
Save( ) auf jedes Objekt in der Collection
OnAfterSave( ) (Entrypoint)
OnAfterSaveCustom( ) (Entrypoint)
Commit( )
</code></pre>
<p>Läuft etwas in einem der Entrypoints schief und es wird eine Exception geworfen, wird die gesamte Transaktion abgebrochen und Rollback( ) ausgeführt.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>Ist der Status einer Component Unchanged, werden die Entry-Points der Save-Methode (OnBeforeSave, OnAfterSave, …) nicht aufgerufen, da der Save-Vorgang abgebrochen wird, und keine Transaktion stattfindet.</p>
</div>
<pre><code class="lang-csharp">public void Save(SaveEntryPoints)
</code></pre>
<p>Diese Überladung der Methode ist dazu da, wenn die Entrypoints abgearbeitet werden sollen, obwohl der Save der Component auf Unchanged steht.</p>
<pre><code class="lang-csharp">// Die Entrypoints werden immer ausgeführt
oCompoinet.Save( SaveEntryPoints.CallAllways )

// Die Entrypoints werden nur ausgeführt, wenn der Status nicht Unchanged ist.
oCompoinet.Save( SaveEntryPoints. CallOnlyIfChanged )
</code></pre>
<h2 id="rollbackchanges-">RollbackChanges( )</h2>
<p>Verfügbar für Component / Collection.</p>
<pre><code class="lang-csharp">public void RollbackChanges( )
</code></pre>
<p>Setzt alle PropertiesValues auf die OrgValues.</p>
<h2 id="createtransaction-">CreateTransaction( )</h2>
<p>Verfügbar für Component / Collection.</p>
<pre><code class="lang-csharp">public FrameworkDataTransaction CreateTransaction( )
</code></pre>
<p>Startet eine Transaktion. Weisen Sie der Komponente einen Datasource zu, damit eine Transaktion gestartet werden kann, da die Transaktion selbst an einen Datasource gebunden ist.</p>
<p>Gibt das Transaktionsobjekt zurück, sofern es erzeugt werden konnte. An diesem Transaktionsobjekt kann der Commit bzw. Rollback erfolgen. An geeigneter Stelle muss es mittels Dispose-Aufruf bzw. dem Ende eines using-Blocks abgeräumt werden.</p>
<p>Wenn die Transaktion aufgrund eines Fehlers nicht gestartet werden kann, wird eine Exception geworfen.</p>
<h2 id="hasdbchanged-">HasDbChanged( )</h2>
<p>Verfügbar an DataComponent.</p>
<pre><code class="lang-csharp">public bool HasDbChanged()
</code></pre>
<p>Damit kann einer RowVersionInvalidException zuvorgekommen werden. Mit der Methode <a href="#reloaddata-">ReloadData()</a> können die Daten des Datensatzes neu eingelesen werden.</p>
<p>Gibt zurück, ob sich der Datensatz auf der Datenbank geändert hat. Diese Methode arbeitet sowohl mit der RowID-RowVersion-Logik als auch mit einer PK-RowVersion-Logik.</p>
<p>Wenn an einer Component die Save-Methode aufgerufen wird, prüft diese, ob der Datensatz in der Datenbank geändert wurde, um ein konkurrierendes Update zu verhindern.
Wenn das zutrifft, dann wird eine RowVersionInvalidException geworfen und die Save-Aktion abgebrochen.
Mit dieser Methode kann das im Vorfeld geprüft und ggf. <a href="#reloaddata-">ReloadData()</a> ausgeführt werden.</p>
<h2 id="reloaddata-">ReloadData( )</h2>
<p>Verfügbar an DataComponent.</p>
<pre><code class="lang-csharp">public int ReloadData()
</code></pre>
<p>Diese Methode aktualisiert die Daten aus der Datenbank. Sie führt einen Load auf die Component aus und verwendet dabei die aktuellen Primary-Key-Informationen für die Suchbedingung. Wenn die Component nicht mit der RowID-RowVersion-Logik arbeitet, dann wird der logische Primary-Key verwendet.</p>
<p>Das ist z.B. sinnvoll, wenn mit der Methode HasDbChanged eine Änderung auf der Datenbank festgestellt wurde.</p>
<p>Zurückgegeben wird das Ergebnis der Load-Methode: 1 – erfolgreich eingelesen; 0 – es wurde nichts gelesen, weil der Datensatz z.B. nicht mehr existiert.</p>
<h2 id="onbeforeload-">OnBeforeLoad( )</h2>
<p>Verfügbar für Component / Collection mit einer Query.</p>
<p>Diese Methode kann überschrieben werden. Sie bietet auf Component-Ebene einen zentralen Einstiegspunkt, um vor einem Datenbank-Load die Load-Condition, die Having-Clause oder die Order-By-Clause zu erweitern oder anzupassen.</p>
<p><strong>Data-Component:</strong></p>
<pre><code class="lang-csharp">protected virtual bool OnBeforeLoad(ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause, bool fromCollection)
</code></pre>
<p>Sie wird aufgerufen, bevor an der Component / Collection ein <a href="#load-">Load()</a> oder an der Component ein GetFetchNext() ausgeführt wird.</p>
<p>Der Aufruf erfolgt vor <code>GlobalOnBeforeLoad( )</code>.</p>
<p>Beim Aufruf aus der Collection wird im Parameter <strong>fromCollection</strong> <code>true</code> übergeben. So kann bei Bedarf entsprechend reagiert werden. Es ist jedoch empfehlenswert, die Load-Condition nur einmal zentral in der Component zu erweitern.</p>
<p>Der Aufruf folgt nach dem Aufruf der OnBeforeLoad-Method in der Collection.</p>
<p><strong>Data-Collection:</strong></p>
<pre><code class="lang-csharp">protected virtual bool OnBeforeLoad(ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause)
</code></pre>
<p>Sie wird aufgerufen, bevor an der Collection ein Load( ) ausgeführt wird.</p>
<p>Der Aufruf erfolgt vor <code>GlobalOnBeforeLoad( )</code>.</p>
<p>Nach dieser Methode ruft die Collection auch an der Component die Methode OnBeforeLoad() auf. Dazu wird temporär ein neues leeres Objekt erzeugt.</p>
<h2 id="onbeforesave-">OnBeforeSave( )</h2>
<p>Verfügbar für Component / Collection.</p>
<pre><code class="lang-csharp">protected virtual bool OnBeforeSave()
</code></pre>
<p>Diese Methode kann in der Component / Collection überschrieben werden.</p>
<p>Siehe auch <a href="#loadcount-">LoadCount()</a></p>
<p>Verfügbar an Component / Collection</p>
<pre><code class="lang-csharp">public int LoadCount(string loadCondition)
</code></pre>
<p>Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert.
<strong>Save( )</strong></p>
<h2 id="onbeforesavecustom-">OnBeforeSaveCustom( )</h2>
<p>Verfügbar für Component / Collection.</p>
<pre><code class="lang-csharp">protected virtual bool OnBeforeSaveCustom()
</code></pre>
<p>Diese Methode kann in der Component / Collection überschrieben werden.</p>
<p>Siehe auch <a href="#loadcount-">LoadCount()</a></p>
<p>Verfügbar an Component / Collection</p>
<pre><code class="lang-csharp">public int LoadCount(string loadCondition)
</code></pre>
<p>Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert.
<strong>Save( )</strong></p>
<h2 id="onbeforesaveaction-">OnBeforeSaveAction( )</h2>
<p>Verfügbar für Component.</p>
<pre><code class="lang-csharp">protected virtual void OnBeforeSaveAction()
</code></pre>
<p>Diese Methode kann in der Component überschrieben werden. Standardmäßig ruft diese Methode <code>this.Global.ocGlobal.GlobalOnBeforeSaveAction()</code> auf.</p>
<p>Siehe auch <a href="#loadcount-">LoadCount()</a></p>
<p>Verfügbar an Component / Collection</p>
<pre><code class="lang-csharp">public int LoadCount(string loadCondition)
</code></pre>
<p>Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert.
<strong>Save( )</strong></p>
<h2 id="onaftersave-">OnAfterSave( )</h2>
<p>Verfügbar für Component / Collection.</p>
<pre><code class="lang-csharp">protected virtual void OnAfterSave()
</code></pre>
<p>Diese Methode kann in der Component / Collection überschrieben werden.</p>
<p>Wird nach dem Speichern aufgerufen.</p>
<p>Siehe auch <a href="#loadcount-">LoadCount()</a></p>
<p>Verfügbar an Component / Collection</p>
<pre><code class="lang-csharp">public int LoadCount(string loadCondition)
</code></pre>
<p>Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert.
<strong>Save( )</strong></p>
<h2 id="onaftersavecustom-">OnAfterSaveCustom( )</h2>
<p>Verfügbar für Component / Collection.</p>
<pre><code class="lang-csharp">protected virtual void OnAfterSaveCustom()
</code></pre>
<p>Diese Methode kann in der Component / Collection überschrieben werden.</p>
<h2 id="loadcount--1">LoadCount( )</h2>
<p>Verfügbar an Component / Collection</p>
<pre><code class="lang-csharp">public int LoadCount(string loadCondition)
</code></pre>
<p>Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert.
<strong>Save( )</strong></p>
<h2 id="onafterinit-">OnAfterInit( )</h2>
<p>Verfügbar für Component / Collection</p>
<pre><code class="lang-csharp">protected virtual void OnAfterInit( )
</code></pre>
<p>Diese Methode kann in der Component / Collection überschrieben werden.</p>
<p>Sie wird aufgerufen, direkt nachdem die Component / Collection instanziiert wurde. Hier können Werte vorbelegt werden, die man ansonsten in einem Konstruktor setzen würde.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>Innerhalb dieser Methode darf kein Load, Save oder sonst eine Datenbank-Aktion ausgeführt werden.</p>
</div>
<p><strong>Hintergrund:</strong> Es kann sein, dass die Methode aufgerufen wird, wenn eine Component im Rahmen eines Collection-Loads instanziiert wird. In diesem Fall ist bereits ein Datareader auf der Datenbank geöffnet. Eine Datenbank-Aktion würde zu einer Exception führen.</p>
<h2 id="onafterload-">OnAfterLoad( )</h2>
<p>Verfügbar für Component</p>
<pre><code class="lang-csharp">protected virtual void OnAfterLoad( )
</code></pre>
<p>Diese Methode kann in der Component überschrieben werden.</p>
<p>Sie wird aufgerufen, nachdem der Inhalt der Component aus der Datenbank gelesen wurde.</p>
<h2 id="gettablename-">GetTableName( )</h2>
<p>Verfügbar für Component</p>
<pre><code class="lang-csharp">public virtual string GetTableName(string propName)
</code></pre>
<p>Gibt den Tabellennamen eines bestimmten Properties zurück. Falls es das Property nicht gibt bzw. das Property nicht mit einer Datenbankspalte verknüpft ist, wird String.Empty zurückgegeben.</p>
<h2 id="getdefaultlabel-">GetDefaultLabel( )</h2>
<p>Verfügbar für Component.</p>
<pre><code class="lang-csharp">public string GetDefaultLabel(string propName)
</code></pre>
<p>Gibt das Default-Label eines bestimmten Properties zurück. Falls es das Property nicht gibt, wird String.Empty zurückgegeben.</p>
<p>Das Label wird in der aktuellen Sprache zurückgegeben.</p>
<h2 id="getpropertymdt-">GetPropertyMdt( )</h2>
<p>Verfügbar an Component / Collection</p>
<pre><code class="lang-csharp">public MLContainer GetPropertyMdt(string propertyName)
</code></pre>
<p>Ermittelt den Metadatentyp des Properties propertyName. Sie ermöglicht dynamisch den Zugriff auf die mdt_-Properties der Factory-Klasse.</p>
<p>Siehe auch Abschnitt Metadaten von Properties.</p>
<p>Die öffentlichen Properties können mit dem Property  ComponentProperties ermittelt werden.</p>
<h2 id="getproperty-">GetProperty( )</h2>
<p>Verfügbar für Component.</p>
<pre><code class="lang-csharp">public virtual object GetProperty(string propertyName)
</code></pre>
<p>Ermittelt den Wert des öffentlichen Properties propertyName.</p>
<p>Die öffentlichen Properties können mit dem Property  ComponentProperties ermittelt werden.</p>
<h2 id="savecallentrypointsallways-">SaveCallEntryPointsAllways( )</h2>
<pre><code class="lang-csharp">public void SaveCallEntryPointsAllways( )
</code></pre>
<h2 id="aufruf-der-loadcount-">Aufruf der LoadCount( )</h2>
<p>Verfügbar an Component / Collection</p>
<pre><code class="lang-csharp">public int LoadCount(string loadCondition)
</code></pre>
<p>Ermittelt die Anzahl der Datensätze für die übergebene Load-Condition. Der Zustand des Objektes bzw. der Collection bleibt dabei unverändert.</p>
<p><a href="#save-">Save()</a> Methode, wobei die Entry-Points auch durchlaufen werden, wenn der Status der Komponente Unchanged ist.</p>
<h2 id="markfordeletion-">MarkForDeletion( )</h2>
<p>Verfügbar an Component</p>
<pre><code class="lang-csharp">public void MarkForDeletion( )
</code></pre>
<p>Mit dieser Methode wird dem Property <a href="#statebeforeupdate">StateBeforeUpdate</a></p>
<p>Verfügbar für Component.</p>
<pre><code class="lang-csharp">public FrameworkComponentState StateBeforeUpdate {get, set}
</code></pre>
<p>Dieses Property übernimmt den Wert des Properies <a href="#state">State</a> direkt bevor im Save der Datenbank-Befehl ausgeführt wird. Dieser Wert bleibt bis zum nächsten <a href="#save-">Save()</a> erhalten.</p>
<p>Somit steht in den Methoden <a href="#onaftersave-">OnAfterSave()</a> und <a href="#onaftersavecustom-">OnAfterSaveCustom()</a> bzw. nach einem Save-Vorgang der Status der Component weiterhin zur Verfügung. Das Property State hingegen nimmt nach der Datenbank-Aktion den Wert Unchanged an.</p>
<p>In den Methoden <a href="#onbeforesave-">OnBeforeSave()</a> und <a href="#onbeforesavecustom-">OnBeforeSaveCustom()</a> hat dieses Property keinen klar definierten Wert.
IsMarkedForDeletion der Wert true zugewiesen.</p>
<p>An der dazugehörigen Collection können anschließend mit der Methode die markierten Objekte aus der Collection gelöscht werden.</p>
<h2 id="deletemarkedobjects-">DeleteMarkedObjects( )</h2>
<p>Verfügbar in Collection</p>
<pre><code class="lang-csharp">public void DeleteMarkedObjects( )
</code></pre>
<p>Mit dieser Methode wird an allen Objekten der Collection, in denen das Property StateBeforeUpdate</p>
<p>Verfügbar für Component.</p>
<pre><code class="lang-csharp">public FrameworkComponentState StateBeforeUpdate {get, set}
</code></pre>
<p>Dieses Property übernimmt den Wert des Properies <a href="#state">State</a> direkt bevor im Save der Datenbank-Befehl ausgeführt wird. Dieser Wert bleibt bis zum nächsten <a href="#save-">Save()</a> erhalten.</p>
<p>Somit steht in den Methoden <a href="#onaftersave-">OnAfterSave()</a> und <a href="#onaftersavecustom-">OnAfterSaveCustom()</a> bzw. nach einem Save-Vorgang der Status der Component weiterhin zur Verfügung. Das Property <a href="#state">State</a> hingegen nimmt nach der Datenbank-Aktion den Wert <strong>Unchanged</strong> an.</p>
<p>In den Methoden <a href="#onbeforesave-">OnBeforeSave()</a> und <a href="#onbeforesavecustom-">OnBeforeSaveCustom()</a> hat dieses Property keinen klar definierten Wert.
IsMarkedForDeletion den Wert true hat, die Methode <a href="#delete-">Delete()</a> ausgeführt.</p>
<h2 id="remove-">Remove( )</h2>
<p>Verfügbar in Collection</p>
<p>Diese Methode entfernt Objekte aus der Collection. Der Status des entfernten Objektes wird dabei auf <strong>Deleted</strong> gesetzt. D.h., ein <code>Save()</code> hätte ggf. einen physischen Delete auf der Datenbank zur Folge.</p>
<p>Diese Methode ist funktional identisch mit der Methode Delete( ).</p>
<pre><code class="lang-csharp">public void Remove( Object )
</code></pre>
<p>Entfernt das übergebene Objekt aus der Collection.</p>
<pre><code class="lang-csharp">public void Remove( SelectedRowsCollection )
</code></pre>
<p>Entfernt alle in der übergebenen SelectedRowsCollection angegebenen Objekte aus der Collection.</p>
<h2 id="drop-">Drop( )</h2>
<p>Verfügbar in Collection</p>
<p>Diese Methode trennt Objekte aus der Collection heraus. Dabei bleibt der Status der Objekte erhalten.</p>
<pre><code class="lang-csharp">public void Drop( guid )
</code></pre>
<p>Entfernt das mit der übergebenen Guid definierte Objekt aus der Collection.</p>
<pre><code class="lang-csharp">public void Drop( DevFrameworkObject )
</code></pre>
<p>Entfernt das übergebene Objekt aus der Collection.</p>
<pre><code class="lang-csharp">public void Drop( SelectedRowsCollection )
</code></pre>
<p>Entfernt alle Komponenten aus der Collection, deren IDs in der übergebenen SelectedRowsCollection enthalten sind.</p>
<h2 id="dispose-">Dispose( )</h2>
<p>Verfügbar in Collection</p>
<p>Die Collection wird geleert und alle verwendeten Ressourcen freigegeben. Nach dieser Operation kann die Collection nicht mehr verwendet werden.</p>
<h2 id="add-">Add( )</h2>
<p>Verfügbar in Collection</p>
<p>Diese Methode fügt ein Objekt in die Collection ein. Es wird die Index-Position des Objektes zurückgegeben.</p>
<pre><code class="lang-csharp">public int Add( object )
</code></pre>
<p>Am eingefügten Objekt wird die Collection-Eigenschaft auf die neue Collection geändert.</p>
<pre><code class="lang-csharp">public int Add( object, bool setCollection )
</code></pre>
<p>Wenn der Parameter setCollection mit false angegeben wird, dann wird die Collection-Eigenschaft des Objektes nicht verändert.</p>
<h2 id="addrange">AddRange()</h2>
<p>Verfügbar in Collection</p>
<p>Diese Methode fügt mehrere Objekte in die Collection ein. Sie können dieser Methode ganze Collections übergeben. So ist es beispielsweise möglich, zwei Collections zusammenzuführen.</p>
<p>Die Methode hat als Parameter den Typ <code>IEnumerable&lt;DevFrameworkObject&gt;</code>. So können auch generische Listen übergeben werden, die z.B. mit einer Linq-Query ermittelt wurden.</p>
<pre><code class="lang-csharp">public void AddRange(IEnumerable&lt;DevFrameworkObject&gt; value)
</code></pre>
<p>An allen hinzugefügten Elementen wird die die Collection-Eigenschaft auf die neue Collection geändert.</p>
<pre><code class="lang-csharp">public void AddRange(IEnumerable&lt;DevFrameworkObject&gt; value, Boolean setCollection)
</code></pre>
<p>Wenn der Parameter setCollection mit false angegeben wird, dann wird die Collection-Eigenschaft der hinzugefügten Objekte nicht verändert.</p>
<h2 id="insert-">Insert( )</h2>
<p>Verfügbar an Collection</p>
<p>Fügt ein Objekt an eine bestimmte Position in die Collection ein.</p>
<pre><code class="lang-csharp">public int Insert( int index, object )
</code></pre>
<p>Mit Index 0 wird das Objekt am Anfang der Collection eingefügt. Mit Index größer oder gleich Collection.Count wird das Objekt am Ende der Collection eingefügt.</p>
<p>Am eingefügten Objekt wird die Collection-Eigenschaft auf die neue Collection geändert.</p>
<pre><code class="lang-csharp">public int Insert( int index, object, bool setCollection )
</code></pre>
<p>Wenn der Parameter setCollection mit false angegeben wird, dann wird die Collection-Eigenschaft des Objektes nicht verändert.</p>
<h2 id="moveitem">MoveItem()</h2>
<p>Verfügbar an Collection</p>
<pre><code class="lang-csharp">int Collection.MoveItem(DevFrameworkObject itemToMove, int indexDelta)
</code></pre>
<p>Verschiebt den übergebenen Eintrag und gibt den neuen Index des verschobenen Eintrags zurück. Der Parameter indexDelta gibt an, wie weit der Eintrag verschoben werden soll. Bei negativen Werten wird nach oben und bei positiven Werten nach unten verschoben. Wird ein Wert angegeben, der die Grenzen der Collection sprengt, dann wird der Eintrag maximal an die Grenze der Collection (Anfang oder Ende) verschoben.</p>
<p>Wird ein Eintrag übergeben, der nicht Bestandteil der Collection ist, dann wird eine Exception geworfen.</p>
<p>Beispiel:</p>
<pre><code class="lang-csharp">// verschiebt den ausgewählten Artikel einen Eintrag nach oben
this.oArticleColl.MoveItem(this.oArticleSelected, -1);

// verschiebt den ausgewählten Artikel 2 Einträge nach unten
this.oArticleColl.MoveItem(this.oArticleSelected, 2);
</code></pre>
<h2 id="moveitemto">MoveItemTo()</h2>
<p>Verfügbar an Collection</p>
<pre><code class="lang-csharp">void Collection.MoveItemTo(DevFrameworkObject itemToMove, int targetIndex)
</code></pre>
<p>Verschiebt den übergebenen Eintrag an eine bestimmte Stelle. Der Parameter targetIndex gibt den Index an, an den der Eintrag verschoben werden soll.</p>
<p>Wird ein Eintrag übergeben, der nicht Bestandteil der Collection ist, dann wird eine Exception geworfen.</p>
<p>Beispiel:</p>
<pre><code class="lang-csharp">// verschiebt den ausgewählten Artikel an den Anfang der Collection
this.oArticleColl.MoveItemTo(this.oArticleSelected, 0);
</code></pre>
<h2 id="createnewrecord-">CreateNewRecord( )</h2>
<p>Verfügbar an Collection</p>
<pre><code class="lang-csharp">DevFrameworkObject Collection.CreateNewRecord()
</code></pre>
<p>Erzeugt passend zur Collection einen neuen Record. Der Rückgabetyp ist DevFrameworkObject bzw. IDevFrameworkObject. Es muss ggf. ein entsprechender cast eingebaut werden.</p>
<p>Beispiel:</p>
<pre><code class="lang-csharp">IcdCustomer oCustomerNew = this.oCustomerColl.CreateNewRecord() as IcdCustomer;
</code></pre>
<h2 id="newrecord-">NewRecord( )</h2>
<p>Verfügbar an Collection</p>
<pre><code class="lang-csharp">DevFrameworkObject Collection.NewRecord()
</code></pre>
<p>Erzeugt passend zur Collection einen neuen Record und fügt ihn am Ende der Collection ein. Der Rückgabetyp ist DevFrameworkObject bzw. IDevFramerworkObject. Es muss ggf. ein entsprechender cast eingebaut werden.</p>
<p>Beispiel:</p>
<pre><code class="lang-csharp">IcdCustomer oCustomerNew = this.oCustomerColl.NewRecord() as IcdCustomer;
</code></pre>
<h2 id="updaterelationkey-">UpdateRelationKey( )</h2>
<p>Verfügbar innerhalb von Component und Collection</p>
<pre><code class="lang-csharp">protected bool UpdateRelationKey(string propertyName, string key)
</code></pre>
<p>Diese Funktion speichert an der Instanz der Component bzw. der Collection pro übergebenem Property-Namen einen Schlüssel. Dabei wird geprüft, ob sich der Schlüssel gegenüber dem letzten Aufruf dieser Funktion geändert hat. Bei einer Änderung wird true zurückgegeben. Wenn sich der Schlüssel nicht geändert hat, wird false zurückgegeben.</p>
<p>Diese Funktion kann z.B. dazu verwendet werden, um in Individual Properties bei der Änderung eines Schlüssel-Wertes einen Reload zu veranlassen.</p>
<p>Die Funktion ist protected und kann somit nur innerhalb der Component bzw. der Collection verwendet werden.</p>
<p>Beispiel:</p>
<pre><code class="lang-csharp">// Get-Methode des Individual Properties &quot;oCustomerIndiv&quot;

if (this.oCustomerMember == null)
{
    this.oCustomerMember = cdCustomerFactory.Create(this.Global);
}

String sWhere = &quot;[lngCustomerID] = &quot; + DB.SqlString(this.lngCustomerID);
if (this.UpdateRelationKey(&quot;oCustomerIndiv&quot;, sWhere)
{
    // Die Suchbedingung – also der Key – hat sich geändert. ==&gt; Reload
    this. oCustomerMember.Load(sWhere);
}
return this.oCustomerMember;
</code></pre>
<h2 id="setcommandtimeout-">SetCommandTimeout( )</h2>
<p>Verfügbar an Data-Collection</p>
<pre><code class="lang-csharp">public void SetCommandTimeout(int seconds)
</code></pre>
<p>Damit kann vor einem Load der Timeout des SQL-Commands gesetzt werden.</p>
<p>In Framework Studio haben alle Commands per Default einen Timeout von 300 Sekunden. Wenn ein Statement längere Zeit benötigt, dann führt das zu einer Exception. Das kann in seltenen Fällen bei komplexen Statements auf großen Datenbeständen der Fall sein.</p>
<p>Mit dem Wert 0 wird der Timeout komplett deaktiviert. Das bedeutet, dass das Statement im schlimmsten Fall <strong>endlos</strong> laufen kann.</p>
<p>Beispiel:</p>
<pre><code class="lang-csharp">// Timeout deaktivieren
this.oCollection.SetCommandTimeout(0);
// Daten lesen.
this.oCollection.Load(&quot;&lt;very complex condition&gt;&quot;);
</code></pre>
<h2 id="properties-in-jeder-component--collection">Properties in jeder Component / Collection</h2>
<h3 id="componentproperties">ComponentProperties</h3>
<p>Verfügbar für Component.</p>
<pre><code class="lang-csharp">public virtual System.Collections.Specialized.StringCollection ComponentProperties {get}
</code></pre>
<p>Gibt eine Liste mit den Namen aller Properties zurück.</p>
<p>Es werden nur Properties ausgegeben, die public sind.</p>
<p>Diese Namen kann man mit verschiedenen Methoden verwenden.
Z.B:</p>
<ul>
<li><code>GetProperty( )</code></li>
<li><code>GetDefaultLabel( )</code></li>
</ul>
<h4 id="state">State</h4>
<p>Verfügbar für Component.</p>
<pre><code class="lang-csharp">public FrameworkComponentState State {get, set}
</code></pre>
<p>Status der Komponente. Dieser kann z.B. im <code>OnBeforeSave()</code> ausgewertet werden.</p>
<p>Mit dem Ausführen der Datenbank-Aktion erhält das Property den Wert <strong>Unchanged</strong> bzw. <strong>UnchangedButDeleted</strong>. Im <strong>OnAfterSave()</strong> bzw. nach dem <strong>Save()</strong> kann der ursprüngliche Wert über das Property <strong>StateBeforeUpdate</strong> erfragt werden.</p>
<p>Das Enum FrameworkComponentState hat folgende Werte:</p>
<p><strong>New:</strong></p>
<p>Die Komponente wurde instanziiert und es wurden keine Daten mit Load() eingelesen. Werden Properties in dieser Komponente geändert, bleibt der Status weiterhin <strong>New</strong>.
Ein Save() führt einen Insert-Befehl auf der Datenbank aus.</p>
<p><strong>Unchanged:</strong></p>
<p>Die Komponente wurde mit Load() eingelesen und die Daten wurden danach nicht verändert.
Ein Save() führt keine Aktion auf der Datenbank aus.</p>
<p><strong>Changed:</strong></p>
<p>Die Komponente wurde mit Load() eingelesen und der Wert mindestens eines Properties wurde geändert.
Ein Save() führt einen Update-Befehl auf der Datenbank aus.</p>
<p>Soll ein Insert-Befehl erzwungen werden, muss der Status manuell auf <strong>New</strong> gesetzt werden.</p>
<p><strong>Deleted:</strong></p>
<p>Die Komponente wurde mit Load() eingelesen und es wurde die Methode Delete() aufgerufen.
Ein Save() führt einen Delete-Befehl auf der Datenbank aus.</p>
<p><strong>NewButDeleted:</strong></p>
<p>Die Komponente wurde mit einem new() erstellt und es wurde die Methode Delete() aufgerufen.
Ein Save() führt keine Aktion auf der Datenbank aus.</p>
<p><strong>UnchangedButDeleted:</strong></p>
<p>Nachdem die Methode Delete() aufgerufen und mit <a href="#save-">Save()</a> der Delete-Befehl auf der Datenbank ausgeführt wurde, erhält die Komponente diesen Status.
Ein weiterer <a href="#save-">Save()</a> führt keine Aktion auf der Datenbank aus.</p>
<p>Wird der Wert eines Properties geändert, behält die Component diesen Status – er wird nicht auf Changed gesetzt.</p>
<h4 id="statebeforeupdate">StateBeforeUpdate</h4>
<p>Verfügbar für Component.</p>
<pre><code class="lang-csharp">public FrameworkComponentState StateBeforeUpdate {get, set}
</code></pre>
<p>Dieses Property übernimmt den Wert des Properies  State direkt bevor im Save der Datenbank-Befehl ausgeführt wird. Dieser Wert bleibt bis zum nächsten Save() erhalten.</p>
<p>Somit steht in den Methoden <a href="#save-">OnAfterSave()</a> und <a href="#onaftersavecustom-">OnAfterSaveCustom()</a> bzw. nach einem Save-Vorgang der Status der Component weiterhin zur Verfügung. Das Property State hingegen nimmt nach der Datenbank-Aktion den Wert Unchanged an.</p>
<p>In den Methoden <a href="#onbeforesave-">OnBeforeSave()</a> und <a href="#onbeforesavecustom-">OnBeforeSaveCustom()</a> hat dieses Property keinen klar definierten Wert.</p>
<h4 id="ismarkedfordeletion">IsMarkedForDeletion</h4>
<p>Verfügbar für Component.</p>
<pre><code class="lang-csharp">public bool IsMarkedForDeletion {get, set}
</code></pre>
<p>Über dieses Property ist es möglich, ein mehrstufiges Löschen zu realisieren. Das ist notwendig, wenn z.B. die Datensätze in einem Grid zum Löschen markiert werden sollen, bevor sie gelöscht werden. Wenn Sie die Methode Delete( ) verwenden, werden die entsprechende Zeilen im Grid nicht mehr angezeigt.
Dieses Property ist vor allem dann interessant, wenn die Component in einer Collection verarbeitet wird.</p>
<p>Wenn an mindestens einem Element in einer Collection diese Eigenschaft true ist, dann liefert Collection.<strong>IsModified</strong> den Wert true.</p>
<p>Ist IsMarkedForDeletion true, dann wird im Grid in der entsprechenden Zeile das im Grid-Property RowDeletedIcon hinterlegte Icon angezeigt. (siehe Grid Properties)</p>
<p>Mit der Methode <strong>DeleteMarkedObjects</strong> an der entsprechenden Collection wird an jedem Objekt, an dem das Property den Wert true hat, ein Delete aufgerufen.</p>
<h4 id="ismodified">IsModified</h4>
<p>Verfügbar für Component und Collection.</p>
<p>Component:</p>
<pre><code class="lang-csharp">public bool IsModified {get}
</code></pre>
<p><strong>IsModified</strong> ist <code>true</code>, wenn <strong>State</strong> nicht den Wert <strong>Unchanged</strong> hat. Insbesondere gilt somit für neue Components (State=New) <strong>IsModified</strong> = <strong>true</strong>.</p>
<p>Collection:</p>
<pre><code class="lang-csharp">public bool IsModified {get}
</code></pre>
<p><strong>IsModified</strong> ist <code>true</code>, wenn bei mindestens einem Element der Liste die Eigenschaft <strong>IsModified</strong> den Wert <code>true</code> hat oder mindestens ein Element gelöscht oder zum Löschen markiert (<strong>IsMarkedForDeletion</strong>) wurde.</p>
<h4 id="loadsize">LoadSize</h4>
<p>Verfügbar für Collection mit Datenbank-Bezug</p>
<p>Über dieses Property kann zur Laufzeit festgelegt werden, für wie viele Datensätze beim ersten Laden die Komponenten direkt instanziiert werden sollen. Für alle weiteren Datensätze wird zunächst nur der Primärschlüssel verwaltet. Durch den automatischen Nachlademechanismus werden die Komponenten dann beim ersten Zugriff automatisch nachgeladen und instanziiert.</p>
<p>Wenn dieses Property auf einen Wert kleiner oder gleich Null gesetzt wird, werden direkt alle Komponenten instanziiert. Ein Nachladen ist dann nicht mehr nötig. Dies ist vor Allem dann sinnvoll, wenn anschließend ohnehin auf alle Components der Collection zugegriffen wird, beispielsweise durch eine foreach Schleife.</p>
<h4 id="loadmaxcount">LoadMaxCount</h4>
<p>Verfügbar für Collection mit Datenbank-Bezug.</p>
<p>Dieses Property gibt an, wie viele Datensätze maximal eingelesen werden sollen.</p>
<p>Es muss gesetzt werden, bevor der Load ausgeführt wird.</p>
<p>Der Standardwert ist 0. Das bedeutet keine Begrenzung.</p>
<pre><code class="lang-csharp">// Beispiel: nur die ersten 30 Sätze lesen:

this.oContactHistoryColl = new cdContactHistoryColl(this.Global);
this.oContactHistoryColl.LoadMaxCount = 30;
this.oContactHistoryColl.Load( this.sWhereClause );
</code></pre>
<p>Das bringt bei sehr großen Datenmengen einen Geschwindigkeits-Vorteil.</p>
<p>Dieses Property hat keinen Einfluss auf das an die Datenbank geschickte Statement. Die Datenbank liefert bei dem ausgeführten Select alle Datensätze.</p>
<p>Die Collection bricht bei Erreichen der Grenze die Verarbeitung ab. Dadurch müssen die <strong>überflüssigen</strong> Primary-Key-Informationen nicht eingelesen werden. Bei sehr vielen Treffern entlastet das auch den Hauptspeicher erheblich.</p>
<p>Noch besser ist es, wenn es möglich ist, die Suchbedingung so zu formulieren, dass die Datenbank-Abfrage nicht zu viele Treffer liefert. Dadurch ist der Performance-Gewinn deutlich größer durch setzen dieses Properties.</p>
<p>Besonders groß ist der Effekt, wenn die Datenbank-Abfrage eine Sortierung beinhaltet. Denn trotz dem Setzen dieses Properties muss die Datenbank alle Treffer sortieren.</p>
<h3 id="metadaten-von-properties">Metadaten von Properties</h3>
<p>Zur Laufzeit kann der Entwickler auf die Metadatentyp-Informationen der Properties zugreifen. Dafür stehen folgende Möglichkeiten zur Verfügung:</p>
<ol>
<li>Über die Factory-Klasse</li>
<li>Mit der Methode GetPropertyMdt</li>
</ol>
<p>Die Factory-Klasse, welche mit den Interfaces kompiliert werden, bietet für jedes Component-Property eine Eigenschaft mdt_... an, welche eine Instanz mit den Metadatentyp-Informationen zurückgibt.</p>
<p>Beispiel: An der Component cdArticle gibt es ein Property sArticleID.</p>
<pre><code class="lang-csharp">int intMaxSize = cdArticleFactory.mdt_sArticleID.Size;
</code></pre>
<p>Mit der Methode <a href="#getpropertymdt-">GetPropertyMdt()</a> kann mithilfe des Property-Namen die Metadatentyp-Information ermittelt werden. Das ermöglicht auch die Arbeit auf der Ebene DevFrameworkObject.</p>
<h4 id="beispiel">Beispiel</h4>
<pre><code class="lang-csharp">MLContainer mdt = oArticle.GetPropertyMdt(&quot;sArticleID&quot;);
if (mdt is MDTStringBase)
{
    int intSize = ((MDTStringBase)mdt).Size;
}
</code></pre>
<p>Folgende Basis-Klassen liegen den Metadatetypen zugrunde:</p>
<table>
<thead>
<tr>
<th>Klasse-Hierarchie</th>
<th>Verwendung (Properties)</th>
</tr>
</thead>
<tbody>
<tr>
<td>MLContainer</td>
<td>Allgemeine Basis. Sie wird für Properties verwendet, die keinen Metadatentyp besitzen: DefaultLabel / MLColumnCaption / MLToolTip/ DragSource</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>MetadatatypeBase</td>
<td>Basis für alle Metadatentypen:  FormatPattern /  FormatMask</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>MDTStringBase</td>
<td>Basis für Strings (FSstring): Size/ Values</td>
</tr>
<tr>
<td>MDTBoolBase</td>
<td>Basis für Booleans (FSbool): Values</td>
</tr>
<tr>
<td>MDTByteArrayBase</td>
<td>Basis für Byte-Arrays (FSByteArray): Values</td>
</tr>
<tr>
<td>MDTDateTimeBase</td>
<td>Basis für DateTime (FSDateTime): Values</td>
</tr>
<tr>
<td>MetadatatypeNumberBase</td>
<td>Allgemeine Basis für Numerische Metadatentypen: Precision/ Scale</td>
</tr>
<tr>
<td>MDTByteBase</td>
<td>Basis für Byte (FSbyte): Values</td>
</tr>
<tr>
<td>MDTDecimalBase</td>
<td>Basis für Decimal (FSdecimal): Values</td>
</tr>
<tr>
<td>MDTDoubleBase</td>
<td>Basis für Double (FSdouble): Values</td>
</tr>
<tr>
<td>MDTFloatBase</td>
<td>Basis für Float (FSfloat): Values</td>
</tr>
<tr>
<td>MDTIntBase</td>
<td>Basis für Int (FSint): Values</td>
</tr>
<tr>
<td>MDTLongBase</td>
<td>Basis für Long (FSlong): Values</td>
</tr>
<tr>
<td>MDTShortBase</td>
<td>Basis für Short (FSshort): Values</td>
</tr>
</tbody>
</table>
<h4 id="beschreibungen-der-og-properties">Beschreibungen der o.g. Properties</h4>
<p><strong>DevMLString DefaultLabel:</strong>
Das mehrsprachige Default-Label</p>
<p><strong>DevMLString MLColumnCaption:</strong>
Die mehrsprachige Spalten-Beschriftung. Wenn diese nicht gepflegt ist, wird DefaultLabel zurückgegeben.</p>
<p><strong>DevMLString MLToolTip:</strong>
Der mehrsprachige Tooltip.</p>
<p><strong>int Precision:</strong>
Anzahl von Nachkommastellen; wird nur bei numerischen Typen angeboten.</p>
<p><strong>int Scale:</strong>
Maximale Anzahl von Stellen inkl. Nachkommastellen. Wird nur bei numerischen Typen angeboten.</p>
<p><strong>int Size:</strong>
Maximale Länge eines Strings.</p>
<p><strong>FrameworkFormatMask FormatMask:</strong> Gibt einen Wert mit dem Typ <strong>FrameworkFormatMask</strong> zurück. Dieses Enum kann folgende Werte beinhalten:</p>
<ul>
<li>FrameworkFormatMask.None</li>
<li>FrameworkFormatMask.LowerCase</li>
<li>FrameworkFormatMask.UpperCase</li>
<li>FrameworkFormatMask.DateOnlyShort</li>
<li>FrameworkFormatMask.DateOnlyMedium</li>
<li>FrameworkFormatMask.DateOnlyLong</li>
<li>FrameworkFormatMask.DateTimeShort</li>
<li>FrameworkFormatMask.DateTimeMedium</li>
<li>FrameworkFormatMask.DateTimeLong</li>
<li>FrameworkFormatMask.TimeOnlyShort</li>
<li>FrameworkFormatMask.TimeOnlyMedium</li>
<li>FrameworkFormatMask.TimeOnlyLong</li>
<li>FrameworkFormatMask.Decimal</li>
<li>FrameworkFormatMask.Integer</li>
<li>FrameworkFormatMask.PositiveInteger</li>
<li>FrameworkFormatMask.NegativeInteger</li>
<li>FrameworkFormatMask.UserDefined</li>
</ul>
<p><strong>string FormatPattern:</strong>
Ein individuelles Format-Pattern. Dieses kann z.B. bei numerischen Typen für die Formatierung von Zahlen in Strings verwendet werden.
Bei FSstrings handelt es sich um einen regulären Ausdruck.</p>
<p><strong><typ>[,] Values:</typ></strong>
Dieser Array beinhaltet die im Metadatentyp vorgenommenen Value-Einschränkungen.
Die erste Dimension des Arrays bildet die einzelnen Einschränkungen ab.
In der 2. Dimension sind der Von- und der Bis-Wert enthalten. Wenn nur der Von-Wert definiert wurde, dann steht dieser auch im Bis-Wert.</p>
<p>Beispiel: <strong>A</strong>, <strong>B</strong>, <strong>E</strong>-<strong>G</strong> bildet folgendes Array</p>
<pre><code class="lang-csharp">new string[,] {
    {@&quot;A&quot;, @&quot;A&quot;},
    {@&quot;C&quot;, @&quot;C&quot;},
    {@&quot;E&quot;, @&quot;G&quot;} };
</code></pre>
<h2 id="kopieren--mergen-kompletter-components">Kopieren / Mergen kompletter Components</h2>
<p>Es ist möglich, komplette Components zu kopieren oder auch zusammenzuführen. Das funktioniert auch, wenn es sich bei Quelle und Ziel um unterschiedliche Repositories handelt.</p>
<p>Zu beachten ist, dass der Dialog sehr viele Freiheiten bietet. Dies ermöglicht natürlich auch fehlerhafte Stände zu erstellen. Dieser Mechanismus ist für versierte Benutzer konzipiert. Grundsätzlich sollte der Benutzer wissen, was er tut und VOR der Aktion sicherstellen, dass alle von der Component benötigten Elemente am Ziel vorhanden sind.</p>
<h3 id="aktionen">Aktionen</h3>
<ul>
<li><p>Eine Component kann über das Kontext Menü an der Component kopiert werden.</p>
</li>
<li><p>Eine Component kann über das Kontext Menü am Namespace eingefügt werden.</p>
</li>
<li><p>Eine Component kann über das Kontext Menü an der Component gemerged (zusammengeführt) werden.</p>
</li>
</ul>
<h3 id="einfügen">Einfügen</h3>
<p>Wird eine Component ohne Basis kopiert, kann diese überall eingefügt werden. Eine Customization wiederrum kann nur erstellt werden, wenn im Package noch keine Customization vorhanden ist und die passende Basis existiert.</p>
<h3 id="dialog">Dialog</h3>
<h4 id="registerkarte-summary">Registerkarte Summary</h4>
<p>Die Summary zeigt, ob beim Paste oder Merge Konflikte gefunden wurden.</p>
<p>MergeDialog - Summary
<img src="media/registerkarte-methods-merge-dialog.png" alt="MergeDialog - Summary"></p>
<p>Framework Studio versucht bei der Aktion die benötigten Elemente im Ziel-Package auf zwei verschiedenen Wegen zu finden:</p>
<ol>
<li><p>Über die interne ID: Das funktioniert meist dann, wenn Quell- und Ziel-Package identisch sind oder wenn Elemente aus einem gemeinsamen Basis-Package verwendet werden.</p>
</li>
<li><p>Über den Namen: Wenn über die ID nichts gefunden wird, wird nach einem gleichnamigen Element (z.B. Metadatentyp, Component, Property) gesucht. Das ist vor allem dann sehr nützlich, wenn nach und nach mehrere Components in ein anderes Package kopiert werden.</p>
</li>
<li><p>Wenn diese Wege nicht zum Ziel führen, wird dies als Konflikt betrachtet und der Benutzer muss nach einer Lösung suchen. Teilweise kann das auf den folgenden Registerkarten erfolgen. Manchmal ist es aber auch nötig, die Aktion abzubrechen, erst die Voraussetzungen zu schaffen (z.B. eine DBTable anlegen) und die Aktion anschließend noch einmal auszuführen.</p>
</li>
</ol>
<p>Die anderen Registerkarte sollten also der Reihe nach – wie ein Wizard – durchgearbeitet und die entsprechenden Einstellungen vorgenommen werden, um die Aktion am Ende korrekt ausführen zu können. Die Registerkarte sind bei beiden Aktionen Paste und Merge identisch.</p>
<h3 id="registerkarte-needed-types">Registerkarte Needed Types</h3>
<p>Bei den Needed Types werden alle Typen aufgelistet, die nicht zum Standard gehören. Diese können beliebig ausgetauscht werden. Das kann z.B. dann sinnvoll sein, wenn eine benötigte Component vorher auch schon kopiert wurde und jetzt ggf. unter einem anderen Namen in einem anderen Namespace zu finden ist.</p>
<p><img src="media/registerkarte-methods-needed-types.png" alt="Registerkarte Needed Types"></p>
<h3 id="registerkarte-general">Registerkarte General</h3>
<p>Unter General können die Interfaces, die Description und die ControlTypes überschrieben werden.</p>
<p><img src="media/registerkarte-methods-merge-dialog-general.png" alt="Registerkarte General"></p>
<h3 id="registerkarte-join-tables">Registerkarte Join Tables</h3>
<p>Bei einer JoinTable stehen zwei Aktionen zur Verfügung, wenn dies nicht durch die Checkbox ignoriert wird. Ein Insert fügt eine neue JoinTable an während der Replace die Werte an der JoinTable ersetzt.</p>
<p><img src="media/registerkarte-methods-merge-dialog-join-tablesl.png" alt="Registerkarte Join Tables"></p>
<h3 id="registerkarte-virtual-columns">Registerkarte Virtual Columns</h3>
<p>Auch bei den VirtualColumns gibt es die Aktionen Replace, Insert oder Ignore. Diese verhalten sich wie bei der JoinTable.</p>
<p><img src="media/registerkarte-methods-merge-dialog-virtual-columns.png" alt="Registerkarte Virtual Columns"></p>
<h3 id="registerkarte-properties">Registerkarte Properties</h3>
<p>Ein Property bietet beim Einfügen noch die weitere Möglichkeit, den Namen anzupassen. Der Replace ersetzt alle Werte für das ausgewählte Property.</p>
<p><img src="media/registerkarte-methods-merge-dialog-properties.png" alt="Registerkarte Properties"></p>
<h3 id="registerkarte-methods-1">Registerkarte Methods</h3>
<p>Bei den Methoden ist wie bei den Properties eine Umbenennung möglich.</p>
<p><img src="media/registerkarte-methods-merge-dialog-methods.png" alt="Registerkarte Methods"></p>
<h3 id="merge">Merge</h3>
<p>Mit einem Merge kann erreicht werden, dass Änderungen an einer Component in einer Kopie davon nachgezogen werden. Was nicht möglich ist, sind gelöschte Elemente durch den Merge zu entfernen. Es werden nur neu hinzugekommene oder geänderte beachtet.</p>
<p>Für jedes Element wird in der Component das zugehörige Element gesucht und dann ein Replace vorgeschlagen. Ein Replace ändert nur dann die Daten, wenn diese sich in der kopierten Component auch geändert haben. Es kann also eine Component mit sich selbst gemerged werden und diese ist danach nicht modified, da es keine Änderungen gab.</p>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span><a href="https://www.enventa-group.com/" target="_blank" rel="noopener noreferrer nofollow"><img class="dark" src="../../media/enventa-group-logo-dark.svg" alt="enventa-group" style="height: 1.5rem"><img class="light" src="../../media/enventa-group-logo.svg" alt="enventa-group" style="height: 1.5rem"></a></span> <span style="float:right">Made with <a href="https://dotnet.github.io/docfx" target="_blank" rel="noopener noreferrer nofollow" class="external">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
