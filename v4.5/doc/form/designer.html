<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Forms </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Forms ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/FrameworkSystemsGmbH/fs/blob/4.5/dev/docs/doc/form/designer.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="forms">Forms</h1>

<p>Der <strong>Form-Designer</strong> ist ein Tool, ähnlich dem Designer in Visual Studio, in dem Sie Controls per Drag &amp; Drop auf einem Form positionieren und mit Funktionalität beleben können. Er wird entweder durch einen Doppelklick auf ein entsprechendes Form-Element auf der Registerkarte <strong>Namespaces</strong> oder durch das Erstellen eines neuen Form-Elements geöffnet.</p>
<h2 id="allgemeiner-überblick">Allgemeiner Überblick</h2>
<h3 id="kontextabhängige-registerkarten">Kontextabhängige Registerkarten</h3>
<p><img src="media/form-designer.png" alt="form-design"></p>
<p>Ist ein Form-Element geöffnet, verhalten sich die Registerkarten auf der linken Seite entsprechend diesem Kontext.</p>
<p>Die Registerkarte <strong>ClassView</strong> zeigt alle Elemente an, über die das Forum verfügt. Über die Registerkarte fügen Sie auch auf gewohnte Weise über das Kontext-Menü des Namespaces neue Properties, Methods, Reports oder Workflow-Events dem Form hinzu. Anschließend können Sie die Properties nutzen, um sie z.B. per Drag &amp; Drop auf dem Form zu positionieren.</p>
<p>Es wird entsprechend das für das Property hinterlegte Standard-Control dargestellt. Ist kein Control als Standard-Control für das Property hinterlegt, wird ein Editfield gewählt. Sind mehrere Controls hinterlegt, wird zunächst das Standard-Control angezeigt. Dieses lässt sich aber ändern, indem Sie das Control auf dem Form auswählen und aus dem Kontext-Menü des Controls den Eintrag <strong>Change Visualisation</strong> auswählen. Dieser Eintrag erscheint nur, wenn zu dem Property mehr als ein Control hinterlegt ist.</p>
<p>Interessant in diesem Zusammenhang dürfte auch der Eintrag <strong>Default-Variant</strong> auf der Registerkarte ClassView sein. Unterhalb des Eintrags sehen Sie eine Auflistung der Controls, die auf dem Formular angezeigt werden. Wenn Sie ein Control z.B. auf einem Panel positionieren, sind die Koordinaten des Controls relativ zur Position des Panels. Wenn Sie wollen, dass sich ein Control in diesem relativen Zusammenhang verhält oder dieser Zusammenhang versehentlich erzeugt wurde, können Sie diesen durch Verschiebung des Controls im Baum per Drag &amp; Drop ändern.</p>
<p>Die <strong>Registerkarte Inheritance</strong> zeigt den Vererbungsbaum des ausgewählten Forms. Ist das Form nicht abgeleitet, wird lediglich ein Eintrag mit der Bezeichnung des Forms angezeigt.</p>
<p>Auf der <strong>Registerkarte Properties</strong> sehen Sie die Eigenschaften des im Hauptfenster ausgewählten Elements. Sie haben zudem die Möglichkeit, über die Combobox oben auf der Registerkarte zu den Eigenschaften eines ausgewählten Elements zu springen.</p>
<p>Auf die Eigenschaften zu den Controls wird in der Beschreibung zu den jeweiligen Controls eingegangen.</p>
<p>Letztlich zeigt die <strong>Registerkarte Toolbox</strong> eine Auswahl aller zu Verfügung stehenden Controls an. Die Controls werden ebenso wie die Properties per Drag &amp; Drop auf dem Formular positioniert. Es werden alle Standard-Controls, also auch Controls angeboten, welche von Ihnen im Default Style Editor definiert wurden.</p>
<p><strong>Form Designer Registerkarte Toolbox:</strong></p>
<p><img src="media/form-designer-toolbox.png" alt="Form Designer Registerkarte Toolbox"></p>
<h3 id="registerkarte-property">Registerkarte Property</h3>
<p><img src="media/form-designer-tab-properties.png" alt="Registerkarte Property"></p>
<p>Auf der Registerkarte <strong>Property</strong> können Sie die einzelnen Properties des Forms bearbeiten.
Wählen Sie dazu das gewünschte Property aus der Tabelle aus, oder doppelklicken Sie auf das entsprechende Property auf der Registerkarte <strong>ClassView</strong>.
Sie können die Properties sortieren, indem Sie auf die Spaltenüberschrift des gewünschten Sortierkriteriums klicken.</p>
<p>Neue Properties können Sie über <strong>New / Public Property</strong> bzw. <strong>New / Protected Property</strong> im Kontextmenü, im Menü des Form Designers oder über den entsprechenden Button anlegen.
Alternativ dazu können Sie auch eine Component aus dem Namespace Treeview in die Tabelle ziehen.
Dadurch wird automatisch ein Property vom Typ der Component angelegt.</p>
<p>Um ein Property zu löschen, wählen Sie <strong>Delete</strong> entweder aus dem Kontextmenü des Properties in der Tabelle oder im Class View.</p>
<h4 id="name">Name</h4>
<p>Dient zum Benennen oder Umbenennen des Properties.</p>
<h4 id="access-level">Access Level</h4>
<p>Steuert den Access Level des Properties.</p>
<h4 id="datatype">Datatype</h4>
<p>Ist als Datentyp eine Component oder Collection ausgewählt, ist das Property ein entsprechendes Objekt. Wenn der Datentyp dagegen ein .Net Datentyp oder ein FS-Datentyp ist, können Sie das Property wie eine formweite Membervariable nutzen.</p>
<p>Siehe <a href="../comp/tab_properties.html#datentyp-bearbeiten">Datentyp bearbeiten</a></p>
<h4 id="description">Description</h4>
<p>Hier können Sie eine Beschreibung für die Dokumentation hinterlegen.</p>
<p>Alle in ein Form eingebundenen Properties werden beim Öffnen eines Forms zur Laufzeit automatisch in der Methode <code>Init()</code> instanziiert.</p>
<h3 id="registerkarte-method">Registerkarte Method</h3>
<p>Auf der Registerkarte <strong>Method</strong> können analog zu den Components Methoden hinterlegt werden. Sie können prinzipiell 2 Arten von Methoden unterscheiden. Zum einen gibt es ganz normale Methoden, die durch einen Funktionsaufruf angestoßen werden. Zum anderen gibt es sogenannte Form-Events. Sie unterscheiden sich nur durch ihre Deklaration von den anderen Methoden und können auf Events von Controls reagieren.</p>
<h3 id="registerkarte-functional-controls">Registerkarte Functional Controls</h3>
<p>Auf dieser Registerkarte werden alle Functional <a href="../custom-controls/custom-controls.html">Custom Controls</a> des Forms angezeigt.</p>
<h3 id="registerkarte-available-reports">Registerkarte Available Reports</h3>
<p>Vorbereitung für spätere Funktionalität. Sie können bislang einen ReportDocumentType definieren, was Ihnen das Einbinden einer Referenz erspart. Der Code zum Erzeugen des Reports muss aber bislang manuell ausprogrammiert werden.</p>
<h3 id="registerkarte-access-units">Registerkarte Access Units</h3>
<p><img src="media/form-designer-tab-access-units.png" alt="access-units"></p>
<p>Zu der Access Unit, die in der Combobox ausgewählt ist, werden in den übrigen Feldern die Details angezeigt.</p>
<h4 id="name-1">Name</h4>
<p>Name der Access Unit. Dieses Feld ist insbesondere für die spezielle Form Access Unit, die das Form selbst repräsentiert, nicht editierbar.</p>
<h4 id="name-in-code">Name in code</h4>
<p>Kompilierbarer Name der AccessUnit, der im Source Code verwendet wird. Um Missverständnisse zu vermeiden, sollten Sie darauf achten, dass der Name einer Access Unit keine ungültigen Sonderzeichen enthält, so dass <strong>Name</strong> und <strong>Name in code</strong> übereinstimmen.</p>
<h4 id="is-form-accessunit">Is form AccessUnit</h4>
<p>Diese Checkbox zeigt an, ob die Access Unit die spezielle Access Unit ist, die das Form selbst repräsentiert. Für jedes Form wird diese Access Unit automatisch angelegt. Die Eigenschaft kann nicht geändert werden.</p>
<h4 id="description-1">Description</h4>
<p>Hier können Sie eine Beschreibung der Access Unit hinterlegen.</p>
<h4 id="parents">Parents</h4>
<p>Die Liste zeigt alle Access Units, unter der die Access Unit in der Access Unit Hierarchie eingebunden ist. Diese Eigenschaft ist hier rein informativ und kann nur über den Menüpunkt <strong>Tools / Access Unit Treeview</strong> ... (Access Unit Hierarchie) geändert werden.</p>
<h2 id="erstellen-bearbeiten-und-löschen-eines-forms">Erstellen, Bearbeiten und Löschen eines Forms</h2>
<h3 id="erstellen-eines-forms">Erstellen eines Forms</h3>
<p><a href="../ide/bearbeiten-von-elementen.html#elemente-erstellen">Elemente erstellen</a></p>
<h3 id="bearbeiten-eines-forms">Bearbeiten eines Forms</h3>
<p><a href="../ide/bearbeiten-von-elementen.html#elemente-bearbeiten">Elemente bearbeiten</a></p>
<p><a href="#design-des-forms">Design des Forms</a></p>
<h3 id="löschen-eines-forms">Löschen eines Forms</h3>
<p><a href="../ide/bearbeiten-von-elementen.html#elemente-l%C3%B6schen">Elemente löschen</a></p>
<h2 id="design-des-forms">Design des Forms</h2>
<p>Gestaltet wird das Form auf der Registerkarte <strong>DefaultVariant</strong>.</p>
<p>Um Controls auf dem Formular zu erstellen, gibt es mehrere Möglichkeiten:</p>
<p>In der <a href="../ide/registerkarten.html#registerkarte-toolbox">Registerkarte Toolbox</a> werden alle zur Verfügung stehenden Controls angeboten. Es sind auch die selbst definierten Default-Styles enthalten. Wenn Sie mit der Maus ein Control aus dieser Liste auf das Form ziehen (per Drag &amp; Drop), wird ein entsprechendes Control erstellt.</p>
<p>Das Control erhält als Vorgabe die Eigenschaften, die in den Default-Styles definiert sind. Werden die Eigenschaften in den Default-Styles geändert, wirkt sich das automatisch auf alle Controls aus, die aus diesem Default-Style erstellt wurden (auch nachträglich). Wenn allerdings die Eigenschaften manuell geändert werden, haben diese Änderungen höhere Priorität und sie werden nicht nachgezogen.</p>
<p>Eine weitere Möglichkeit besteht darin, eine Membervariable auf das Form zu ziehen. Es werden automatisch ein Control und dazu auch ein Label erstellt. Das Label erhält den Wert, der im Property oder im dahinterliegenden Metadatentypen als Default-Label hinterlegt ist. (Siehe dazu Metadatentypen und Components). Als Control wird das gezogen, welches im Property oder im Metadatentypen als Default-Control hinterlegt und als Default gekennzeichnet wurde. Sind noch weitere Default-Controls hinterlegt, können Sie die Darstellung nachträglich ändern. Im Context-Menu des Controls gibt es dazu einen Punkt <strong>Change Visualization</strong>. Dort werden alle Default-Controls angeboten und das, welches gerade verwendet wird, ist mit einem Haken versehen.</p>
<p>Weitere Informationen dazu finden Sie im Abschnitt <strong>Membervariablen/Databinding</strong>.</p>
<h2 id="actions">Actions</h2>
<h2 id="setapplicationtitlestring-title">SetApplicationTitle(string title)</h2>
<p>Mit dieser Methode kann der Titel der Applikation zur Laufzeit festgelegt werden. Unter Windows wird der Titel sowohl im Java Client-Fenster als auch in der Taskleiste angezeigt.</p>
<h2 id="setdialogplacementint-value">SetDialogPlacement(int value)</h2>
<p>Standardmäßig werden modale Dialoge in Framework Studio mittig im Hauptfenster der Anwendung angezeigt. Dies lässt sich über die Action <code>SetDialogPlacement(int value)</code> am Form ändern.</p>
<p><strong>Beispiel:</strong></p>
<pre><code class="lang-csharp">protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e)
{
    this.SetDialogPlacement(1); // Absolute
}
</code></pre>
<p>Die Action nimmt einen Integer zwischen 0 und 2 als Parameter:</p>
<ul>
<li>0 = None</li>
<li>1 = Absolute</li>
<li>2 = Relative</li>
</ul>
<h4 id="none">None</h4>
<p>Der JavaClient zeigt alle modalen Dialoge zentriert zur Anwendung an.</p>
<h4 id="absolute">Absolute</h4>
<p>Der JavaClient speichert sich die absolute Position und Größe aller modalen Dialoge beim Schließen. Die Dialoge werden genau an der Stelle geöffnet, an der sie geschlossen wurden.</p>
<h4 id="relative">Relative</h4>
<p>Der JavaClient speichert sich die relative Position der modalen Dialoge, bezogen auf die Position der Anwendung und die Größe. Die Dialoge werden relativ zur Anwendung wieder geöffnet.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Der JavaClient speichert sich den per <code>SetDialogPlacement()</code> übergebenen Wert <strong>NICHT</strong>. Es muss von der Anwendung aus bei jedem Start die Action aufgerufen werden (z.B. beim Laden des ersten Formulars der Anwendung).</p>
</div>
<h3 id="settooltipdelaysint-initialdelay-int-dismissdelay">SetToolTipDelays(int initialDelay, int dismissDelay)</h3>
<p>Mit dieser Action kann im JavaClient die Anzeigezeit für Tooltips geändert werden. Die Einstellung gilt dann für den gesamten JavaClient. Der Parameter <code>initialDelay</code> gibt die Zeit in Millisekunden an, wie lange es dauert, bis der Tooltip angezeigt wird, nachdem der Mauszeiger über ein Control bewegt wurde. Der Parameter „dismissDelay“ gibt die Zeit in Millisekunden an, wie lange der Tooltip angezeigt werden soll. Die Action ist an der Form-Klasse zu finden.</p>
<p><strong>Beispiel:</strong></p>
<pre><code class="lang-csharp">this.SetToolTipDelay(3000, 10000);
</code></pre>
<p>Nach diesem Beispiel würde ein Tooltip nach 3 Sekunden eingeblendet werden und dann für 10 Sekunden zu sehen sein.</p>
<p>Soll bei einem Aufruf der Action nur ein Parameter geändert werden, muss der andere mit dem Wert -1 übergeben werden:</p>
<p><strong>Beispiel:</strong></p>
<pre><code class="lang-csharp">this.SetToolTipDelay(-1, 10000);
</code></pre>
<p>Somit wird nur die Anzeigedauer der Tooltips auf 10 Sekunden geändert.</p>
<h3 id="beeplong-length-double-frequency">Beep(long length, double frequency)</h3>
<p>Erzeugt einen einheitlichen Beep-Ton.</p>
<h4 id="length">length</h4>
<p>Länge des Tons in Millisekunden.</p>
<h4 id="frequency">frequency</h4>
<p>Frequenz des Tons in Herz.</p>
<p><strong>Beispiel:</strong></p>
<pre><code class="lang-csharp">protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e)
{
    this.Beep(500, 750);
}
</code></pre>
<p>Dieser Code erzeugt einen Beep-Ton von einer halben Sekunde bei 750Hz.</p>
<h3 id="beepdoublelong-length1-long-length2-double-frequency1-double-frequency2">BeepDouble(long length1, long length2, double frequency1, double frequency2)</h3>
<p>Erzeugt einen Ton aus zwei Frequenzen, die hintereinander abgespielt werden. Damit lassen sich z.B. Bestätigungs- oder Fehler-Sounds erstellen.</p>
<h4 id="length1">length1</h4>
<p>Länge des ersten Teils des Tons in Millisekunden.</p>
<h4 id="length2">length2</h4>
<p>Länge des zweiten Teils des Tons in Millisekunden.</p>
<h4 id="frequency1">frequency1</h4>
<p>Frequenz des ersten Teils des Tons.</p>
<h4 id="frequency2">frequency2</h4>
<p>Frequenz des zweiten Teils des Tons.</p>
<p><strong>Beispiel 1:</strong></p>
<pre><code class="lang-csharp">protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e)
{
    this.BeepDouble(200, 200, 500, 2000);
}
</code></pre>
<p>Dieser Code erzeugt einen Beep-Ton mit einer Gesamtlänge von 400ms. Die ersten 200ms werden mit 500Hz wiedergegeben, die zweiten 200ms mit 2000Hz. Dies ist ein klassischer Bestätigungs-Sound.</p>
<p><strong>Beispiel 2:</strong></p>
<pre><code class="lang-csharp">protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e)
{
    this.BeepDouble(200, 350, 1000, 400);
}
</code></pre>
<p>Dieser Code erzeugt einen Beep-Ton mit einer Gesamtlänge von 550ms. Die ersten 200ms werden mit 1000Hz wiedergegeben, die restlichen 350ms mit 400Hz. Dies könnte z.B. ein akustisches Signal bei einem Fehler sein.</p>
<h3 id="beepmultipleint-beepcount-long-beeplength-long-breaklength-double-frequency">BeepMultiple(int beepCount, long beepLength, long breakLength, double frequency)</h3>
<p>Erzeugt mehrere Beep-Töne hintereinander mit Pausen dazwischen.</p>
<h4 id="beepcount">beepCount</h4>
<p>Anzahl der abzuspielenden Töne.</p>
<h4 id="beeplength">beepLength</h4>
<p>Länder eines einzelnen Tons in Millisekunden.</p>
<h4 id="breaklength">breakLength</h4>
<p>Länge der Pause zwischen den Tönen in Millisekunden.</p>
<h4 id="frequency-1">frequency</h4>
<p>Frequenz der einzelnen Töne.</p>
<p><strong>Beispiel:</strong></p>
<pre><code class="lang-csharp">protected virtual void FE_btn_OnClick(FrameworkButtonClickEventArgs e)
{
    this.BeepMultiple(3, 200, 100, 800);
}
</code></pre>
<p>Dieser Code erzeugt 3 Beep-Töne hintereinander mit einer Einzellänge von 200ms und jeweils einer 100ms langen Pause dazwischen. Die Töne werden mit 800Hz abgespielt.</p>
<h2 id="events">Events</h2>
<p>Damit in einem Form eine Aktion ausgeführt werden kann, sind sogenannte Events notwendig. Events reagieren auf Ereignisse, die im Form auftreten. Es ist möglich, diese Events mit Funktionalität zu verbinden.</p>
<p>Events können auf unterschiedliche Ereignisse reagieren: öffnen eines Forms, ändern des Inhalts eines Editfields, Klick auf einen Button usw.</p>
<p>Es gibt unterschiedliche Arten von Events: Form-Events, Workflow-Events.</p>
<h3 id="form-events">Form-Events</h3>
<p>Form-Events spielen sich sozusagen im Form ab. Damit ein Form-Event etwas tut, müssen Sie ihm eine Methode aus dem Form zuordnen. Es wird dann beim Eintreten des entsprechenden Ereignisses die im Form-Event hinterlegte Methode aufgerufen. Ein Form-Event ist immer eine Anfrage an den Broker.</p>
<p>Wurden vor dem Absenden des Events im Client Daten im Form geändert, stehen diese Änderungen in den entsprechenden Membervariablen zur Verfügung.</p>
<p>Werden im Form-Event Daten der Membervariablen geändert, werden diese Änderungen dem Client mitgeteilt und er ändert die Daten in der Anzeige entsprechend ab.</p>
<p>Bevor ein Form-Event an den Broker gesendet wird, werden die in den Metadatentypen hinterlegten Gültigkeitsprüfungen durchgeführt.</p>
<h3 id="workflow-events">Workflow-Events</h3>
<p>Workflow-Events stellen eine Schnittstelle aus dem Form heraus dar. Auf die im Form hinterlegten Workflow-Events kann später im Workflow reagiert werden. So kann z.B. zwischen verschiedenen Forms kommuniziert werden.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>Sind für ein Ereignis ein Form-Event und ein Workflow-Event hinterlegt, wird zuerst das Form-Event ausgeführt und anschließend das Workflow-Event.</p>
</div>
<p>Workflow-Events können auch manuell aus einer Form-Method heraus angestoßen (gefeuert) werden. Dazu bietet jedes Workflow-Event eine Fire-Methode an.</p>
<p><strong>Beispiel:</strong></p>
<p>Zu einem Workflow-Event <code>WE_btnSearch_OnClick</code> existiert eine Methode <code>FireWE_btnSearch_OnClick()</code>. Beim Aufruf dieser Methode wird das Workflow-Event <code>WE_btnSearch_OnClick</code> angestoßen.</p>
<pre><code class="lang-csharp">// FormEvent btn_Search_OnClick
public void FE_btnSearch_OnClick(FrameworkButtonClickEventArgs e)
{
  if (!this.GenerateLoadConditionOnoCustomer.IsNull)
  {
    FireWE_btnSearch_OnClick();
  }
}
</code></pre>
<h3 id="bearbeiten-von-control-events">Bearbeiten von Control-Events</h3>
<p>Die Events von Controls werden in einem Dialog bearbeitet. Dieser öffnet sich z.B. mit einem Doppelklick auf das Control.</p>
<p><img src="media/form-designer-control-events.png" alt="Control Events"></p>
<p>Dieser Dialog kann auf folgenden Wegen geöffnet werden:</p>
<ol>
<li>Mit einem Doppelklick auf ein Control.</li>
<li>Über das Context-Menü des Control – dort gibt es einen Menü-Punkt Events.</li>
<li>Über das Property-Grid. Das Control bietet eine Eigenschaft Control Events an.</li>
</ol>
<p><img src="media/form-designer-control-events-propgrid.png" alt="Control Events PropGrid"></p>
<p>Der Dialog zeigt erst einmal nur an, welche Events dem Control bereits zugeordnet sind. Erst bei Bedarf können diese dann geändert werden.</p>
<p>Wenn ein Event in einem Basis-Form oder einem Basis-Package zugeordnet wurde, dann wird dies mit grauem Text angezeigt. Ein Tooltip gibt Information, aus welchen Form oder Package diese Event-Zuordnung genau kommt und in welchem Form oder Package ggf. die letzte Überschreibung der Form-Methode existiert. Ist die Form-Methode im aktuellen Form überschrieben, dann wird der Link mit blauer Schrift dargestellt.</p>
<p><img src="media/form-designer-control-events-tooltip.png" alt="Control Events Tooltip"></p>
<p>Mit einem weiteren Mausklick können folgende Aktionen durchgeführt werden:</p>
<ol>
<li><p>Mit dem Button <strong>Cancel</strong> (oder mit Esc, Enter oder Leertaste) wird der Dialog geschlossen.</p>
</li>
<li><p>Mit Klick auf den Event-Link wird die entsprechende Form-Methode geöffnet bzw. das Workflow-Event im Class-View angezeigt.
Dies funktioniert auch für Events aus einem Basis-Form oder Basis-Package. In diesem Fall wird die letzte überschriebene Form-Methode geöffnet.</p>
</li>
<li><p>Mit dem Button <img src="../media/icon-plus.png" alt="plus"> kann man ein neues Event anlegen und zuordnnen. Der Dialog wird sofort geschlossen. Bei einem Form-Event wird unmittelbar in die entsprechende Form-Methode gesprungen und ein Workflow-Event wird im Class-View angezeigt.
Ist das Event in der Basis zugeordnet, dann wird dieser Befehl unterhalb des Buttons <img src="../media/icon-more.png" alt="more"> angeboten. Durch diesen Befehl wird die Basis-Event-Zuordnung ausgeblendet, was zur Folge hat, dass es nicht mehr ausgeführt wird. Es dann nur das neu zugeordnete Event ausgeführt. (Anders wäre es, wenn man z.B. eine Form-Event-Methode überschreibt.)</p>
</li>
<li><p>Mit dem Button <img src="../media/icon-basis-form.png" alt="basis-form"> kann eine im Basis-Form zugewiesene Form-Methode im aktuellen Form überschrieben werden. Der Button wird nur angeboten, wenn die Methode virtual ist und wenn sie nicht bereits im aktuellen Form überschrieben ist.</p>
</li>
<li><p>Mit dem Button <img src="../media/icon-more.png" alt="more"> kann ein vorhandenes Event zugeordnet werden. In einem Context-Menü werden alle gültigen Events angeboten. Nach einer Auswahl wird der Dialog sofort geschlossen.</p>
</li>
<li><p>Mit dem Button <img src="../media/icon-delete.png" alt="delete"> kann eine Event-Zordnung entfernt werden. Nach einer Rückfrage wird die Zuordnung gelöscht und der Dialog geschlossen. Die Form-Event-Methode bzw. das Workflow-Event werden dabei nicht gelöscht..</p>
</li>
</ol>
<h2 id="properties--databinding">Properties / Databinding</h2>
<p>Ein Form dient ja in erster Linie dazu, Daten anzuzeigen und zu verändern. Es ist aber so, dass ein Control selber keinen Wert hat (eine Ausnahme sind Labels). Dies wird über das sogenannte Databinding gelöst. Das funktioniert, indem einem Control eine Membervariable des Forms zugewiesen wird. Diese Zuordnung findet im <strong>Property Datasource</strong> auf der Registerkarte <strong>Property</strong> statt.</p>
<p>Ist die Zuordnung erfolgt, zeigt das Form im entsprechenden Control den Wert der Membervariablen an. Wird der Wert im Control durch eine Eingabe geändert, wird der neue Wert bei der nächsten Anfrage an den Broker in die Membervariable zurückgeschrieben.</p>
<p>Die Controls bieten unterschiedliche Möglichkeiten, Datasources zuzuordnen:</p>
<p><strong>Editfields</strong> haben einen Datasource. Diesem Datasource kann eine Membervariable vom Typ String, Number (long, int, short...) oder Datum zugewiesen werden. Das Editfield zeigt den entsprechenden Wert an.</p>
<p><img src="media/form-designer-properties-editfield.png" alt="Editfield"></p>
<p><strong>Labels</strong> haben ebenfalls einen Datasource. Diesem kann ebenfalls (wie dem Editfield) eine Membervariable zugeordnet werden. Ist dem Label ein Datasource zugeordnet, wird das, was im <strong>Property Caption</strong> angegeben ist, ignoriert.</p>
<p>Zudem besitzen Labels ein <strong>Property LabelOfControl</strong>. Ist ein Label einem Control zugeordnet und Control hat ein Property als DataSource, wird in dem Label automatisch die Caption angezeigt, die zu dem Property als DefaultLabel hinterlegt ist.</p>
<p><img src="media/form-designer-properties-caption.png" alt="Caption"></p>
<p><strong>Comboboxen</strong> und <strong>Listboxen</strong> haben neben dem Datasource eine Property List. Der Datasource gibt an, welchen Wert die Combobox repräsentieren soll. Unter List wird angegeben, woher die Werte der Liste hergenommen werden sollen. Hier sind Collections und Textcollections möglich. Nachdem List ausgewählt wurde, müssen noch DisplayMember und ValueMember angegeben werden.</p>
<p><strong>DisplayMember:</strong> Gibt an, welches Property aus der Component der Collection angezeigt werden soll. (Sollen zusammengesetzte Properties dargestellt werden, muss in der Component dafür ein extra Property erstellt werden, welches dann hier ausgewählt werden kann).</p>
<p><strong>ValueMember:</strong> Gibt an, welches Property der Component mit dem Datasource verknüpft werden soll.</p>
<p><img src="media/form-designer-properties-value-member.png" alt="Display/ValueMember"></p>
<p><strong>Tabbed Windows</strong> können als Datasource eine Membervariable vom Typ short besitzen. Der Inhalt dieser Membervariablen gibt an, welches Tab gerade aktiv ist. Durch Ändern der Membervariable in einem FormEvent kann somit auch beeinflusst werden, welches Tab aktiv sein soll.</p>
<p><img src="media/form-designer-properties-datasource-tab.png" alt="DataSource für Tab"></p>
<p><strong>Radio-Buttons / Panels:</strong> Radiobuttons besitzen selber keinen Datasource. Bei Radiobuttons bilden immer mehrere Controls eine logische Einheit, zwischen denen gewechselt werden kann. Um dies zu lösen, werden die Radiobuttons auf einem Panel positioniert. Das Panel, welches die Radiobuttons beinhaltet, bekommt dann im Property <strong>ButtonGroupDataSource</strong> ein Datasource zugeordnet. Den Radiobuttons wird im Property <strong>DatasourceOnValue</strong> gesagt, bei welchem Wert er aktiv sein soll.</p>
<p><img src="media/form-designer-properties-datasource-onvalue.png" alt="Datasource OnValue"></p>
<p><strong>Pictures</strong> bekommen im Datasource gesagt, welches Bild dargestellt werden soll. Ist im Picture ein Datasource zugeordnet, wird die Angabe im Property Image ignoriert. Damit ist es möglich, ein Bild dynamisch anzuzeigen.</p>
<p><strong>Grids</strong> bekommen als Datasource eine Collection. Diese Collection stellt die Tabelle dar, die angezeigt werden soll. Anschließend können Sie aus dem Kontext-Menü des Grids über den Eintrag Grid-Columns / New die Properties aus der Component zu der Collection als Grid-Columns übernehmen.</p>
<p>Nur in der Component enthaltene Properties können zu Spalten werden. Es ist nicht möglich, darüber hinaus weitere Spalten zu definieren. Bei Bedarf müssen Sie in der Component zusätzliche Properties definieren und diese dynamisch über die Get/Set-Methoden befüllen.</p>
<p><strong>Grids</strong> bieten einen weiteren Datasource <strong>SelectedRows</strong> an. Hier kann eine Membervariable vom Typ System.Framework.SelectedRowsCollection zugeordnet werden. Diese Collection enthält Guids (eindeutige ID eines Objekts), die angeben, welche Zeilen in der Tabelle markiert sind. Die Guids repräsentieren also eine Untermenge der Objekte aus der Datasource-Collection.</p>
<p><img src="media/form-designer-properties-grid.png" alt="Grid"></p>
<p><strong>TreeViews</strong> stellen einen Baum aus Objekten dar. Als Datasource muss ein ganzes Objekt angegeben werden. Wenn der TreeView Objekte nur eines Typs darstellt, muss der Datasource denselben Typ besitzen. Stellt der TreeView Objekte verschiedener Typen dar, muss als Datasource ein Objekt vom Typ Object gewählt werden. In dem Fall müssen Sie in den Form-Methoden entsprechende Typenkonvertierungen vornehmen.</p>
<p><strong>Framework Studio</strong> bietet auch eine ganz einfache Möglichkeit, ein Control mit Datasource zu erstellen. Sie können die Membervariable einfach auf das Form ziehen. Es wird das entsprechende hinterlegte Default-Control erzeugt. Es erhält einen Namen, angelehnt an den der Membervariable. Der Datasource wird automatisch eingetragen und es wird zum Control ein Label erstellt, welches das in der Membervariable hinterlegte Default-Label enthält.</p>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span><a href="https://www.enventa-group.com/" target="_blank" rel="noopener noreferrer nofollow"><img class="dark" src="../../media/enventa-group-logo-dark.svg" alt="enventa-group" style="height: 1.5rem"><img class="light" src="../../media/enventa-group-logo.svg" alt="enventa-group" style="height: 1.5rem"></a></span> <span style="float:right">Made with <a href="https://dotnet.github.io/docfx" target="_blank" rel="noopener noreferrer nofollow" class="external">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
